/* istanbul ignore file */

/** (string) of bytes in Base64 */
export type bytes = string;

/** String in Base64 or Uint8Array. Will be converted to Base64 */
export type bytes$Input = string | Uint8Array;

/** (float64) */
export type double = number;

/** (float64) Integer number ranging from Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER */
export type int53 = number;

/** (int32) Integer number ranging from -2147483648 to 2147483647 */
export type int32 = number;

/** (string) of digits. Use BigInt for handling this */
export type int64 = string;

/** String or BigInt. Will be converted to String */
export type int64$Input = string | bigint;

export type boolTrue = true;

export type boolFalse = false;

export type vector<T> = Array<T>;

export type vector$Input<T> = ReadonlyArray<T>;

export const $Methods = Object.freeze({
  getAuthorizationState: "getAuthorizationState",
  setTdlibParameters: "setTdlibParameters",
  setAuthenticationPhoneNumber: "setAuthenticationPhoneNumber",
  setAuthenticationEmailAddress: "setAuthenticationEmailAddress",
  resendAuthenticationCode: "resendAuthenticationCode",
  checkAuthenticationEmailCode: "checkAuthenticationEmailCode",
  checkAuthenticationCode: "checkAuthenticationCode",
  requestQrCodeAuthentication: "requestQrCodeAuthentication",
  registerUser: "registerUser",
  resetAuthenticationEmailAddress: "resetAuthenticationEmailAddress",
  checkAuthenticationPassword: "checkAuthenticationPassword",
  requestAuthenticationPasswordRecovery: "requestAuthenticationPasswordRecovery",
  checkAuthenticationPasswordRecoveryCode: "checkAuthenticationPasswordRecoveryCode",
  recoverAuthenticationPassword: "recoverAuthenticationPassword",
  sendAuthenticationFirebaseSms: "sendAuthenticationFirebaseSms",
  checkAuthenticationBotToken: "checkAuthenticationBotToken",
  logOut: "logOut",
  close: "close",
  destroy: "destroy",
  confirmQrCodeAuthentication: "confirmQrCodeAuthentication",
  getCurrentState: "getCurrentState",
  setDatabaseEncryptionKey: "setDatabaseEncryptionKey",
  getPasswordState: "getPasswordState",
  setPassword: "setPassword",
  setLoginEmailAddress: "setLoginEmailAddress",
  resendLoginEmailAddressCode: "resendLoginEmailAddressCode",
  checkLoginEmailAddressCode: "checkLoginEmailAddressCode",
  getRecoveryEmailAddress: "getRecoveryEmailAddress",
  setRecoveryEmailAddress: "setRecoveryEmailAddress",
  checkRecoveryEmailAddressCode: "checkRecoveryEmailAddressCode",
  resendRecoveryEmailAddressCode: "resendRecoveryEmailAddressCode",
  requestPasswordRecovery: "requestPasswordRecovery",
  checkPasswordRecoveryCode: "checkPasswordRecoveryCode",
  recoverPassword: "recoverPassword",
  resetPassword: "resetPassword",
  cancelPasswordReset: "cancelPasswordReset",
  createTemporaryPassword: "createTemporaryPassword",
  getTemporaryPasswordState: "getTemporaryPasswordState",
  getMe: "getMe",
  getUser: "getUser",
  getUserFullInfo: "getUserFullInfo",
  getBasicGroup: "getBasicGroup",
  getBasicGroupFullInfo: "getBasicGroupFullInfo",
  getSupergroup: "getSupergroup",
  getSupergroupFullInfo: "getSupergroupFullInfo",
  getSecretChat: "getSecretChat",
  getChat: "getChat",
  getMessage: "getMessage",
  getMessageLocally: "getMessageLocally",
  getRepliedMessage: "getRepliedMessage",
  getChatPinnedMessage: "getChatPinnedMessage",
  getCallbackQueryMessage: "getCallbackQueryMessage",
  getMessages: "getMessages",
  getMessageThread: "getMessageThread",
  getMessageViewers: "getMessageViewers",
  getFile: "getFile",
  getRemoteFile: "getRemoteFile",
  loadChats: "loadChats",
  getChats: "getChats",
  searchPublicChat: "searchPublicChat",
  searchPublicChats: "searchPublicChats",
  searchChats: "searchChats",
  searchChatsOnServer: "searchChatsOnServer",
  searchChatsNearby: "searchChatsNearby",
  getChatSimilarChats: "getChatSimilarChats",
  getChatSimilarChatCount: "getChatSimilarChatCount",
  openChatSimilarChat: "openChatSimilarChat",
  getTopChats: "getTopChats",
  removeTopChat: "removeTopChat",
  searchRecentlyFoundChats: "searchRecentlyFoundChats",
  addRecentlyFoundChat: "addRecentlyFoundChat",
  removeRecentlyFoundChat: "removeRecentlyFoundChat",
  clearRecentlyFoundChats: "clearRecentlyFoundChats",
  getRecentlyOpenedChats: "getRecentlyOpenedChats",
  checkChatUsername: "checkChatUsername",
  getCreatedPublicChats: "getCreatedPublicChats",
  checkCreatedPublicChatsLimit: "checkCreatedPublicChatsLimit",
  getSuitableDiscussionChats: "getSuitableDiscussionChats",
  getInactiveSupergroupChats: "getInactiveSupergroupChats",
  getGroupsInCommon: "getGroupsInCommon",
  getChatHistory: "getChatHistory",
  getMessageThreadHistory: "getMessageThreadHistory",
  deleteChatHistory: "deleteChatHistory",
  deleteChat: "deleteChat",
  searchChatMessages: "searchChatMessages",
  searchMessages: "searchMessages",
  searchSecretMessages: "searchSecretMessages",
  searchCallMessages: "searchCallMessages",
  searchOutgoingDocumentMessages: "searchOutgoingDocumentMessages",
  deleteAllCallMessages: "deleteAllCallMessages",
  searchChatRecentLocationMessages: "searchChatRecentLocationMessages",
  getActiveLiveLocationMessages: "getActiveLiveLocationMessages",
  getChatMessageByDate: "getChatMessageByDate",
  getChatSparseMessagePositions: "getChatSparseMessagePositions",
  getChatMessageCalendar: "getChatMessageCalendar",
  getChatMessageCount: "getChatMessageCount",
  getChatMessagePosition: "getChatMessagePosition",
  getChatScheduledMessages: "getChatScheduledMessages",
  getChatSponsoredMessages: "getChatSponsoredMessages",
  clickChatSponsoredMessage: "clickChatSponsoredMessage",
  removeNotification: "removeNotification",
  removeNotificationGroup: "removeNotificationGroup",
  getMessageLink: "getMessageLink",
  getMessageEmbeddingCode: "getMessageEmbeddingCode",
  getMessageLinkInfo: "getMessageLinkInfo",
  translateText: "translateText",
  translateMessageText: "translateMessageText",
  recognizeSpeech: "recognizeSpeech",
  rateSpeechRecognition: "rateSpeechRecognition",
  getChatAvailableMessageSenders: "getChatAvailableMessageSenders",
  setChatMessageSender: "setChatMessageSender",
  sendMessage: "sendMessage",
  sendMessageAlbum: "sendMessageAlbum",
  sendBotStartMessage: "sendBotStartMessage",
  sendInlineQueryResultMessage: "sendInlineQueryResultMessage",
  forwardMessages: "forwardMessages",
  resendMessages: "resendMessages",
  addLocalMessage: "addLocalMessage",
  deleteMessages: "deleteMessages",
  deleteChatMessagesBySender: "deleteChatMessagesBySender",
  deleteChatMessagesByDate: "deleteChatMessagesByDate",
  editMessageText: "editMessageText",
  editMessageLiveLocation: "editMessageLiveLocation",
  editMessageMedia: "editMessageMedia",
  editMessageCaption: "editMessageCaption",
  editMessageReplyMarkup: "editMessageReplyMarkup",
  editInlineMessageText: "editInlineMessageText",
  editInlineMessageLiveLocation: "editInlineMessageLiveLocation",
  editInlineMessageMedia: "editInlineMessageMedia",
  editInlineMessageCaption: "editInlineMessageCaption",
  editInlineMessageReplyMarkup: "editInlineMessageReplyMarkup",
  editMessageSchedulingState: "editMessageSchedulingState",
  getForumTopicDefaultIcons: "getForumTopicDefaultIcons",
  createForumTopic: "createForumTopic",
  editForumTopic: "editForumTopic",
  getForumTopic: "getForumTopic",
  getForumTopicLink: "getForumTopicLink",
  getForumTopics: "getForumTopics",
  setForumTopicNotificationSettings: "setForumTopicNotificationSettings",
  toggleForumTopicIsClosed: "toggleForumTopicIsClosed",
  toggleGeneralForumTopicIsHidden: "toggleGeneralForumTopicIsHidden",
  toggleForumTopicIsPinned: "toggleForumTopicIsPinned",
  setPinnedForumTopics: "setPinnedForumTopics",
  deleteForumTopic: "deleteForumTopic",
  getEmojiReaction: "getEmojiReaction",
  getCustomEmojiReactionAnimations: "getCustomEmojiReactionAnimations",
  getMessageAvailableReactions: "getMessageAvailableReactions",
  clearRecentReactions: "clearRecentReactions",
  addMessageReaction: "addMessageReaction",
  removeMessageReaction: "removeMessageReaction",
  setMessageReactions: "setMessageReactions",
  getMessageAddedReactions: "getMessageAddedReactions",
  setDefaultReactionType: "setDefaultReactionType",
  searchQuote: "searchQuote",
  getTextEntities: "getTextEntities",
  parseTextEntities: "parseTextEntities",
  parseMarkdown: "parseMarkdown",
  getMarkdownText: "getMarkdownText",
  getFileMimeType: "getFileMimeType",
  getFileExtension: "getFileExtension",
  cleanFileName: "cleanFileName",
  getLanguagePackString: "getLanguagePackString",
  getJsonValue: "getJsonValue",
  getJsonString: "getJsonString",
  getThemeParametersJsonString: "getThemeParametersJsonString",
  setPollAnswer: "setPollAnswer",
  getPollVoters: "getPollVoters",
  stopPoll: "stopPoll",
  hideSuggestedAction: "hideSuggestedAction",
  getLoginUrlInfo: "getLoginUrlInfo",
  getLoginUrl: "getLoginUrl",
  shareUsersWithBot: "shareUsersWithBot",
  shareChatWithBot: "shareChatWithBot",
  getInlineQueryResults: "getInlineQueryResults",
  answerInlineQuery: "answerInlineQuery",
  searchWebApp: "searchWebApp",
  getWebAppLinkUrl: "getWebAppLinkUrl",
  getWebAppUrl: "getWebAppUrl",
  sendWebAppData: "sendWebAppData",
  openWebApp: "openWebApp",
  closeWebApp: "closeWebApp",
  answerWebAppQuery: "answerWebAppQuery",
  getCallbackQueryAnswer: "getCallbackQueryAnswer",
  answerCallbackQuery: "answerCallbackQuery",
  answerShippingQuery: "answerShippingQuery",
  answerPreCheckoutQuery: "answerPreCheckoutQuery",
  setGameScore: "setGameScore",
  setInlineGameScore: "setInlineGameScore",
  getGameHighScores: "getGameHighScores",
  getInlineGameHighScores: "getInlineGameHighScores",
  deleteChatReplyMarkup: "deleteChatReplyMarkup",
  sendChatAction: "sendChatAction",
  openChat: "openChat",
  closeChat: "closeChat",
  viewMessages: "viewMessages",
  openMessageContent: "openMessageContent",
  clickAnimatedEmojiMessage: "clickAnimatedEmojiMessage",
  getInternalLink: "getInternalLink",
  getInternalLinkType: "getInternalLinkType",
  getExternalLinkInfo: "getExternalLinkInfo",
  getExternalLink: "getExternalLink",
  readAllChatMentions: "readAllChatMentions",
  readAllMessageThreadMentions: "readAllMessageThreadMentions",
  readAllChatReactions: "readAllChatReactions",
  readAllMessageThreadReactions: "readAllMessageThreadReactions",
  createPrivateChat: "createPrivateChat",
  createBasicGroupChat: "createBasicGroupChat",
  createSupergroupChat: "createSupergroupChat",
  createSecretChat: "createSecretChat",
  createNewBasicGroupChat: "createNewBasicGroupChat",
  createNewSupergroupChat: "createNewSupergroupChat",
  createNewSecretChat: "createNewSecretChat",
  upgradeBasicGroupChatToSupergroupChat: "upgradeBasicGroupChatToSupergroupChat",
  getChatListsToAddChat: "getChatListsToAddChat",
  addChatToList: "addChatToList",
  getChatFolder: "getChatFolder",
  createChatFolder: "createChatFolder",
  editChatFolder: "editChatFolder",
  deleteChatFolder: "deleteChatFolder",
  getChatFolderChatsToLeave: "getChatFolderChatsToLeave",
  getChatFolderChatCount: "getChatFolderChatCount",
  reorderChatFolders: "reorderChatFolders",
  getRecommendedChatFolders: "getRecommendedChatFolders",
  getChatFolderDefaultIconName: "getChatFolderDefaultIconName",
  getChatsForChatFolderInviteLink: "getChatsForChatFolderInviteLink",
  createChatFolderInviteLink: "createChatFolderInviteLink",
  getChatFolderInviteLinks: "getChatFolderInviteLinks",
  editChatFolderInviteLink: "editChatFolderInviteLink",
  deleteChatFolderInviteLink: "deleteChatFolderInviteLink",
  checkChatFolderInviteLink: "checkChatFolderInviteLink",
  addChatFolderByInviteLink: "addChatFolderByInviteLink",
  getChatFolderNewChats: "getChatFolderNewChats",
  processChatFolderNewChats: "processChatFolderNewChats",
  getArchiveChatListSettings: "getArchiveChatListSettings",
  setArchiveChatListSettings: "setArchiveChatListSettings",
  setChatTitle: "setChatTitle",
  setChatPhoto: "setChatPhoto",
  setChatAccentColor: "setChatAccentColor",
  setChatProfileAccentColor: "setChatProfileAccentColor",
  setChatMessageAutoDeleteTime: "setChatMessageAutoDeleteTime",
  setChatEmojiStatus: "setChatEmojiStatus",
  setChatPermissions: "setChatPermissions",
  setChatBackground: "setChatBackground",
  deleteChatBackground: "deleteChatBackground",
  setChatTheme: "setChatTheme",
  setChatDraftMessage: "setChatDraftMessage",
  setChatNotificationSettings: "setChatNotificationSettings",
  toggleChatHasProtectedContent: "toggleChatHasProtectedContent",
  toggleChatViewAsTopics: "toggleChatViewAsTopics",
  toggleChatIsTranslatable: "toggleChatIsTranslatable",
  toggleChatIsMarkedAsUnread: "toggleChatIsMarkedAsUnread",
  toggleChatDefaultDisableNotification: "toggleChatDefaultDisableNotification",
  setChatAvailableReactions: "setChatAvailableReactions",
  setChatClientData: "setChatClientData",
  setChatDescription: "setChatDescription",
  setChatDiscussionGroup: "setChatDiscussionGroup",
  setChatLocation: "setChatLocation",
  setChatSlowModeDelay: "setChatSlowModeDelay",
  pinChatMessage: "pinChatMessage",
  unpinChatMessage: "unpinChatMessage",
  unpinAllChatMessages: "unpinAllChatMessages",
  unpinAllMessageThreadMessages: "unpinAllMessageThreadMessages",
  joinChat: "joinChat",
  leaveChat: "leaveChat",
  addChatMember: "addChatMember",
  addChatMembers: "addChatMembers",
  setChatMemberStatus: "setChatMemberStatus",
  banChatMember: "banChatMember",
  canTransferOwnership: "canTransferOwnership",
  transferChatOwnership: "transferChatOwnership",
  getChatMember: "getChatMember",
  searchChatMembers: "searchChatMembers",
  getChatAdministrators: "getChatAdministrators",
  clearAllDraftMessages: "clearAllDraftMessages",
  getSavedNotificationSound: "getSavedNotificationSound",
  getSavedNotificationSounds: "getSavedNotificationSounds",
  addSavedNotificationSound: "addSavedNotificationSound",
  removeSavedNotificationSound: "removeSavedNotificationSound",
  getChatNotificationSettingsExceptions: "getChatNotificationSettingsExceptions",
  getScopeNotificationSettings: "getScopeNotificationSettings",
  setScopeNotificationSettings: "setScopeNotificationSettings",
  resetAllNotificationSettings: "resetAllNotificationSettings",
  toggleChatIsPinned: "toggleChatIsPinned",
  setPinnedChats: "setPinnedChats",
  readChatList: "readChatList",
  getStory: "getStory",
  getChatsToSendStories: "getChatsToSendStories",
  canSendStory: "canSendStory",
  sendStory: "sendStory",
  editStory: "editStory",
  setStoryPrivacySettings: "setStoryPrivacySettings",
  toggleStoryIsPinned: "toggleStoryIsPinned",
  deleteStory: "deleteStory",
  getStoryNotificationSettingsExceptions: "getStoryNotificationSettingsExceptions",
  loadActiveStories: "loadActiveStories",
  setChatActiveStoriesList: "setChatActiveStoriesList",
  getChatActiveStories: "getChatActiveStories",
  getChatPinnedStories: "getChatPinnedStories",
  getChatArchivedStories: "getChatArchivedStories",
  openStory: "openStory",
  closeStory: "closeStory",
  getStoryAvailableReactions: "getStoryAvailableReactions",
  setStoryReaction: "setStoryReaction",
  getStoryInteractions: "getStoryInteractions",
  getChatStoryInteractions: "getChatStoryInteractions",
  reportStory: "reportStory",
  activateStoryStealthMode: "activateStoryStealthMode",
  getStoryPublicForwards: "getStoryPublicForwards",
  getChatBoostLevelFeatures: "getChatBoostLevelFeatures",
  getChatBoostFeatures: "getChatBoostFeatures",
  getAvailableChatBoostSlots: "getAvailableChatBoostSlots",
  getChatBoostStatus: "getChatBoostStatus",
  boostChat: "boostChat",
  getChatBoostLink: "getChatBoostLink",
  getChatBoostLinkInfo: "getChatBoostLinkInfo",
  getChatBoosts: "getChatBoosts",
  getUserChatBoosts: "getUserChatBoosts",
  getAttachmentMenuBot: "getAttachmentMenuBot",
  toggleBotIsAddedToAttachmentMenu: "toggleBotIsAddedToAttachmentMenu",
  getThemedEmojiStatuses: "getThemedEmojiStatuses",
  getRecentEmojiStatuses: "getRecentEmojiStatuses",
  getDefaultEmojiStatuses: "getDefaultEmojiStatuses",
  clearRecentEmojiStatuses: "clearRecentEmojiStatuses",
  getThemedChatEmojiStatuses: "getThemedChatEmojiStatuses",
  getDefaultChatEmojiStatuses: "getDefaultChatEmojiStatuses",
  getDisallowedChatEmojiStatuses: "getDisallowedChatEmojiStatuses",
  downloadFile: "downloadFile",
  getFileDownloadedPrefixSize: "getFileDownloadedPrefixSize",
  cancelDownloadFile: "cancelDownloadFile",
  getSuggestedFileName: "getSuggestedFileName",
  preliminaryUploadFile: "preliminaryUploadFile",
  cancelPreliminaryUploadFile: "cancelPreliminaryUploadFile",
  writeGeneratedFilePart: "writeGeneratedFilePart",
  setFileGenerationProgress: "setFileGenerationProgress",
  finishFileGeneration: "finishFileGeneration",
  readFilePart: "readFilePart",
  deleteFile: "deleteFile",
  addFileToDownloads: "addFileToDownloads",
  toggleDownloadIsPaused: "toggleDownloadIsPaused",
  toggleAllDownloadsArePaused: "toggleAllDownloadsArePaused",
  removeFileFromDownloads: "removeFileFromDownloads",
  removeAllFilesFromDownloads: "removeAllFilesFromDownloads",
  searchFileDownloads: "searchFileDownloads",
  getMessageFileType: "getMessageFileType",
  getMessageImportConfirmationText: "getMessageImportConfirmationText",
  importMessages: "importMessages",
  replacePrimaryChatInviteLink: "replacePrimaryChatInviteLink",
  createChatInviteLink: "createChatInviteLink",
  editChatInviteLink: "editChatInviteLink",
  getChatInviteLink: "getChatInviteLink",
  getChatInviteLinkCounts: "getChatInviteLinkCounts",
  getChatInviteLinks: "getChatInviteLinks",
  getChatInviteLinkMembers: "getChatInviteLinkMembers",
  revokeChatInviteLink: "revokeChatInviteLink",
  deleteRevokedChatInviteLink: "deleteRevokedChatInviteLink",
  deleteAllRevokedChatInviteLinks: "deleteAllRevokedChatInviteLinks",
  checkChatInviteLink: "checkChatInviteLink",
  joinChatByInviteLink: "joinChatByInviteLink",
  getChatJoinRequests: "getChatJoinRequests",
  processChatJoinRequest: "processChatJoinRequest",
  processChatJoinRequests: "processChatJoinRequests",
  createCall: "createCall",
  acceptCall: "acceptCall",
  sendCallSignalingData: "sendCallSignalingData",
  discardCall: "discardCall",
  sendCallRating: "sendCallRating",
  sendCallDebugInformation: "sendCallDebugInformation",
  sendCallLog: "sendCallLog",
  getVideoChatAvailableParticipants: "getVideoChatAvailableParticipants",
  setVideoChatDefaultParticipant: "setVideoChatDefaultParticipant",
  createVideoChat: "createVideoChat",
  getVideoChatRtmpUrl: "getVideoChatRtmpUrl",
  replaceVideoChatRtmpUrl: "replaceVideoChatRtmpUrl",
  getGroupCall: "getGroupCall",
  startScheduledGroupCall: "startScheduledGroupCall",
  toggleGroupCallEnabledStartNotification: "toggleGroupCallEnabledStartNotification",
  joinGroupCall: "joinGroupCall",
  startGroupCallScreenSharing: "startGroupCallScreenSharing",
  toggleGroupCallScreenSharingIsPaused: "toggleGroupCallScreenSharingIsPaused",
  endGroupCallScreenSharing: "endGroupCallScreenSharing",
  setGroupCallTitle: "setGroupCallTitle",
  toggleGroupCallMuteNewParticipants: "toggleGroupCallMuteNewParticipants",
  inviteGroupCallParticipants: "inviteGroupCallParticipants",
  getGroupCallInviteLink: "getGroupCallInviteLink",
  revokeGroupCallInviteLink: "revokeGroupCallInviteLink",
  startGroupCallRecording: "startGroupCallRecording",
  endGroupCallRecording: "endGroupCallRecording",
  toggleGroupCallIsMyVideoPaused: "toggleGroupCallIsMyVideoPaused",
  toggleGroupCallIsMyVideoEnabled: "toggleGroupCallIsMyVideoEnabled",
  setGroupCallParticipantIsSpeaking: "setGroupCallParticipantIsSpeaking",
  toggleGroupCallParticipantIsMuted: "toggleGroupCallParticipantIsMuted",
  setGroupCallParticipantVolumeLevel: "setGroupCallParticipantVolumeLevel",
  toggleGroupCallParticipantIsHandRaised: "toggleGroupCallParticipantIsHandRaised",
  loadGroupCallParticipants: "loadGroupCallParticipants",
  leaveGroupCall: "leaveGroupCall",
  endGroupCall: "endGroupCall",
  getGroupCallStreams: "getGroupCallStreams",
  getGroupCallStreamSegment: "getGroupCallStreamSegment",
  setMessageSenderBlockList: "setMessageSenderBlockList",
  blockMessageSenderFromReplies: "blockMessageSenderFromReplies",
  getBlockedMessageSenders: "getBlockedMessageSenders",
  addContact: "addContact",
  importContacts: "importContacts",
  getContacts: "getContacts",
  searchContacts: "searchContacts",
  removeContacts: "removeContacts",
  getImportedContactCount: "getImportedContactCount",
  changeImportedContacts: "changeImportedContacts",
  clearImportedContacts: "clearImportedContacts",
  setCloseFriends: "setCloseFriends",
  getCloseFriends: "getCloseFriends",
  setUserPersonalProfilePhoto: "setUserPersonalProfilePhoto",
  suggestUserProfilePhoto: "suggestUserProfilePhoto",
  searchUserByPhoneNumber: "searchUserByPhoneNumber",
  sharePhoneNumber: "sharePhoneNumber",
  getUserProfilePhotos: "getUserProfilePhotos",
  getStickers: "getStickers",
  getAllStickerEmojis: "getAllStickerEmojis",
  searchStickers: "searchStickers",
  getPremiumStickers: "getPremiumStickers",
  getInstalledStickerSets: "getInstalledStickerSets",
  getArchivedStickerSets: "getArchivedStickerSets",
  getTrendingStickerSets: "getTrendingStickerSets",
  getAttachedStickerSets: "getAttachedStickerSets",
  getStickerSet: "getStickerSet",
  searchStickerSet: "searchStickerSet",
  searchInstalledStickerSets: "searchInstalledStickerSets",
  searchStickerSets: "searchStickerSets",
  changeStickerSet: "changeStickerSet",
  viewTrendingStickerSets: "viewTrendingStickerSets",
  reorderInstalledStickerSets: "reorderInstalledStickerSets",
  getRecentStickers: "getRecentStickers",
  addRecentSticker: "addRecentSticker",
  removeRecentSticker: "removeRecentSticker",
  clearRecentStickers: "clearRecentStickers",
  getFavoriteStickers: "getFavoriteStickers",
  addFavoriteSticker: "addFavoriteSticker",
  removeFavoriteSticker: "removeFavoriteSticker",
  getStickerEmojis: "getStickerEmojis",
  searchEmojis: "searchEmojis",
  getEmojiCategories: "getEmojiCategories",
  getAnimatedEmoji: "getAnimatedEmoji",
  getEmojiSuggestionsUrl: "getEmojiSuggestionsUrl",
  getCustomEmojiStickers: "getCustomEmojiStickers",
  getDefaultChatPhotoCustomEmojiStickers: "getDefaultChatPhotoCustomEmojiStickers",
  getDefaultProfilePhotoCustomEmojiStickers:
    "getDefaultProfilePhotoCustomEmojiStickers",
  getDefaultBackgroundCustomEmojiStickers: "getDefaultBackgroundCustomEmojiStickers",
  getSavedAnimations: "getSavedAnimations",
  addSavedAnimation: "addSavedAnimation",
  removeSavedAnimation: "removeSavedAnimation",
  getRecentInlineBots: "getRecentInlineBots",
  searchHashtags: "searchHashtags",
  removeRecentHashtag: "removeRecentHashtag",
  getWebPagePreview: "getWebPagePreview",
  getWebPageInstantView: "getWebPageInstantView",
  setProfilePhoto: "setProfilePhoto",
  deleteProfilePhoto: "deleteProfilePhoto",
  setAccentColor: "setAccentColor",
  setProfileAccentColor: "setProfileAccentColor",
  setName: "setName",
  setBio: "setBio",
  setUsername: "setUsername",
  toggleUsernameIsActive: "toggleUsernameIsActive",
  reorderActiveUsernames: "reorderActiveUsernames",
  setEmojiStatus: "setEmojiStatus",
  setLocation: "setLocation",
  changePhoneNumber: "changePhoneNumber",
  resendChangePhoneNumberCode: "resendChangePhoneNumberCode",
  checkChangePhoneNumberCode: "checkChangePhoneNumberCode",
  getUserLink: "getUserLink",
  searchUserByToken: "searchUserByToken",
  setCommands: "setCommands",
  deleteCommands: "deleteCommands",
  getCommands: "getCommands",
  setMenuButton: "setMenuButton",
  getMenuButton: "getMenuButton",
  setDefaultGroupAdministratorRights: "setDefaultGroupAdministratorRights",
  setDefaultChannelAdministratorRights: "setDefaultChannelAdministratorRights",
  canBotSendMessages: "canBotSendMessages",
  allowBotToSendMessages: "allowBotToSendMessages",
  sendWebAppCustomRequest: "sendWebAppCustomRequest",
  setBotName: "setBotName",
  getBotName: "getBotName",
  setBotProfilePhoto: "setBotProfilePhoto",
  toggleBotUsernameIsActive: "toggleBotUsernameIsActive",
  reorderBotActiveUsernames: "reorderBotActiveUsernames",
  setBotInfoDescription: "setBotInfoDescription",
  getBotInfoDescription: "getBotInfoDescription",
  setBotInfoShortDescription: "setBotInfoShortDescription",
  getBotInfoShortDescription: "getBotInfoShortDescription",
  getActiveSessions: "getActiveSessions",
  terminateSession: "terminateSession",
  terminateAllOtherSessions: "terminateAllOtherSessions",
  confirmSession: "confirmSession",
  toggleSessionCanAcceptCalls: "toggleSessionCanAcceptCalls",
  toggleSessionCanAcceptSecretChats: "toggleSessionCanAcceptSecretChats",
  setInactiveSessionTtl: "setInactiveSessionTtl",
  getConnectedWebsites: "getConnectedWebsites",
  disconnectWebsite: "disconnectWebsite",
  disconnectAllWebsites: "disconnectAllWebsites",
  setSupergroupUsername: "setSupergroupUsername",
  toggleSupergroupUsernameIsActive: "toggleSupergroupUsernameIsActive",
  disableAllSupergroupUsernames: "disableAllSupergroupUsernames",
  reorderSupergroupActiveUsernames: "reorderSupergroupActiveUsernames",
  setSupergroupStickerSet: "setSupergroupStickerSet",
  toggleSupergroupSignMessages: "toggleSupergroupSignMessages",
  toggleSupergroupJoinToSendMessages: "toggleSupergroupJoinToSendMessages",
  toggleSupergroupJoinByRequest: "toggleSupergroupJoinByRequest",
  toggleSupergroupIsAllHistoryAvailable: "toggleSupergroupIsAllHistoryAvailable",
  toggleSupergroupHasHiddenMembers: "toggleSupergroupHasHiddenMembers",
  toggleSupergroupHasAggressiveAntiSpamEnabled:
    "toggleSupergroupHasAggressiveAntiSpamEnabled",
  toggleSupergroupIsForum: "toggleSupergroupIsForum",
  toggleSupergroupIsBroadcastGroup: "toggleSupergroupIsBroadcastGroup",
  reportSupergroupSpam: "reportSupergroupSpam",
  reportSupergroupAntiSpamFalsePositive: "reportSupergroupAntiSpamFalsePositive",
  getSupergroupMembers: "getSupergroupMembers",
  closeSecretChat: "closeSecretChat",
  getChatEventLog: "getChatEventLog",
  getPaymentForm: "getPaymentForm",
  validateOrderInfo: "validateOrderInfo",
  sendPaymentForm: "sendPaymentForm",
  getPaymentReceipt: "getPaymentReceipt",
  getSavedOrderInfo: "getSavedOrderInfo",
  deleteSavedOrderInfo: "deleteSavedOrderInfo",
  deleteSavedCredentials: "deleteSavedCredentials",
  createInvoiceLink: "createInvoiceLink",
  getSupportUser: "getSupportUser",
  getBackgroundUrl: "getBackgroundUrl",
  searchBackground: "searchBackground",
  setDefaultBackground: "setDefaultBackground",
  deleteDefaultBackground: "deleteDefaultBackground",
  getInstalledBackgrounds: "getInstalledBackgrounds",
  removeInstalledBackground: "removeInstalledBackground",
  resetInstalledBackgrounds: "resetInstalledBackgrounds",
  getLocalizationTargetInfo: "getLocalizationTargetInfo",
  getLanguagePackInfo: "getLanguagePackInfo",
  getLanguagePackStrings: "getLanguagePackStrings",
  synchronizeLanguagePack: "synchronizeLanguagePack",
  addCustomServerLanguagePack: "addCustomServerLanguagePack",
  setCustomLanguagePack: "setCustomLanguagePack",
  editCustomLanguagePackInfo: "editCustomLanguagePackInfo",
  setCustomLanguagePackString: "setCustomLanguagePackString",
  deleteLanguagePack: "deleteLanguagePack",
  registerDevice: "registerDevice",
  processPushNotification: "processPushNotification",
  getPushReceiverId: "getPushReceiverId",
  getRecentlyVisitedTMeUrls: "getRecentlyVisitedTMeUrls",
  setUserPrivacySettingRules: "setUserPrivacySettingRules",
  getUserPrivacySettingRules: "getUserPrivacySettingRules",
  getOption: "getOption",
  setOption: "setOption",
  setAccountTtl: "setAccountTtl",
  getAccountTtl: "getAccountTtl",
  deleteAccount: "deleteAccount",
  setDefaultMessageAutoDeleteTime: "setDefaultMessageAutoDeleteTime",
  getDefaultMessageAutoDeleteTime: "getDefaultMessageAutoDeleteTime",
  removeChatActionBar: "removeChatActionBar",
  reportChat: "reportChat",
  reportChatPhoto: "reportChatPhoto",
  reportMessageReactions: "reportMessageReactions",
  getChatStatistics: "getChatStatistics",
  getMessageStatistics: "getMessageStatistics",
  getMessagePublicForwards: "getMessagePublicForwards",
  getStoryStatistics: "getStoryStatistics",
  getStatisticalGraph: "getStatisticalGraph",
  getStorageStatistics: "getStorageStatistics",
  getStorageStatisticsFast: "getStorageStatisticsFast",
  getDatabaseStatistics: "getDatabaseStatistics",
  optimizeStorage: "optimizeStorage",
  setNetworkType: "setNetworkType",
  getNetworkStatistics: "getNetworkStatistics",
  addNetworkStatistics: "addNetworkStatistics",
  resetNetworkStatistics: "resetNetworkStatistics",
  getAutoDownloadSettingsPresets: "getAutoDownloadSettingsPresets",
  setAutoDownloadSettings: "setAutoDownloadSettings",
  getAutosaveSettings: "getAutosaveSettings",
  setAutosaveSettings: "setAutosaveSettings",
  clearAutosaveSettingsExceptions: "clearAutosaveSettingsExceptions",
  getBankCardInfo: "getBankCardInfo",
  getPassportElement: "getPassportElement",
  getAllPassportElements: "getAllPassportElements",
  setPassportElement: "setPassportElement",
  deletePassportElement: "deletePassportElement",
  setPassportElementErrors: "setPassportElementErrors",
  getPreferredCountryLanguage: "getPreferredCountryLanguage",
  sendPhoneNumberVerificationCode: "sendPhoneNumberVerificationCode",
  resendPhoneNumberVerificationCode: "resendPhoneNumberVerificationCode",
  checkPhoneNumberVerificationCode: "checkPhoneNumberVerificationCode",
  sendEmailAddressVerificationCode: "sendEmailAddressVerificationCode",
  resendEmailAddressVerificationCode: "resendEmailAddressVerificationCode",
  checkEmailAddressVerificationCode: "checkEmailAddressVerificationCode",
  getPassportAuthorizationForm: "getPassportAuthorizationForm",
  getPassportAuthorizationFormAvailableElements:
    "getPassportAuthorizationFormAvailableElements",
  sendPassportAuthorizationForm: "sendPassportAuthorizationForm",
  sendPhoneNumberConfirmationCode: "sendPhoneNumberConfirmationCode",
  resendPhoneNumberConfirmationCode: "resendPhoneNumberConfirmationCode",
  checkPhoneNumberConfirmationCode: "checkPhoneNumberConfirmationCode",
  setBotUpdatesStatus: "setBotUpdatesStatus",
  uploadStickerFile: "uploadStickerFile",
  getSuggestedStickerSetName: "getSuggestedStickerSetName",
  checkStickerSetName: "checkStickerSetName",
  createNewStickerSet: "createNewStickerSet",
  addStickerToSet: "addStickerToSet",
  setStickerSetThumbnail: "setStickerSetThumbnail",
  setCustomEmojiStickerSetThumbnail: "setCustomEmojiStickerSetThumbnail",
  setStickerSetTitle: "setStickerSetTitle",
  deleteStickerSet: "deleteStickerSet",
  setStickerPositionInSet: "setStickerPositionInSet",
  removeStickerFromSet: "removeStickerFromSet",
  setStickerEmojis: "setStickerEmojis",
  setStickerKeywords: "setStickerKeywords",
  setStickerMaskPosition: "setStickerMaskPosition",
  getMapThumbnailFile: "getMapThumbnailFile",
  getPremiumLimit: "getPremiumLimit",
  getPremiumFeatures: "getPremiumFeatures",
  getPremiumStickerExamples: "getPremiumStickerExamples",
  viewPremiumFeature: "viewPremiumFeature",
  clickPremiumSubscriptionButton: "clickPremiumSubscriptionButton",
  getPremiumState: "getPremiumState",
  getPremiumGiftCodePaymentOptions: "getPremiumGiftCodePaymentOptions",
  checkPremiumGiftCode: "checkPremiumGiftCode",
  applyPremiumGiftCode: "applyPremiumGiftCode",
  launchPrepaidPremiumGiveaway: "launchPrepaidPremiumGiveaway",
  getPremiumGiveawayInfo: "getPremiumGiveawayInfo",
  canPurchasePremium: "canPurchasePremium",
  assignAppStoreTransaction: "assignAppStoreTransaction",
  assignGooglePlayTransaction: "assignGooglePlayTransaction",
  acceptTermsOfService: "acceptTermsOfService",
  searchStringsByPrefix: "searchStringsByPrefix",
  sendCustomRequest: "sendCustomRequest",
  answerCustomQuery: "answerCustomQuery",
  setAlarm: "setAlarm",
  getCountries: "getCountries",
  getCountryCode: "getCountryCode",
  getPhoneNumberInfo: "getPhoneNumberInfo",
  getPhoneNumberInfoSync: "getPhoneNumberInfoSync",
  getDeepLinkInfo: "getDeepLinkInfo",
  getApplicationConfig: "getApplicationConfig",
  saveApplicationLogEvent: "saveApplicationLogEvent",
  getApplicationDownloadLink: "getApplicationDownloadLink",
  addProxy: "addProxy",
  editProxy: "editProxy",
  enableProxy: "enableProxy",
  disableProxy: "disableProxy",
  removeProxy: "removeProxy",
  getProxies: "getProxies",
  getProxyLink: "getProxyLink",
  pingProxy: "pingProxy",
  setLogStream: "setLogStream",
  getLogStream: "getLogStream",
  setLogVerbosityLevel: "setLogVerbosityLevel",
  getLogVerbosityLevel: "getLogVerbosityLevel",
  getLogTags: "getLogTags",
  setLogTagVerbosityLevel: "setLogTagVerbosityLevel",
  getLogTagVerbosityLevel: "getLogTagVerbosityLevel",
  addLogMessage: "addLogMessage",
  getUserSupportInfo: "getUserSupportInfo",
  setUserSupportInfo: "setUserSupportInfo",
  getSupportName: "getSupportName",
  testCallEmpty: "testCallEmpty",
  testCallString: "testCallString",
  testCallBytes: "testCallBytes",
  testCallVectorInt: "testCallVectorInt",
  testCallVectorIntObject: "testCallVectorIntObject",
  testCallVectorString: "testCallVectorString",
  testCallVectorStringObject: "testCallVectorStringObject",
  testSquareInt: "testSquareInt",
  testNetwork: "testNetwork",
  testProxy: "testProxy",
  testGetDifference: "testGetDifference",
  testUseUpdate: "testUseUpdate",
  testReturnError: "testReturnError"
} as const);

export type $Methods = (typeof $Methods)[keyof typeof $Methods];

export const LogStream$Type = Object.freeze({
  Default: "logStreamDefault",
  File: "logStreamFile",
  Empty: "logStreamEmpty"
} as const);

export type LogStream$Type = (typeof LogStream$Type)[keyof typeof LogStream$Type];

export const Update$Type = Object.freeze({
  AuthorizationState: "updateAuthorizationState",
  NewMessage: "updateNewMessage",
  MessageSendAcknowledged: "updateMessageSendAcknowledged",
  MessageSendSucceeded: "updateMessageSendSucceeded",
  MessageSendFailed: "updateMessageSendFailed",
  MessageContent: "updateMessageContent",
  MessageEdited: "updateMessageEdited",
  MessageIsPinned: "updateMessageIsPinned",
  MessageInteractionInfo: "updateMessageInteractionInfo",
  MessageContentOpened: "updateMessageContentOpened",
  MessageMentionRead: "updateMessageMentionRead",
  MessageUnreadReactions: "updateMessageUnreadReactions",
  MessageLiveLocationViewed: "updateMessageLiveLocationViewed",
  NewChat: "updateNewChat",
  ChatTitle: "updateChatTitle",
  ChatPhoto: "updateChatPhoto",
  ChatAccentColors: "updateChatAccentColors",
  ChatPermissions: "updateChatPermissions",
  ChatLastMessage: "updateChatLastMessage",
  ChatPosition: "updateChatPosition",
  ChatReadInbox: "updateChatReadInbox",
  ChatReadOutbox: "updateChatReadOutbox",
  ChatActionBar: "updateChatActionBar",
  ChatAvailableReactions: "updateChatAvailableReactions",
  ChatDraftMessage: "updateChatDraftMessage",
  ChatEmojiStatus: "updateChatEmojiStatus",
  ChatMessageSender: "updateChatMessageSender",
  ChatMessageAutoDeleteTime: "updateChatMessageAutoDeleteTime",
  ChatNotificationSettings: "updateChatNotificationSettings",
  ChatPendingJoinRequests: "updateChatPendingJoinRequests",
  ChatReplyMarkup: "updateChatReplyMarkup",
  ChatBackground: "updateChatBackground",
  ChatTheme: "updateChatTheme",
  ChatUnreadMentionCount: "updateChatUnreadMentionCount",
  ChatUnreadReactionCount: "updateChatUnreadReactionCount",
  ChatVideoChat: "updateChatVideoChat",
  ChatDefaultDisableNotification: "updateChatDefaultDisableNotification",
  ChatHasProtectedContent: "updateChatHasProtectedContent",
  ChatIsTranslatable: "updateChatIsTranslatable",
  ChatIsMarkedAsUnread: "updateChatIsMarkedAsUnread",
  ChatViewAsTopics: "updateChatViewAsTopics",
  ChatBlockList: "updateChatBlockList",
  ChatHasScheduledMessages: "updateChatHasScheduledMessages",
  ChatFolders: "updateChatFolders",
  ChatOnlineMemberCount: "updateChatOnlineMemberCount",
  ForumTopicInfo: "updateForumTopicInfo",
  ScopeNotificationSettings: "updateScopeNotificationSettings",
  Notification: "updateNotification",
  NotificationGroup: "updateNotificationGroup",
  ActiveNotifications: "updateActiveNotifications",
  HavePendingNotifications: "updateHavePendingNotifications",
  DeleteMessages: "updateDeleteMessages",
  ChatAction: "updateChatAction",
  UserStatus: "updateUserStatus",
  User: "updateUser",
  BasicGroup: "updateBasicGroup",
  Supergroup: "updateSupergroup",
  SecretChat: "updateSecretChat",
  UserFullInfo: "updateUserFullInfo",
  BasicGroupFullInfo: "updateBasicGroupFullInfo",
  SupergroupFullInfo: "updateSupergroupFullInfo",
  ServiceNotification: "updateServiceNotification",
  File: "updateFile",
  FileGenerationStart: "updateFileGenerationStart",
  FileGenerationStop: "updateFileGenerationStop",
  FileDownloads: "updateFileDownloads",
  FileAddedToDownloads: "updateFileAddedToDownloads",
  FileDownload: "updateFileDownload",
  FileRemovedFromDownloads: "updateFileRemovedFromDownloads",
  Call: "updateCall",
  GroupCall: "updateGroupCall",
  GroupCallParticipant: "updateGroupCallParticipant",
  NewCallSignalingData: "updateNewCallSignalingData",
  UserPrivacySettingRules: "updateUserPrivacySettingRules",
  UnreadMessageCount: "updateUnreadMessageCount",
  UnreadChatCount: "updateUnreadChatCount",
  Story: "updateStory",
  StoryDeleted: "updateStoryDeleted",
  StorySendSucceeded: "updateStorySendSucceeded",
  StorySendFailed: "updateStorySendFailed",
  ChatActiveStories: "updateChatActiveStories",
  StoryListChatCount: "updateStoryListChatCount",
  StoryStealthMode: "updateStoryStealthMode",
  Option: "updateOption",
  StickerSet: "updateStickerSet",
  InstalledStickerSets: "updateInstalledStickerSets",
  TrendingStickerSets: "updateTrendingStickerSets",
  RecentStickers: "updateRecentStickers",
  FavoriteStickers: "updateFavoriteStickers",
  SavedAnimations: "updateSavedAnimations",
  SavedNotificationSounds: "updateSavedNotificationSounds",
  DefaultBackground: "updateDefaultBackground",
  ChatThemes: "updateChatThemes",
  AccentColors: "updateAccentColors",
  ProfileAccentColors: "updateProfileAccentColors",
  LanguagePackStrings: "updateLanguagePackStrings",
  ConnectionState: "updateConnectionState",
  TermsOfService: "updateTermsOfService",
  UsersNearby: "updateUsersNearby",
  UnconfirmedSession: "updateUnconfirmedSession",
  AttachmentMenuBots: "updateAttachmentMenuBots",
  WebAppMessageSent: "updateWebAppMessageSent",
  ActiveEmojiReactions: "updateActiveEmojiReactions",
  DefaultReactionType: "updateDefaultReactionType",
  SpeechRecognitionTrial: "updateSpeechRecognitionTrial",
  DiceEmojis: "updateDiceEmojis",
  AnimatedEmojiMessageClicked: "updateAnimatedEmojiMessageClicked",
  AnimationSearchParameters: "updateAnimationSearchParameters",
  SuggestedActions: "updateSuggestedActions",
  AddChatMembersPrivacyForbidden: "updateAddChatMembersPrivacyForbidden",
  AutosaveSettings: "updateAutosaveSettings",
  NewInlineQuery: "updateNewInlineQuery",
  NewChosenInlineResult: "updateNewChosenInlineResult",
  NewCallbackQuery: "updateNewCallbackQuery",
  NewInlineCallbackQuery: "updateNewInlineCallbackQuery",
  NewShippingQuery: "updateNewShippingQuery",
  NewPreCheckoutQuery: "updateNewPreCheckoutQuery",
  NewCustomEvent: "updateNewCustomEvent",
  NewCustomQuery: "updateNewCustomQuery",
  Poll: "updatePoll",
  PollAnswer: "updatePollAnswer",
  ChatMember: "updateChatMember",
  NewChatJoinRequest: "updateNewChatJoinRequest",
  ChatBoost: "updateChatBoost",
  MessageReaction: "updateMessageReaction",
  MessageReactions: "updateMessageReactions"
} as const);

export type Update$Type = (typeof Update$Type)[keyof typeof Update$Type];

export const BotCommandScope$Type = Object.freeze({
  Default: "botCommandScopeDefault",
  AllPrivateChats: "botCommandScopeAllPrivateChats",
  AllGroupChats: "botCommandScopeAllGroupChats",
  AllChatAdministrators: "botCommandScopeAllChatAdministrators",
  Chat: "botCommandScopeChat",
  ChatAdministrators: "botCommandScopeChatAdministrators",
  ChatMember: "botCommandScopeChatMember"
} as const);

export type BotCommandScope$Type =
  (typeof BotCommandScope$Type)[keyof typeof BotCommandScope$Type];

export const VectorPathCommand$Type = Object.freeze({
  Line: "vectorPathCommandLine",
  CubicBezierCurve: "vectorPathCommandCubicBezierCurve"
} as const);

export type VectorPathCommand$Type =
  (typeof VectorPathCommand$Type)[keyof typeof VectorPathCommand$Type];

export const ChatStatistics$Type = Object.freeze({
  Supergroup: "chatStatisticsSupergroup",
  Channel: "chatStatisticsChannel"
} as const);

export type ChatStatistics$Type =
  (typeof ChatStatistics$Type)[keyof typeof ChatStatistics$Type];

export const ChatStatisticsObjectType$Type = Object.freeze({
  Message: "chatStatisticsObjectTypeMessage",
  Story: "chatStatisticsObjectTypeStory"
} as const);

export type ChatStatisticsObjectType$Type =
  (typeof ChatStatisticsObjectType$Type)[keyof typeof ChatStatisticsObjectType$Type];

export const StatisticalGraph$Type = Object.freeze({
  Data: "statisticalGraphData",
  Async: "statisticalGraphAsync",
  Error: "statisticalGraphError"
} as const);

export type StatisticalGraph$Type =
  (typeof StatisticalGraph$Type)[keyof typeof StatisticalGraph$Type];

export const ProxyType$Type = Object.freeze({
  Socks5: "proxyTypeSocks5",
  Http: "proxyTypeHttp",
  Mtproto: "proxyTypeMtproto"
} as const);

export type ProxyType$Type = (typeof ProxyType$Type)[keyof typeof ProxyType$Type];

export const TextParseMode$Type = Object.freeze({
  Markdown: "textParseModeMarkdown",
  HTML: "textParseModeHTML"
} as const);

export type TextParseMode$Type =
  (typeof TextParseMode$Type)[keyof typeof TextParseMode$Type];

export const SuggestedAction$Type = Object.freeze({
  EnableArchiveAndMuteNewChats: "suggestedActionEnableArchiveAndMuteNewChats",
  CheckPassword: "suggestedActionCheckPassword",
  CheckPhoneNumber: "suggestedActionCheckPhoneNumber",
  ViewChecksHint: "suggestedActionViewChecksHint",
  ConvertToBroadcastGroup: "suggestedActionConvertToBroadcastGroup",
  SetPassword: "suggestedActionSetPassword",
  UpgradePremium: "suggestedActionUpgradePremium",
  RestorePremium: "suggestedActionRestorePremium",
  SubscribeToAnnualPremium: "suggestedActionSubscribeToAnnualPremium",
  GiftPremiumForChristmas: "suggestedActionGiftPremiumForChristmas"
} as const);

export type SuggestedAction$Type =
  (typeof SuggestedAction$Type)[keyof typeof SuggestedAction$Type];

export const TMeUrlType$Type = Object.freeze({
  User: "tMeUrlTypeUser",
  Supergroup: "tMeUrlTypeSupergroup",
  ChatInvite: "tMeUrlTypeChatInvite",
  StickerSet: "tMeUrlTypeStickerSet"
} as const);

export type TMeUrlType$Type = (typeof TMeUrlType$Type)[keyof typeof TMeUrlType$Type];

export const TopChatCategory$Type = Object.freeze({
  Users: "topChatCategoryUsers",
  Bots: "topChatCategoryBots",
  Groups: "topChatCategoryGroups",
  Channels: "topChatCategoryChannels",
  InlineBots: "topChatCategoryInlineBots",
  Calls: "topChatCategoryCalls",
  ForwardChats: "topChatCategoryForwardChats"
} as const);

export type TopChatCategory$Type =
  (typeof TopChatCategory$Type)[keyof typeof TopChatCategory$Type];

export const ConnectionState$Type = Object.freeze({
  WaitingForNetwork: "connectionStateWaitingForNetwork",
  ConnectingToProxy: "connectionStateConnectingToProxy",
  Connecting: "connectionStateConnecting",
  Updating: "connectionStateUpdating",
  Ready: "connectionStateReady"
} as const);

export type ConnectionState$Type =
  (typeof ConnectionState$Type)[keyof typeof ConnectionState$Type];

export const AutosaveSettingsScope$Type = Object.freeze({
  PrivateChats: "autosaveSettingsScopePrivateChats",
  GroupChats: "autosaveSettingsScopeGroupChats",
  ChannelChats: "autosaveSettingsScopeChannelChats",
  Chat: "autosaveSettingsScopeChat"
} as const);

export type AutosaveSettingsScope$Type =
  (typeof AutosaveSettingsScope$Type)[keyof typeof AutosaveSettingsScope$Type];

export const NetworkStatisticsEntry$Type = Object.freeze({
  File: "networkStatisticsEntryFile",
  Call: "networkStatisticsEntryCall"
} as const);

export type NetworkStatisticsEntry$Type =
  (typeof NetworkStatisticsEntry$Type)[keyof typeof NetworkStatisticsEntry$Type];

export const NetworkType$Type = Object.freeze({
  None: "networkTypeNone",
  Mobile: "networkTypeMobile",
  MobileRoaming: "networkTypeMobileRoaming",
  WiFi: "networkTypeWiFi",
  Other: "networkTypeOther"
} as const);

export type NetworkType$Type =
  (typeof NetworkType$Type)[keyof typeof NetworkType$Type];

export const FileType$Type = Object.freeze({
  None: "fileTypeNone",
  Animation: "fileTypeAnimation",
  Audio: "fileTypeAudio",
  Document: "fileTypeDocument",
  NotificationSound: "fileTypeNotificationSound",
  Photo: "fileTypePhoto",
  PhotoStory: "fileTypePhotoStory",
  ProfilePhoto: "fileTypeProfilePhoto",
  Secret: "fileTypeSecret",
  SecretThumbnail: "fileTypeSecretThumbnail",
  Secure: "fileTypeSecure",
  Sticker: "fileTypeSticker",
  Thumbnail: "fileTypeThumbnail",
  Unknown: "fileTypeUnknown",
  Video: "fileTypeVideo",
  VideoNote: "fileTypeVideoNote",
  VideoStory: "fileTypeVideoStory",
  VoiceNote: "fileTypeVoiceNote",
  Wallpaper: "fileTypeWallpaper"
} as const);

export type FileType$Type = (typeof FileType$Type)[keyof typeof FileType$Type];

export const BlockList$Type = Object.freeze({
  Main: "blockListMain",
  Stories: "blockListStories"
} as const);

export type BlockList$Type = (typeof BlockList$Type)[keyof typeof BlockList$Type];

export const InternalLinkType$Type = Object.freeze({
  ActiveSessions: "internalLinkTypeActiveSessions",
  AttachmentMenuBot: "internalLinkTypeAttachmentMenuBot",
  AuthenticationCode: "internalLinkTypeAuthenticationCode",
  Background: "internalLinkTypeBackground",
  BotAddToChannel: "internalLinkTypeBotAddToChannel",
  BotStart: "internalLinkTypeBotStart",
  BotStartInGroup: "internalLinkTypeBotStartInGroup",
  ChangePhoneNumber: "internalLinkTypeChangePhoneNumber",
  ChatBoost: "internalLinkTypeChatBoost",
  ChatFolderInvite: "internalLinkTypeChatFolderInvite",
  ChatFolderSettings: "internalLinkTypeChatFolderSettings",
  ChatInvite: "internalLinkTypeChatInvite",
  DefaultMessageAutoDeleteTimerSettings:
    "internalLinkTypeDefaultMessageAutoDeleteTimerSettings",
  EditProfileSettings: "internalLinkTypeEditProfileSettings",
  Game: "internalLinkTypeGame",
  InstantView: "internalLinkTypeInstantView",
  Invoice: "internalLinkTypeInvoice",
  LanguagePack: "internalLinkTypeLanguagePack",
  LanguageSettings: "internalLinkTypeLanguageSettings",
  Message: "internalLinkTypeMessage",
  MessageDraft: "internalLinkTypeMessageDraft",
  PassportDataRequest: "internalLinkTypePassportDataRequest",
  PhoneNumberConfirmation: "internalLinkTypePhoneNumberConfirmation",
  PremiumFeatures: "internalLinkTypePremiumFeatures",
  PremiumGift: "internalLinkTypePremiumGift",
  PremiumGiftCode: "internalLinkTypePremiumGiftCode",
  PrivacyAndSecuritySettings: "internalLinkTypePrivacyAndSecuritySettings",
  Proxy: "internalLinkTypeProxy",
  PublicChat: "internalLinkTypePublicChat",
  QrCodeAuthentication: "internalLinkTypeQrCodeAuthentication",
  RestorePurchases: "internalLinkTypeRestorePurchases",
  Settings: "internalLinkTypeSettings",
  SideMenuBot: "internalLinkTypeSideMenuBot",
  StickerSet: "internalLinkTypeStickerSet",
  Story: "internalLinkTypeStory",
  Theme: "internalLinkTypeTheme",
  ThemeSettings: "internalLinkTypeThemeSettings",
  UnknownDeepLink: "internalLinkTypeUnknownDeepLink",
  UnsupportedProxy: "internalLinkTypeUnsupportedProxy",
  UserPhoneNumber: "internalLinkTypeUserPhoneNumber",
  UserToken: "internalLinkTypeUserToken",
  VideoChat: "internalLinkTypeVideoChat",
  WebApp: "internalLinkTypeWebApp"
} as const);

export type InternalLinkType$Type =
  (typeof InternalLinkType$Type)[keyof typeof InternalLinkType$Type];

export const TargetChat$Type = Object.freeze({
  Current: "targetChatCurrent",
  Chosen: "targetChatChosen",
  InternalLink: "targetChatInternalLink"
} as const);

export type TargetChat$Type = (typeof TargetChat$Type)[keyof typeof TargetChat$Type];

export const ReportReason$Type = Object.freeze({
  Spam: "reportReasonSpam",
  Violence: "reportReasonViolence",
  Pornography: "reportReasonPornography",
  ChildAbuse: "reportReasonChildAbuse",
  Copyright: "reportReasonCopyright",
  UnrelatedLocation: "reportReasonUnrelatedLocation",
  Fake: "reportReasonFake",
  IllegalDrugs: "reportReasonIllegalDrugs",
  PersonalDetails: "reportReasonPersonalDetails",
  Custom: "reportReasonCustom"
} as const);

export type ReportReason$Type =
  (typeof ReportReason$Type)[keyof typeof ReportReason$Type];

export const SessionType$Type = Object.freeze({
  Android: "sessionTypeAndroid",
  Apple: "sessionTypeApple",
  Brave: "sessionTypeBrave",
  Chrome: "sessionTypeChrome",
  Edge: "sessionTypeEdge",
  Firefox: "sessionTypeFirefox",
  Ipad: "sessionTypeIpad",
  Iphone: "sessionTypeIphone",
  Linux: "sessionTypeLinux",
  Mac: "sessionTypeMac",
  Opera: "sessionTypeOpera",
  Safari: "sessionTypeSafari",
  Ubuntu: "sessionTypeUbuntu",
  Unknown: "sessionTypeUnknown",
  Vivaldi: "sessionTypeVivaldi",
  Windows: "sessionTypeWindows",
  Xbox: "sessionTypeXbox"
} as const);

export type SessionType$Type =
  (typeof SessionType$Type)[keyof typeof SessionType$Type];

export const UserPrivacySetting$Type = Object.freeze({
  ShowStatus: "userPrivacySettingShowStatus",
  ShowProfilePhoto: "userPrivacySettingShowProfilePhoto",
  ShowLinkInForwardedMessages: "userPrivacySettingShowLinkInForwardedMessages",
  ShowPhoneNumber: "userPrivacySettingShowPhoneNumber",
  ShowBio: "userPrivacySettingShowBio",
  AllowChatInvites: "userPrivacySettingAllowChatInvites",
  AllowCalls: "userPrivacySettingAllowCalls",
  AllowPeerToPeerCalls: "userPrivacySettingAllowPeerToPeerCalls",
  AllowFindingByPhoneNumber: "userPrivacySettingAllowFindingByPhoneNumber",
  AllowPrivateVoiceAndVideoNoteMessages:
    "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages"
} as const);

export type UserPrivacySetting$Type =
  (typeof UserPrivacySetting$Type)[keyof typeof UserPrivacySetting$Type];

export const UserPrivacySettingRule$Type = Object.freeze({
  AllowAll: "userPrivacySettingRuleAllowAll",
  AllowContacts: "userPrivacySettingRuleAllowContacts",
  AllowUsers: "userPrivacySettingRuleAllowUsers",
  AllowChatMembers: "userPrivacySettingRuleAllowChatMembers",
  RestrictAll: "userPrivacySettingRuleRestrictAll",
  RestrictContacts: "userPrivacySettingRuleRestrictContacts",
  RestrictUsers: "userPrivacySettingRuleRestrictUsers",
  RestrictChatMembers: "userPrivacySettingRuleRestrictChatMembers"
} as const);

export type UserPrivacySettingRule$Type =
  (typeof UserPrivacySettingRule$Type)[keyof typeof UserPrivacySettingRule$Type];

export const StoryPrivacySettings$Type = Object.freeze({
  Everyone: "storyPrivacySettingsEveryone",
  Contacts: "storyPrivacySettingsContacts",
  CloseFriends: "storyPrivacySettingsCloseFriends",
  SelectedUsers: "storyPrivacySettingsSelectedUsers"
} as const);

export type StoryPrivacySettings$Type =
  (typeof StoryPrivacySettings$Type)[keyof typeof StoryPrivacySettings$Type];

export const JsonValue$Type = Object.freeze({
  Null: "jsonValueNull",
  Boolean: "jsonValueBoolean",
  Number: "jsonValueNumber",
  String: "jsonValueString",
  Array: "jsonValueArray",
  Object: "jsonValueObject"
} as const);

export type JsonValue$Type = (typeof JsonValue$Type)[keyof typeof JsonValue$Type];

export const OptionValue$Type = Object.freeze({
  Boolean: "optionValueBoolean",
  Empty: "optionValueEmpty",
  Integer: "optionValueInteger",
  String: "optionValueString"
} as const);

export type OptionValue$Type =
  (typeof OptionValue$Type)[keyof typeof OptionValue$Type];

export const NotificationGroupType$Type = Object.freeze({
  Messages: "notificationGroupTypeMessages",
  Mentions: "notificationGroupTypeMentions",
  SecretChat: "notificationGroupTypeSecretChat",
  Calls: "notificationGroupTypeCalls"
} as const);

export type NotificationGroupType$Type =
  (typeof NotificationGroupType$Type)[keyof typeof NotificationGroupType$Type];

export const NotificationType$Type = Object.freeze({
  Message: "notificationTypeNewMessage",
  SecretChat: "notificationTypeNewSecretChat",
  Call: "notificationTypeNewCall",
  PushMessage: "notificationTypeNewPushMessage"
} as const);

export type NotificationType$Type =
  (typeof NotificationType$Type)[keyof typeof NotificationType$Type];

export const PushMessageContent$Type = Object.freeze({
  Hidden: "pushMessageContentHidden",
  Animation: "pushMessageContentAnimation",
  Audio: "pushMessageContentAudio",
  Contact: "pushMessageContentContact",
  ContactRegistered: "pushMessageContentContactRegistered",
  Document: "pushMessageContentDocument",
  Game: "pushMessageContentGame",
  GameScore: "pushMessageContentGameScore",
  Invoice: "pushMessageContentInvoice",
  Location: "pushMessageContentLocation",
  Photo: "pushMessageContentPhoto",
  Poll: "pushMessageContentPoll",
  PremiumGiftCode: "pushMessageContentPremiumGiftCode",
  PremiumGiveaway: "pushMessageContentPremiumGiveaway",
  ScreenshotTaken: "pushMessageContentScreenshotTaken",
  Sticker: "pushMessageContentSticker",
  Story: "pushMessageContentStory",
  Text: "pushMessageContentText",
  Video: "pushMessageContentVideo",
  VideoNote: "pushMessageContentVideoNote",
  VoiceNote: "pushMessageContentVoiceNote",
  BasicGroupChatCreate: "pushMessageContentBasicGroupChatCreate",
  ChatAddMembers: "pushMessageContentChatAddMembers",
  ChatChangePhoto: "pushMessageContentChatChangePhoto",
  ChatChangeTitle: "pushMessageContentChatChangeTitle",
  ChatSetBackground: "pushMessageContentChatSetBackground",
  ChatSetTheme: "pushMessageContentChatSetTheme",
  ChatDeleteMember: "pushMessageContentChatDeleteMember",
  ChatJoinByLink: "pushMessageContentChatJoinByLink",
  ChatJoinByRequest: "pushMessageContentChatJoinByRequest",
  RecurringPayment: "pushMessageContentRecurringPayment",
  SuggestProfilePhoto: "pushMessageContentSuggestProfilePhoto",
  MessageForwards: "pushMessageContentMessageForwards",
  MediaAlbum: "pushMessageContentMediaAlbum"
} as const);

export type PushMessageContent$Type =
  (typeof PushMessageContent$Type)[keyof typeof PushMessageContent$Type];

export const MessageFileType$Type = Object.freeze({
  Private: "messageFileTypePrivate",
  Group: "messageFileTypeGroup",
  Unknown: "messageFileTypeUnknown"
} as const);

export type MessageFileType$Type =
  (typeof MessageFileType$Type)[keyof typeof MessageFileType$Type];

export const ResetPasswordResult$Type = Object.freeze({
  Ok: "resetPasswordResultOk",
  Pending: "resetPasswordResultPending",
  Declined: "resetPasswordResultDeclined"
} as const);

export type ResetPasswordResult$Type =
  (typeof ResetPasswordResult$Type)[keyof typeof ResetPasswordResult$Type];

export const CheckStickerSetNameResult$Type = Object.freeze({
  Ok: "checkStickerSetNameResultOk",
  NameInvalid: "checkStickerSetNameResultNameInvalid",
  NameOccupied: "checkStickerSetNameResultNameOccupied"
} as const);

export type CheckStickerSetNameResult$Type =
  (typeof CheckStickerSetNameResult$Type)[keyof typeof CheckStickerSetNameResult$Type];

export const CheckChatUsernameResult$Type = Object.freeze({
  Ok: "checkChatUsernameResultOk",
  UsernameInvalid: "checkChatUsernameResultUsernameInvalid",
  UsernameOccupied: "checkChatUsernameResultUsernameOccupied",
  UsernamePurchasable: "checkChatUsernameResultUsernamePurchasable",
  PublicChatsTooMany: "checkChatUsernameResultPublicChatsTooMany",
  PublicGroupsUnavailable: "checkChatUsernameResultPublicGroupsUnavailable"
} as const);

export type CheckChatUsernameResult$Type =
  (typeof CheckChatUsernameResult$Type)[keyof typeof CheckChatUsernameResult$Type];

export const CanTransferOwnershipResult$Type = Object.freeze({
  Ok: "canTransferOwnershipResultOk",
  PasswordNeeded: "canTransferOwnershipResultPasswordNeeded",
  PasswordTooFresh: "canTransferOwnershipResultPasswordTooFresh",
  SessionTooFresh: "canTransferOwnershipResultSessionTooFresh"
} as const);

export type CanTransferOwnershipResult$Type =
  (typeof CanTransferOwnershipResult$Type)[keyof typeof CanTransferOwnershipResult$Type];

export const CanSendStoryResult$Type = Object.freeze({
  Ok: "canSendStoryResultOk",
  PremiumNeeded: "canSendStoryResultPremiumNeeded",
  BoostNeeded: "canSendStoryResultBoostNeeded",
  ActiveStoryLimitExceeded: "canSendStoryResultActiveStoryLimitExceeded",
  WeeklyLimitExceeded: "canSendStoryResultWeeklyLimitExceeded",
  MonthlyLimitExceeded: "canSendStoryResultMonthlyLimitExceeded"
} as const);

export type CanSendStoryResult$Type =
  (typeof CanSendStoryResult$Type)[keyof typeof CanSendStoryResult$Type];

export const InputBackground$Type = Object.freeze({
  Local: "inputBackgroundLocal",
  Remote: "inputBackgroundRemote",
  Previous: "inputBackgroundPrevious"
} as const);

export type InputBackground$Type =
  (typeof InputBackground$Type)[keyof typeof InputBackground$Type];

export const BackgroundType$Type = Object.freeze({
  Wallpaper: "backgroundTypeWallpaper",
  Pattern: "backgroundTypePattern",
  Fill: "backgroundTypeFill",
  ChatTheme: "backgroundTypeChatTheme"
} as const);

export type BackgroundType$Type =
  (typeof BackgroundType$Type)[keyof typeof BackgroundType$Type];

export const BackgroundFill$Type = Object.freeze({
  Solid: "backgroundFillSolid",
  Gradient: "backgroundFillGradient",
  FreeformGradient: "backgroundFillFreeformGradient"
} as const);

export type BackgroundFill$Type =
  (typeof BackgroundFill$Type)[keyof typeof BackgroundFill$Type];

export const DeviceToken$Type = Object.freeze({
  FirebaseCloudMessaging: "deviceTokenFirebaseCloudMessaging",
  ApplePush: "deviceTokenApplePush",
  ApplePushVoIP: "deviceTokenApplePushVoIP",
  WindowsPush: "deviceTokenWindowsPush",
  MicrosoftPush: "deviceTokenMicrosoftPush",
  MicrosoftPushVoIP: "deviceTokenMicrosoftPushVoIP",
  WebPush: "deviceTokenWebPush",
  SimplePush: "deviceTokenSimplePush",
  UbuntuPush: "deviceTokenUbuntuPush",
  BlackBerryPush: "deviceTokenBlackBerryPush",
  TizenPush: "deviceTokenTizenPush",
  HuaweiPush: "deviceTokenHuaweiPush"
} as const);

export type DeviceToken$Type =
  (typeof DeviceToken$Type)[keyof typeof DeviceToken$Type];

export const TelegramPaymentPurpose$Type = Object.freeze({
  ftCodes: "telegramPaymentPurposePremiumGiftCodes",
  veaway: "telegramPaymentPurposePremiumGiveaway"
} as const);

export type TelegramPaymentPurpose$Type =
  (typeof TelegramPaymentPurpose$Type)[keyof typeof TelegramPaymentPurpose$Type];

export const StorePaymentPurpose$Type = Object.freeze({
  PremiumSubscription: "storePaymentPurposePremiumSubscription",
  GiftedPremium: "storePaymentPurposeGiftedPremium",
  PremiumGiftCodes: "storePaymentPurposePremiumGiftCodes",
  PremiumGiveaway: "storePaymentPurposePremiumGiveaway"
} as const);

export type StorePaymentPurpose$Type =
  (typeof StorePaymentPurpose$Type)[keyof typeof StorePaymentPurpose$Type];

export const PremiumSource$Type = Object.freeze({
  LimitExceeded: "premiumSourceLimitExceeded",
  Feature: "premiumSourceFeature",
  StoryFeature: "premiumSourceStoryFeature",
  Link: "premiumSourceLink",
  Settings: "premiumSourceSettings"
} as const);

export type PremiumSource$Type =
  (typeof PremiumSource$Type)[keyof typeof PremiumSource$Type];

export const PremiumStoryFeature$Type = Object.freeze({
  PriorityOrder: "premiumStoryFeaturePriorityOrder",
  StealthMode: "premiumStoryFeatureStealthMode",
  PermanentViewsHistory: "premiumStoryFeaturePermanentViewsHistory",
  CustomExpirationDuration: "premiumStoryFeatureCustomExpirationDuration",
  SaveStories: "premiumStoryFeatureSaveStories",
  LinksAndFormatting: "premiumStoryFeatureLinksAndFormatting"
} as const);

export type PremiumStoryFeature$Type =
  (typeof PremiumStoryFeature$Type)[keyof typeof PremiumStoryFeature$Type];

export const PremiumFeature$Type = Object.freeze({
  IncreasedLimits: "premiumFeatureIncreasedLimits",
  IncreasedUploadFileSize: "premiumFeatureIncreasedUploadFileSize",
  ImprovedDownloadSpeed: "premiumFeatureImprovedDownloadSpeed",
  VoiceRecognition: "premiumFeatureVoiceRecognition",
  DisabledAds: "premiumFeatureDisabledAds",
  UniqueReactions: "premiumFeatureUniqueReactions",
  UniqueStickers: "premiumFeatureUniqueStickers",
  CustomEmoji: "premiumFeatureCustomEmoji",
  AdvancedChatManagement: "premiumFeatureAdvancedChatManagement",
  ProfileBadge: "premiumFeatureProfileBadge",
  EmojiStatus: "premiumFeatureEmojiStatus",
  AnimatedProfilePhoto: "premiumFeatureAnimatedProfilePhoto",
  ForumTopicIcon: "premiumFeatureForumTopicIcon",
  AppIcons: "premiumFeatureAppIcons",
  RealTimeChatTranslation: "premiumFeatureRealTimeChatTranslation",
  UpgradedStories: "premiumFeatureUpgradedStories",
  ChatBoost: "premiumFeatureChatBoost",
  AccentColor: "premiumFeatureAccentColor",
  BackgroundForBoth: "premiumFeatureBackgroundForBoth"
} as const);

export type PremiumFeature$Type =
  (typeof PremiumFeature$Type)[keyof typeof PremiumFeature$Type];

export const PremiumLimitType$Type = Object.freeze({
  SupergroupCount: "premiumLimitTypeSupergroupCount",
  PinnedChatCount: "premiumLimitTypePinnedChatCount",
  CreatedPublicChatCount: "premiumLimitTypeCreatedPublicChatCount",
  SavedAnimationCount: "premiumLimitTypeSavedAnimationCount",
  FavoriteStickerCount: "premiumLimitTypeFavoriteStickerCount",
  ChatFolderCount: "premiumLimitTypeChatFolderCount",
  ChatFolderChosenChatCount: "premiumLimitTypeChatFolderChosenChatCount",
  PinnedArchivedChatCount: "premiumLimitTypePinnedArchivedChatCount",
  CaptionLength: "premiumLimitTypeCaptionLength",
  BioLength: "premiumLimitTypeBioLength",
  ChatFolderInviteLinkCount: "premiumLimitTypeChatFolderInviteLinkCount",
  ShareableChatFolderCount: "premiumLimitTypeShareableChatFolderCount",
  ActiveStoryCount: "premiumLimitTypeActiveStoryCount",
  WeeklySentStoryCount: "premiumLimitTypeWeeklySentStoryCount",
  MonthlySentStoryCount: "premiumLimitTypeMonthlySentStoryCount",
  StoryCaptionLength: "premiumLimitTypeStoryCaptionLength",
  StorySuggestedReactionAreaCount: "premiumLimitTypeStorySuggestedReactionAreaCount",
  SimilarChatCount: "premiumLimitTypeSimilarChatCount"
} as const);

export type PremiumLimitType$Type =
  (typeof PremiumLimitType$Type)[keyof typeof PremiumLimitType$Type];

export const LanguagePackStringValue$Type = Object.freeze({
  Ordinary: "languagePackStringValueOrdinary",
  Pluralized: "languagePackStringValuePluralized",
  Deleted: "languagePackStringValueDeleted"
} as const);

export type LanguagePackStringValue$Type =
  (typeof LanguagePackStringValue$Type)[keyof typeof LanguagePackStringValue$Type];

export const ChatEventAction$Type = Object.freeze({
  MessageEdited: "chatEventMessageEdited",
  MessageDeleted: "chatEventMessageDeleted",
  MessagePinned: "chatEventMessagePinned",
  MessageUnpinned: "chatEventMessageUnpinned",
  PollStopped: "chatEventPollStopped",
  MemberJoined: "chatEventMemberJoined",
  MemberJoinedByInviteLink: "chatEventMemberJoinedByInviteLink",
  MemberJoinedByRequest: "chatEventMemberJoinedByRequest",
  MemberInvited: "chatEventMemberInvited",
  MemberLeft: "chatEventMemberLeft",
  MemberPromoted: "chatEventMemberPromoted",
  MemberRestricted: "chatEventMemberRestricted",
  AvailableReactionsChanged: "chatEventAvailableReactionsChanged",
  BackgroundChanged: "chatEventBackgroundChanged",
  DescriptionChanged: "chatEventDescriptionChanged",
  EmojiStatusChanged: "chatEventEmojiStatusChanged",
  LinkedChatChanged: "chatEventLinkedChatChanged",
  LocationChanged: "chatEventLocationChanged",
  MessageAutoDeleteTimeChanged: "chatEventMessageAutoDeleteTimeChanged",
  PermissionsChanged: "chatEventPermissionsChanged",
  PhotoChanged: "chatEventPhotoChanged",
  SlowModeDelayChanged: "chatEventSlowModeDelayChanged",
  StickerSetChanged: "chatEventStickerSetChanged",
  TitleChanged: "chatEventTitleChanged",
  UsernameChanged: "chatEventUsernameChanged",
  ActiveUsernamesChanged: "chatEventActiveUsernamesChanged",
  AccentColorChanged: "chatEventAccentColorChanged",
  ProfileAccentColorChanged: "chatEventProfileAccentColorChanged",
  HasProtectedContentToggled: "chatEventHasProtectedContentToggled",
  InvitesToggled: "chatEventInvitesToggled",
  IsAllHistoryAvailableToggled: "chatEventIsAllHistoryAvailableToggled",
  HasAggressiveAntiSpamEnabledToggled:
    "chatEventHasAggressiveAntiSpamEnabledToggled",
  SignMessagesToggled: "chatEventSignMessagesToggled",
  InviteLinkEdited: "chatEventInviteLinkEdited",
  InviteLinkRevoked: "chatEventInviteLinkRevoked",
  InviteLinkDeleted: "chatEventInviteLinkDeleted",
  VideoChatCreated: "chatEventVideoChatCreated",
  VideoChatEnded: "chatEventVideoChatEnded",
  VideoChatMuteNewParticipantsToggled:
    "chatEventVideoChatMuteNewParticipantsToggled",
  VideoChatParticipantIsMutedToggled: "chatEventVideoChatParticipantIsMutedToggled",
  VideoChatParticipantVolumeLevelChanged:
    "chatEventVideoChatParticipantVolumeLevelChanged",
  IsForumToggled: "chatEventIsForumToggled",
  ForumTopicCreated: "chatEventForumTopicCreated",
  ForumTopicEdited: "chatEventForumTopicEdited",
  ForumTopicToggleIsClosed: "chatEventForumTopicToggleIsClosed",
  ForumTopicToggleIsHidden: "chatEventForumTopicToggleIsHidden",
  ForumTopicDeleted: "chatEventForumTopicDeleted",
  ForumTopicPinned: "chatEventForumTopicPinned"
} as const);

export type ChatEventAction$Type =
  (typeof ChatEventAction$Type)[keyof typeof ChatEventAction$Type];

export const CallbackQueryPayload$Type = Object.freeze({
  Data: "callbackQueryPayloadData",
  DataWithPassword: "callbackQueryPayloadDataWithPassword",
  Game: "callbackQueryPayloadGame"
} as const);

export type CallbackQueryPayload$Type =
  (typeof CallbackQueryPayload$Type)[keyof typeof CallbackQueryPayload$Type];

export const InlineQueryResultsButtonType$Type = Object.freeze({
  StartBot: "inlineQueryResultsButtonTypeStartBot",
  WebApp: "inlineQueryResultsButtonTypeWebApp"
} as const);

export type InlineQueryResultsButtonType$Type =
  (typeof InlineQueryResultsButtonType$Type)[keyof typeof InlineQueryResultsButtonType$Type];

export const InlineQueryResult$Type = Object.freeze({
  Article: "inlineQueryResultArticle",
  Contact: "inlineQueryResultContact",
  Location: "inlineQueryResultLocation",
  Venue: "inlineQueryResultVenue",
  Game: "inlineQueryResultGame",
  Animation: "inlineQueryResultAnimation",
  Audio: "inlineQueryResultAudio",
  Document: "inlineQueryResultDocument",
  Photo: "inlineQueryResultPhoto",
  Sticker: "inlineQueryResultSticker",
  Video: "inlineQueryResultVideo",
  VoiceNote: "inlineQueryResultVoiceNote"
} as const);

export type InlineQueryResult$Type =
  (typeof InlineQueryResult$Type)[keyof typeof InlineQueryResult$Type];

export const InputInlineQueryResult$Type = Object.freeze({
  Animation: "inputInlineQueryResultAnimation",
  Article: "inputInlineQueryResultArticle",
  Audio: "inputInlineQueryResultAudio",
  Contact: "inputInlineQueryResultContact",
  Document: "inputInlineQueryResultDocument",
  Game: "inputInlineQueryResultGame",
  Location: "inputInlineQueryResultLocation",
  Photo: "inputInlineQueryResultPhoto",
  Sticker: "inputInlineQueryResultSticker",
  Venue: "inputInlineQueryResultVenue",
  Video: "inputInlineQueryResultVideo",
  VoiceNote: "inputInlineQueryResultVoiceNote"
} as const);

export type InputInlineQueryResult$Type =
  (typeof InputInlineQueryResult$Type)[keyof typeof InputInlineQueryResult$Type];

export const BotWriteAccessAllowReason$Type = Object.freeze({
  ConnectedWebsite: "botWriteAccessAllowReasonConnectedWebsite",
  AddedToAttachmentMenu: "botWriteAccessAllowReasonAddedToAttachmentMenu",
  LaunchedWebApp: "botWriteAccessAllowReasonLaunchedWebApp",
  AcceptedRequest: "botWriteAccessAllowReasonAcceptedRequest"
} as const);

export type BotWriteAccessAllowReason$Type =
  (typeof BotWriteAccessAllowReason$Type)[keyof typeof BotWriteAccessAllowReason$Type];

export const SpeechRecognitionResult$Type = Object.freeze({
  Pending: "speechRecognitionResultPending",
  Text: "speechRecognitionResultText",
  Error: "speechRecognitionResultError"
} as const);

export type SpeechRecognitionResult$Type =
  (typeof SpeechRecognitionResult$Type)[keyof typeof SpeechRecognitionResult$Type];

export const DiceStickers$Type = Object.freeze({
  Regular: "diceStickersRegular",
  SlotMachine: "diceStickersSlotMachine"
} as const);

export type DiceStickers$Type =
  (typeof DiceStickers$Type)[keyof typeof DiceStickers$Type];

export const FirebaseAuthenticationSettings$Type = Object.freeze({
  Android: "firebaseAuthenticationSettingsAndroid",
  Ios: "firebaseAuthenticationSettingsIos"
} as const);

export type FirebaseAuthenticationSettings$Type =
  (typeof FirebaseAuthenticationSettings$Type)[keyof typeof FirebaseAuthenticationSettings$Type];

export const CallProblem$Type = Object.freeze({
  Echo: "callProblemEcho",
  Noise: "callProblemNoise",
  Interruptions: "callProblemInterruptions",
  DistortedSpeech: "callProblemDistortedSpeech",
  SilentLocal: "callProblemSilentLocal",
  SilentRemote: "callProblemSilentRemote",
  Dropped: "callProblemDropped",
  DistortedVideo: "callProblemDistortedVideo",
  PixelatedVideo: "callProblemPixelatedVideo"
} as const);

export type CallProblem$Type =
  (typeof CallProblem$Type)[keyof typeof CallProblem$Type];

export const GroupCallVideoQuality$Type = Object.freeze({
  Thumbnail: "groupCallVideoQualityThumbnail",
  Medium: "groupCallVideoQualityMedium",
  Full: "groupCallVideoQualityFull"
} as const);

export type GroupCallVideoQuality$Type =
  (typeof GroupCallVideoQuality$Type)[keyof typeof GroupCallVideoQuality$Type];

export const CallState$Type = Object.freeze({
  Pending: "callStatePending",
  ExchangingKeys: "callStateExchangingKeys",
  Ready: "callStateReady",
  HangingUp: "callStateHangingUp",
  Discarded: "callStateDiscarded",
  Error: "callStateError"
} as const);

export type CallState$Type = (typeof CallState$Type)[keyof typeof CallState$Type];

export const CallServerType$Type = Object.freeze({
  TelegramReflector: "callServerTypeTelegramReflector",
  Webrtc: "callServerTypeWebrtc"
} as const);

export type CallServerType$Type =
  (typeof CallServerType$Type)[keyof typeof CallServerType$Type];

export const CallDiscardReason$Type = Object.freeze({
  Empty: "callDiscardReasonEmpty",
  Missed: "callDiscardReasonMissed",
  Declined: "callDiscardReasonDeclined",
  Disconnected: "callDiscardReasonDisconnected",
  HungUp: "callDiscardReasonHungUp"
} as const);

export type CallDiscardReason$Type =
  (typeof CallDiscardReason$Type)[keyof typeof CallDiscardReason$Type];

export const ChatBoostSource$Type = Object.freeze({
  GiftCode: "chatBoostSourceGiftCode",
  Giveaway: "chatBoostSourceGiveaway",
  Premium: "chatBoostSourcePremium"
} as const);

export type ChatBoostSource$Type =
  (typeof ChatBoostSource$Type)[keyof typeof ChatBoostSource$Type];

export const PublicForward$Type = Object.freeze({
  Message: "publicForwardMessage",
  Story: "publicForwardStory"
} as const);

export type PublicForward$Type =
  (typeof PublicForward$Type)[keyof typeof PublicForward$Type];

export const StoryInteractionType$Type = Object.freeze({
  View: "storyInteractionTypeView",
  Forward: "storyInteractionTypeForward",
  Repost: "storyInteractionTypeRepost"
} as const);

export type StoryInteractionType$Type =
  (typeof StoryInteractionType$Type)[keyof typeof StoryInteractionType$Type];

export const StoryOrigin$Type = Object.freeze({
  PublicStory: "storyOriginPublicStory",
  HiddenUser: "storyOriginHiddenUser"
} as const);

export type StoryOrigin$Type =
  (typeof StoryOrigin$Type)[keyof typeof StoryOrigin$Type];

export const StoryList$Type = Object.freeze({
  Main: "storyListMain",
  Archive: "storyListArchive"
} as const);

export type StoryList$Type = (typeof StoryList$Type)[keyof typeof StoryList$Type];

export const InputStoryContent$Type = Object.freeze({
  Photo: "inputStoryContentPhoto",
  Video: "inputStoryContentVideo"
} as const);

export type InputStoryContent$Type =
  (typeof InputStoryContent$Type)[keyof typeof InputStoryContent$Type];

export const StoryContent$Type = Object.freeze({
  Photo: "storyContentPhoto",
  Video: "storyContentVideo",
  Unsupported: "storyContentUnsupported"
} as const);

export type StoryContent$Type =
  (typeof StoryContent$Type)[keyof typeof StoryContent$Type];

export const InputStoryAreaType$Type = Object.freeze({
  Location: "inputStoryAreaTypeLocation",
  FoundVenue: "inputStoryAreaTypeFoundVenue",
  PreviousVenue: "inputStoryAreaTypePreviousVenue",
  SuggestedReaction: "inputStoryAreaTypeSuggestedReaction",
  Message: "inputStoryAreaTypeMessage"
} as const);

export type InputStoryAreaType$Type =
  (typeof InputStoryAreaType$Type)[keyof typeof InputStoryAreaType$Type];

export const StoryAreaType$Type = Object.freeze({
  Location: "storyAreaTypeLocation",
  Venue: "storyAreaTypeVenue",
  SuggestedReaction: "storyAreaTypeSuggestedReaction",
  Message: "storyAreaTypeMessage"
} as const);

export type StoryAreaType$Type =
  (typeof StoryAreaType$Type)[keyof typeof StoryAreaType$Type];

export const EmojiCategoryType$Type = Object.freeze({
  Default: "emojiCategoryTypeDefault",
  EmojiStatus: "emojiCategoryTypeEmojiStatus",
  ChatPhoto: "emojiCategoryTypeChatPhoto"
} as const);

export type EmojiCategoryType$Type =
  (typeof EmojiCategoryType$Type)[keyof typeof EmojiCategoryType$Type];

export const UserStatus$Type = Object.freeze({
  Empty: "userStatusEmpty",
  Online: "userStatusOnline",
  Offline: "userStatusOffline",
  Recently: "userStatusRecently",
  LastWeek: "userStatusLastWeek",
  LastMonth: "userStatusLastMonth"
} as const);

export type UserStatus$Type = (typeof UserStatus$Type)[keyof typeof UserStatus$Type];

export const ChatAction$Type = Object.freeze({
  Typing: "chatActionTyping",
  RecordingVideo: "chatActionRecordingVideo",
  UploadingVideo: "chatActionUploadingVideo",
  RecordingVoiceNote: "chatActionRecordingVoiceNote",
  UploadingVoiceNote: "chatActionUploadingVoiceNote",
  UploadingPhoto: "chatActionUploadingPhoto",
  UploadingDocument: "chatActionUploadingDocument",
  ChoosingSticker: "chatActionChoosingSticker",
  ChoosingLocation: "chatActionChoosingLocation",
  ChoosingContact: "chatActionChoosingContact",
  StartPlayingGame: "chatActionStartPlayingGame",
  RecordingVideoNote: "chatActionRecordingVideoNote",
  UploadingVideoNote: "chatActionUploadingVideoNote",
  WatchingAnimations: "chatActionWatchingAnimations",
  Cancel: "chatActionCancel"
} as const);

export type ChatAction$Type = (typeof ChatAction$Type)[keyof typeof ChatAction$Type];

export const SearchMessagesFilter$Type = Object.freeze({
  Empty: "searchMessagesFilterEmpty",
  Animation: "searchMessagesFilterAnimation",
  Audio: "searchMessagesFilterAudio",
  Document: "searchMessagesFilterDocument",
  Photo: "searchMessagesFilterPhoto",
  Video: "searchMessagesFilterVideo",
  VoiceNote: "searchMessagesFilterVoiceNote",
  PhotoAndVideo: "searchMessagesFilterPhotoAndVideo",
  Url: "searchMessagesFilterUrl",
  ChatPhoto: "searchMessagesFilterChatPhoto",
  VideoNote: "searchMessagesFilterVideoNote",
  VoiceAndVideoNote: "searchMessagesFilterVoiceAndVideoNote",
  Mention: "searchMessagesFilterMention",
  UnreadMention: "searchMessagesFilterUnreadMention",
  UnreadReaction: "searchMessagesFilterUnreadReaction",
  FailedToSend: "searchMessagesFilterFailedToSend",
  Pinned: "searchMessagesFilterPinned"
} as const);

export type SearchMessagesFilter$Type =
  (typeof SearchMessagesFilter$Type)[keyof typeof SearchMessagesFilter$Type];

export const InputMessageContent$Type = Object.freeze({
  Text: "inputMessageText",
  Animation: "inputMessageAnimation",
  Audio: "inputMessageAudio",
  Document: "inputMessageDocument",
  Photo: "inputMessagePhoto",
  Sticker: "inputMessageSticker",
  Video: "inputMessageVideo",
  VideoNote: "inputMessageVideoNote",
  VoiceNote: "inputMessageVoiceNote",
  Location: "inputMessageLocation",
  Venue: "inputMessageVenue",
  Contact: "inputMessageContact",
  Dice: "inputMessageDice",
  Game: "inputMessageGame",
  Invoice: "inputMessageInvoice",
  Poll: "inputMessagePoll",
  Story: "inputMessageStory",
  Forwarded: "inputMessageForwarded"
} as const);

export type InputMessageContent$Type =
  (typeof InputMessageContent$Type)[keyof typeof InputMessageContent$Type];

export const MessageSelfDestructType$Type = Object.freeze({
  Timer: "messageSelfDestructTypeTimer",
  Immediately: "messageSelfDestructTypeImmediately"
} as const);

export type MessageSelfDestructType$Type =
  (typeof MessageSelfDestructType$Type)[keyof typeof MessageSelfDestructType$Type];

export const MessageSchedulingState$Type = Object.freeze({
  AtDate: "messageSchedulingStateSendAtDate",
  WhenOnline: "messageSchedulingStateSendWhenOnline"
} as const);

export type MessageSchedulingState$Type =
  (typeof MessageSchedulingState$Type)[keyof typeof MessageSchedulingState$Type];

export const TextEntityType$Type = Object.freeze({
  Mention: "textEntityTypeMention",
  Hashtag: "textEntityTypeHashtag",
  Cashtag: "textEntityTypeCashtag",
  BotCommand: "textEntityTypeBotCommand",
  Url: "textEntityTypeUrl",
  EmailAddress: "textEntityTypeEmailAddress",
  PhoneNumber: "textEntityTypePhoneNumber",
  BankCardNumber: "textEntityTypeBankCardNumber",
  Bold: "textEntityTypeBold",
  Italic: "textEntityTypeItalic",
  Underline: "textEntityTypeUnderline",
  Strikethrough: "textEntityTypeStrikethrough",
  Spoiler: "textEntityTypeSpoiler",
  Code: "textEntityTypeCode",
  Pre: "textEntityTypePre",
  PreCode: "textEntityTypePreCode",
  BlockQuote: "textEntityTypeBlockQuote",
  TextUrl: "textEntityTypeTextUrl",
  MentionName: "textEntityTypeMentionName",
  CustomEmoji: "textEntityTypeCustomEmoji",
  MediaTimestamp: "textEntityTypeMediaTimestamp"
} as const);

export type TextEntityType$Type =
  (typeof TextEntityType$Type)[keyof typeof TextEntityType$Type];

export const MessageContent$Type = Object.freeze({
  Text: "messageText",
  Animation: "messageAnimation",
  Audio: "messageAudio",
  Document: "messageDocument",
  Photo: "messagePhoto",
  ExpiredPhoto: "messageExpiredPhoto",
  Sticker: "messageSticker",
  Video: "messageVideo",
  ExpiredVideo: "messageExpiredVideo",
  VideoNote: "messageVideoNote",
  VoiceNote: "messageVoiceNote",
  Location: "messageLocation",
  Venue: "messageVenue",
  Contact: "messageContact",
  AnimatedEmoji: "messageAnimatedEmoji",
  Dice: "messageDice",
  Game: "messageGame",
  Poll: "messagePoll",
  Story: "messageStory",
  Invoice: "messageInvoice",
  Call: "messageCall",
  VideoChatScheduled: "messageVideoChatScheduled",
  VideoChatStarted: "messageVideoChatStarted",
  VideoChatEnded: "messageVideoChatEnded",
  InviteVideoChatParticipants: "messageInviteVideoChatParticipants",
  BasicGroupChatCreate: "messageBasicGroupChatCreate",
  SupergroupChatCreate: "messageSupergroupChatCreate",
  ChatChangeTitle: "messageChatChangeTitle",
  ChatChangePhoto: "messageChatChangePhoto",
  ChatDeletePhoto: "messageChatDeletePhoto",
  ChatAddMembers: "messageChatAddMembers",
  ChatJoinByLink: "messageChatJoinByLink",
  ChatJoinByRequest: "messageChatJoinByRequest",
  ChatDeleteMember: "messageChatDeleteMember",
  ChatUpgradeTo: "messageChatUpgradeTo",
  ChatUpgradeFrom: "messageChatUpgradeFrom",
  PinMessage: "messagePinMessage",
  ScreenshotTaken: "messageScreenshotTaken",
  ChatSetBackground: "messageChatSetBackground",
  ChatSetTheme: "messageChatSetTheme",
  ChatSetMessageAutoDeleteTime: "messageChatSetMessageAutoDeleteTime",
  ForumTopicCreated: "messageForumTopicCreated",
  ForumTopicEdited: "messageForumTopicEdited",
  ForumTopicIsClosedToggled: "messageForumTopicIsClosedToggled",
  ForumTopicIsHiddenToggled: "messageForumTopicIsHiddenToggled",
  SuggestProfilePhoto: "messageSuggestProfilePhoto",
  CustomServiceAction: "messageCustomServiceAction",
  GameScore: "messageGameScore",
  PaymentSuccessful: "messagePaymentSuccessful",
  PaymentSuccessfulBot: "messagePaymentSuccessfulBot",
  GiftedPremium: "messageGiftedPremium",
  PremiumGiftCode: "messagePremiumGiftCode",
  PremiumGiveawayCreated: "messagePremiumGiveawayCreated",
  PremiumGiveaway: "messagePremiumGiveaway",
  PremiumGiveawayCompleted: "messagePremiumGiveawayCompleted",
  PremiumGiveawayWinners: "messagePremiumGiveawayWinners",
  ContactRegistered: "messageContactRegistered",
  UsersShared: "messageUsersShared",
  ChatShared: "messageChatShared",
  BotWriteAccessAllowed: "messageBotWriteAccessAllowed",
  WebAppDataSent: "messageWebAppDataSent",
  WebAppDataReceived: "messageWebAppDataReceived",
  PassportDataSent: "messagePassportDataSent",
  PassportDataReceived: "messagePassportDataReceived",
  ProximityAlertTriggered: "messageProximityAlertTriggered",
  Unsupported: "messageUnsupported"
} as const);

export type MessageContent$Type =
  (typeof MessageContent$Type)[keyof typeof MessageContent$Type];

export const InputPassportElementErrorSource$Type = Object.freeze({
  Unspecified: "inputPassportElementErrorSourceUnspecified",
  DataField: "inputPassportElementErrorSourceDataField",
  FrontSide: "inputPassportElementErrorSourceFrontSide",
  ReverseSide: "inputPassportElementErrorSourceReverseSide",
  Selfie: "inputPassportElementErrorSourceSelfie",
  TranslationFile: "inputPassportElementErrorSourceTranslationFile",
  TranslationFiles: "inputPassportElementErrorSourceTranslationFiles",
  File: "inputPassportElementErrorSourceFile",
  Files: "inputPassportElementErrorSourceFiles"
} as const);

export type InputPassportElementErrorSource$Type =
  (typeof InputPassportElementErrorSource$Type)[keyof typeof InputPassportElementErrorSource$Type];

export const PassportElementErrorSource$Type = Object.freeze({
  Unspecified: "passportElementErrorSourceUnspecified",
  DataField: "passportElementErrorSourceDataField",
  FrontSide: "passportElementErrorSourceFrontSide",
  ReverseSide: "passportElementErrorSourceReverseSide",
  Selfie: "passportElementErrorSourceSelfie",
  TranslationFile: "passportElementErrorSourceTranslationFile",
  TranslationFiles: "passportElementErrorSourceTranslationFiles",
  File: "passportElementErrorSourceFile",
  Files: "passportElementErrorSourceFiles"
} as const);

export type PassportElementErrorSource$Type =
  (typeof PassportElementErrorSource$Type)[keyof typeof PassportElementErrorSource$Type];

export const InputPassportElement$Type = Object.freeze({
  PersonalDetails: "inputPassportElementPersonalDetails",
  Passport: "inputPassportElementPassport",
  DriverLicense: "inputPassportElementDriverLicense",
  IdentityCard: "inputPassportElementIdentityCard",
  InternalPassport: "inputPassportElementInternalPassport",
  Address: "inputPassportElementAddress",
  UtilityBill: "inputPassportElementUtilityBill",
  BankStatement: "inputPassportElementBankStatement",
  RentalAgreement: "inputPassportElementRentalAgreement",
  PassportRegistration: "inputPassportElementPassportRegistration",
  TemporaryRegistration: "inputPassportElementTemporaryRegistration",
  PhoneNumber: "inputPassportElementPhoneNumber",
  EmailAddress: "inputPassportElementEmailAddress"
} as const);

export type InputPassportElement$Type =
  (typeof InputPassportElement$Type)[keyof typeof InputPassportElement$Type];

export const PassportElement$Type = Object.freeze({
  PersonalDetails: "passportElementPersonalDetails",
  Passport: "passportElementPassport",
  DriverLicense: "passportElementDriverLicense",
  IdentityCard: "passportElementIdentityCard",
  InternalPassport: "passportElementInternalPassport",
  Address: "passportElementAddress",
  UtilityBill: "passportElementUtilityBill",
  BankStatement: "passportElementBankStatement",
  RentalAgreement: "passportElementRentalAgreement",
  PassportRegistration: "passportElementPassportRegistration",
  TemporaryRegistration: "passportElementTemporaryRegistration",
  PhoneNumber: "passportElementPhoneNumber",
  EmailAddress: "passportElementEmailAddress"
} as const);

export type PassportElement$Type =
  (typeof PassportElement$Type)[keyof typeof PassportElement$Type];

export const PassportElementType$Type = Object.freeze({
  PersonalDetails: "passportElementTypePersonalDetails",
  Passport: "passportElementTypePassport",
  DriverLicense: "passportElementTypeDriverLicense",
  IdentityCard: "passportElementTypeIdentityCard",
  InternalPassport: "passportElementTypeInternalPassport",
  Address: "passportElementTypeAddress",
  UtilityBill: "passportElementTypeUtilityBill",
  BankStatement: "passportElementTypeBankStatement",
  RentalAgreement: "passportElementTypeRentalAgreement",
  PassportRegistration: "passportElementTypePassportRegistration",
  TemporaryRegistration: "passportElementTypeTemporaryRegistration",
  PhoneNumber: "passportElementTypePhoneNumber",
  EmailAddress: "passportElementTypeEmailAddress"
} as const);

export type PassportElementType$Type =
  (typeof PassportElementType$Type)[keyof typeof PassportElementType$Type];

export const MessageExtendedMedia$Type = Object.freeze({
  Preview: "messageExtendedMediaPreview",
  Photo: "messageExtendedMediaPhoto",
  Video: "messageExtendedMediaVideo",
  Unsupported: "messageExtendedMediaUnsupported"
} as const);

export type MessageExtendedMedia$Type =
  (typeof MessageExtendedMedia$Type)[keyof typeof MessageExtendedMedia$Type];

export const InputInvoice$Type = Object.freeze({
  Message: "inputInvoiceMessage",
  Name: "inputInvoiceName",
  Telegram: "inputInvoiceTelegram"
} as const);

export type InputInvoice$Type =
  (typeof InputInvoice$Type)[keyof typeof InputInvoice$Type];

export const PaymentProvider$Type = Object.freeze({
  SmartGlocal: "paymentProviderSmartGlocal",
  Stripe: "paymentProviderStripe",
  Other: "paymentProviderOther"
} as const);

export type PaymentProvider$Type =
  (typeof PaymentProvider$Type)[keyof typeof PaymentProvider$Type];

export const InputCredentials$Type = Object.freeze({
  Saved: "inputCredentialsSaved",
  New: "inputCredentialsNew",
  ApplePay: "inputCredentialsApplePay",
  GooglePay: "inputCredentialsGooglePay"
} as const);

export type InputCredentials$Type =
  (typeof InputCredentials$Type)[keyof typeof InputCredentials$Type];

export const PageBlock$Type = Object.freeze({
  Title: "pageBlockTitle",
  Subtitle: "pageBlockSubtitle",
  AuthorDate: "pageBlockAuthorDate",
  Header: "pageBlockHeader",
  Subheader: "pageBlockSubheader",
  Kicker: "pageBlockKicker",
  Paragraph: "pageBlockParagraph",
  Preformatted: "pageBlockPreformatted",
  Footer: "pageBlockFooter",
  Divider: "pageBlockDivider",
  Anchor: "pageBlockAnchor",
  List: "pageBlockList",
  BlockQuote: "pageBlockBlockQuote",
  PullQuote: "pageBlockPullQuote",
  Animation: "pageBlockAnimation",
  Audio: "pageBlockAudio",
  Photo: "pageBlockPhoto",
  Video: "pageBlockVideo",
  VoiceNote: "pageBlockVoiceNote",
  Cover: "pageBlockCover",
  Embedded: "pageBlockEmbedded",
  EmbeddedPost: "pageBlockEmbeddedPost",
  Collage: "pageBlockCollage",
  Slideshow: "pageBlockSlideshow",
  ChatLink: "pageBlockChatLink",
  Table: "pageBlockTable",
  Details: "pageBlockDetails",
  RelatedArticles: "pageBlockRelatedArticles",
  Map: "pageBlockMap"
} as const);

export type PageBlock$Type = (typeof PageBlock$Type)[keyof typeof PageBlock$Type];

export const PageBlockVerticalAlignment$Type = Object.freeze({
  Top: "pageBlockVerticalAlignmentTop",
  Middle: "pageBlockVerticalAlignmentMiddle",
  Bottom: "pageBlockVerticalAlignmentBottom"
} as const);

export type PageBlockVerticalAlignment$Type =
  (typeof PageBlockVerticalAlignment$Type)[keyof typeof PageBlockVerticalAlignment$Type];

export const PageBlockHorizontalAlignment$Type = Object.freeze({
  Left: "pageBlockHorizontalAlignmentLeft",
  Center: "pageBlockHorizontalAlignmentCenter",
  Right: "pageBlockHorizontalAlignmentRight"
} as const);

export type PageBlockHorizontalAlignment$Type =
  (typeof PageBlockHorizontalAlignment$Type)[keyof typeof PageBlockHorizontalAlignment$Type];

export const RichText$Type = Object.freeze({
  Plain: "richTextPlain",
  Bold: "richTextBold",
  Italic: "richTextItalic",
  Underline: "richTextUnderline",
  Strikethrough: "richTextStrikethrough",
  Fixed: "richTextFixed",
  Url: "richTextUrl",
  EmailAddress: "richTextEmailAddress",
  Subscript: "richTextSubscript",
  Superscript: "richTextSuperscript",
  Marked: "richTextMarked",
  PhoneNumber: "richTextPhoneNumber",
  Icon: "richTextIcon",
  Reference: "richTextReference",
  Anchor: "richTextAnchor",
  AnchorLink: "richTextAnchorLink",
  RichTexts: "richTexts"
} as const);

export type RichText$Type = (typeof RichText$Type)[keyof typeof RichText$Type];

export const LoginUrlInfo$Type = Object.freeze({
  Open: "loginUrlInfoOpen",
  RequestConfirmation: "loginUrlInfoRequestConfirmation"
} as const);

export type LoginUrlInfo$Type =
  (typeof LoginUrlInfo$Type)[keyof typeof LoginUrlInfo$Type];

export const ReplyMarkup$Type = Object.freeze({
  RemoveKeyboard: "replyMarkupRemoveKeyboard",
  ForceReply: "replyMarkupForceReply",
  ShowKeyboard: "replyMarkupShowKeyboard",
  InlineKeyboard: "replyMarkupInlineKeyboard"
} as const);

export type ReplyMarkup$Type =
  (typeof ReplyMarkup$Type)[keyof typeof ReplyMarkup$Type];

export const InlineKeyboardButtonType$Type = Object.freeze({
  Url: "inlineKeyboardButtonTypeUrl",
  LoginUrl: "inlineKeyboardButtonTypeLoginUrl",
  WebApp: "inlineKeyboardButtonTypeWebApp",
  Callback: "inlineKeyboardButtonTypeCallback",
  CallbackWithPassword: "inlineKeyboardButtonTypeCallbackWithPassword",
  CallbackGame: "inlineKeyboardButtonTypeCallbackGame",
  SwitchInline: "inlineKeyboardButtonTypeSwitchInline",
  Buy: "inlineKeyboardButtonTypeBuy",
  User: "inlineKeyboardButtonTypeUser"
} as const);

export type InlineKeyboardButtonType$Type =
  (typeof InlineKeyboardButtonType$Type)[keyof typeof InlineKeyboardButtonType$Type];

export const KeyboardButtonType$Type = Object.freeze({
  Text: "keyboardButtonTypeText",
  RequestPhoneNumber: "keyboardButtonTypeRequestPhoneNumber",
  RequestLocation: "keyboardButtonTypeRequestLocation",
  RequestPoll: "keyboardButtonTypeRequestPoll",
  RequestUsers: "keyboardButtonTypeRequestUsers",
  RequestChat: "keyboardButtonTypeRequestChat",
  WebApp: "keyboardButtonTypeWebApp"
} as const);

export type KeyboardButtonType$Type =
  (typeof KeyboardButtonType$Type)[keyof typeof KeyboardButtonType$Type];

export const ChatActionBar$Type = Object.freeze({
  ReportSpam: "chatActionBarReportSpam",
  ReportUnrelatedLocation: "chatActionBarReportUnrelatedLocation",
  InviteMembers: "chatActionBarInviteMembers",
  ReportAddBlock: "chatActionBarReportAddBlock",
  AddContact: "chatActionBarAddContact",
  SharePhoneNumber: "chatActionBarSharePhoneNumber",
  JoinRequest: "chatActionBarJoinRequest"
} as const);

export type ChatActionBar$Type =
  (typeof ChatActionBar$Type)[keyof typeof ChatActionBar$Type];

export const PublicChatType$Type = Object.freeze({
  HasUsername: "publicChatTypeHasUsername",
  IsLocationBased: "publicChatTypeIsLocationBased"
} as const);

export type PublicChatType$Type =
  (typeof PublicChatType$Type)[keyof typeof PublicChatType$Type];

export const ChatAvailableReactions$Type = Object.freeze({
  All: "chatAvailableReactionsAll",
  Some: "chatAvailableReactionsSome"
} as const);

export type ChatAvailableReactions$Type =
  (typeof ChatAvailableReactions$Type)[keyof typeof ChatAvailableReactions$Type];

export const ChatSource$Type = Object.freeze({
  MtprotoProxy: "chatSourceMtprotoProxy",
  PublicServiceAnnouncement: "chatSourcePublicServiceAnnouncement"
} as const);

export type ChatSource$Type = (typeof ChatSource$Type)[keyof typeof ChatSource$Type];

export const ChatList$Type = Object.freeze({
  Main: "chatListMain",
  Archive: "chatListArchive",
  Folder: "chatListFolder"
} as const);

export type ChatList$Type = (typeof ChatList$Type)[keyof typeof ChatList$Type];

export const ChatType$Type = Object.freeze({
  Private: "chatTypePrivate",
  BasicGroup: "chatTypeBasicGroup",
  Supergroup: "chatTypeSupergroup",
  Secret: "chatTypeSecret"
} as const);

export type ChatType$Type = (typeof ChatType$Type)[keyof typeof ChatType$Type];

export const NotificationSettingsScope$Type = Object.freeze({
  PrivateChats: "notificationSettingsScopePrivateChats",
  GroupChats: "notificationSettingsScopeGroupChats",
  ChannelChats: "notificationSettingsScopeChannelChats"
} as const);

export type NotificationSettingsScope$Type =
  (typeof NotificationSettingsScope$Type)[keyof typeof NotificationSettingsScope$Type];

export const MessageSponsorType$Type = Object.freeze({
  Bot: "messageSponsorTypeBot",
  WebApp: "messageSponsorTypeWebApp",
  PublicChannel: "messageSponsorTypePublicChannel",
  PrivateChannel: "messageSponsorTypePrivateChannel",
  Website: "messageSponsorTypeWebsite"
} as const);

export type MessageSponsorType$Type =
  (typeof MessageSponsorType$Type)[keyof typeof MessageSponsorType$Type];

export const MessageSource$Type = Object.freeze({
  ChatHistory: "messageSourceChatHistory",
  MessageThreadHistory: "messageSourceMessageThreadHistory",
  ForumTopicHistory: "messageSourceForumTopicHistory",
  HistoryPreview: "messageSourceHistoryPreview",
  ChatList: "messageSourceChatList",
  Search: "messageSourceSearch",
  ChatEventLog: "messageSourceChatEventLog",
  Notification: "messageSourceNotification",
  Screenshot: "messageSourceScreenshot",
  Other: "messageSourceOther"
} as const);

export type MessageSource$Type =
  (typeof MessageSource$Type)[keyof typeof MessageSource$Type];

export const InputMessageReplyTo$Type = Object.freeze({
  Message: "inputMessageReplyToMessage",
  Story: "inputMessageReplyToStory"
} as const);

export type InputMessageReplyTo$Type =
  (typeof InputMessageReplyTo$Type)[keyof typeof InputMessageReplyTo$Type];

export const MessageReplyTo$Type = Object.freeze({
  Message: "messageReplyToMessage",
  Story: "messageReplyToStory"
} as const);

export type MessageReplyTo$Type =
  (typeof MessageReplyTo$Type)[keyof typeof MessageReplyTo$Type];

export const MessageSendingState$Type = Object.freeze({
  Pending: "messageSendingStatePending",
  Failed: "messageSendingStateFailed"
} as const);

export type MessageSendingState$Type =
  (typeof MessageSendingState$Type)[keyof typeof MessageSendingState$Type];

export const ReactionType$Type = Object.freeze({
  Emoji: "reactionTypeEmoji",
  CustomEmoji: "reactionTypeCustomEmoji"
} as const);

export type ReactionType$Type =
  (typeof ReactionType$Type)[keyof typeof ReactionType$Type];

export const MessageOrigin$Type = Object.freeze({
  User: "messageOriginUser",
  HiddenUser: "messageOriginHiddenUser",
  Chat: "messageOriginChat",
  Channel: "messageOriginChannel"
} as const);

export type MessageOrigin$Type =
  (typeof MessageOrigin$Type)[keyof typeof MessageOrigin$Type];

export const MessageSender$Type = Object.freeze({
  User: "messageSenderUser",
  Chat: "messageSenderChat"
} as const);

export type MessageSender$Type =
  (typeof MessageSender$Type)[keyof typeof MessageSender$Type];

export const SecretChatState$Type = Object.freeze({
  Pending: "secretChatStatePending",
  Ready: "secretChatStateReady",
  Closed: "secretChatStateClosed"
} as const);

export type SecretChatState$Type =
  (typeof SecretChatState$Type)[keyof typeof SecretChatState$Type];

export const InviteLinkChatType$Type = Object.freeze({
  BasicGroup: "inviteLinkChatTypeBasicGroup",
  Supergroup: "inviteLinkChatTypeSupergroup",
  Channel: "inviteLinkChatTypeChannel"
} as const);

export type InviteLinkChatType$Type =
  (typeof InviteLinkChatType$Type)[keyof typeof InviteLinkChatType$Type];

export const SupergroupMembersFilter$Type = Object.freeze({
  Recent: "supergroupMembersFilterRecent",
  Contacts: "supergroupMembersFilterContacts",
  Administrators: "supergroupMembersFilterAdministrators",
  Search: "supergroupMembersFilterSearch",
  Restricted: "supergroupMembersFilterRestricted",
  Banned: "supergroupMembersFilterBanned",
  Mention: "supergroupMembersFilterMention",
  Bots: "supergroupMembersFilterBots"
} as const);

export type SupergroupMembersFilter$Type =
  (typeof SupergroupMembersFilter$Type)[keyof typeof SupergroupMembersFilter$Type];

export const ChatMembersFilter$Type = Object.freeze({
  Contacts: "chatMembersFilterContacts",
  Administrators: "chatMembersFilterAdministrators",
  Members: "chatMembersFilterMembers",
  Mention: "chatMembersFilterMention",
  Restricted: "chatMembersFilterRestricted",
  Banned: "chatMembersFilterBanned",
  Bots: "chatMembersFilterBots"
} as const);

export type ChatMembersFilter$Type =
  (typeof ChatMembersFilter$Type)[keyof typeof ChatMembersFilter$Type];

export const ChatMemberStatus$Type = Object.freeze({
  Creator: "chatMemberStatusCreator",
  Administrator: "chatMemberStatusAdministrator",
  Member: "chatMemberStatusMember",
  Restricted: "chatMemberStatusRestricted",
  Left: "chatMemberStatusLeft",
  Banned: "chatMemberStatusBanned"
} as const);

export type ChatMemberStatus$Type =
  (typeof ChatMemberStatus$Type)[keyof typeof ChatMemberStatus$Type];

export const PremiumGiveawayInfo$Type = Object.freeze({
  Ongoing: "premiumGiveawayInfoOngoing",
  Completed: "premiumGiveawayInfoCompleted"
} as const);

export type PremiumGiveawayInfo$Type =
  (typeof PremiumGiveawayInfo$Type)[keyof typeof PremiumGiveawayInfo$Type];

export const PremiumGiveawayParticipantStatus$Type = Object.freeze({
  Eligible: "premiumGiveawayParticipantStatusEligible",
  Participating: "premiumGiveawayParticipantStatusParticipating",
  AlreadyWasMember: "premiumGiveawayParticipantStatusAlreadyWasMember",
  Administrator: "premiumGiveawayParticipantStatusAdministrator",
  DisallowedCountry: "premiumGiveawayParticipantStatusDisallowedCountry"
} as const);

export type PremiumGiveawayParticipantStatus$Type =
  (typeof PremiumGiveawayParticipantStatus$Type)[keyof typeof PremiumGiveawayParticipantStatus$Type];

export const InputChatPhoto$Type = Object.freeze({
  Previous: "inputChatPhotoPrevious",
  Static: "inputChatPhotoStatic",
  Animation: "inputChatPhotoAnimation",
  Sticker: "inputChatPhotoSticker"
} as const);

export type InputChatPhoto$Type =
  (typeof InputChatPhoto$Type)[keyof typeof InputChatPhoto$Type];

export const ChatPhotoStickerType$Type = Object.freeze({
  RegularOrMask: "chatPhotoStickerTypeRegularOrMask",
  CustomEmoji: "chatPhotoStickerTypeCustomEmoji"
} as const);

export type ChatPhotoStickerType$Type =
  (typeof ChatPhotoStickerType$Type)[keyof typeof ChatPhotoStickerType$Type];

export const UserType$Type = Object.freeze({
  Regular: "userTypeRegular",
  Deleted: "userTypeDeleted",
  Bot: "userTypeBot",
  Unknown: "userTypeUnknown"
} as const);

export type UserType$Type = (typeof UserType$Type)[keyof typeof UserType$Type];

export const PollType$Type = Object.freeze({
  Regular: "pollTypeRegular",
  Quiz: "pollTypeQuiz"
} as const);

export type PollType$Type = (typeof PollType$Type)[keyof typeof PollType$Type];

export const StickerFullType$Type = Object.freeze({
  Regular: "stickerFullTypeRegular",
  Mask: "stickerFullTypeMask",
  CustomEmoji: "stickerFullTypeCustomEmoji"
} as const);

export type StickerFullType$Type =
  (typeof StickerFullType$Type)[keyof typeof StickerFullType$Type];

export const StickerType$Type = Object.freeze({
  Regular: "stickerTypeRegular",
  Mask: "stickerTypeMask",
  CustomEmoji: "stickerTypeCustomEmoji"
} as const);

export type StickerType$Type =
  (typeof StickerType$Type)[keyof typeof StickerType$Type];

export const StickerFormat$Type = Object.freeze({
  Webp: "stickerFormatWebp",
  Tgs: "stickerFormatTgs",
  Webm: "stickerFormatWebm"
} as const);

export type StickerFormat$Type =
  (typeof StickerFormat$Type)[keyof typeof StickerFormat$Type];

export const MaskPoint$Type = Object.freeze({
  Forehead: "maskPointForehead",
  Eyes: "maskPointEyes",
  Mouth: "maskPointMouth",
  Chin: "maskPointChin"
} as const);

export type MaskPoint$Type = (typeof MaskPoint$Type)[keyof typeof MaskPoint$Type];

export const ThumbnailFormat$Type = Object.freeze({
  Jpeg: "thumbnailFormatJpeg",
  Gif: "thumbnailFormatGif",
  Mpeg4: "thumbnailFormatMpeg4",
  Png: "thumbnailFormatPng",
  Tgs: "thumbnailFormatTgs",
  Webm: "thumbnailFormatWebm",
  Webp: "thumbnailFormatWebp"
} as const);

export type ThumbnailFormat$Type =
  (typeof ThumbnailFormat$Type)[keyof typeof ThumbnailFormat$Type];

export const InputFile$Type = Object.freeze({
  Id: "inputFileId",
  Remote: "inputFileRemote",
  Local: "inputFileLocal",
  Generated: "inputFileGenerated"
} as const);

export type InputFile$Type = (typeof InputFile$Type)[keyof typeof InputFile$Type];

export const AuthorizationState$Type = Object.freeze({
  WaitTdlibParameters: "authorizationStateWaitTdlibParameters",
  WaitPhoneNumber: "authorizationStateWaitPhoneNumber",
  WaitEmailAddress: "authorizationStateWaitEmailAddress",
  WaitEmailCode: "authorizationStateWaitEmailCode",
  WaitCode: "authorizationStateWaitCode",
  WaitOtherDeviceConfirmation: "authorizationStateWaitOtherDeviceConfirmation",
  WaitRegistration: "authorizationStateWaitRegistration",
  WaitPassword: "authorizationStateWaitPassword",
  Ready: "authorizationStateReady",
  LoggingOut: "authorizationStateLoggingOut",
  Closing: "authorizationStateClosing",
  Closed: "authorizationStateClosed"
} as const);

export type AuthorizationState$Type =
  (typeof AuthorizationState$Type)[keyof typeof AuthorizationState$Type];

export const EmailAddressResetState$Type = Object.freeze({
  Available: "emailAddressResetStateAvailable",
  Pending: "emailAddressResetStatePending"
} as const);

export type EmailAddressResetState$Type =
  (typeof EmailAddressResetState$Type)[keyof typeof EmailAddressResetState$Type];

export const EmailAddressAuthentication$Type = Object.freeze({
  Code: "emailAddressAuthenticationCode",
  AppleId: "emailAddressAuthenticationAppleId",
  GoogleId: "emailAddressAuthenticationGoogleId"
} as const);

export type EmailAddressAuthentication$Type =
  (typeof EmailAddressAuthentication$Type)[keyof typeof EmailAddressAuthentication$Type];

export const AuthenticationCodeType$Type = Object.freeze({
  TelegramMessage: "authenticationCodeTypeTelegramMessage",
  Sms: "authenticationCodeTypeSms",
  Call: "authenticationCodeTypeCall",
  FlashCall: "authenticationCodeTypeFlashCall",
  MissedCall: "authenticationCodeTypeMissedCall",
  Fragment: "authenticationCodeTypeFragment",
  FirebaseAndroid: "authenticationCodeTypeFirebaseAndroid",
  FirebaseIos: "authenticationCodeTypeFirebaseIos"
} as const);

export type AuthenticationCodeType$Type =
  (typeof AuthenticationCodeType$Type)[keyof typeof AuthenticationCodeType$Type];

export const Bool$Type = Object.freeze({
  False: "boolFalse",
  True: "boolTrue"
} as const);

export type Bool$Type = (typeof Bool$Type)[keyof typeof Bool$Type];

/**
 * An object of this type can be returned on every function call, in case of an error
 */
export type error = {
  _: "error";

  /**
   * Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
   * @type {int32} {@link int32}
   */
  code: int32;

  /**
   * Error message; subject to future changes
   * @type {string} {@link string}
   */
  message: string;
};

/**
 * Version of {@link error} for method parameters.
 *
 * An object of this type can be returned on every function call, in case of an error
 */
export type error$Input = {
  readonly _: "error";

  /**
   * Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
   * @type {int32} {@link int32}
   */
  readonly code?: int32;

  /**
   * Error message; subject to future changes
   * @type {string} {@link string}
   */
  readonly message?: string;
};

/**
 * An object of this type is returned on a successful function call for certain functions
 */
export type ok = {
  _: "ok";
};

/**
 * Version of {@link ok} for method parameters.
 *
 * An object of this type is returned on a successful function call for certain functions
 */
export type ok$Input = {
  readonly _: "ok";
};

/**
 * An authentication code is delivered via a private Telegram message, which can be viewed from another active session
 */
export type authenticationCodeTypeTelegramMessage = {
  _: "authenticationCodeTypeTelegramMessage";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeTelegramMessage} for method parameters.
 *
 * An authentication code is delivered via a private Telegram message, which can be viewed from another active session
 */
export type authenticationCodeTypeTelegramMessage$Input = {
  readonly _: "authenticationCodeTypeTelegramMessage";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code is delivered via an SMS message to the specified phone number; applications may not receive this type of code
 */
export type authenticationCodeTypeSms = {
  _: "authenticationCodeTypeSms";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeSms} for method parameters.
 *
 * An authentication code is delivered via an SMS message to the specified phone number; applications may not receive this type of code
 */
export type authenticationCodeTypeSms$Input = {
  readonly _: "authenticationCodeTypeSms";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code is delivered via a phone call to the specified phone number
 */
export type authenticationCodeTypeCall = {
  _: "authenticationCodeTypeCall";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeCall} for method parameters.
 *
 * An authentication code is delivered via a phone call to the specified phone number
 */
export type authenticationCodeTypeCall$Input = {
  readonly _: "authenticationCodeTypeCall";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically
 */
export type authenticationCodeTypeFlashCall = {
  _: "authenticationCodeTypeFlashCall";

  /**
   * Pattern of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  pattern: string;
};

/**
 * Version of {@link authenticationCodeTypeFlashCall} for method parameters.
 *
 * An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically
 */
export type authenticationCodeTypeFlashCall$Input = {
  readonly _: "authenticationCodeTypeFlashCall";

  /**
   * Pattern of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  readonly pattern?: string;
};

/**
 * An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user
 */
export type authenticationCodeTypeMissedCall = {
  _: "authenticationCodeTypeMissedCall";

  /**
   * Prefix of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  phone_number_prefix: string;

  /**
   * Number of digits in the code, excluding the prefix
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeMissedCall} for method parameters.
 *
 * An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user
 */
export type authenticationCodeTypeMissedCall$Input = {
  readonly _: "authenticationCodeTypeMissedCall";

  /**
   * Prefix of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;

  /**
   * Number of digits in the code, excluding the prefix
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT
 */
export type authenticationCodeTypeFragment = {
  _: "authenticationCodeTypeFragment";

  /**
   * URL to open to receive the code
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeFragment} for method parameters.
 *
 * An authentication code is delivered to https://fragment.com. The user must be logged in there via a wallet owning the phone number's NFT
 */
export type authenticationCodeTypeFragment$Input = {
  readonly _: "authenticationCodeTypeFragment";

  /**
   * URL to open to receive the code
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code is delivered via Firebase Authentication to the official Android application
 */
export type authenticationCodeTypeFirebaseAndroid = {
  _: "authenticationCodeTypeFirebaseAndroid";

  /**
   * Nonce to pass to the SafetyNet Attestation API
   * @type {bytes} {@link bytes}
   */
  nonce: bytes;

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeFirebaseAndroid} for method parameters.
 *
 * An authentication code is delivered via Firebase Authentication to the official Android application
 */
export type authenticationCodeTypeFirebaseAndroid$Input = {
  readonly _: "authenticationCodeTypeFirebaseAndroid";

  /**
   * Nonce to pass to the SafetyNet Attestation API
   * @type {bytes} {@link bytes}
   */
  readonly nonce?: bytes$Input;

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code is delivered via Firebase Authentication to the official iOS application
 */
export type authenticationCodeTypeFirebaseIos = {
  _: "authenticationCodeTypeFirebaseIos";

  /**
   * Receipt of successful application token validation to compare with receipt from push notification
   * @type {string} {@link string}
   */
  receipt: string;

  /**
   * Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds
   * @type {int32} {@link int32}
   */
  push_timeout: int32;

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link authenticationCodeTypeFirebaseIos} for method parameters.
 *
 * An authentication code is delivered via Firebase Authentication to the official iOS application
 */
export type authenticationCodeTypeFirebaseIos$Input = {
  readonly _: "authenticationCodeTypeFirebaseIos";

  /**
   * Receipt of successful application token validation to compare with receipt from push notification
   * @type {string} {@link string}
   */
  readonly receipt?: string;

  /**
   * Time after the next authentication method is supposed to be used if verification push notification isn't received, in seconds
   * @type {int32} {@link int32}
   */
  readonly push_timeout?: int32;

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * Information about the authentication code that was sent
 */
export type authenticationCodeInfo = {
  _: "authenticationCodeInfo";

  /**
   * A phone number that is being authenticated
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * The way the code was sent to the user
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  type: AuthenticationCodeType;

  /**
   * The way the next code will be sent to the user; may be null
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  next_type: AuthenticationCodeType | null;

  /**
   * Timeout before the code can be re-sent, in seconds
   * @type {int32} {@link int32}
   */
  timeout: int32;
};

/**
 * Version of {@link authenticationCodeInfo} for method parameters.
 *
 * Information about the authentication code that was sent
 */
export type authenticationCodeInfo$Input = {
  readonly _: "authenticationCodeInfo";

  /**
   * A phone number that is being authenticated
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * The way the code was sent to the user
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  readonly type?: AuthenticationCodeType$Input;

  /**
   * The way the next code will be sent to the user; may be null
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  readonly next_type?: AuthenticationCodeType$Input | null;

  /**
   * Timeout before the code can be re-sent, in seconds
   * @type {int32} {@link int32}
   */
  readonly timeout?: int32;
};

/**
 * Information about the email address authentication code that was sent
 */
export type emailAddressAuthenticationCodeInfo = {
  _: "emailAddressAuthenticationCodeInfo";

  /**
   * Pattern of the email address to which an authentication code was sent
   * @type {string} {@link string}
   */
  email_address_pattern: string;

  /**
   * Length of the code; 0 if unknown
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link emailAddressAuthenticationCodeInfo} for method parameters.
 *
 * Information about the email address authentication code that was sent
 */
export type emailAddressAuthenticationCodeInfo$Input = {
  readonly _: "emailAddressAuthenticationCodeInfo";

  /**
   * Pattern of the email address to which an authentication code was sent
   * @type {string} {@link string}
   */
  readonly email_address_pattern?: string;

  /**
   * Length of the code; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * An authentication code delivered to a user's email address
 */
export type emailAddressAuthenticationCode = {
  _: "emailAddressAuthenticationCode";

  /**
   * The code
   * @type {string} {@link string}
   */
  code: string;
};

/**
 * Version of {@link emailAddressAuthenticationCode} for method parameters.
 *
 * An authentication code delivered to a user's email address
 */
export type emailAddressAuthenticationCode$Input = {
  readonly _: "emailAddressAuthenticationCode";

  /**
   * The code
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * An authentication token received through Apple ID
 */
export type emailAddressAuthenticationAppleId = {
  _: "emailAddressAuthenticationAppleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  token: string;
};

/**
 * Version of {@link emailAddressAuthenticationAppleId} for method parameters.
 *
 * An authentication token received through Apple ID
 */
export type emailAddressAuthenticationAppleId$Input = {
  readonly _: "emailAddressAuthenticationAppleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * An authentication token received through Google ID
 */
export type emailAddressAuthenticationGoogleId = {
  _: "emailAddressAuthenticationGoogleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  token: string;
};

/**
 * Version of {@link emailAddressAuthenticationGoogleId} for method parameters.
 *
 * An authentication token received through Google ID
 */
export type emailAddressAuthenticationGoogleId$Input = {
  readonly _: "emailAddressAuthenticationGoogleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number
 */
export type emailAddressResetStateAvailable = {
  _: "emailAddressResetStateAvailable";

  /**
   * Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
   * @type {int32} {@link int32}
   */
  wait_period: int32;
};

/**
 * Version of {@link emailAddressResetStateAvailable} for method parameters.
 *
 * Email address can be reset after the given period. Call resetAuthenticationEmailAddress to reset it and allow the user to authorize with a code sent to the user's phone number
 */
export type emailAddressResetStateAvailable$Input = {
  readonly _: "emailAddressResetStateAvailable";

  /**
   * Time required to wait before the email address can be reset; 0 if the user is subscribed to Telegram Premium
   * @type {int32} {@link int32}
   */
  readonly wait_period?: int32;
};

/**
 * Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible
 */
export type emailAddressResetStatePending = {
  _: "emailAddressResetStatePending";

  /**
   * Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
   * @type {int32} {@link int32}
   */
  reset_in: int32;
};

/**
 * Version of {@link emailAddressResetStatePending} for method parameters.
 *
 * Email address reset has already been requested. Call resetAuthenticationEmailAddress to check whether immediate reset is possible
 */
export type emailAddressResetStatePending$Input = {
  readonly _: "emailAddressResetStatePending";

  /**
   * Left time before the email address will be reset, in seconds. updateAuthorizationState is not sent when this field changes
   * @type {int32} {@link int32}
   */
  readonly reset_in?: int32;
};

/**
 * Represents a part of the text that needs to be formatted in some unusual way
 */
export type textEntity = {
  _: "textEntity";

  /**
   * Offset of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  offset: int32;

  /**
   * Length of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  length: int32;

  /**
   * Type of the entity
   * @type {TextEntityType} {@link TextEntityType}
   */
  type: TextEntityType;
};

/**
 * Version of {@link textEntity} for method parameters.
 *
 * Represents a part of the text that needs to be formatted in some unusual way
 */
export type textEntity$Input = {
  readonly _: "textEntity";

  /**
   * Offset of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * Length of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly length?: int32;

  /**
   * Type of the entity
   * @type {TextEntityType} {@link TextEntityType}
   */
  readonly type?: TextEntityType$Input;
};

/**
 * Contains a list of text entities
 */
export type textEntities = {
  _: "textEntities";

  /**
   * List of text entities
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  entities: vector<textEntity>;
};

/**
 * Version of {@link textEntities} for method parameters.
 *
 * Contains a list of text entities
 */
export type textEntities$Input = {
  readonly _: "textEntities";

  /**
   * List of text entities
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  readonly entities?: vector$Input<textEntity$Input>;
};

/**
 * A text with some entities
 */
export type formattedText = {
  _: "formattedText";

  /**
   * The text
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Entities contained in the text. Entities can be nested, but must not mutually intersect with each other.
   *
   * - Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  entities: vector<textEntity>;
};

/**
 * Version of {@link formattedText} for method parameters.
 *
 * A text with some entities
 */
export type formattedText$Input = {
  readonly _: "formattedText";

  /**
   * The text
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Entities contained in the text. Entities can be nested, but must not mutually intersect with each other.
   *
   * - Pre, Code and PreCode entities can't contain other entities. BlockQuote entities can't contain other BlockQuote entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  readonly entities?: vector$Input<textEntity$Input>;
};

/**
 * Contains Telegram terms of service
 */
export type termsOfService = {
  _: "termsOfService";

  /**
   * Text of the terms of service
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
   * @type {int32} {@link int32}
   */
  min_user_age: int32;

  /**
   * True, if a blocking popup with terms of service must be shown to the user
   * @type {Bool} {@link Bool}
   */
  show_popup: Bool;
};

/**
 * Version of {@link termsOfService} for method parameters.
 *
 * Contains Telegram terms of service
 */
export type termsOfService$Input = {
  readonly _: "termsOfService";

  /**
   * Text of the terms of service
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
   * @type {int32} {@link int32}
   */
  readonly min_user_age?: int32;

  /**
   * True, if a blocking popup with terms of service must be shown to the user
   * @type {Bool} {@link Bool}
   */
  readonly show_popup?: Bool$Input;
};

/**
 * Initialization parameters are needed. Call setTdlibParameters to provide them
 */
export type authorizationStateWaitTdlibParameters = {
  _: "authorizationStateWaitTdlibParameters";
};

/**
 * Version of {@link authorizationStateWaitTdlibParameters} for method parameters.
 *
 * Initialization parameters are needed. Call setTdlibParameters to provide them
 */
export type authorizationStateWaitTdlibParameters$Input = {
  readonly _: "authorizationStateWaitTdlibParameters";
};

/**
 * TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
 */
export type authorizationStateWaitPhoneNumber = {
  _: "authorizationStateWaitPhoneNumber";
};

/**
 * Version of {@link authorizationStateWaitPhoneNumber} for method parameters.
 *
 * TDLib needs the user's phone number to authorize. Call setAuthenticationPhoneNumber to provide the phone number, or use requestQrCodeAuthentication or checkAuthenticationBotToken for other authentication options
 */
export type authorizationStateWaitPhoneNumber$Input = {
  readonly _: "authorizationStateWaitPhoneNumber";
};

/**
 * TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed
 */
export type authorizationStateWaitEmailAddress = {
  _: "authorizationStateWaitEmailAddress";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_apple_id: Bool;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_google_id: Bool;
};

/**
 * Version of {@link authorizationStateWaitEmailAddress} for method parameters.
 *
 * TDLib needs the user's email address to authorize. Call setAuthenticationEmailAddress to provide the email address, or directly call checkAuthenticationEmailCode with Apple ID/Google ID token if allowed
 */
export type authorizationStateWaitEmailAddress$Input = {
  readonly _: "authorizationStateWaitEmailAddress";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_apple_id?: Bool$Input;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_google_id?: Bool$Input;
};

/**
 * TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code
 */
export type authorizationStateWaitEmailCode = {
  _: "authorizationStateWaitEmailCode";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_apple_id: Bool;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_google_id: Bool;

  /**
   * Information about the sent authentication code
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  code_info: emailAddressAuthenticationCodeInfo;

  /**
   * Reset state of the email address; may be null if the email address can't be reset
   * @type {EmailAddressResetState} {@link EmailAddressResetState}
   */
  email_address_reset_state: EmailAddressResetState | null;
};

/**
 * Version of {@link authorizationStateWaitEmailCode} for method parameters.
 *
 * TDLib needs the user's authentication code sent to an email address to authorize. Call checkAuthenticationEmailCode to provide the code
 */
export type authorizationStateWaitEmailCode$Input = {
  readonly _: "authorizationStateWaitEmailCode";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_apple_id?: Bool$Input;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_google_id?: Bool$Input;

  /**
   * Information about the sent authentication code
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  readonly code_info?: emailAddressAuthenticationCodeInfo$Input;

  /**
   * Reset state of the email address; may be null if the email address can't be reset
   * @type {EmailAddressResetState} {@link EmailAddressResetState}
   */
  readonly email_address_reset_state?: EmailAddressResetState$Input | null;
};

/**
 * TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code
 */
export type authorizationStateWaitCode = {
  _: "authorizationStateWaitCode";

  /**
   * Information about the authorization code that was sent
   * @type {authenticationCodeInfo} {@link authenticationCodeInfo}
   */
  code_info: authenticationCodeInfo;
};

/**
 * Version of {@link authorizationStateWaitCode} for method parameters.
 *
 * TDLib needs the user's authentication code to authorize. Call checkAuthenticationCode to check the code
 */
export type authorizationStateWaitCode$Input = {
  readonly _: "authorizationStateWaitCode";

  /**
   * Information about the authorization code that was sent
   * @type {authenticationCodeInfo} {@link authenticationCodeInfo}
   */
  readonly code_info?: authenticationCodeInfo$Input;
};

/**
 * The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
 */
export type authorizationStateWaitOtherDeviceConfirmation = {
  _: "authorizationStateWaitOtherDeviceConfirmation";

  /**
   * A tg:// URL for the QR code. The link will be updated frequently
   * @type {string} {@link string}
   */
  link: string;
};

/**
 * Version of {@link authorizationStateWaitOtherDeviceConfirmation} for method parameters.
 *
 * The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
 */
export type authorizationStateWaitOtherDeviceConfirmation$Input = {
  readonly _: "authorizationStateWaitOtherDeviceConfirmation";

  /**
   * A tg:// URL for the QR code. The link will be updated frequently
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data
 */
export type authorizationStateWaitRegistration = {
  _: "authorizationStateWaitRegistration";

  /**
   * Telegram terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  terms_of_service: termsOfService;
};

/**
 * Version of {@link authorizationStateWaitRegistration} for method parameters.
 *
 * The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration. Call registerUser to accept the terms of service and provide the data
 */
export type authorizationStateWaitRegistration$Input = {
  readonly _: "authorizationStateWaitRegistration";

  /**
   * Telegram terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  readonly terms_of_service?: termsOfService$Input;
};

/**
 * The user has been authorized, but needs to enter a 2-step verification password to start using the application.
 *
 * - Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week
 */
export type authorizationStateWaitPassword = {
  _: "authorizationStateWaitPassword";

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  password_hint: string;

  /**
   * True, if a recovery email address has been set up
   * @type {Bool} {@link Bool}
   */
  has_recovery_email_address: Bool;

  /**
   * True, if some Telegram Passport elements were saved
   * @type {Bool} {@link Bool}
   */
  has_passport_data: Bool;

  /**
   * Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
   * @type {string} {@link string}
   */
  recovery_email_address_pattern: string;
};

/**
 * Version of {@link authorizationStateWaitPassword} for method parameters.
 *
 * The user has been authorized, but needs to enter a 2-step verification password to start using the application.
 *
 * - Call checkAuthenticationPassword to provide the password, or requestAuthenticationPasswordRecovery to recover the password, or deleteAccount to delete the account after a week
 */
export type authorizationStateWaitPassword$Input = {
  readonly _: "authorizationStateWaitPassword";

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  readonly password_hint?: string;

  /**
   * True, if a recovery email address has been set up
   * @type {Bool} {@link Bool}
   */
  readonly has_recovery_email_address?: Bool$Input;

  /**
   * True, if some Telegram Passport elements were saved
   * @type {Bool} {@link Bool}
   */
  readonly has_passport_data?: Bool$Input;

  /**
   * Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
   * @type {string} {@link string}
   */
  readonly recovery_email_address_pattern?: string;
};

/**
 * The user has been successfully authorized. TDLib is now ready to answer general requests
 */
export type authorizationStateReady = {
  _: "authorizationStateReady";
};

/**
 * Version of {@link authorizationStateReady} for method parameters.
 *
 * The user has been successfully authorized. TDLib is now ready to answer general requests
 */
export type authorizationStateReady$Input = {
  readonly _: "authorizationStateReady";
};

/**
 * The user is currently logging out
 */
export type authorizationStateLoggingOut = {
  _: "authorizationStateLoggingOut";
};

/**
 * Version of {@link authorizationStateLoggingOut} for method parameters.
 *
 * The user is currently logging out
 */
export type authorizationStateLoggingOut$Input = {
  readonly _: "authorizationStateLoggingOut";
};

/**
 * TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
 */
export type authorizationStateClosing = {
  _: "authorizationStateClosing";
};

/**
 * Version of {@link authorizationStateClosing} for method parameters.
 *
 * TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
 */
export type authorizationStateClosing$Input = {
  readonly _: "authorizationStateClosing";
};

/**
 * TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to
 *
 * - with error code 500. To continue working, one must create a new instance of the TDLib client
 */
export type authorizationStateClosed = {
  _: "authorizationStateClosed";
};

/**
 * Version of {@link authorizationStateClosed} for method parameters.
 *
 * TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to
 *
 * - with error code 500. To continue working, one must create a new instance of the TDLib client
 */
export type authorizationStateClosed$Input = {
  readonly _: "authorizationStateClosed";
};

/**
 * Represents the current state of 2-step verification
 */
export type passwordState = {
  _: "passwordState";

  /**
   * True, if a 2-step verification password is set
   * @type {Bool} {@link Bool}
   */
  has_password: Bool;

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  password_hint: string;

  /**
   * True, if a recovery email is set
   * @type {Bool} {@link Bool}
   */
  has_recovery_email_address: Bool;

  /**
   * True, if some Telegram Passport elements were saved
   * @type {Bool} {@link Bool}
   */
  has_passport_data: Bool;

  /**
   * Information about the recovery email address to which the confirmation email was sent; may be null
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  recovery_email_address_code_info: emailAddressAuthenticationCodeInfo | null;

  /**
   * Pattern of the email address set up for logging in
   * @type {string} {@link string}
   */
  login_email_address_pattern: string;

  /**
   * If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  pending_reset_date: int32;
};

/**
 * Version of {@link passwordState} for method parameters.
 *
 * Represents the current state of 2-step verification
 */
export type passwordState$Input = {
  readonly _: "passwordState";

  /**
   * True, if a 2-step verification password is set
   * @type {Bool} {@link Bool}
   */
  readonly has_password?: Bool$Input;

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  readonly password_hint?: string;

  /**
   * True, if a recovery email is set
   * @type {Bool} {@link Bool}
   */
  readonly has_recovery_email_address?: Bool$Input;

  /**
   * True, if some Telegram Passport elements were saved
   * @type {Bool} {@link Bool}
   */
  readonly has_passport_data?: Bool$Input;

  /**
   * Information about the recovery email address to which the confirmation email was sent; may be null
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  readonly recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo$Input | null;

  /**
   * Pattern of the email address set up for logging in
   * @type {string} {@link string}
   */
  readonly login_email_address_pattern?: string;

  /**
   * If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  readonly pending_reset_date?: int32;
};

/**
 * Contains information about the current recovery email address
 */
export type recoveryEmailAddress = {
  _: "recoveryEmailAddress";

  /**
   * Recovery email address
   * @type {string} {@link string}
   */
  recovery_email_address: string;
};

/**
 * Version of {@link recoveryEmailAddress} for method parameters.
 *
 * Contains information about the current recovery email address
 */
export type recoveryEmailAddress$Input = {
  readonly _: "recoveryEmailAddress";

  /**
   * Recovery email address
   * @type {string} {@link string}
   */
  readonly recovery_email_address?: string;
};

/**
 * Returns information about the availability of a temporary password, which can be used for payments
 */
export type temporaryPasswordState = {
  _: "temporaryPasswordState";

  /**
   * True, if a temporary password is available
   * @type {Bool} {@link Bool}
   */
  has_password: Bool;

  /**
   * Time left before the temporary password expires, in seconds
   * @type {int32} {@link int32}
   */
  valid_for: int32;
};

/**
 * Version of {@link temporaryPasswordState} for method parameters.
 *
 * Returns information about the availability of a temporary password, which can be used for payments
 */
export type temporaryPasswordState$Input = {
  readonly _: "temporaryPasswordState";

  /**
   * True, if a temporary password is available
   * @type {Bool} {@link Bool}
   */
  readonly has_password?: Bool$Input;

  /**
   * Time left before the temporary password expires, in seconds
   * @type {int32} {@link int32}
   */
  readonly valid_for?: int32;
};

/**
 * Represents a local file
 */
export type localFile = {
  _: "localFile";

  /**
   * Local path to the locally available file part; may be empty
   * @type {string} {@link string}
   */
  path: string;

  /**
   * True, if it is possible to download or generate the file
   * @type {Bool} {@link Bool}
   */
  can_be_downloaded: Bool;

  /**
   * True, if the file can be deleted
   * @type {Bool} {@link Bool}
   */
  can_be_deleted: Bool;

  /**
   * True, if the file is currently being downloaded (or a local copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  is_downloading_active: Bool;

  /**
   * True, if the local copy is fully available
   * @type {Bool} {@link Bool}
   */
  is_downloading_completed: Bool;

  /**
   * Download will be started from this offset. downloaded_prefix_size is calculated from this offset
   * @type {int53} {@link int53}
   */
  download_offset: int53;

  /**
   * If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
   * @type {int53} {@link int53}
   */
  downloaded_prefix_size: int53;

  /**
   * Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
   * @type {int53} {@link int53}
   */
  downloaded_size: int53;
};

/**
 * Version of {@link localFile} for method parameters.
 *
 * Represents a local file
 */
export type localFile$Input = {
  readonly _: "localFile";

  /**
   * Local path to the locally available file part; may be empty
   * @type {string} {@link string}
   */
  readonly path?: string;

  /**
   * True, if it is possible to download or generate the file
   * @type {Bool} {@link Bool}
   */
  readonly can_be_downloaded?: Bool$Input;

  /**
   * True, if the file can be deleted
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted?: Bool$Input;

  /**
   * True, if the file is currently being downloaded (or a local copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  readonly is_downloading_active?: Bool$Input;

  /**
   * True, if the local copy is fully available
   * @type {Bool} {@link Bool}
   */
  readonly is_downloading_completed?: Bool$Input;

  /**
   * Download will be started from this offset. downloaded_prefix_size is calculated from this offset
   * @type {int53} {@link int53}
   */
  readonly download_offset?: int53;

  /**
   * If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
   * @type {int53} {@link int53}
   */
  readonly downloaded_prefix_size?: int53;

  /**
   * Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
   * @type {int53} {@link int53}
   */
  readonly downloaded_size?: int53;
};

/**
 * Represents a remote file
 */
export type remoteFile = {
  _: "remoteFile";

  /**
   * Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
   *
   * - If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
   *
   * - If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string.
   *
   * - Application must generate the file by downloading it to the specified location
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
   * @type {string} {@link string}
   */
  unique_id: string;

  /**
   * True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  is_uploading_active: Bool;

  /**
   * True, if a remote copy is fully available
   * @type {Bool} {@link Bool}
   */
  is_uploading_completed: Bool;

  /**
   * Size of the remote available part of the file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  uploaded_size: int53;
};

/**
 * Version of {@link remoteFile} for method parameters.
 *
 * Represents a remote file
 */
export type remoteFile$Input = {
  readonly _: "remoteFile";

  /**
   * Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
   *
   * - If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
   *
   * - If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string.
   *
   * - Application must generate the file by downloading it to the specified location
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
   * @type {string} {@link string}
   */
  readonly unique_id?: string;

  /**
   * True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  readonly is_uploading_active?: Bool$Input;

  /**
   * True, if a remote copy is fully available
   * @type {Bool} {@link Bool}
   */
  readonly is_uploading_completed?: Bool$Input;

  /**
   * Size of the remote available part of the file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly uploaded_size?: int53;
};

/**
 * Represents a file
 */
export type file = {
  _: "file";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * File size, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
   * @type {int53} {@link int53}
   */
  expected_size: int53;

  /**
   * Information about the local copy of the file
   * @type {localFile} {@link localFile}
   */
  local: localFile;

  /**
   * Information about the remote copy of the file
   * @type {remoteFile} {@link remoteFile}
   */
  remote: remoteFile;
};

/**
 * Version of {@link file} for method parameters.
 *
 * Represents a file
 */
export type file$Input = {
  readonly _: "file";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * File size, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;

  /**
   * Information about the local copy of the file
   * @type {localFile} {@link localFile}
   */
  readonly local?: localFile$Input;

  /**
   * Information about the remote copy of the file
   * @type {remoteFile} {@link remoteFile}
   */
  readonly remote?: remoteFile$Input;
};

/**
 * A file defined by its unique identifier
 */
export type inputFileId = {
  _: "inputFileId";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  id: int32;
};

/**
 * Version of {@link inputFileId} for method parameters.
 *
 * A file defined by its unique identifier
 */
export type inputFileId$Input = {
  readonly _: "inputFileId";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;
};

/**
 * A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib.
 *
 * - For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
 */
export type inputFileRemote = {
  _: "inputFileRemote";

  /**
   * Remote file identifier
   * @type {string} {@link string}
   */
  id: string;
};

/**
 * Version of {@link inputFileRemote} for method parameters.
 *
 * A file defined by its remote identifier. The remote identifier is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib.
 *
 * - For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
 */
export type inputFileRemote$Input = {
  readonly _: "inputFileRemote";

  /**
   * Remote file identifier
   * @type {string} {@link string}
   */
  readonly id?: string;
};

/**
 * A file defined by a local path
 */
export type inputFileLocal = {
  _: "inputFileLocal";

  /**
   * Local path to the file
   * @type {string} {@link string}
   */
  path: string;
};

/**
 * Version of {@link inputFileLocal} for method parameters.
 *
 * A file defined by a local path
 */
export type inputFileLocal$Input = {
  readonly _: "inputFileLocal";

  /**
   * Local path to the file
   * @type {string} {@link string}
   */
  readonly path?: string;
};

/**
 * A file generated by the application
 */
export type inputFileGenerated = {
  _: "inputFileGenerated";

  /**
   * Local path to a file from which the file is generated; may be empty if there is no such file
   * @type {string} {@link string}
   */
  original_path: string;

  /**
   * String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
   * @type {string} {@link string}
   */
  conversion: string;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  expected_size: int53;
};

/**
 * Version of {@link inputFileGenerated} for method parameters.
 *
 * A file generated by the application
 */
export type inputFileGenerated$Input = {
  readonly _: "inputFileGenerated";

  /**
   * Local path to a file from which the file is generated; may be empty if there is no such file
   * @type {string} {@link string}
   */
  readonly original_path?: string;

  /**
   * String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
   * @type {string} {@link string}
   */
  readonly conversion?: string;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;
};

/**
 * Describes an image in JPEG format
 */
export type photoSize = {
  _: "photoSize";

  /**
   * Image type (see https://core.telegram.org/constructor/photoSize)
   * @type {string} {@link string}
   */
  type: string;

  /**
   * Information about the image file
   * @type {file} {@link file}
   */
  photo: file;

  /**
   * Image width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Image height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
   * @type {vector<int32>} {@link vector<int32>}
   */
  progressive_sizes: vector<int32>;
};

/**
 * Version of {@link photoSize} for method parameters.
 *
 * Describes an image in JPEG format
 */
export type photoSize$Input = {
  readonly _: "photoSize";

  /**
   * Image type (see https://core.telegram.org/constructor/photoSize)
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Information about the image file
   * @type {file} {@link file}
   */
  readonly photo?: file$Input;

  /**
   * Image width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Image height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly progressive_sizes?: vector$Input<int32>;
};

/**
 * Thumbnail image of a very poor quality and low resolution
 */
export type minithumbnail = {
  _: "minithumbnail";

  /**
   * Thumbnail width, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Thumbnail height, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * The thumbnail in JPEG format
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link minithumbnail} for method parameters.
 *
 * Thumbnail image of a very poor quality and low resolution
 */
export type minithumbnail$Input = {
  readonly _: "minithumbnail";

  /**
   * Thumbnail width, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Thumbnail height, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * The thumbnail in JPEG format
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * The thumbnail is in JPEG format
 */
export type thumbnailFormatJpeg = {
  _: "thumbnailFormatJpeg";
};

/**
 * Version of {@link thumbnailFormatJpeg} for method parameters.
 *
 * The thumbnail is in JPEG format
 */
export type thumbnailFormatJpeg$Input = {
  readonly _: "thumbnailFormatJpeg";
};

/**
 * The thumbnail is in static GIF format. It will be used only for some bot inline query results
 */
export type thumbnailFormatGif = {
  _: "thumbnailFormatGif";
};

/**
 * Version of {@link thumbnailFormatGif} for method parameters.
 *
 * The thumbnail is in static GIF format. It will be used only for some bot inline query results
 */
export type thumbnailFormatGif$Input = {
  readonly _: "thumbnailFormatGif";
};

/**
 * The thumbnail is in MPEG4 format. It will be used only for some animations and videos
 */
export type thumbnailFormatMpeg4 = {
  _: "thumbnailFormatMpeg4";
};

/**
 * Version of {@link thumbnailFormatMpeg4} for method parameters.
 *
 * The thumbnail is in MPEG4 format. It will be used only for some animations and videos
 */
export type thumbnailFormatMpeg4$Input = {
  readonly _: "thumbnailFormatMpeg4";
};

/**
 * The thumbnail is in PNG format. It will be used only for background patterns
 */
export type thumbnailFormatPng = {
  _: "thumbnailFormatPng";
};

/**
 * Version of {@link thumbnailFormatPng} for method parameters.
 *
 * The thumbnail is in PNG format. It will be used only for background patterns
 */
export type thumbnailFormatPng$Input = {
  readonly _: "thumbnailFormatPng";
};

/**
 * The thumbnail is in TGS format. It will be used only for TGS sticker sets
 */
export type thumbnailFormatTgs = {
  _: "thumbnailFormatTgs";
};

/**
 * Version of {@link thumbnailFormatTgs} for method parameters.
 *
 * The thumbnail is in TGS format. It will be used only for TGS sticker sets
 */
export type thumbnailFormatTgs$Input = {
  readonly _: "thumbnailFormatTgs";
};

/**
 * The thumbnail is in WEBM format. It will be used only for WEBM sticker sets
 */
export type thumbnailFormatWebm = {
  _: "thumbnailFormatWebm";
};

/**
 * Version of {@link thumbnailFormatWebm} for method parameters.
 *
 * The thumbnail is in WEBM format. It will be used only for WEBM sticker sets
 */
export type thumbnailFormatWebm$Input = {
  readonly _: "thumbnailFormatWebm";
};

/**
 * The thumbnail is in WEBP format. It will be used only for some stickers
 */
export type thumbnailFormatWebp = {
  _: "thumbnailFormatWebp";
};

/**
 * Version of {@link thumbnailFormatWebp} for method parameters.
 *
 * The thumbnail is in WEBP format. It will be used only for some stickers
 */
export type thumbnailFormatWebp$Input = {
  readonly _: "thumbnailFormatWebp";
};

/**
 * Represents a thumbnail
 */
export type thumbnail = {
  _: "thumbnail";

  /**
   * Thumbnail format
   * @type {ThumbnailFormat} {@link ThumbnailFormat}
   */
  format: ThumbnailFormat;

  /**
   * Thumbnail width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Thumbnail height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * The thumbnail
   * @type {file} {@link file}
   */
  file: file;
};

/**
 * Version of {@link thumbnail} for method parameters.
 *
 * Represents a thumbnail
 */
export type thumbnail$Input = {
  readonly _: "thumbnail";

  /**
   * Thumbnail format
   * @type {ThumbnailFormat} {@link ThumbnailFormat}
   */
  readonly format?: ThumbnailFormat$Input;

  /**
   * Thumbnail width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Thumbnail height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * The thumbnail
   * @type {file} {@link file}
   */
  readonly file?: file$Input;
};

/**
 * The mask is placed relatively to the forehead
 */
export type maskPointForehead = {
  _: "maskPointForehead";
};

/**
 * Version of {@link maskPointForehead} for method parameters.
 *
 * The mask is placed relatively to the forehead
 */
export type maskPointForehead$Input = {
  readonly _: "maskPointForehead";
};

/**
 * The mask is placed relatively to the eyes
 */
export type maskPointEyes = {
  _: "maskPointEyes";
};

/**
 * Version of {@link maskPointEyes} for method parameters.
 *
 * The mask is placed relatively to the eyes
 */
export type maskPointEyes$Input = {
  readonly _: "maskPointEyes";
};

/**
 * The mask is placed relatively to the mouth
 */
export type maskPointMouth = {
  _: "maskPointMouth";
};

/**
 * Version of {@link maskPointMouth} for method parameters.
 *
 * The mask is placed relatively to the mouth
 */
export type maskPointMouth$Input = {
  readonly _: "maskPointMouth";
};

/**
 * The mask is placed relatively to the chin
 */
export type maskPointChin = {
  _: "maskPointChin";
};

/**
 * Version of {@link maskPointChin} for method parameters.
 *
 * The mask is placed relatively to the chin
 */
export type maskPointChin$Input = {
  readonly _: "maskPointChin";
};

/**
 * Position on a photo where a mask is placed
 */
export type maskPosition = {
  _: "maskPosition";

  /**
   * Part of the face, relative to which the mask is placed
   * @type {MaskPoint} {@link MaskPoint}
   */
  point: MaskPoint;

  /**
   * Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
   * @type {double} {@link double}
   */
  x_shift: double;

  /**
   * Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
   * @type {double} {@link double}
   */
  y_shift: double;

  /**
   * Mask scaling coefficient. (For example, 2.0 means a doubled size)
   * @type {double} {@link double}
   */
  scale: double;
};

/**
 * Version of {@link maskPosition} for method parameters.
 *
 * Position on a photo where a mask is placed
 */
export type maskPosition$Input = {
  readonly _: "maskPosition";

  /**
   * Part of the face, relative to which the mask is placed
   * @type {MaskPoint} {@link MaskPoint}
   */
  readonly point?: MaskPoint$Input;

  /**
   * Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
   * @type {double} {@link double}
   */
  readonly x_shift?: double;

  /**
   * Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
   * @type {double} {@link double}
   */
  readonly y_shift?: double;

  /**
   * Mask scaling coefficient. (For example, 2.0 means a doubled size)
   * @type {double} {@link double}
   */
  readonly scale?: double;
};

/**
 * The sticker is an image in WEBP format
 */
export type stickerFormatWebp = {
  _: "stickerFormatWebp";
};

/**
 * Version of {@link stickerFormatWebp} for method parameters.
 *
 * The sticker is an image in WEBP format
 */
export type stickerFormatWebp$Input = {
  readonly _: "stickerFormatWebp";
};

/**
 * The sticker is an animation in TGS format
 */
export type stickerFormatTgs = {
  _: "stickerFormatTgs";
};

/**
 * Version of {@link stickerFormatTgs} for method parameters.
 *
 * The sticker is an animation in TGS format
 */
export type stickerFormatTgs$Input = {
  readonly _: "stickerFormatTgs";
};

/**
 * The sticker is a video in WEBM format
 */
export type stickerFormatWebm = {
  _: "stickerFormatWebm";
};

/**
 * Version of {@link stickerFormatWebm} for method parameters.
 *
 * The sticker is a video in WEBM format
 */
export type stickerFormatWebm$Input = {
  readonly _: "stickerFormatWebm";
};

/**
 * The sticker is a regular sticker
 */
export type stickerTypeRegular = {
  _: "stickerTypeRegular";
};

/**
 * Version of {@link stickerTypeRegular} for method parameters.
 *
 * The sticker is a regular sticker
 */
export type stickerTypeRegular$Input = {
  readonly _: "stickerTypeRegular";
};

/**
 * The sticker is a mask in WEBP format to be placed on photos or videos
 */
export type stickerTypeMask = {
  _: "stickerTypeMask";
};

/**
 * Version of {@link stickerTypeMask} for method parameters.
 *
 * The sticker is a mask in WEBP format to be placed on photos or videos
 */
export type stickerTypeMask$Input = {
  readonly _: "stickerTypeMask";
};

/**
 * The sticker is a custom emoji to be used inside message text and caption
 */
export type stickerTypeCustomEmoji = {
  _: "stickerTypeCustomEmoji";
};

/**
 * Version of {@link stickerTypeCustomEmoji} for method parameters.
 *
 * The sticker is a custom emoji to be used inside message text and caption
 */
export type stickerTypeCustomEmoji$Input = {
  readonly _: "stickerTypeCustomEmoji";
};

/**
 * The sticker is a regular sticker
 */
export type stickerFullTypeRegular = {
  _: "stickerFullTypeRegular";

  /**
   * Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
   * @type {file} {@link file}
   */
  premium_animation: file | null;
};

/**
 * Version of {@link stickerFullTypeRegular} for method parameters.
 *
 * The sticker is a regular sticker
 */
export type stickerFullTypeRegular$Input = {
  readonly _: "stickerFullTypeRegular";

  /**
   * Premium animation of the sticker; may be null. If present, only Telegram Premium users can use the sticker
   * @type {file} {@link file}
   */
  readonly premium_animation?: file$Input | null;
};

/**
 * The sticker is a mask in WEBP format to be placed on photos or videos
 */
export type stickerFullTypeMask = {
  _: "stickerFullTypeMask";

  /**
   * Position where the mask is placed; may be null
   * @type {maskPosition} {@link maskPosition}
   */
  mask_position: maskPosition | null;
};

/**
 * Version of {@link stickerFullTypeMask} for method parameters.
 *
 * The sticker is a mask in WEBP format to be placed on photos or videos
 */
export type stickerFullTypeMask$Input = {
  readonly _: "stickerFullTypeMask";

  /**
   * Position where the mask is placed; may be null
   * @type {maskPosition} {@link maskPosition}
   */
  readonly mask_position?: maskPosition$Input | null;
};

/**
 * The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji
 */
export type stickerFullTypeCustomEmoji = {
  _: "stickerFullTypeCustomEmoji";

  /**
   * Identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;

  /**
   * True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
   * @type {Bool} {@link Bool}
   */
  needs_repainting: Bool;
};

/**
 * Version of {@link stickerFullTypeCustomEmoji} for method parameters.
 *
 * The sticker is a custom emoji to be used inside message text and caption. Currently, only Telegram Premium users can use custom emoji
 */
export type stickerFullTypeCustomEmoji$Input = {
  readonly _: "stickerFullTypeCustomEmoji";

  /**
   * Identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;

  /**
   * True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places
   * @type {Bool} {@link Bool}
   */
  readonly needs_repainting?: Bool$Input;
};

/**
 * Represents a closed vector path. The path begins at the end point of the last command
 */
export type closedVectorPath = {
  _: "closedVectorPath";

  /**
   * List of vector path commands
   * @type {vector<VectorPathCommand>} {@link vector<VectorPathCommand>}
   */
  commands: vector<VectorPathCommand>;
};

/**
 * Version of {@link closedVectorPath} for method parameters.
 *
 * Represents a closed vector path. The path begins at the end point of the last command
 */
export type closedVectorPath$Input = {
  readonly _: "closedVectorPath";

  /**
   * List of vector path commands
   * @type {vector<VectorPathCommand>} {@link vector<VectorPathCommand>}
   */
  readonly commands?: vector$Input<VectorPathCommand$Input>;
};

/**
 * Describes one answer option of a poll
 */
export type pollOption = {
  _: "pollOption";

  /**
   * Option text; 1-100 characters
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Number of voters for this option, available only for closed or voted polls
   * @type {int32} {@link int32}
   */
  voter_count: int32;

  /**
   * The percentage of votes for this option; 0-100
   * @type {int32} {@link int32}
   */
  vote_percentage: int32;

  /**
   * True, if the option was chosen by the user
   * @type {Bool} {@link Bool}
   */
  is_chosen: Bool;

  /**
   * True, if the option is being chosen by a pending setPollAnswer request
   * @type {Bool} {@link Bool}
   */
  is_being_chosen: Bool;
};

/**
 * Version of {@link pollOption} for method parameters.
 *
 * Describes one answer option of a poll
 */
export type pollOption$Input = {
  readonly _: "pollOption";

  /**
   * Option text; 1-100 characters
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Number of voters for this option, available only for closed or voted polls
   * @type {int32} {@link int32}
   */
  readonly voter_count?: int32;

  /**
   * The percentage of votes for this option; 0-100
   * @type {int32} {@link int32}
   */
  readonly vote_percentage?: int32;

  /**
   * True, if the option was chosen by the user
   * @type {Bool} {@link Bool}
   */
  readonly is_chosen?: Bool$Input;

  /**
   * True, if the option is being chosen by a pending setPollAnswer request
   * @type {Bool} {@link Bool}
   */
  readonly is_being_chosen?: Bool$Input;
};

/**
 * A regular poll
 */
export type pollTypeRegular = {
  _: "pollTypeRegular";

  /**
   * True, if multiple answer options can be chosen simultaneously
   * @type {Bool} {@link Bool}
   */
  allow_multiple_answers: Bool;
};

/**
 * Version of {@link pollTypeRegular} for method parameters.
 *
 * A regular poll
 */
export type pollTypeRegular$Input = {
  readonly _: "pollTypeRegular";

  /**
   * True, if multiple answer options can be chosen simultaneously
   * @type {Bool} {@link Bool}
   */
  readonly allow_multiple_answers?: Bool$Input;
};

/**
 * A poll in quiz mode, which has exactly one correct answer option and can be answered only once
 */
export type pollTypeQuiz = {
  _: "pollTypeQuiz";

  /**
   * 0-based identifier of the correct answer option; -1 for a yet unanswered poll
   * @type {int32} {@link int32}
   */
  correct_option_id: int32;

  /**
   * Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
   * @type {formattedText} {@link formattedText}
   */
  explanation: formattedText;
};

/**
 * Version of {@link pollTypeQuiz} for method parameters.
 *
 * A poll in quiz mode, which has exactly one correct answer option and can be answered only once
 */
export type pollTypeQuiz$Input = {
  readonly _: "pollTypeQuiz";

  /**
   * 0-based identifier of the correct answer option; -1 for a yet unanswered poll
   * @type {int32} {@link int32}
   */
  readonly correct_option_id?: int32;

  /**
   * Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
   * @type {formattedText} {@link formattedText}
   */
  readonly explanation?: formattedText$Input;
};

/**
 * Describes an animation file. The animation must be encoded in GIF or MPEG4 format
 */
export type animation = {
  _: "animation";

  /**
   * Duration of the animation, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Width of the animation
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Height of the animation
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * MIME type of the file, usually "image/gif" or "video/mp4"
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * Animation minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Animation thumbnail in JPEG or MPEG4 format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * File containing the animation
   * @type {file} {@link file}
   */
  animation: file;
};

/**
 * Version of {@link animation} for method parameters.
 *
 * Describes an animation file. The animation must be encoded in GIF or MPEG4 format
 */
export type animation$Input = {
  readonly _: "animation";

  /**
   * Duration of the animation, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Width of the animation
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Height of the animation
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * MIME type of the file, usually "image/gif" or "video/mp4"
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * Animation minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Animation thumbnail in JPEG or MPEG4 format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * File containing the animation
   * @type {file} {@link file}
   */
  readonly animation?: file$Input;
};

/**
 * Describes an audio file. Audio is usually in MP3 or M4A format
 */
export type audio = {
  _: "audio";

  /**
   * Duration of the audio, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Title of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Performer of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  performer: string;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * The MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * The minithumbnail of the album cover; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  album_cover_minithumbnail: minithumbnail | null;

  /**
   * The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  album_cover_thumbnail: thumbnail | null;

  /**
   * Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
   * @type {vector<thumbnail>} {@link vector<thumbnail>}
   */
  external_album_covers: vector<thumbnail>;

  /**
   * File containing the audio
   * @type {file} {@link file}
   */
  audio: file;
};

/**
 * Version of {@link audio} for method parameters.
 *
 * Describes an audio file. Audio is usually in MP3 or M4A format
 */
export type audio$Input = {
  readonly _: "audio";

  /**
   * Duration of the audio, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Title of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Performer of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  readonly performer?: string;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * The MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * The minithumbnail of the album cover; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly album_cover_minithumbnail?: minithumbnail$Input | null;

  /**
   * The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly album_cover_thumbnail?: thumbnail$Input | null;

  /**
   * Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
   * @type {vector<thumbnail>} {@link vector<thumbnail>}
   */
  readonly external_album_covers?: vector$Input<thumbnail$Input>;

  /**
   * File containing the audio
   * @type {file} {@link file}
   */
  readonly audio?: file$Input;
};

/**
 * Describes a document of any type
 */
export type document = {
  _: "document";

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * Document minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * File containing the document
   * @type {file} {@link file}
   */
  document: file;
};

/**
 * Version of {@link document} for method parameters.
 *
 * Describes a document of any type
 */
export type document$Input = {
  readonly _: "document";

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * Document minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * File containing the document
   * @type {file} {@link file}
   */
  readonly document?: file$Input;
};

/**
 * Describes a photo
 */
export type photo = {
  _: "photo";

  /**
   * True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Available variants of the photo, in different sizes
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  sizes: vector<photoSize>;
};

/**
 * Version of {@link photo} for method parameters.
 *
 * Describes a photo
 */
export type photo$Input = {
  readonly _: "photo";

  /**
   * True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Available variants of the photo, in different sizes
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  readonly sizes?: vector$Input<photoSize$Input>;
};

/**
 * Describes a sticker
 */
export type sticker = {
  _: "sticker";

  /**
   * Unique sticker identifier within the set; 0 if none
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the sticker set to which the sticker belongs; 0 if none
   * @type {int64} {@link int64}
   */
  set_id: int64;

  /**
   * Sticker width; as defined by the sender
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Sticker height; as defined by the sender
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * Sticker format
   * @type {StickerFormat} {@link StickerFormat}
   */
  format: StickerFormat;

  /**
   * Sticker's full type
   * @type {StickerFullType} {@link StickerFullType}
   */
  full_type: StickerFullType;

  /**
   * Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  outline: vector<closedVectorPath>;

  /**
   * Sticker thumbnail in WEBP or JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * File containing the sticker
   * @type {file} {@link file}
   */
  sticker: file;
};

/**
 * Version of {@link sticker} for method parameters.
 *
 * Describes a sticker
 */
export type sticker$Input = {
  readonly _: "sticker";

  /**
   * Unique sticker identifier within the set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Identifier of the sticker set to which the sticker belongs; 0 if none
   * @type {int64} {@link int64}
   */
  readonly set_id?: int64$Input;

  /**
   * Sticker width; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Sticker height; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * Sticker format
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly format?: StickerFormat$Input;

  /**
   * Sticker's full type
   * @type {StickerFullType} {@link StickerFullType}
   */
  readonly full_type?: StickerFullType$Input;

  /**
   * Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  readonly outline?: vector$Input<closedVectorPath$Input>;

  /**
   * Sticker thumbnail in WEBP or JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * File containing the sticker
   * @type {file} {@link file}
   */
  readonly sticker?: file$Input;
};

/**
 * Describes a video file
 */
export type video = {
  _: "video";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Video width; as defined by the sender
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Video height; as defined by the sender
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  supports_streaming: Bool;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  video: file;
};

/**
 * Version of {@link video} for method parameters.
 *
 * Describes a video file
 */
export type video$Input = {
  readonly _: "video";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Video width; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Video height; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  readonly supports_streaming?: Bool$Input;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  readonly video?: file$Input;
};

/**
 * Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
 */
export type videoNote = {
  _: "videoNote";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
   * @type {bytes} {@link bytes}
   */
  waveform: bytes;

  /**
   * Video width and height; as defined by the sender
   * @type {int32} {@link int32}
   */
  length: int32;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Video thumbnail in JPEG format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * Result of speech recognition in the video note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  speech_recognition_result: SpeechRecognitionResult | null;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  video: file;
};

/**
 * Version of {@link videoNote} for method parameters.
 *
 * Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
 */
export type videoNote$Input = {
  readonly _: "videoNote";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
   * @type {bytes} {@link bytes}
   */
  readonly waveform?: bytes$Input;

  /**
   * Video width and height; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly length?: int32;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Video thumbnail in JPEG format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * Result of speech recognition in the video note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  readonly speech_recognition_result?: SpeechRecognitionResult$Input | null;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  readonly video?: file$Input;
};

/**
 * Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
 */
export type voiceNote = {
  _: "voiceNote";

  /**
   * Duration of the voice note, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * A waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  waveform: bytes;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * Result of speech recognition in the voice note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  speech_recognition_result: SpeechRecognitionResult | null;

  /**
   * File containing the voice note
   * @type {file} {@link file}
   */
  voice: file;
};

/**
 * Version of {@link voiceNote} for method parameters.
 *
 * Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
 */
export type voiceNote$Input = {
  readonly _: "voiceNote";

  /**
   * Duration of the voice note, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * A waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  readonly waveform?: bytes$Input;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * Result of speech recognition in the voice note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  readonly speech_recognition_result?: SpeechRecognitionResult$Input | null;

  /**
   * File containing the voice note
   * @type {file} {@link file}
   */
  readonly voice?: file$Input;
};

/**
 * Describes an animated or custom representation of an emoji
 */
export type animatedEmoji = {
  _: "animatedEmoji";

  /**
   * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs
   * @type {sticker} {@link sticker}
   */
  sticker: sticker | null;

  /**
   * Expected width of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  sticker_width: int32;

  /**
   * Expected height of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  sticker_height: int32;

  /**
   * Emoji modifier fitzpatrick type; 0-6; 0 if none
   * @type {int32} {@link int32}
   */
  fitzpatrick_type: int32;

  /**
   * File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
   * @type {file} {@link file}
   */
  sound: file | null;
};

/**
 * Version of {@link animatedEmoji} for method parameters.
 *
 * Describes an animated or custom representation of an emoji
 */
export type animatedEmoji$Input = {
  readonly _: "animatedEmoji";

  /**
   * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input | null;

  /**
   * Expected width of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  readonly sticker_width?: int32;

  /**
   * Expected height of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  readonly sticker_height?: int32;

  /**
   * Emoji modifier fitzpatrick type; 0-6; 0 if none
   * @type {int32} {@link int32}
   */
  readonly fitzpatrick_type?: int32;

  /**
   * File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
   * @type {file} {@link file}
   */
  readonly sound?: file$Input | null;
};

/**
 * Describes a user contact
 */
export type contact = {
  _: "contact";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * First name of the user; 1-255 characters in length
   * @type {string} {@link string}
   */
  first_name: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  last_name: string;

  /**
   * Additional data about the user in a form of vCard; 0-2048 bytes in length
   * @type {string} {@link string}
   */
  vcard: string;

  /**
   * Identifier of the user, if known; 0 otherwise
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link contact} for method parameters.
 *
 * Describes a user contact
 */
export type contact$Input = {
  readonly _: "contact";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * First name of the user; 1-255 characters in length
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  readonly last_name?: string;

  /**
   * Additional data about the user in a form of vCard; 0-2048 bytes in length
   * @type {string} {@link string}
   */
  readonly vcard?: string;

  /**
   * Identifier of the user, if known; 0 otherwise
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Describes a location on planet Earth
 */
export type location = {
  _: "location";

  /**
   * Latitude of the location in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  latitude: double;

  /**
   * Longitude of the location, in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  longitude: double;

  /**
   * The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
   * @type {double} {@link double}
   */
  horizontal_accuracy: double;
};

/**
 * Version of {@link location} for method parameters.
 *
 * Describes a location on planet Earth
 */
export type location$Input = {
  readonly _: "location";

  /**
   * Latitude of the location in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  readonly latitude?: double;

  /**
   * Longitude of the location, in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  readonly longitude?: double;

  /**
   * The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
   * @type {double} {@link double}
   */
  readonly horizontal_accuracy?: double;
};

/**
 * Describes a venue
 */
export type venue = {
  _: "venue";

  /**
   * Venue location; as defined by the sender
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Venue name; as defined by the sender
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Venue address; as defined by the sender
   * @type {string} {@link string}
   */
  address: string;

  /**
   * Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
   * @type {string} {@link string}
   */
  provider: string;

  /**
   * Identifier of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Type of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  type: string;
};

/**
 * Version of {@link venue} for method parameters.
 *
 * Describes a venue
 */
export type venue$Input = {
  readonly _: "venue";

  /**
   * Venue location; as defined by the sender
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Venue name; as defined by the sender
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Venue address; as defined by the sender
   * @type {string} {@link string}
   */
  readonly address?: string;

  /**
   * Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
   * @type {string} {@link string}
   */
  readonly provider?: string;

  /**
   * Identifier of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Type of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  readonly type?: string;
};

/**
 * Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
 */
export type game = {
  _: "game";

  /**
   * Unique game identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Game short name
   * @type {string} {@link string}
   */
  short_name: string;

  /**
   * Game title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Game text, usually containing scoreboards for a game
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Game photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Game animation; may be null
   * @type {animation} {@link animation}
   */
  animation: animation | null;
};

/**
 * Version of {@link game} for method parameters.
 *
 * Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
 */
export type game$Input = {
  readonly _: "game";

  /**
   * Unique game identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Game short name
   * @type {string} {@link string}
   */
  readonly short_name?: string;

  /**
   * Game title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Game text, usually containing scoreboards for a game
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Describes a game. Use getInternalLink with internalLinkTypeGame to share the game
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Game photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Game animation; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input | null;
};

/**
 * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
 */
export type webApp = {
  _: "webApp";

  /**
   * Web App short name
   * @type {string} {@link string}
   */
  short_name: string;

  /**
   * Web App title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Web App photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Web App animation; may be null
   * @type {animation} {@link animation}
   */
  animation: animation | null;
};

/**
 * Version of {@link webApp} for method parameters.
 *
 * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
 */
export type webApp$Input = {
  readonly _: "webApp";

  /**
   * Web App short name
   * @type {string} {@link string}
   */
  readonly short_name?: string;

  /**
   * Web App title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Describes a Web App. Use getInternalLink with internalLinkTypeWebApp to share the Web App
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Web App photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Web App animation; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input | null;
};

/**
 * Describes a poll
 */
export type poll = {
  _: "poll";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Poll question; 1-300 characters
   * @type {string} {@link string}
   */
  question: string;

  /**
   * List of poll answer options
   * @type {vector<pollOption>} {@link vector<pollOption>}
   */
  options: vector<pollOption>;

  /**
   * Total number of voters, participating in the poll
   * @type {int32} {@link int32}
   */
  total_voter_count: int32;

  /**
   * Identifiers of recent voters, if the poll is non-anonymous
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  recent_voter_ids: vector<MessageSender>;

  /**
   * True, if the poll is anonymous
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  type: PollType;

  /**
   * Amount of time the poll will be active after creation, in seconds
   * @type {int32} {@link int32}
   */
  open_period: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed
   * @type {int32} {@link int32}
   */
  close_date: int32;

  /**
   * True, if the poll is closed
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

/**
 * Version of {@link poll} for method parameters.
 *
 * Describes a poll
 */
export type poll$Input = {
  readonly _: "poll";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Poll question; 1-300 characters
   * @type {string} {@link string}
   */
  readonly question?: string;

  /**
   * List of poll answer options
   * @type {vector<pollOption>} {@link vector<pollOption>}
   */
  readonly options?: vector$Input<pollOption$Input>;

  /**
   * Total number of voters, participating in the poll
   * @type {int32} {@link int32}
   */
  readonly total_voter_count?: int32;

  /**
   * Identifiers of recent voters, if the poll is non-anonymous
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly recent_voter_ids?: vector$Input<MessageSender$Input>;

  /**
   * True, if the poll is anonymous
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  readonly type?: PollType$Input;

  /**
   * Amount of time the poll will be active after creation, in seconds
   * @type {int32} {@link int32}
   */
  readonly open_period?: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed
   * @type {int32} {@link int32}
   */
  readonly close_date?: int32;

  /**
   * True, if the poll is closed
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/**
 * Describes a chat background
 */
export type background = {
  _: "background";

  /**
   * Unique background identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * True, if this is one of default backgrounds
   * @type {Bool} {@link Bool}
   */
  is_default: Bool;

  /**
   * True, if the background is dark and is recommended to be used with dark theme
   * @type {Bool} {@link Bool}
   */
  is_dark: Bool;

  /**
   * Unique background name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Document with the background; may be null. Null only for filled and chat theme backgrounds
   * @type {document} {@link document}
   */
  document: document | null;

  /**
   * Type of the background
   * @type {BackgroundType} {@link BackgroundType}
   */
  type: BackgroundType;
};

/**
 * Version of {@link background} for method parameters.
 *
 * Describes a chat background
 */
export type background$Input = {
  readonly _: "background";

  /**
   * Unique background identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * True, if this is one of default backgrounds
   * @type {Bool} {@link Bool}
   */
  readonly is_default?: Bool$Input;

  /**
   * True, if the background is dark and is recommended to be used with dark theme
   * @type {Bool} {@link Bool}
   */
  readonly is_dark?: Bool$Input;

  /**
   * Unique background name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Document with the background; may be null. Null only for filled and chat theme backgrounds
   * @type {document} {@link document}
   */
  readonly document?: document$Input | null;

  /**
   * Type of the background
   * @type {BackgroundType} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input;
};

/**
 * Contains a list of backgrounds
 */
export type backgrounds = {
  _: "backgrounds";

  /**
   * A list of backgrounds
   * @type {vector<background>} {@link vector<background>}
   */
  backgrounds: vector<background>;
};

/**
 * Version of {@link backgrounds} for method parameters.
 *
 * Contains a list of backgrounds
 */
export type backgrounds$Input = {
  readonly _: "backgrounds";

  /**
   * A list of backgrounds
   * @type {vector<background>} {@link vector<background>}
   */
  readonly backgrounds?: vector$Input<background$Input>;
};

/**
 * Describes a background set for a specific chat
 */
export type chatBackground = {
  _: "chatBackground";

  /**
   * The background
   * @type {background} {@link background}
   */
  background: background;

  /**
   * Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
   * @type {int32} {@link int32}
   */
  dark_theme_dimming: int32;
};

/**
 * Version of {@link chatBackground} for method parameters.
 *
 * Describes a background set for a specific chat
 */
export type chatBackground$Input = {
  readonly _: "chatBackground";

  /**
   * The background
   * @type {background} {@link background}
   */
  readonly background?: background$Input;

  /**
   * Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
   * @type {int32} {@link int32}
   */
  readonly dark_theme_dimming?: int32;
};

/**
 * Describes a user profile photo
 */
export type profilePhoto = {
  _: "profilePhoto";

  /**
   * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  small: file;

  /**
   * A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  big: file;

  /**
   * User profile photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  has_animation: Bool;

  /**
   * True, if the photo is visible only for the current user
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;
};

/**
 * Version of {@link profilePhoto} for method parameters.
 *
 * Describes a user profile photo
 */
export type profilePhoto$Input = {
  readonly _: "profilePhoto";

  /**
   * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly small?: file$Input;

  /**
   * A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly big?: file$Input;

  /**
   * User profile photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  readonly has_animation?: Bool$Input;

  /**
   * True, if the photo is visible only for the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;
};

/**
 * Contains basic information about the photo of a chat
 */
export type chatPhotoInfo = {
  _: "chatPhotoInfo";

  /**
   * A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  small: file;

  /**
   * A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  big: file;

  /**
   * Chat photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  has_animation: Bool;

  /**
   * True, if the photo is visible only for the current user
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;
};

/**
 * Version of {@link chatPhotoInfo} for method parameters.
 *
 * Contains basic information about the photo of a chat
 */
export type chatPhotoInfo$Input = {
  readonly _: "chatPhotoInfo";

  /**
   * A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly small?: file$Input;

  /**
   * A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly big?: file$Input;

  /**
   * Chat photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  readonly has_animation?: Bool$Input;

  /**
   * True, if the photo is visible only for the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;
};

/**
 * A regular user
 */
export type userTypeRegular = {
  _: "userTypeRegular";
};

/**
 * Version of {@link userTypeRegular} for method parameters.
 *
 * A regular user
 */
export type userTypeRegular$Input = {
  readonly _: "userTypeRegular";
};

/**
 * A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
 */
export type userTypeDeleted = {
  _: "userTypeDeleted";
};

/**
 * Version of {@link userTypeDeleted} for method parameters.
 *
 * A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
 */
export type userTypeDeleted$Input = {
  readonly _: "userTypeDeleted";
};

/**
 * A bot (see https://core.telegram.org/bots)
 */
export type userTypeBot = {
  _: "userTypeBot";

  /**
   * True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
   * @type {Bool} {@link Bool}
   */
  can_be_edited: Bool;

  /**
   * True, if the bot can be invited to basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  can_join_groups: Bool;

  /**
   * True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
   * @type {Bool} {@link Bool}
   */
  can_read_all_group_messages: Bool;

  /**
   * True, if the bot supports inline queries
   * @type {Bool} {@link Bool}
   */
  is_inline: Bool;

  /**
   * Placeholder for inline queries (displayed on the application input field)
   * @type {string} {@link string}
   */
  inline_query_placeholder: string;

  /**
   * True, if the location of the user is expected to be sent with every inline query to this bot
   * @type {Bool} {@link Bool}
   */
  need_location: Bool;

  /**
   * True, if the bot can be added to attachment or side menu
   * @type {Bool} {@link Bool}
   */
  can_be_added_to_attachment_menu: Bool;
};

/**
 * Version of {@link userTypeBot} for method parameters.
 *
 * A bot (see https://core.telegram.org/bots)
 */
export type userTypeBot$Input = {
  readonly _: "userTypeBot";

  /**
   * True, if the bot is owned by the current user and can be edited using the methods toggleBotUsernameIsActive, reorderBotActiveUsernames, setBotProfilePhoto, setBotName, setBotInfoDescription, and setBotInfoShortDescription
   * @type {Bool} {@link Bool}
   */
  readonly can_be_edited?: Bool$Input;

  /**
   * True, if the bot can be invited to basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  readonly can_join_groups?: Bool$Input;

  /**
   * True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
   * @type {Bool} {@link Bool}
   */
  readonly can_read_all_group_messages?: Bool$Input;

  /**
   * True, if the bot supports inline queries
   * @type {Bool} {@link Bool}
   */
  readonly is_inline?: Bool$Input;

  /**
   * Placeholder for inline queries (displayed on the application input field)
   * @type {string} {@link string}
   */
  readonly inline_query_placeholder?: string;

  /**
   * True, if the location of the user is expected to be sent with every inline query to this bot
   * @type {Bool} {@link Bool}
   */
  readonly need_location?: Bool$Input;

  /**
   * True, if the bot can be added to attachment or side menu
   * @type {Bool} {@link Bool}
   */
  readonly can_be_added_to_attachment_menu?: Bool$Input;
};

/**
 * No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
 */
export type userTypeUnknown = {
  _: "userTypeUnknown";
};

/**
 * Version of {@link userTypeUnknown} for method parameters.
 *
 * No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
 */
export type userTypeUnknown$Input = {
  readonly _: "userTypeUnknown";
};

/**
 * Represents a command supported by a bot
 */
export type botCommand = {
  _: "botCommand";

  /**
   * Text of the bot command
   * @type {string} {@link string}
   */
  command: string;

  /**
   * Represents a command supported by a bot
   * @type {string} {@link string}
   */
  description: string;
};

/**
 * Version of {@link botCommand} for method parameters.
 *
 * Represents a command supported by a bot
 */
export type botCommand$Input = {
  readonly _: "botCommand";

  /**
   * Text of the bot command
   * @type {string} {@link string}
   */
  readonly command?: string;

  /**
   * Represents a command supported by a bot
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Contains a list of bot commands
 */
export type botCommands = {
  _: "botCommands";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * List of bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  commands: vector<botCommand>;
};

/**
 * Version of {@link botCommands} for method parameters.
 *
 * Contains a list of bot commands
 */
export type botCommands$Input = {
  readonly _: "botCommands";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * List of bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;
};

/**
 * Describes a button to be shown instead of bot commands menu button
 */
export type botMenuButton = {
  _: "botMenuButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link botMenuButton} for method parameters.
 *
 * Describes a button to be shown instead of bot commands menu button
 */
export type botMenuButton$Input = {
  readonly _: "botMenuButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Represents a location to which a chat is connected
 */
export type chatLocation = {
  _: "chatLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Location address; 1-64 characters, as defined by the chat owner
   * @type {string} {@link string}
   */
  address: string;
};

/**
 * Version of {@link chatLocation} for method parameters.
 *
 * Represents a location to which a chat is connected
 */
export type chatLocation$Input = {
  readonly _: "chatLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Location address; 1-64 characters, as defined by the chat owner
   * @type {string} {@link string}
   */
  readonly address?: string;
};

/**
 * Information about the sticker, which was used to create the chat photo
 */
export type chatPhotoStickerTypeRegularOrMask = {
  _: "chatPhotoStickerTypeRegularOrMask";

  /**
   * Sticker set identifier
   * @type {int64} {@link int64}
   */
  sticker_set_id: int64;

  /**
   * Identifier of the sticker in the set
   * @type {int64} {@link int64}
   */
  sticker_id: int64;
};

/**
 * Version of {@link chatPhotoStickerTypeRegularOrMask} for method parameters.
 *
 * Information about the sticker, which was used to create the chat photo
 */
export type chatPhotoStickerTypeRegularOrMask$Input = {
  readonly _: "chatPhotoStickerTypeRegularOrMask";

  /**
   * Sticker set identifier
   * @type {int64} {@link int64}
   */
  readonly sticker_set_id?: int64$Input;

  /**
   * Identifier of the sticker in the set
   * @type {int64} {@link int64}
   */
  readonly sticker_id?: int64$Input;
};

/**
 * Information about the custom emoji, which was used to create the chat photo
 */
export type chatPhotoStickerTypeCustomEmoji = {
  _: "chatPhotoStickerTypeCustomEmoji";

  /**
   * Identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

/**
 * Version of {@link chatPhotoStickerTypeCustomEmoji} for method parameters.
 *
 * Information about the custom emoji, which was used to create the chat photo
 */
export type chatPhotoStickerTypeCustomEmoji$Input = {
  readonly _: "chatPhotoStickerTypeCustomEmoji";

  /**
   * Identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;
};

/**
 * Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it
 */
export type chatPhotoSticker = {
  _: "chatPhotoSticker";

  /**
   * Type of the sticker
   * @type {ChatPhotoStickerType} {@link ChatPhotoStickerType}
   */
  type: ChatPhotoStickerType;

  /**
   * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  background_fill: BackgroundFill;
};

/**
 * Version of {@link chatPhotoSticker} for method parameters.
 *
 * Information about the sticker, which was used to create the chat photo. The sticker is shown at the center of the photo and occupies at most 67% of it
 */
export type chatPhotoSticker$Input = {
  readonly _: "chatPhotoSticker";

  /**
   * Type of the sticker
   * @type {ChatPhotoStickerType} {@link ChatPhotoStickerType}
   */
  readonly type?: ChatPhotoStickerType$Input;

  /**
   * The fill to be used as background for the sticker; rotation angle in backgroundFillGradient isn't supported
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly background_fill?: BackgroundFill$Input;
};

/**
 * Animated variant of a chat photo in MPEG4 format
 */
export type animatedChatPhoto = {
  _: "animatedChatPhoto";

  /**
   * Animation width and height
   * @type {int32} {@link int32}
   */
  length: int32;

  /**
   * Information about the animation file
   * @type {file} {@link file}
   */
  file: file;

  /**
   * Timestamp of the frame, used as a static chat photo
   * @type {double} {@link double}
   */
  main_frame_timestamp: double;
};

/**
 * Version of {@link animatedChatPhoto} for method parameters.
 *
 * Animated variant of a chat photo in MPEG4 format
 */
export type animatedChatPhoto$Input = {
  readonly _: "animatedChatPhoto";

  /**
   * Animation width and height
   * @type {int32} {@link int32}
   */
  readonly length?: int32;

  /**
   * Information about the animation file
   * @type {file} {@link file}
   */
  readonly file?: file$Input;

  /**
   * Timestamp of the frame, used as a static chat photo
   * @type {double} {@link double}
   */
  readonly main_frame_timestamp?: double;
};

/**
 * Describes a chat or user profile photo
 */
export type chatPhoto = {
  _: "chatPhoto";

  /**
   * Unique photo identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Point in time (Unix timestamp) when the photo has been added
   * @type {int32} {@link int32}
   */
  added_date: int32;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Available variants of the photo in JPEG format, in different size
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  sizes: vector<photoSize>;

  /**
   * A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  animation: animatedChatPhoto | null;

  /**
   * A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  small_animation: animatedChatPhoto | null;

  /**
   * Sticker-based version of the chat photo; may be null
   * @type {chatPhotoSticker} {@link chatPhotoSticker}
   */
  sticker: chatPhotoSticker | null;
};

/**
 * Version of {@link chatPhoto} for method parameters.
 *
 * Describes a chat or user profile photo
 */
export type chatPhoto$Input = {
  readonly _: "chatPhoto";

  /**
   * Unique photo identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Point in time (Unix timestamp) when the photo has been added
   * @type {int32} {@link int32}
   */
  readonly added_date?: int32;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Available variants of the photo in JPEG format, in different size
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  readonly sizes?: vector$Input<photoSize$Input>;

  /**
   * A big (up to 1280x1280) animated variant of the photo in MPEG4 format; may be null
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  readonly animation?: animatedChatPhoto$Input | null;

  /**
   * A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  readonly small_animation?: animatedChatPhoto$Input | null;

  /**
   * Sticker-based version of the chat photo; may be null
   * @type {chatPhotoSticker} {@link chatPhotoSticker}
   */
  readonly sticker?: chatPhotoSticker$Input | null;
};

/**
 * Contains a list of chat or user profile photos
 */
export type chatPhotos = {
  _: "chatPhotos";

  /**
   * Total number of photos
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of photos
   * @type {vector<chatPhoto>} {@link vector<chatPhoto>}
   */
  photos: vector<chatPhoto>;
};

/**
 * Version of {@link chatPhotos} for method parameters.
 *
 * Contains a list of chat or user profile photos
 */
export type chatPhotos$Input = {
  readonly _: "chatPhotos";

  /**
   * Total number of photos
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of photos
   * @type {vector<chatPhoto>} {@link vector<chatPhoto>}
   */
  readonly photos?: vector$Input<chatPhoto$Input>;
};

/**
 * A previously used profile photo of the current user
 */
export type inputChatPhotoPrevious = {
  _: "inputChatPhotoPrevious";

  /**
   * Identifier of the current user's profile photo to reuse
   * @type {int64} {@link int64}
   */
  chat_photo_id: int64;
};

/**
 * Version of {@link inputChatPhotoPrevious} for method parameters.
 *
 * A previously used profile photo of the current user
 */
export type inputChatPhotoPrevious$Input = {
  readonly _: "inputChatPhotoPrevious";

  /**
   * Identifier of the current user's profile photo to reuse
   * @type {int64} {@link int64}
   */
  readonly chat_photo_id?: int64$Input;
};

/**
 * A static photo in JPEG format
 */
export type inputChatPhotoStatic = {
  _: "inputChatPhotoStatic";

  /**
   * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  photo: InputFile;
};

/**
 * Version of {@link inputChatPhotoStatic} for method parameters.
 *
 * A static photo in JPEG format
 */
export type inputChatPhotoStatic$Input = {
  readonly _: "inputChatPhotoStatic";

  /**
   * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  readonly photo?: InputFile$Input;
};

/**
 * An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size
 */
export type inputChatPhotoAnimation = {
  _: "inputChatPhotoAnimation";

  /**
   * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  animation: InputFile;

  /**
   * Timestamp of the frame, which will be used as static chat photo
   * @type {double} {@link double}
   */
  main_frame_timestamp: double;
};

/**
 * Version of {@link inputChatPhotoAnimation} for method parameters.
 *
 * An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 1280 and be at most 2MB in size
 */
export type inputChatPhotoAnimation$Input = {
  readonly _: "inputChatPhotoAnimation";

  /**
   * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  readonly animation?: InputFile$Input;

  /**
   * Timestamp of the frame, which will be used as static chat photo
   * @type {double} {@link double}
   */
  readonly main_frame_timestamp?: double;
};

/**
 * A sticker on a custom background
 */
export type inputChatPhotoSticker = {
  _: "inputChatPhotoSticker";

  /**
   * Information about the sticker
   * @type {chatPhotoSticker} {@link chatPhotoSticker}
   */
  sticker: chatPhotoSticker;
};

/**
 * Version of {@link inputChatPhotoSticker} for method parameters.
 *
 * A sticker on a custom background
 */
export type inputChatPhotoSticker$Input = {
  readonly _: "inputChatPhotoSticker";

  /**
   * Information about the sticker
   * @type {chatPhotoSticker} {@link chatPhotoSticker}
   */
  readonly sticker?: chatPhotoSticker$Input;
};

/**
 * Describes actions that a user is allowed to take in a chat
 */
export type chatPermissions = {
  _: "chatPermissions";

  /**
   * True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
   * @type {Bool} {@link Bool}
   */
  can_send_basic_messages: Bool;

  /**
   * True, if the user can send music files
   * @type {Bool} {@link Bool}
   */
  can_send_audios: Bool;

  /**
   * True, if the user can send documents
   * @type {Bool} {@link Bool}
   */
  can_send_documents: Bool;

  /**
   * True, if the user can send photos
   * @type {Bool} {@link Bool}
   */
  can_send_photos: Bool;

  /**
   * True, if the user can send videos
   * @type {Bool} {@link Bool}
   */
  can_send_videos: Bool;

  /**
   * True, if the user can send video notes
   * @type {Bool} {@link Bool}
   */
  can_send_video_notes: Bool;

  /**
   * True, if the user can send voice notes
   * @type {Bool} {@link Bool}
   */
  can_send_voice_notes: Bool;

  /**
   * True, if the user can send polls
   * @type {Bool} {@link Bool}
   */
  can_send_polls: Bool;

  /**
   * True, if the user can send animations, games, stickers, and dice and use inline bots
   * @type {Bool} {@link Bool}
   */
  can_send_other_messages: Bool;

  /**
   * True, if the user may add a web page preview to their messages
   * @type {Bool} {@link Bool}
   */
  can_add_web_page_previews: Bool;

  /**
   * True, if the user can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  can_change_info: Bool;

  /**
   * True, if the user can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  can_invite_users: Bool;

  /**
   * True, if the user can pin messages
   * @type {Bool} {@link Bool}
   */
  can_pin_messages: Bool;

  /**
   * True, if the user can manage topics
   * @type {Bool} {@link Bool}
   */
  can_manage_topics: Bool;
};

/**
 * Version of {@link chatPermissions} for method parameters.
 *
 * Describes actions that a user is allowed to take in a chat
 */
export type chatPermissions$Input = {
  readonly _: "chatPermissions";

  /**
   * True, if the user can send text messages, contacts, giveaways, giveaway winners, invoices, locations, and venues
   * @type {Bool} {@link Bool}
   */
  readonly can_send_basic_messages?: Bool$Input;

  /**
   * True, if the user can send music files
   * @type {Bool} {@link Bool}
   */
  readonly can_send_audios?: Bool$Input;

  /**
   * True, if the user can send documents
   * @type {Bool} {@link Bool}
   */
  readonly can_send_documents?: Bool$Input;

  /**
   * True, if the user can send photos
   * @type {Bool} {@link Bool}
   */
  readonly can_send_photos?: Bool$Input;

  /**
   * True, if the user can send videos
   * @type {Bool} {@link Bool}
   */
  readonly can_send_videos?: Bool$Input;

  /**
   * True, if the user can send video notes
   * @type {Bool} {@link Bool}
   */
  readonly can_send_video_notes?: Bool$Input;

  /**
   * True, if the user can send voice notes
   * @type {Bool} {@link Bool}
   */
  readonly can_send_voice_notes?: Bool$Input;

  /**
   * True, if the user can send polls
   * @type {Bool} {@link Bool}
   */
  readonly can_send_polls?: Bool$Input;

  /**
   * True, if the user can send animations, games, stickers, and dice and use inline bots
   * @type {Bool} {@link Bool}
   */
  readonly can_send_other_messages?: Bool$Input;

  /**
   * True, if the user may add a web page preview to their messages
   * @type {Bool} {@link Bool}
   */
  readonly can_add_web_page_previews?: Bool$Input;

  /**
   * True, if the user can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  readonly can_change_info?: Bool$Input;

  /**
   * True, if the user can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  readonly can_invite_users?: Bool$Input;

  /**
   * True, if the user can pin messages
   * @type {Bool} {@link Bool}
   */
  readonly can_pin_messages?: Bool$Input;

  /**
   * True, if the user can manage topics
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_topics?: Bool$Input;
};

/**
 * Describes rights of the administrator
 */
export type chatAdministratorRights = {
  _: "chatAdministratorRights";

  /**
   * True, if the administrator can get chat event log, get chat boosts in channels, get channel members, report supergroup spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
   * @type {Bool} {@link Bool}
   */
  can_manage_chat: Bool;

  /**
   * True, if the administrator can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  can_change_info: Bool;

  /**
   * True, if the administrator can create channel posts or view channel statistics; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_post_messages: Bool;

  /**
   * True, if the administrator can edit messages of other users and pin messages; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_edit_messages: Bool;

  /**
   * True, if the administrator can delete messages of other users
   * @type {Bool} {@link Bool}
   */
  can_delete_messages: Bool;

  /**
   * True, if the administrator can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  can_invite_users: Bool;

  /**
   * True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
   * @type {Bool} {@link Bool}
   */
  can_restrict_members: Bool;

  /**
   * True, if the administrator can pin messages; applicable to basic groups and supergroups only
   * @type {Bool} {@link Bool}
   */
  can_pin_messages: Bool;

  /**
   * True, if the administrator can manage topics; applicable to forum supergroups only
   * @type {Bool} {@link Bool}
   */
  can_manage_topics: Bool;

  /**
   * True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
   * @type {Bool} {@link Bool}
   */
  can_promote_members: Bool;

  /**
   * True, if the administrator can manage video chats
   * @type {Bool} {@link Bool}
   */
  can_manage_video_chats: Bool;

  /**
   * True, if the administrator can create new channel stories, or edit and delete posted stories; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_post_stories: Bool;

  /**
   * True, if the administrator can edit stories posted by other users, pin stories and access story archive; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_edit_stories: Bool;

  /**
   * True, if the administrator can delete stories posted by other users; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_delete_stories: Bool;

  /**
   * True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;
};

/**
 * Version of {@link chatAdministratorRights} for method parameters.
 *
 * Describes rights of the administrator
 */
export type chatAdministratorRights$Input = {
  readonly _: "chatAdministratorRights";

  /**
   * True, if the administrator can get chat event log, get chat boosts in channels, get channel members, report supergroup spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_chat?: Bool$Input;

  /**
   * True, if the administrator can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  readonly can_change_info?: Bool$Input;

  /**
   * True, if the administrator can create channel posts or view channel statistics; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_post_messages?: Bool$Input;

  /**
   * True, if the administrator can edit messages of other users and pin messages; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_edit_messages?: Bool$Input;

  /**
   * True, if the administrator can delete messages of other users
   * @type {Bool} {@link Bool}
   */
  readonly can_delete_messages?: Bool$Input;

  /**
   * True, if the administrator can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  readonly can_invite_users?: Bool$Input;

  /**
   * True, if the administrator can restrict, ban, or unban chat members or view supergroup statistics; always true for channels
   * @type {Bool} {@link Bool}
   */
  readonly can_restrict_members?: Bool$Input;

  /**
   * True, if the administrator can pin messages; applicable to basic groups and supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly can_pin_messages?: Bool$Input;

  /**
   * True, if the administrator can manage topics; applicable to forum supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_topics?: Bool$Input;

  /**
   * True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
   * @type {Bool} {@link Bool}
   */
  readonly can_promote_members?: Bool$Input;

  /**
   * True, if the administrator can manage video chats
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_video_chats?: Bool$Input;

  /**
   * True, if the administrator can create new channel stories, or edit and delete posted stories; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_post_stories?: Bool$Input;

  /**
   * True, if the administrator can edit stories posted by other users, pin stories and access story archive; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_edit_stories?: Bool$Input;

  /**
   * True, if the administrator can delete stories posted by other users; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_delete_stories?: Bool$Input;

  /**
   * True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;
};

/**
 * Describes an option for buying Telegram Premium to a user
 */
export type premiumPaymentOption = {
  _: "premiumPaymentOption";

  /**
   * ISO 4217 currency code for Telegram Premium subscription payment
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * The amount to pay, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * The discount associated with this option, as a percentage
   * @type {int32} {@link int32}
   */
  discount_percentage: int32;

  /**
   * Number of months the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * Identifier of the store product associated with the option
   * @type {string} {@link string}
   */
  store_product_id: string;

  /**
   * An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  payment_link: InternalLinkType | null;
};

/**
 * Version of {@link premiumPaymentOption} for method parameters.
 *
 * Describes an option for buying Telegram Premium to a user
 */
export type premiumPaymentOption$Input = {
  readonly _: "premiumPaymentOption";

  /**
   * ISO 4217 currency code for Telegram Premium subscription payment
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * The amount to pay, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * The discount associated with this option, as a percentage
   * @type {int32} {@link int32}
   */
  readonly discount_percentage?: int32;

  /**
   * Number of months the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * Identifier of the store product associated with the option
   * @type {string} {@link string}
   */
  readonly store_product_id?: string;

  /**
   * An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly payment_link?: InternalLinkType$Input | null;
};

/**
 * Describes an option for buying or upgrading Telegram Premium for self
 */
export type premiumStatePaymentOption = {
  _: "premiumStatePaymentOption";

  /**
   * Information about the payment option
   * @type {premiumPaymentOption} {@link premiumPaymentOption}
   */
  payment_option: premiumPaymentOption;

  /**
   * True, if this is the currently used Telegram Premium subscription option
   * @type {Bool} {@link Bool}
   */
  is_current: Bool;

  /**
   * True, if the payment option can be used to upgrade the existing Telegram Premium subscription
   * @type {Bool} {@link Bool}
   */
  is_upgrade: Bool;

  /**
   * Identifier of the last in-store transaction for the currently used option
   * @type {string} {@link string}
   */
  last_transaction_id: string;
};

/**
 * Version of {@link premiumStatePaymentOption} for method parameters.
 *
 * Describes an option for buying or upgrading Telegram Premium for self
 */
export type premiumStatePaymentOption$Input = {
  readonly _: "premiumStatePaymentOption";

  /**
   * Information about the payment option
   * @type {premiumPaymentOption} {@link premiumPaymentOption}
   */
  readonly payment_option?: premiumPaymentOption$Input;

  /**
   * True, if this is the currently used Telegram Premium subscription option
   * @type {Bool} {@link Bool}
   */
  readonly is_current?: Bool$Input;

  /**
   * True, if the payment option can be used to upgrade the existing Telegram Premium subscription
   * @type {Bool} {@link Bool}
   */
  readonly is_upgrade?: Bool$Input;

  /**
   * Identifier of the last in-store transaction for the currently used option
   * @type {string} {@link string}
   */
  readonly last_transaction_id?: string;
};

/**
 * Describes an option for creating Telegram Premium gift codes
 */
export type premiumGiftCodePaymentOption = {
  _: "premiumGiftCodePaymentOption";

  /**
   * ISO 4217 currency code for Telegram Premium gift code payment
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * The amount to pay, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Number of users which will be able to activate the gift codes
   * @type {int32} {@link int32}
   */
  user_count: int32;

  /**
   * Number of months the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * Identifier of the store product associated with the option; may be empty if none
   * @type {string} {@link string}
   */
  store_product_id: string;

  /**
   * Number of times the store product must be paid
   * @type {int32} {@link int32}
   */
  store_product_quantity: int32;
};

/**
 * Version of {@link premiumGiftCodePaymentOption} for method parameters.
 *
 * Describes an option for creating Telegram Premium gift codes
 */
export type premiumGiftCodePaymentOption$Input = {
  readonly _: "premiumGiftCodePaymentOption";

  /**
   * ISO 4217 currency code for Telegram Premium gift code payment
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * The amount to pay, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Number of users which will be able to activate the gift codes
   * @type {int32} {@link int32}
   */
  readonly user_count?: int32;

  /**
   * Number of months the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * Identifier of the store product associated with the option; may be empty if none
   * @type {string} {@link string}
   */
  readonly store_product_id?: string;

  /**
   * Number of times the store product must be paid
   * @type {int32} {@link int32}
   */
  readonly store_product_quantity?: int32;
};

/**
 * Contains a list of options for creating Telegram Premium gift codes
 */
export type premiumGiftCodePaymentOptions = {
  _: "premiumGiftCodePaymentOptions";

  /**
   * The list of options
   * @type {vector<premiumGiftCodePaymentOption>} {@link vector<premiumGiftCodePaymentOption>}
   */
  options: vector<premiumGiftCodePaymentOption>;
};

/**
 * Version of {@link premiumGiftCodePaymentOptions} for method parameters.
 *
 * Contains a list of options for creating Telegram Premium gift codes
 */
export type premiumGiftCodePaymentOptions$Input = {
  readonly _: "premiumGiftCodePaymentOptions";

  /**
   * The list of options
   * @type {vector<premiumGiftCodePaymentOption>} {@link vector<premiumGiftCodePaymentOption>}
   */
  readonly options?: vector$Input<premiumGiftCodePaymentOption$Input>;
};

/**
 * Contains information about a Telegram Premium gift code
 */
export type premiumGiftCodeInfo = {
  _: "premiumGiftCodeInfo";

  /**
   * Identifier of a chat or a user that created the gift code; may be null if unknown. If null and the code is from messagePremiumGiftCode message, then creator_id from the message can be used
   * @type {MessageSender} {@link MessageSender}
   */
  creator_id: MessageSender | null;

  /**
   * Point in time (Unix timestamp) when the code was created
   * @type {int32} {@link int32}
   */
  creation_date: int32;

  /**
   * True, if the gift code was created for a giveaway
   * @type {Bool} {@link Bool}
   */
  is_from_giveaway: Bool;

  /**
   * Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  giveaway_message_id: int53;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * Identifier of a user for which the code was created; 0 if none
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Point in time (Unix timestamp) when the code was activated; 0 if none
   * @type {int32} {@link int32}
   */
  use_date: int32;
};

/**
 * Version of {@link premiumGiftCodeInfo} for method parameters.
 *
 * Contains information about a Telegram Premium gift code
 */
export type premiumGiftCodeInfo$Input = {
  readonly _: "premiumGiftCodeInfo";

  /**
   * Identifier of a chat or a user that created the gift code; may be null if unknown. If null and the code is from messagePremiumGiftCode message, then creator_id from the message can be used
   * @type {MessageSender} {@link MessageSender}
   */
  readonly creator_id?: MessageSender$Input | null;

  /**
   * Point in time (Unix timestamp) when the code was created
   * @type {int32} {@link int32}
   */
  readonly creation_date?: int32;

  /**
   * True, if the gift code was created for a giveaway
   * @type {Bool} {@link Bool}
   */
  readonly is_from_giveaway?: Bool$Input;

  /**
   * Identifier of the corresponding giveaway message in the creator_id chat; can be 0 or an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly giveaway_message_id?: int53;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * Identifier of a user for which the code was created; 0 if none
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the code was activated; 0 if none
   * @type {int32} {@link int32}
   */
  readonly use_date?: int32;
};

/**
 * The user is eligible for the giveaway
 */
export type premiumGiveawayParticipantStatusEligible = {
  _: "premiumGiveawayParticipantStatusEligible";
};

/**
 * Version of {@link premiumGiveawayParticipantStatusEligible} for method parameters.
 *
 * The user is eligible for the giveaway
 */
export type premiumGiveawayParticipantStatusEligible$Input = {
  readonly _: "premiumGiveawayParticipantStatusEligible";
};

/**
 * The user participates in the giveaway
 */
export type premiumGiveawayParticipantStatusParticipating = {
  _: "premiumGiveawayParticipantStatusParticipating";
};

/**
 * Version of {@link premiumGiveawayParticipantStatusParticipating} for method parameters.
 *
 * The user participates in the giveaway
 */
export type premiumGiveawayParticipantStatusParticipating$Input = {
  readonly _: "premiumGiveawayParticipantStatusParticipating";
};

/**
 * The user can't participate in the giveaway, because they have already been member of the chat
 */
export type premiumGiveawayParticipantStatusAlreadyWasMember = {
  _: "premiumGiveawayParticipantStatusAlreadyWasMember";

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  joined_chat_date: int32;
};

/**
 * Version of {@link premiumGiveawayParticipantStatusAlreadyWasMember} for method parameters.
 *
 * The user can't participate in the giveaway, because they have already been member of the chat
 */
export type premiumGiveawayParticipantStatusAlreadyWasMember$Input = {
  readonly _: "premiumGiveawayParticipantStatusAlreadyWasMember";

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  readonly joined_chat_date?: int32;
};

/**
 * The user can't participate in the giveaway, because they are an administrator in one of the chats that created the giveaway
 */
export type premiumGiveawayParticipantStatusAdministrator = {
  _: "premiumGiveawayParticipantStatusAdministrator";

  /**
   * Identifier of the chat administered by the user
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

/**
 * Version of {@link premiumGiveawayParticipantStatusAdministrator} for method parameters.
 *
 * The user can't participate in the giveaway, because they are an administrator in one of the chats that created the giveaway
 */
export type premiumGiveawayParticipantStatusAdministrator$Input = {
  readonly _: "premiumGiveawayParticipantStatusAdministrator";

  /**
   * Identifier of the chat administered by the user
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * The user can't participate in the giveaway, because they phone number is from a disallowed country
 */
export type premiumGiveawayParticipantStatusDisallowedCountry = {
  _: "premiumGiveawayParticipantStatusDisallowedCountry";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's country
   * @type {string} {@link string}
   */
  user_country_code: string;
};

/**
 * Version of {@link premiumGiveawayParticipantStatusDisallowedCountry} for method parameters.
 *
 * The user can't participate in the giveaway, because they phone number is from a disallowed country
 */
export type premiumGiveawayParticipantStatusDisallowedCountry$Input = {
  readonly _: "premiumGiveawayParticipantStatusDisallowedCountry";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's country
   * @type {string} {@link string}
   */
  readonly user_country_code?: string;
};

/**
 * Describes an ongoing giveaway
 */
export type premiumGiveawayInfoOngoing = {
  _: "premiumGiveawayInfoOngoing";

  /**
   * Point in time (Unix timestamp) when the giveaway was created
   * @type {int32} {@link int32}
   */
  creation_date: int32;

  /**
   * Status of the current user in the giveaway
   * @type {PremiumGiveawayParticipantStatus} {@link PremiumGiveawayParticipantStatus}
   */
  status: PremiumGiveawayParticipantStatus;

  /**
   * True, if the giveaway has ended and results are being prepared
   * @type {Bool} {@link Bool}
   */
  is_ended: Bool;
};

/**
 * Version of {@link premiumGiveawayInfoOngoing} for method parameters.
 *
 * Describes an ongoing giveaway
 */
export type premiumGiveawayInfoOngoing$Input = {
  readonly _: "premiumGiveawayInfoOngoing";

  /**
   * Point in time (Unix timestamp) when the giveaway was created
   * @type {int32} {@link int32}
   */
  readonly creation_date?: int32;

  /**
   * Status of the current user in the giveaway
   * @type {PremiumGiveawayParticipantStatus} {@link PremiumGiveawayParticipantStatus}
   */
  readonly status?: PremiumGiveawayParticipantStatus$Input;

  /**
   * True, if the giveaway has ended and results are being prepared
   * @type {Bool} {@link Bool}
   */
  readonly is_ended?: Bool$Input;
};

/**
 * Describes a completed giveaway
 */
export type premiumGiveawayInfoCompleted = {
  _: "premiumGiveawayInfoCompleted";

  /**
   * Point in time (Unix timestamp) when the giveaway was created
   * @type {int32} {@link int32}
   */
  creation_date: int32;

  /**
   * Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
   * @type {int32} {@link int32}
   */
  actual_winners_selection_date: int32;

  /**
   * True, if the giveaway was canceled and was fully refunded
   * @type {Bool} {@link Bool}
   */
  was_refunded: Bool;

  /**
   * Number of winners in the giveaway
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Number of winners, which activated their gift codes
   * @type {int32} {@link int32}
   */
  activation_count: int32;

  /**
   * Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway
   * @type {string} {@link string}
   */
  gift_code: string;
};

/**
 * Version of {@link premiumGiveawayInfoCompleted} for method parameters.
 *
 * Describes a completed giveaway
 */
export type premiumGiveawayInfoCompleted$Input = {
  readonly _: "premiumGiveawayInfoCompleted";

  /**
   * Point in time (Unix timestamp) when the giveaway was created
   * @type {int32} {@link int32}
   */
  readonly creation_date?: int32;

  /**
   * Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
   * @type {int32} {@link int32}
   */
  readonly actual_winners_selection_date?: int32;

  /**
   * True, if the giveaway was canceled and was fully refunded
   * @type {Bool} {@link Bool}
   */
  readonly was_refunded?: Bool$Input;

  /**
   * Number of winners in the giveaway
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Number of winners, which activated their gift codes
   * @type {int32} {@link int32}
   */
  readonly activation_count?: int32;

  /**
   * Telegram Premium gift code that was received by the current user; empty if the user isn't a winner in the giveaway
   * @type {string} {@link string}
   */
  readonly gift_code?: string;
};

/**
 * Contains information about supported accent color for user/chat name, background of empty chat photo, replies to messages and link previews
 */
export type accentColor = {
  _: "accentColor";

  /**
   * Accent color identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Identifier of a built-in color to use in places, where only one color is needed; 0-6
   * @type {int32} {@link int32}
   */
  built_in_accent_color_id: int32;

  /**
   * The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
   * @type {vector<int32>} {@link vector<int32>}
   */
  light_theme_colors: vector<int32>;

  /**
   * The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
   * @type {vector<int32>} {@link vector<int32>}
   */
  dark_theme_colors: vector<int32>;

  /**
   * The minimum chat boost level required to use the color
   * @type {int32} {@link int32}
   */
  min_chat_boost_level: int32;
};

/**
 * Version of {@link accentColor} for method parameters.
 *
 * Contains information about supported accent color for user/chat name, background of empty chat photo, replies to messages and link previews
 */
export type accentColor$Input = {
  readonly _: "accentColor";

  /**
   * Accent color identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Identifier of a built-in color to use in places, where only one color is needed; 0-6
   * @type {int32} {@link int32}
   */
  readonly built_in_accent_color_id?: int32;

  /**
   * The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in light themes
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly light_theme_colors?: vector$Input<int32>;

  /**
   * The list of 1-3 colors in RGB format, describing the accent color, as expected to be shown in dark themes
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly dark_theme_colors?: vector$Input<int32>;

  /**
   * The minimum chat boost level required to use the color
   * @type {int32} {@link int32}
   */
  readonly min_chat_boost_level?: int32;
};

/**
 * Contains information about supported accent colors for user profile photo background in RGB format
 */
export type profileAccentColors = {
  _: "profileAccentColors";

  /**
   * The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
   * @type {vector<int32>} {@link vector<int32>}
   */
  palette_colors: vector<int32>;

  /**
   * The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
   * @type {vector<int32>} {@link vector<int32>}
   */
  background_colors: vector<int32>;

  /**
   * The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
   * @type {vector<int32>} {@link vector<int32>}
   */
  story_colors: vector<int32>;
};

/**
 * Version of {@link profileAccentColors} for method parameters.
 *
 * Contains information about supported accent colors for user profile photo background in RGB format
 */
export type profileAccentColors$Input = {
  readonly _: "profileAccentColors";

  /**
   * The list of 1-2 colors in RGB format, describing the colors, as expected to be shown in the color palette settings
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly palette_colors?: vector$Input<int32>;

  /**
   * The list of 1-2 colors in RGB format, describing the colors, as expected to be used for the profile photo background
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly background_colors?: vector$Input<int32>;

  /**
   * The list of 2 colors in RGB format, describing the colors of the gradient to be used for the unread active story indicator around profile photo
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly story_colors?: vector$Input<int32>;
};

/**
 * Contains information about supported accent color for user profile photo background
 */
export type profileAccentColor = {
  _: "profileAccentColor";

  /**
   * Profile accent color identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Accent colors expected to be used in light themes
   * @type {profileAccentColors} {@link profileAccentColors}
   */
  light_theme_colors: profileAccentColors;

  /**
   * Accent colors expected to be used in dark themes
   * @type {profileAccentColors} {@link profileAccentColors}
   */
  dark_theme_colors: profileAccentColors;

  /**
   * The minimum chat boost level required to use the color
   * @type {int32} {@link int32}
   */
  min_chat_boost_level: int32;
};

/**
 * Version of {@link profileAccentColor} for method parameters.
 *
 * Contains information about supported accent color for user profile photo background
 */
export type profileAccentColor$Input = {
  readonly _: "profileAccentColor";

  /**
   * Profile accent color identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Accent colors expected to be used in light themes
   * @type {profileAccentColors} {@link profileAccentColors}
   */
  readonly light_theme_colors?: profileAccentColors$Input;

  /**
   * Accent colors expected to be used in dark themes
   * @type {profileAccentColors} {@link profileAccentColors}
   */
  readonly dark_theme_colors?: profileAccentColors$Input;

  /**
   * The minimum chat boost level required to use the color
   * @type {int32} {@link int32}
   */
  readonly min_chat_boost_level?: int32;
};

/**
 * Describes a custom emoji to be shown instead of the Telegram Premium badge
 */
export type emojiStatus = {
  _: "emojiStatus";

  /**
   * Identifier of the custom emoji in stickerFormatTgs format
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;

  /**
   * Point in time (Unix timestamp) when the status will expire; 0 if never
   * @type {int32} {@link int32}
   */
  expiration_date: int32;
};

/**
 * Version of {@link emojiStatus} for method parameters.
 *
 * Describes a custom emoji to be shown instead of the Telegram Premium badge
 */
export type emojiStatus$Input = {
  readonly _: "emojiStatus";

  /**
   * Identifier of the custom emoji in stickerFormatTgs format
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;

  /**
   * Point in time (Unix timestamp) when the status will expire; 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;
};

/**
 * Contains a list of custom emoji identifiers for emoji statuses
 */
export type emojiStatuses = {
  _: "emojiStatuses";

  /**
   * The list of custom emoji identifiers
   * @type {vector<int64>} {@link vector<int64>}
   */
  custom_emoji_ids: vector<int64>;
};

/**
 * Version of {@link emojiStatuses} for method parameters.
 *
 * Contains a list of custom emoji identifiers for emoji statuses
 */
export type emojiStatuses$Input = {
  readonly _: "emojiStatuses";

  /**
   * The list of custom emoji identifiers
   * @type {vector<int64>} {@link vector<int64>}
   */
  readonly custom_emoji_ids?: vector$Input<int64$Input>;
};

/**
 * Describes usernames assigned to a user, a supergroup, or a channel
 */
export type usernames = {
  _: "usernames";

  /**
   * List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
   * @type {vector<string>} {@link vector<string>}
   */
  active_usernames: vector<string>;

  /**
   * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
   * @type {vector<string>} {@link vector<string>}
   */
  disabled_usernames: vector<string>;

  /**
   * The active username, which can be changed with setUsername or setSupergroupUsername
   * @type {string} {@link string}
   */
  editable_username: string;
};

/**
 * Version of {@link usernames} for method parameters.
 *
 * Describes usernames assigned to a user, a supergroup, or a channel
 */
export type usernames$Input = {
  readonly _: "usernames";

  /**
   * List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames, reorderBotActiveUsernames or reorderSupergroupActiveUsernames
   * @type {vector<string>} {@link vector<string>}
   */
  readonly active_usernames?: vector$Input<string>;

  /**
   * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive, toggleBotUsernameIsActive, or toggleSupergroupUsernameIsActive
   * @type {vector<string>} {@link vector<string>}
   */
  readonly disabled_usernames?: vector$Input<string>;

  /**
   * The active username, which can be changed with setUsername or setSupergroupUsername
   * @type {string} {@link string}
   */
  readonly editable_username?: string;
};

/**
 * Represents a user
 */
export type user = {
  _: "user";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * First name of the user
   * @type {string} {@link string}
   */
  first_name: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  last_name: string;

  /**
   * Usernames of the user; may be null
   * @type {usernames} {@link usernames}
   */
  usernames: usernames | null;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * Current online status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  status: UserStatus;

  /**
   * Profile photo of the user; may be null
   * @type {profilePhoto} {@link profilePhoto}
   */
  profile_photo: profilePhoto | null;

  /**
   * Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview. For Telegram Premium users only
   * @type {int32} {@link int32}
   */
  accent_color_id: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. For Telegram Premium users only
   * @type {int64} {@link int64}
   */
  background_custom_emoji_id: int64;

  /**
   * Identifier of the accent color for the user's profile; -1 if none. For Telegram Premium users only
   * @type {int32} {@link int32}
   */
  profile_accent_color_id: int32;

  /**
   * Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none. For Telegram Premium users only
   * @type {int64} {@link int64}
   */
  profile_background_custom_emoji_id: int64;

  /**
   * Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
   * @type {emojiStatus} {@link emojiStatus}
   */
  emoji_status: emojiStatus | null;

  /**
   * The user is a contact of the current user
   * @type {Bool} {@link Bool}
   */
  is_contact: Bool;

  /**
   * The user is a contact of the current user and the current user is a contact of the user
   * @type {Bool} {@link Bool}
   */
  is_mutual_contact: Bool;

  /**
   * The user is a close friend of the current user; implies that the user is a contact
   * @type {Bool} {@link Bool}
   */
  is_close_friend: Bool;

  /**
   * True, if the user is verified
   * @type {Bool} {@link Bool}
   */
  is_verified: Bool;

  /**
   * True, if the user is a Telegram Premium user
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;

  /**
   * True, if the user is Telegram support account
   * @type {Bool} {@link Bool}
   */
  is_support: Bool;

  /**
   * If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
   * @type {string} {@link string}
   */
  restriction_reason: string;

  /**
   * True, if many users reported this user as a scam
   * @type {Bool} {@link Bool}
   */
  is_scam: Bool;

  /**
   * True, if many users reported this user as a fake account
   * @type {Bool} {@link Bool}
   */
  is_fake: Bool;

  /**
   * True, if the user has non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  has_active_stories: Bool;

  /**
   * True, if the user has unread non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  has_unread_active_stories: Bool;

  /**
   * If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
   * @type {Bool} {@link Bool}
   */
  have_access: Bool;

  /**
   * Type of the user
   * @type {UserType} {@link UserType}
   */
  type: UserType;

  /**
   * IETF language tag of the user's language; only available to bots
   * @type {string} {@link string}
   */
  language_code: string;

  /**
   * True, if the user added the current bot to attachment menu; only available to bots
   * @type {Bool} {@link Bool}
   */
  added_to_attachment_menu: Bool;
};

/**
 * Version of {@link user} for method parameters.
 *
 * Represents a user
 */
export type user$Input = {
  readonly _: "user";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * First name of the user
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  readonly last_name?: string;

  /**
   * Usernames of the user; may be null
   * @type {usernames} {@link usernames}
   */
  readonly usernames?: usernames$Input | null;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Current online status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  readonly status?: UserStatus$Input;

  /**
   * Profile photo of the user; may be null
   * @type {profilePhoto} {@link profilePhoto}
   */
  readonly profile_photo?: profilePhoto$Input | null;

  /**
   * Identifier of the accent color for name, and backgrounds of profile photo, reply header, and link preview. For Telegram Premium users only
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. For Telegram Premium users only
   * @type {int64} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;

  /**
   * Identifier of the accent color for the user's profile; -1 if none. For Telegram Premium users only
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the background of the user's profile; 0 if none. For Telegram Premium users only
   * @type {int64} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;

  /**
   * Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
   * @type {emojiStatus} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;

  /**
   * The user is a contact of the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_contact?: Bool$Input;

  /**
   * The user is a contact of the current user and the current user is a contact of the user
   * @type {Bool} {@link Bool}
   */
  readonly is_mutual_contact?: Bool$Input;

  /**
   * The user is a close friend of the current user; implies that the user is a contact
   * @type {Bool} {@link Bool}
   */
  readonly is_close_friend?: Bool$Input;

  /**
   * True, if the user is verified
   * @type {Bool} {@link Bool}
   */
  readonly is_verified?: Bool$Input;

  /**
   * True, if the user is a Telegram Premium user
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;

  /**
   * True, if the user is Telegram support account
   * @type {Bool} {@link Bool}
   */
  readonly is_support?: Bool$Input;

  /**
   * If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
   * @type {string} {@link string}
   */
  readonly restriction_reason?: string;

  /**
   * True, if many users reported this user as a scam
   * @type {Bool} {@link Bool}
   */
  readonly is_scam?: Bool$Input;

  /**
   * True, if many users reported this user as a fake account
   * @type {Bool} {@link Bool}
   */
  readonly is_fake?: Bool$Input;

  /**
   * True, if the user has non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  readonly has_active_stories?: Bool$Input;

  /**
   * True, if the user has unread non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  readonly has_unread_active_stories?: Bool$Input;

  /**
   * If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method
   * @type {Bool} {@link Bool}
   */
  readonly have_access?: Bool$Input;

  /**
   * Type of the user
   * @type {UserType} {@link UserType}
   */
  readonly type?: UserType$Input;

  /**
   * IETF language tag of the user's language; only available to bots
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * True, if the user added the current bot to attachment menu; only available to bots
   * @type {Bool} {@link Bool}
   */
  readonly added_to_attachment_menu?: Bool$Input;
};

/**
 * Contains information about a bot
 */
export type botInfo = {
  _: "botInfo";

  /**
   * The text that is shown on the bot's profile page and is sent together with the link when users share the bot
   * @type {string} {@link string}
   */
  short_description: string;

  /**
   * Contains information about a bot
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Photo shown in the chat with the bot if the chat is empty; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * Animation shown in the chat with the bot if the chat is empty; may be null
   * @type {animation} {@link animation}
   */
  animation: animation | null;

  /**
   * Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
   * @type {botMenuButton} {@link botMenuButton}
   */
  menu_button: botMenuButton | null;

  /**
   * List of the bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  commands: vector<botCommand>;

  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  default_group_administrator_rights: chatAdministratorRights | null;

  /**
   * Default administrator rights for adding the bot to channels; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  default_channel_administrator_rights: chatAdministratorRights | null;

  /**
   * The internal link, which can be used to edit bot commands; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  edit_commands_link: InternalLinkType | null;

  /**
   * The internal link, which can be used to edit bot description; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  edit_description_link: InternalLinkType | null;

  /**
   * The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  edit_description_media_link: InternalLinkType | null;

  /**
   * The internal link, which can be used to edit bot settings; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  edit_settings_link: InternalLinkType | null;
};

/**
 * Version of {@link botInfo} for method parameters.
 *
 * Contains information about a bot
 */
export type botInfo$Input = {
  readonly _: "botInfo";

  /**
   * The text that is shown on the bot's profile page and is sent together with the link when users share the bot
   * @type {string} {@link string}
   */
  readonly short_description?: string;

  /**
   * Contains information about a bot
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Photo shown in the chat with the bot if the chat is empty; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * Animation shown in the chat with the bot if the chat is empty; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input | null;

  /**
   * Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
   * @type {botMenuButton} {@link botMenuButton}
   */
  readonly menu_button?: botMenuButton$Input | null;

  /**
   * List of the bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;

  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly default_group_administrator_rights?: chatAdministratorRights$Input | null;

  /**
   * Default administrator rights for adding the bot to channels; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly default_channel_administrator_rights?: chatAdministratorRights$Input | null;

  /**
   * The internal link, which can be used to edit bot commands; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly edit_commands_link?: InternalLinkType$Input | null;

  /**
   * The internal link, which can be used to edit bot description; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly edit_description_link?: InternalLinkType$Input | null;

  /**
   * The internal link, which can be used to edit the photo or animation shown in the chat with the bot if the chat is empty; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly edit_description_media_link?: InternalLinkType$Input | null;

  /**
   * The internal link, which can be used to edit bot settings; may be null
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly edit_settings_link?: InternalLinkType$Input | null;
};

/**
 * Contains full information about a user
 */
export type userFullInfo = {
  _: "userFullInfo";

  /**
   * User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown.
   *
   * - If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
   * @type {chatPhoto} {@link chatPhoto}
   */
  personal_photo: chatPhoto | null;

  /**
   * User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown.
   *
   * - If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto | null;

  /**
   * User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown.
   *
   * - If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
   * @type {chatPhoto} {@link chatPhoto}
   */
  public_photo: chatPhoto | null;

  /**
   * Block list to which the user is added; may be null if none
   * @type {BlockList} {@link BlockList}
   */
  block_list: BlockList | null;

  /**
   * True, if the user can be called
   * @type {Bool} {@link Bool}
   */
  can_be_called: Bool;

  /**
   * True, if a video call can be created with the user
   * @type {Bool} {@link Bool}
   */
  supports_video_calls: Bool;

  /**
   * True, if the user can't be called due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  has_private_calls: Bool;

  /**
   * True, if the user can't be linked in forwarded messages due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  has_private_forwards: Bool;

  /**
   * True, if voice and video notes can't be sent or forwarded to the user
   * @type {Bool} {@link Bool}
   */
  has_restricted_voice_and_video_note_messages: Bool;

  /**
   * True, if the user has pinned stories
   * @type {Bool} {@link Bool}
   */
  has_pinned_stories: Bool;

  /**
   * True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
   * @type {Bool} {@link Bool}
   */
  need_phone_number_privacy_exception: Bool;

  /**
   * True, if the user set chat background for both chat users and it wasn't reverted yet
   * @type {Bool} {@link Bool}
   */
  set_chat_background: Bool;

  /**
   * A short user bio; may be null for bots
   * @type {formattedText} {@link formattedText}
   */
  bio: formattedText | null;

  /**
   * The list of available options for gifting Telegram Premium to the user
   * @type {vector<premiumPaymentOption>} {@link vector<premiumPaymentOption>}
   */
  premium_gift_options: vector<premiumPaymentOption>;

  /**
   * Number of group chats where both the other user and the current user are a member; 0 for the current user
   * @type {int32} {@link int32}
   */
  group_in_common_count: int32;

  /**
   * For bots, information about the bot; may be null if the user isn't a bot
   * @type {botInfo} {@link botInfo}
   */
  bot_info: botInfo | null;
};

/**
 * Version of {@link userFullInfo} for method parameters.
 *
 * Contains full information about a user
 */
export type userFullInfo$Input = {
  readonly _: "userFullInfo";

  /**
   * User profile photo set by the current user for the contact; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown.
   *
   * - If non-null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly personal_photo?: chatPhoto$Input | null;

  /**
   * User profile photo; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown.
   *
   * - If non-null and personal_photo is null, then it is the same photo as in user.profile_photo and chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input | null;

  /**
   * User profile photo visible if the main photo is hidden by privacy settings; may be null. If null and user.profile_photo is null, then the photo is empty; otherwise, it is unknown.
   *
   * - If non-null and both photo and personal_photo are null, then it is the same photo as in user.profile_photo and chat.photo. This photo isn't returned in the list of user photos
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly public_photo?: chatPhoto$Input | null;

  /**
   * Block list to which the user is added; may be null if none
   * @type {BlockList} {@link BlockList}
   */
  readonly block_list?: BlockList$Input | null;

  /**
   * True, if the user can be called
   * @type {Bool} {@link Bool}
   */
  readonly can_be_called?: Bool$Input;

  /**
   * True, if a video call can be created with the user
   * @type {Bool} {@link Bool}
   */
  readonly supports_video_calls?: Bool$Input;

  /**
   * True, if the user can't be called due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  readonly has_private_calls?: Bool$Input;

  /**
   * True, if the user can't be linked in forwarded messages due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  readonly has_private_forwards?: Bool$Input;

  /**
   * True, if voice and video notes can't be sent or forwarded to the user
   * @type {Bool} {@link Bool}
   */
  readonly has_restricted_voice_and_video_note_messages?: Bool$Input;

  /**
   * True, if the user has pinned stories
   * @type {Bool} {@link Bool}
   */
  readonly has_pinned_stories?: Bool$Input;

  /**
   * True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
   * @type {Bool} {@link Bool}
   */
  readonly need_phone_number_privacy_exception?: Bool$Input;

  /**
   * True, if the user set chat background for both chat users and it wasn't reverted yet
   * @type {Bool} {@link Bool}
   */
  readonly set_chat_background?: Bool$Input;

  /**
   * A short user bio; may be null for bots
   * @type {formattedText} {@link formattedText}
   */
  readonly bio?: formattedText$Input | null;

  /**
   * The list of available options for gifting Telegram Premium to the user
   * @type {vector<premiumPaymentOption>} {@link vector<premiumPaymentOption>}
   */
  readonly premium_gift_options?: vector$Input<premiumPaymentOption$Input>;

  /**
   * Number of group chats where both the other user and the current user are a member; 0 for the current user
   * @type {int32} {@link int32}
   */
  readonly group_in_common_count?: int32;

  /**
   * For bots, information about the bot; may be null if the user isn't a bot
   * @type {botInfo} {@link botInfo}
   */
  readonly bot_info?: botInfo$Input | null;
};

/**
 * Represents a list of users
 */
export type users = {
  _: "users";

  /**
   * Approximate total number of users found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * A list of user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link users} for method parameters.
 *
 * Represents a list of users
 */
export type users$Input = {
  readonly _: "users";

  /**
   * Approximate total number of users found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * A list of user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Contains information about a chat administrator
 */
export type chatAdministrator = {
  _: "chatAdministrator";

  /**
   * User identifier of the administrator
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Custom title of the administrator
   * @type {string} {@link string}
   */
  custom_title: string;

  /**
   * True, if the user is the owner of the chat
   * @type {Bool} {@link Bool}
   */
  is_owner: Bool;
};

/**
 * Version of {@link chatAdministrator} for method parameters.
 *
 * Contains information about a chat administrator
 */
export type chatAdministrator$Input = {
  readonly _: "chatAdministrator";

  /**
   * User identifier of the administrator
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Custom title of the administrator
   * @type {string} {@link string}
   */
  readonly custom_title?: string;

  /**
   * True, if the user is the owner of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_owner?: Bool$Input;
};

/**
 * Represents a list of chat administrators
 */
export type chatAdministrators = {
  _: "chatAdministrators";

  /**
   * A list of chat administrators
   * @type {vector<chatAdministrator>} {@link vector<chatAdministrator>}
   */
  administrators: vector<chatAdministrator>;
};

/**
 * Version of {@link chatAdministrators} for method parameters.
 *
 * Represents a list of chat administrators
 */
export type chatAdministrators$Input = {
  readonly _: "chatAdministrators";

  /**
   * A list of chat administrators
   * @type {vector<chatAdministrator>} {@link vector<chatAdministrator>}
   */
  readonly administrators?: vector$Input<chatAdministrator$Input>;
};

/**
 * The user is the owner of the chat and has all the administrator privileges
 */
export type chatMemberStatusCreator = {
  _: "chatMemberStatusCreator";

  /**
   * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  custom_title: string;

  /**
   * True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  is_member: Bool;
};

/**
 * Version of {@link chatMemberStatusCreator} for method parameters.
 *
 * The user is the owner of the chat and has all the administrator privileges
 */
export type chatMemberStatusCreator$Input = {
  readonly _: "chatMemberStatusCreator";

  /**
   * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  readonly custom_title?: string;

  /**
   * True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_member?: Bool$Input;
};

/**
 * The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats.
 *
 * - In supergroups and channels, there are more detailed options for administrator privileges
 */
export type chatMemberStatusAdministrator = {
  _: "chatMemberStatusAdministrator";

  /**
   * A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  custom_title: string;

  /**
   * True, if the current user can edit the administrator privileges for the called user
   * @type {Bool} {@link Bool}
   */
  can_be_edited: Bool;

  /**
   * Rights of the administrator
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  rights: chatAdministratorRights;
};

/**
 * Version of {@link chatMemberStatusAdministrator} for method parameters.
 *
 * The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats.
 *
 * - In supergroups and channels, there are more detailed options for administrator privileges
 */
export type chatMemberStatusAdministrator$Input = {
  readonly _: "chatMemberStatusAdministrator";

  /**
   * A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  readonly custom_title?: string;

  /**
   * True, if the current user can edit the administrator privileges for the called user
   * @type {Bool} {@link Bool}
   */
  readonly can_be_edited?: Bool$Input;

  /**
   * Rights of the administrator
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly rights?: chatAdministratorRights$Input;
};

/**
 * The user is a member of the chat, without any additional privileges or restrictions
 */
export type chatMemberStatusMember = {
  _: "chatMemberStatusMember";
};

/**
 * Version of {@link chatMemberStatusMember} for method parameters.
 *
 * The user is a member of the chat, without any additional privileges or restrictions
 */
export type chatMemberStatusMember$Input = {
  readonly _: "chatMemberStatusMember";
};

/**
 * The user is under certain restrictions in the chat. Not supported in basic groups and channels
 */
export type chatMemberStatusRestricted = {
  _: "chatMemberStatusRestricted";

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  is_member: Bool;

  /**
   * Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
   * @type {int32} {@link int32}
   */
  restricted_until_date: int32;

  /**
   * User permissions in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  permissions: chatPermissions;
};

/**
 * Version of {@link chatMemberStatusRestricted} for method parameters.
 *
 * The user is under certain restrictions in the chat. Not supported in basic groups and channels
 */
export type chatMemberStatusRestricted$Input = {
  readonly _: "chatMemberStatusRestricted";

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_member?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
   * @type {int32} {@link int32}
   */
  readonly restricted_until_date?: int32;

  /**
   * User permissions in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/**
 * The user or the chat is not a chat member
 */
export type chatMemberStatusLeft = {
  _: "chatMemberStatusLeft";
};

/**
 * Version of {@link chatMemberStatusLeft} for method parameters.
 *
 * The user or the chat is not a chat member
 */
export type chatMemberStatusLeft$Input = {
  readonly _: "chatMemberStatusLeft";
};

/**
 * The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
 */
export type chatMemberStatusBanned = {
  _: "chatMemberStatusBanned";

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
   * @type {int32} {@link int32}
   */
  banned_until_date: int32;
};

/**
 * Version of {@link chatMemberStatusBanned} for method parameters.
 *
 * The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
 */
export type chatMemberStatusBanned$Input = {
  readonly _: "chatMemberStatusBanned";

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
   * @type {int32} {@link int32}
   */
  readonly banned_until_date?: int32;
};

/**
 * Describes a user or a chat as a member of another chat
 */
export type chatMember = {
  _: "chatMember";

  /**
   * Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
   * @type {MessageSender} {@link MessageSender}
   */
  member_id: MessageSender;

  /**
   * Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
   * @type {int53} {@link int53}
   */
  inviter_user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
   * @type {int32} {@link int32}
   */
  joined_chat_date: int32;

  /**
   * Status of the member in the chat
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;
};

/**
 * Version of {@link chatMember} for method parameters.
 *
 * Describes a user or a chat as a member of another chat
 */
export type chatMember$Input = {
  readonly _: "chatMember";

  /**
   * Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
   * @type {MessageSender} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly inviter_user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user joined/was promoted/was banned in the chat
   * @type {int32} {@link int32}
   */
  readonly joined_chat_date?: int32;

  /**
   * Status of the member in the chat
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/**
 * Contains a list of chat members
 */
export type chatMembers = {
  _: "chatMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * A list of chat members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  members: vector<chatMember>;
};

/**
 * Version of {@link chatMembers} for method parameters.
 *
 * Contains a list of chat members
 */
export type chatMembers$Input = {
  readonly _: "chatMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * A list of chat members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  readonly members?: vector$Input<chatMember$Input>;
};

/**
 * Returns contacts of the user
 */
export type chatMembersFilterContacts = {
  _: "chatMembersFilterContacts";
};

/**
 * Version of {@link chatMembersFilterContacts} for method parameters.
 *
 * Returns contacts of the user
 */
export type chatMembersFilterContacts$Input = {
  readonly _: "chatMembersFilterContacts";
};

/**
 * Returns the owner and administrators
 */
export type chatMembersFilterAdministrators = {
  _: "chatMembersFilterAdministrators";
};

/**
 * Version of {@link chatMembersFilterAdministrators} for method parameters.
 *
 * Returns the owner and administrators
 */
export type chatMembersFilterAdministrators$Input = {
  readonly _: "chatMembersFilterAdministrators";
};

/**
 * Returns all chat members, including restricted chat members
 */
export type chatMembersFilterMembers = {
  _: "chatMembersFilterMembers";
};

/**
 * Version of {@link chatMembersFilterMembers} for method parameters.
 *
 * Returns all chat members, including restricted chat members
 */
export type chatMembersFilterMembers$Input = {
  readonly _: "chatMembersFilterMembers";
};

/**
 * Returns users which can be mentioned in the chat
 */
export type chatMembersFilterMention = {
  _: "chatMembersFilterMention";

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;
};

/**
 * Version of {@link chatMembersFilterMention} for method parameters.
 *
 * Returns users which can be mentioned in the chat
 */
export type chatMembersFilterMention$Input = {
  readonly _: "chatMembersFilterMention";

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
 */
export type chatMembersFilterRestricted = {
  _: "chatMembersFilterRestricted";
};

/**
 * Version of {@link chatMembersFilterRestricted} for method parameters.
 *
 * Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
 */
export type chatMembersFilterRestricted$Input = {
  readonly _: "chatMembersFilterRestricted";
};

/**
 * Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
 */
export type chatMembersFilterBanned = {
  _: "chatMembersFilterBanned";
};

/**
 * Version of {@link chatMembersFilterBanned} for method parameters.
 *
 * Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
 */
export type chatMembersFilterBanned$Input = {
  readonly _: "chatMembersFilterBanned";
};

/**
 * Returns bot members of the chat
 */
export type chatMembersFilterBots = {
  _: "chatMembersFilterBots";
};

/**
 * Version of {@link chatMembersFilterBots} for method parameters.
 *
 * Returns bot members of the chat
 */
export type chatMembersFilterBots$Input = {
  readonly _: "chatMembersFilterBots";
};

/**
 * Returns recently active users in reverse chronological order
 */
export type supergroupMembersFilterRecent = {
  _: "supergroupMembersFilterRecent";
};

/**
 * Version of {@link supergroupMembersFilterRecent} for method parameters.
 *
 * Returns recently active users in reverse chronological order
 */
export type supergroupMembersFilterRecent$Input = {
  readonly _: "supergroupMembersFilterRecent";
};

/**
 * Returns contacts of the user, which are members of the supergroup or channel
 */
export type supergroupMembersFilterContacts = {
  _: "supergroupMembersFilterContacts";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

/**
 * Version of {@link supergroupMembersFilterContacts} for method parameters.
 *
 * Returns contacts of the user, which are members of the supergroup or channel
 */
export type supergroupMembersFilterContacts$Input = {
  readonly _: "supergroupMembersFilterContacts";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Returns the owner and administrators
 */
export type supergroupMembersFilterAdministrators = {
  _: "supergroupMembersFilterAdministrators";
};

/**
 * Version of {@link supergroupMembersFilterAdministrators} for method parameters.
 *
 * Returns the owner and administrators
 */
export type supergroupMembersFilterAdministrators$Input = {
  readonly _: "supergroupMembersFilterAdministrators";
};

/**
 * Used to search for supergroup or channel members via a (string) query
 */
export type supergroupMembersFilterSearch = {
  _: "supergroupMembersFilterSearch";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

/**
 * Version of {@link supergroupMembersFilterSearch} for method parameters.
 *
 * Used to search for supergroup or channel members via a (string) query
 */
export type supergroupMembersFilterSearch$Input = {
  readonly _: "supergroupMembersFilterSearch";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Returns restricted supergroup members; can be used only by administrators
 */
export type supergroupMembersFilterRestricted = {
  _: "supergroupMembersFilterRestricted";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

/**
 * Version of {@link supergroupMembersFilterRestricted} for method parameters.
 *
 * Returns restricted supergroup members; can be used only by administrators
 */
export type supergroupMembersFilterRestricted$Input = {
  readonly _: "supergroupMembersFilterRestricted";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Returns users banned from the supergroup or channel; can be used only by administrators
 */
export type supergroupMembersFilterBanned = {
  _: "supergroupMembersFilterBanned";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

/**
 * Version of {@link supergroupMembersFilterBanned} for method parameters.
 *
 * Returns users banned from the supergroup or channel; can be used only by administrators
 */
export type supergroupMembersFilterBanned$Input = {
  readonly _: "supergroupMembersFilterBanned";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Returns users which can be mentioned in the supergroup
 */
export type supergroupMembersFilterMention = {
  _: "supergroupMembersFilterMention";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;
};

/**
 * Version of {@link supergroupMembersFilterMention} for method parameters.
 *
 * Returns users which can be mentioned in the supergroup
 */
export type supergroupMembersFilterMention$Input = {
  readonly _: "supergroupMembersFilterMention";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns bot members of the supergroup or channel
 */
export type supergroupMembersFilterBots = {
  _: "supergroupMembersFilterBots";
};

/**
 * Version of {@link supergroupMembersFilterBots} for method parameters.
 *
 * Returns bot members of the supergroup or channel
 */
export type supergroupMembersFilterBots$Input = {
  readonly _: "supergroupMembersFilterBots";
};

/**
 * Contains a chat invite link
 */
export type chatInviteLink = {
  _: "chatInviteLink";

  /**
   * Chat invite link
   * @type {string} {@link string}
   */
  invite_link: string;

  /**
   * Name of the link
   * @type {string} {@link string}
   */
  name: string;

  /**
   * User identifier of an administrator created the link
   * @type {int53} {@link int53}
   */
  creator_user_id: int53;

  /**
   * Point in time (Unix timestamp) when the link was created
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
   * @type {int32} {@link int32}
   */
  edit_date: int32;

  /**
   * Point in time (Unix timestamp) when the link will expire; 0 if never
   * @type {int32} {@link int32}
   */
  expiration_date: int32;

  /**
   * The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
   * @type {int32} {@link int32}
   */
  member_limit: int32;

  /**
   * Number of chat members, which joined the chat using the link
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Number of pending join requests created using this link
   * @type {int32} {@link int32}
   */
  pending_join_request_count: int32;

  /**
   * True, if the link only creates join request. If true, total number of joining members will be unlimited
   * @type {Bool} {@link Bool}
   */
  creates_join_request: Bool;

  /**
   * True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
   * @type {Bool} {@link Bool}
   */
  is_primary: Bool;

  /**
   * True, if the link was revoked
   * @type {Bool} {@link Bool}
   */
  is_revoked: Bool;
};

/**
 * Version of {@link chatInviteLink} for method parameters.
 *
 * Contains a chat invite link
 */
export type chatInviteLink$Input = {
  readonly _: "chatInviteLink";

  /**
   * Chat invite link
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Name of the link
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * User identifier of an administrator created the link
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the link was created
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
   * @type {int32} {@link int32}
   */
  readonly edit_date?: int32;

  /**
   * Point in time (Unix timestamp) when the link will expire; 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Number of chat members, which joined the chat using the link
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Number of pending join requests created using this link
   * @type {int32} {@link int32}
   */
  readonly pending_join_request_count?: int32;

  /**
   * True, if the link only creates join request. If true, total number of joining members will be unlimited
   * @type {Bool} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;

  /**
   * True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
   * @type {Bool} {@link Bool}
   */
  readonly is_primary?: Bool$Input;

  /**
   * True, if the link was revoked
   * @type {Bool} {@link Bool}
   */
  readonly is_revoked?: Bool$Input;
};

/**
 * Contains a list of chat invite links
 */
export type chatInviteLinks = {
  _: "chatInviteLinks";

  /**
   * Approximate total number of chat invite links found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of invite links
   * @type {vector<chatInviteLink>} {@link vector<chatInviteLink>}
   */
  invite_links: vector<chatInviteLink>;
};

/**
 * Version of {@link chatInviteLinks} for method parameters.
 *
 * Contains a list of chat invite links
 */
export type chatInviteLinks$Input = {
  readonly _: "chatInviteLinks";

  /**
   * Approximate total number of chat invite links found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of invite links
   * @type {vector<chatInviteLink>} {@link vector<chatInviteLink>}
   */
  readonly invite_links?: vector$Input<chatInviteLink$Input>;
};

/**
 * Describes a chat administrator with a number of active and revoked chat invite links
 */
export type chatInviteLinkCount = {
  _: "chatInviteLinkCount";

  /**
   * Administrator's user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of active invite links
   * @type {int32} {@link int32}
   */
  invite_link_count: int32;

  /**
   * Number of revoked invite links
   * @type {int32} {@link int32}
   */
  revoked_invite_link_count: int32;
};

/**
 * Version of {@link chatInviteLinkCount} for method parameters.
 *
 * Describes a chat administrator with a number of active and revoked chat invite links
 */
export type chatInviteLinkCount$Input = {
  readonly _: "chatInviteLinkCount";

  /**
   * Administrator's user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of active invite links
   * @type {int32} {@link int32}
   */
  readonly invite_link_count?: int32;

  /**
   * Number of revoked invite links
   * @type {int32} {@link int32}
   */
  readonly revoked_invite_link_count?: int32;
};

/**
 * Contains a list of chat invite link counts
 */
export type chatInviteLinkCounts = {
  _: "chatInviteLinkCounts";

  /**
   * List of invite link counts
   * @type {vector<chatInviteLinkCount>} {@link vector<chatInviteLinkCount>}
   */
  invite_link_counts: vector<chatInviteLinkCount>;
};

/**
 * Version of {@link chatInviteLinkCounts} for method parameters.
 *
 * Contains a list of chat invite link counts
 */
export type chatInviteLinkCounts$Input = {
  readonly _: "chatInviteLinkCounts";

  /**
   * List of invite link counts
   * @type {vector<chatInviteLinkCount>} {@link vector<chatInviteLinkCount>}
   */
  readonly invite_link_counts?: vector$Input<chatInviteLinkCount$Input>;
};

/**
 * Describes a chat member joined a chat via an invite link
 */
export type chatInviteLinkMember = {
  _: "chatInviteLinkMember";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  joined_chat_date: int32;

  /**
   * True, if the user has joined the chat using an invite link for a chat folder
   * @type {Bool} {@link Bool}
   */
  via_chat_folder_invite_link: Bool;

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  approver_user_id: int53;
};

/**
 * Version of {@link chatInviteLinkMember} for method parameters.
 *
 * Describes a chat member joined a chat via an invite link
 */
export type chatInviteLinkMember$Input = {
  readonly _: "chatInviteLinkMember";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  readonly joined_chat_date?: int32;

  /**
   * True, if the user has joined the chat using an invite link for a chat folder
   * @type {Bool} {@link Bool}
   */
  readonly via_chat_folder_invite_link?: Bool$Input;

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  readonly approver_user_id?: int53;
};

/**
 * Contains a list of chat members joined a chat via an invite link
 */
export type chatInviteLinkMembers = {
  _: "chatInviteLinkMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of chat members, joined a chat via an invite link
   * @type {vector<chatInviteLinkMember>} {@link vector<chatInviteLinkMember>}
   */
  members: vector<chatInviteLinkMember>;
};

/**
 * Version of {@link chatInviteLinkMembers} for method parameters.
 *
 * Contains a list of chat members joined a chat via an invite link
 */
export type chatInviteLinkMembers$Input = {
  readonly _: "chatInviteLinkMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of chat members, joined a chat via an invite link
   * @type {vector<chatInviteLinkMember>} {@link vector<chatInviteLinkMember>}
   */
  readonly members?: vector$Input<chatInviteLinkMember$Input>;
};

/**
 * The link is an invite link for a basic group
 */
export type inviteLinkChatTypeBasicGroup = {
  _: "inviteLinkChatTypeBasicGroup";
};

/**
 * Version of {@link inviteLinkChatTypeBasicGroup} for method parameters.
 *
 * The link is an invite link for a basic group
 */
export type inviteLinkChatTypeBasicGroup$Input = {
  readonly _: "inviteLinkChatTypeBasicGroup";
};

/**
 * The link is an invite link for a supergroup
 */
export type inviteLinkChatTypeSupergroup = {
  _: "inviteLinkChatTypeSupergroup";
};

/**
 * Version of {@link inviteLinkChatTypeSupergroup} for method parameters.
 *
 * The link is an invite link for a supergroup
 */
export type inviteLinkChatTypeSupergroup$Input = {
  readonly _: "inviteLinkChatTypeSupergroup";
};

/**
 * The link is an invite link for a channel
 */
export type inviteLinkChatTypeChannel = {
  _: "inviteLinkChatTypeChannel";
};

/**
 * Version of {@link inviteLinkChatTypeChannel} for method parameters.
 *
 * The link is an invite link for a channel
 */
export type inviteLinkChatTypeChannel$Input = {
  readonly _: "inviteLinkChatTypeChannel";
};

/**
 * Contains information about a chat invite link
 */
export type chatInviteLinkInfo = {
  _: "chatInviteLinkInfo";

  /**
   * Chat identifier of the invite link; 0 if the user has no access to the chat before joining
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * If non-zero, the amount of time for which read access to the chat will remain available, in seconds
   * @type {int32} {@link int32}
   */
  accessible_for: int32;

  /**
   * Type of the chat
   * @type {InviteLinkChatType} {@link InviteLinkChatType}
   */
  type: InviteLinkChatType;

  /**
   * Title of the chat
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo | null;

  /**
   * Identifier of the accent color for chat title and background of chat photo
   * @type {int32} {@link int32}
   */
  accent_color_id: int32;

  /**
   * Contains information about a chat invite link
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Number of members in the chat
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * User identifiers of some chat members that may be known to the current user
   * @type {vector<int53>} {@link vector<int53>}
   */
  member_user_ids: vector<int53>;

  /**
   * True, if the link only creates join request
   * @type {Bool} {@link Bool}
   */
  creates_join_request: Bool;

  /**
   * True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;

  /**
   * True, if the chat is verified
   * @type {Bool} {@link Bool}
   */
  is_verified: Bool;

  /**
   * True, if many users reported this chat as a scam
   * @type {Bool} {@link Bool}
   */
  is_scam: Bool;

  /**
   * True, if many users reported this chat as a fake account
   * @type {Bool} {@link Bool}
   */
  is_fake: Bool;
};

/**
 * Version of {@link chatInviteLinkInfo} for method parameters.
 *
 * Contains information about a chat invite link
 */
export type chatInviteLinkInfo$Input = {
  readonly _: "chatInviteLinkInfo";

  /**
   * Chat identifier of the invite link; 0 if the user has no access to the chat before joining
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If non-zero, the amount of time for which read access to the chat will remain available, in seconds
   * @type {int32} {@link int32}
   */
  readonly accessible_for?: int32;

  /**
   * Type of the chat
   * @type {InviteLinkChatType} {@link InviteLinkChatType}
   */
  readonly type?: InviteLinkChatType$Input;

  /**
   * Title of the chat
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input | null;

  /**
   * Identifier of the accent color for chat title and background of chat photo
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Contains information about a chat invite link
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Number of members in the chat
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * User identifiers of some chat members that may be known to the current user
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly member_user_ids?: vector$Input<int53>;

  /**
   * True, if the link only creates join request
   * @type {Bool} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;

  /**
   * True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;

  /**
   * True, if the chat is verified
   * @type {Bool} {@link Bool}
   */
  readonly is_verified?: Bool$Input;

  /**
   * True, if many users reported this chat as a scam
   * @type {Bool} {@link Bool}
   */
  readonly is_scam?: Bool$Input;

  /**
   * True, if many users reported this chat as a fake account
   * @type {Bool} {@link Bool}
   */
  readonly is_fake?: Bool$Input;
};

/**
 * Describes a user that sent a join request and waits for administrator approval
 */
export type chatJoinRequest = {
  _: "chatJoinRequest";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user sent the join request
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * A short bio of the user
   * @type {string} {@link string}
   */
  bio: string;
};

/**
 * Version of {@link chatJoinRequest} for method parameters.
 *
 * Describes a user that sent a join request and waits for administrator approval
 */
export type chatJoinRequest$Input = {
  readonly _: "chatJoinRequest";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user sent the join request
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * A short bio of the user
   * @type {string} {@link string}
   */
  readonly bio?: string;
};

/**
 * Contains a list of requests to join a chat
 */
export type chatJoinRequests = {
  _: "chatJoinRequests";

  /**
   * Approximate total number of requests found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of the requests
   * @type {vector<chatJoinRequest>} {@link vector<chatJoinRequest>}
   */
  requests: vector<chatJoinRequest>;
};

/**
 * Version of {@link chatJoinRequests} for method parameters.
 *
 * Contains a list of requests to join a chat
 */
export type chatJoinRequests$Input = {
  readonly _: "chatJoinRequests";

  /**
   * Approximate total number of requests found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of the requests
   * @type {vector<chatJoinRequest>} {@link vector<chatJoinRequest>}
   */
  readonly requests?: vector$Input<chatJoinRequest$Input>;
};

/**
 * Contains information about pending join requests for a chat
 */
export type chatJoinRequestsInfo = {
  _: "chatJoinRequestsInfo";

  /**
   * Total number of pending join requests
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Identifiers of at most 3 users sent the newest pending join requests
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link chatJoinRequestsInfo} for method parameters.
 *
 * Contains information about pending join requests for a chat
 */
export type chatJoinRequestsInfo$Input = {
  readonly _: "chatJoinRequestsInfo";

  /**
   * Total number of pending join requests
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Identifiers of at most 3 users sent the newest pending join requests
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
 */
export type basicGroup = {
  _: "basicGroup";

  /**
   * Group identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Number of members in the group
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Status of the current user in the group
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;

  /**
   * True, if the group is active
   * @type {Bool} {@link Bool}
   */
  is_active: Bool;

  /**
   * Identifier of the supergroup to which this group was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  upgraded_to_supergroup_id: int53;
};

/**
 * Version of {@link basicGroup} for method parameters.
 *
 * Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
 */
export type basicGroup$Input = {
  readonly _: "basicGroup";

  /**
   * Group identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Number of members in the group
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Status of the current user in the group
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;

  /**
   * True, if the group is active
   * @type {Bool} {@link Bool}
   */
  readonly is_active?: Bool$Input;

  /**
   * Identifier of the supergroup to which this group was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  readonly upgraded_to_supergroup_id?: int53;
};

/**
 * Contains full information about a basic group
 */
export type basicGroupFullInfo = {
  _: "basicGroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto | null;

  /**
   * Contains full information about a basic group
   * @type {string} {@link string}
   */
  description: string;

  /**
   * User identifier of the creator of the group; 0 if unknown
   * @type {int53} {@link int53}
   */
  creator_user_id: int53;

  /**
   * Group members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  members: vector<chatMember>;

  /**
   * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
   * @type {Bool} {@link Bool}
   */
  can_hide_members: Bool;

  /**
   * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
   * @type {Bool} {@link Bool}
   */
  can_toggle_aggressive_anti_spam: Bool;

  /**
   * Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink | null;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  bot_commands: vector<botCommands>;
};

/**
 * Version of {@link basicGroupFullInfo} for method parameters.
 *
 * Contains full information about a basic group
 */
export type basicGroupFullInfo$Input = {
  readonly _: "basicGroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input | null;

  /**
   * Contains full information about a basic group
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * User identifier of the creator of the group; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Group members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  readonly members?: vector$Input<chatMember$Input>;

  /**
   * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators after upgrading the basic group to a supergroup
   * @type {Bool} {@link Bool}
   */
  readonly can_hide_members?: Bool$Input;

  /**
   * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup after upgrading the basic group to a supergroup
   * @type {Bool} {@link Bool}
   */
  readonly can_toggle_aggressive_anti_spam?: Bool$Input;

  /**
   * Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input | null;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  readonly bot_commands?: vector$Input<botCommands$Input>;
};

/**
 * Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup:
 *
 * - only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos.
 *
 * - Unlike supergroups, channels can have an unlimited number of subscribers
 */
export type supergroup = {
  _: "supergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Usernames of the supergroup or channel; may be null
   * @type {usernames} {@link usernames}
   */
  usernames: usernames | null;

  /**
   * Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Status of the current user in the supergroup or channel; custom title will always be empty
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;

  /**
   * Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through
   *
   * - getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants,
   *
   * - searchChatsNearby, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or for public chats in which where sent messages and posted stories from publicForwards,
   *
   * - or for public chats in which where sent messages from getMessagePublicForwards response
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Approximate boost level for the chat
   * @type {int32} {@link int32}
   */
  boost_level: int32;

  /**
   * True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
   * @type {Bool} {@link Bool}
   */
  has_linked_chat: Bool;

  /**
   * True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  has_location: Bool;

  /**
   * True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels
   * @type {Bool} {@link Bool}
   */
  sign_messages: Bool;

  /**
   * True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
   * @type {Bool} {@link Bool}
   */
  join_to_send_messages: Bool;

  /**
   * True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
   * @type {Bool} {@link Bool}
   */
  join_by_request: Bool;

  /**
   * True, if the slow mode is enabled in the supergroup
   * @type {Bool} {@link Bool}
   */
  is_slow_mode_enabled: Bool;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  is_channel: Bool;

  /**
   * True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
   * @type {Bool} {@link Bool}
   */
  is_broadcast_group: Bool;

  /**
   * True, if the supergroup is a forum with topics
   * @type {Bool} {@link Bool}
   */
  is_forum: Bool;

  /**
   * True, if the supergroup or channel is verified
   * @type {Bool} {@link Bool}
   */
  is_verified: Bool;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
   * @type {string} {@link string}
   */
  restriction_reason: string;

  /**
   * True, if many users reported this supergroup or channel as a scam
   * @type {Bool} {@link Bool}
   */
  is_scam: Bool;

  /**
   * True, if many users reported this supergroup or channel as a fake account
   * @type {Bool} {@link Bool}
   */
  is_fake: Bool;

  /**
   * True, if the channel has non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  has_active_stories: Bool;

  /**
   * True, if the channel has unread non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  has_unread_active_stories: Bool;
};

/**
 * Version of {@link supergroup} for method parameters.
 *
 * Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup:
 *
 * - only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos.
 *
 * - Unlike supergroups, channels can have an unlimited number of subscribers
 */
export type supergroup$Input = {
  readonly _: "supergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Usernames of the supergroup or channel; may be null
   * @type {usernames} {@link usernames}
   */
  readonly usernames?: usernames$Input | null;

  /**
   * Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Status of the current user in the supergroup or channel; custom title will always be empty
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;

  /**
   * Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through
   *
   * - getChatSimilarChats, getChatsToSendStories, getCreatedPublicChats, getGroupsInCommon, getInactiveSupergroupChats, getSuitableDiscussionChats, getUserPrivacySettingRules, getVideoChatAvailableParticipants,
   *
   * - searchChatsNearby, searchPublicChats, or in chatFolderInviteLinkInfo.missing_chat_ids, or for public chats in which where sent messages and posted stories from publicForwards,
   *
   * - or for public chats in which where sent messages from getMessagePublicForwards response
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Approximate boost level for the chat
   * @type {int32} {@link int32}
   */
  readonly boost_level?: int32;

  /**
   * True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
   * @type {Bool} {@link Bool}
   */
  readonly has_linked_chat?: Bool$Input;

  /**
   * True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  readonly has_location?: Bool$Input;

  /**
   * True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels
   * @type {Bool} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;

  /**
   * True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
   * @type {Bool} {@link Bool}
   */
  readonly join_to_send_messages?: Bool$Input;

  /**
   * True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
   * @type {Bool} {@link Bool}
   */
  readonly join_by_request?: Bool$Input;

  /**
   * True, if the slow mode is enabled in the supergroup
   * @type {Bool} {@link Bool}
   */
  readonly is_slow_mode_enabled?: Bool$Input;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
   * @type {Bool} {@link Bool}
   */
  readonly is_broadcast_group?: Bool$Input;

  /**
   * True, if the supergroup is a forum with topics
   * @type {Bool} {@link Bool}
   */
  readonly is_forum?: Bool$Input;

  /**
   * True, if the supergroup or channel is verified
   * @type {Bool} {@link Bool}
   */
  readonly is_verified?: Bool$Input;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
   * @type {string} {@link string}
   */
  readonly restriction_reason?: string;

  /**
   * True, if many users reported this supergroup or channel as a scam
   * @type {Bool} {@link Bool}
   */
  readonly is_scam?: Bool$Input;

  /**
   * True, if many users reported this supergroup or channel as a fake account
   * @type {Bool} {@link Bool}
   */
  readonly is_fake?: Bool$Input;

  /**
   * True, if the channel has non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  readonly has_active_stories?: Bool$Input;

  /**
   * True, if the channel has unread non-expired stories available to the current user
   * @type {Bool} {@link Bool}
   */
  readonly has_unread_active_stories?: Bool$Input;
};

/**
 * Contains full information about a supergroup or channel
 */
export type supergroupFullInfo = {
  _: "supergroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto | null;

  /**
   * Contains full information about a supergroup or channel
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Number of members in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Number of privileged users in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  administrator_count: int32;

  /**
   * Number of restricted users in the supergroup; 0 if unknown
   * @type {int32} {@link int32}
   */
  restricted_count: int32;

  /**
   * Number of users banned from chat; 0 if unknown
   * @type {int32} {@link int32}
   */
  banned_count: int32;

  /**
   * Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
   * @type {int53} {@link int53}
   */
  linked_chat_id: int53;

  /**
   * Delay between consecutive sent messages for non-administrator supergroup members, in seconds
   * @type {int32} {@link int32}
   */
  slow_mode_delay: int32;

  /**
   * Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
   * @type {double} {@link double}
   */
  slow_mode_delay_expires_in: double;

  /**
   * True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
   * @type {Bool} {@link Bool}
   */
  can_get_members: Bool;

  /**
   * True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
   * @type {Bool} {@link Bool}
   */
  has_hidden_members: Bool;

  /**
   * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
   * @type {Bool} {@link Bool}
   */
  can_hide_members: Bool;

  /**
   * True, if the supergroup sticker set can be changed
   * @type {Bool} {@link Bool}
   */
  can_set_sticker_set: Bool;

  /**
   * True, if the supergroup location can be changed
   * @type {Bool} {@link Bool}
   */
  can_set_location: Bool;

  /**
   * True, if the supergroup or channel statistics are available
   * @type {Bool} {@link Bool}
   */
  can_get_statistics: Bool;

  /**
   * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
   * @type {Bool} {@link Bool}
   */
  can_toggle_aggressive_anti_spam: Bool;

  /**
   * True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available,
   *
   * - so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
   * @type {Bool} {@link Bool}
   */
  is_all_history_available: Bool;

  /**
   * True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
   * @type {Bool} {@link Bool}
   */
  has_aggressive_anti_spam_enabled: Bool;

  /**
   * True, if the channel has pinned stories
   * @type {Bool} {@link Bool}
   */
  has_pinned_stories: Bool;

  /**
   * Identifier of the supergroup sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  sticker_set_id: int64;

  /**
   * Location to which the supergroup is connected; may be null if none
   * @type {chatLocation} {@link chatLocation}
   */
  location: chatLocation | null;

  /**
   * Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink | null;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  bot_commands: vector<botCommands>;

  /**
   * Identifier of the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  upgraded_from_basic_group_id: int53;

  /**
   * Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  upgraded_from_max_message_id: int53;
};

/**
 * Version of {@link supergroupFullInfo} for method parameters.
 *
 * Contains full information about a supergroup or channel
 */
export type supergroupFullInfo$Input = {
  readonly _: "supergroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input | null;

  /**
   * Contains full information about a supergroup or channel
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Number of members in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Number of privileged users in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly administrator_count?: int32;

  /**
   * Number of restricted users in the supergroup; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly restricted_count?: int32;

  /**
   * Number of users banned from chat; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly banned_count?: int32;

  /**
   * Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
   * @type {int53} {@link int53}
   */
  readonly linked_chat_id?: int53;

  /**
   * Delay between consecutive sent messages for non-administrator supergroup members, in seconds
   * @type {int32} {@link int32}
   */
  readonly slow_mode_delay?: int32;

  /**
   * Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
   * @type {double} {@link double}
   */
  readonly slow_mode_delay_expires_in?: double;

  /**
   * True, if members of the chat can be retrieved via getSupergroupMembers or searchChatMembers
   * @type {Bool} {@link Bool}
   */
  readonly can_get_members?: Bool$Input;

  /**
   * True, if non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers
   * @type {Bool} {@link Bool}
   */
  readonly has_hidden_members?: Bool$Input;

  /**
   * True, if non-administrators and non-bots can be hidden in responses to getSupergroupMembers and searchChatMembers for non-administrators
   * @type {Bool} {@link Bool}
   */
  readonly can_hide_members?: Bool$Input;

  /**
   * True, if the supergroup sticker set can be changed
   * @type {Bool} {@link Bool}
   */
  readonly can_set_sticker_set?: Bool$Input;

  /**
   * True, if the supergroup location can be changed
   * @type {Bool} {@link Bool}
   */
  readonly can_set_location?: Bool$Input;

  /**
   * True, if the supergroup or channel statistics are available
   * @type {Bool} {@link Bool}
   */
  readonly can_get_statistics?: Bool$Input;

  /**
   * True, if aggressive anti-spam checks can be enabled or disabled in the supergroup
   * @type {Bool} {@link Bool}
   */
  readonly can_toggle_aggressive_anti_spam?: Bool$Input;

  /**
   * True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available,
   *
   * - so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available to chat administrators
   * @type {Bool} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;

  /**
   * True, if aggressive anti-spam checks are enabled in the supergroup. The value of this field is only available to chat administrators
   * @type {Bool} {@link Bool}
   */
  readonly has_aggressive_anti_spam_enabled?: Bool$Input;

  /**
   * True, if the channel has pinned stories
   * @type {Bool} {@link Bool}
   */
  readonly has_pinned_stories?: Bool$Input;

  /**
   * Identifier of the supergroup sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly sticker_set_id?: int64$Input;

  /**
   * Location to which the supergroup is connected; may be null if none
   * @type {chatLocation} {@link chatLocation}
   */
  readonly location?: chatLocation$Input | null;

  /**
   * Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input | null;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  readonly bot_commands?: vector$Input<botCommands$Input>;

  /**
   * Identifier of the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  readonly upgraded_from_basic_group_id?: int53;

  /**
   * Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  readonly upgraded_from_max_message_id?: int53;
};

/**
 * The secret chat is not yet created; waiting for the other user to get online
 */
export type secretChatStatePending = {
  _: "secretChatStatePending";
};

/**
 * Version of {@link secretChatStatePending} for method parameters.
 *
 * The secret chat is not yet created; waiting for the other user to get online
 */
export type secretChatStatePending$Input = {
  readonly _: "secretChatStatePending";
};

/**
 * The secret chat is ready to use
 */
export type secretChatStateReady = {
  _: "secretChatStateReady";
};

/**
 * Version of {@link secretChatStateReady} for method parameters.
 *
 * The secret chat is ready to use
 */
export type secretChatStateReady$Input = {
  readonly _: "secretChatStateReady";
};

/**
 * The secret chat is closed
 */
export type secretChatStateClosed = {
  _: "secretChatStateClosed";
};

/**
 * Version of {@link secretChatStateClosed} for method parameters.
 *
 * The secret chat is closed
 */
export type secretChatStateClosed$Input = {
  readonly _: "secretChatStateClosed";
};

/**
 * Represents a secret chat
 */
export type secretChat = {
  _: "secretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Identifier of the chat partner
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * State of the secret chat
   * @type {SecretChatState} {@link SecretChatState}
   */
  state: SecretChatState;

  /**
   * True, if the chat was created by the current user; false otherwise
   * @type {Bool} {@link Bool}
   */
  is_outbound: Bool;

  /**
   * Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9.
   *
   * - The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
   * @type {bytes} {@link bytes}
   */
  key_hash: bytes;

  /**
   * Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101,
   *
   * - files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
   * @type {int32} {@link int32}
   */
  layer: int32;
};

/**
 * Version of {@link secretChat} for method parameters.
 *
 * Represents a secret chat
 */
export type secretChat$Input = {
  readonly _: "secretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Identifier of the chat partner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * State of the secret chat
   * @type {SecretChatState} {@link SecretChatState}
   */
  readonly state?: SecretChatState$Input;

  /**
   * True, if the chat was created by the current user; false otherwise
   * @type {Bool} {@link Bool}
   */
  readonly is_outbound?: Bool$Input;

  /**
   * Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9.
   *
   * - The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
   * @type {bytes} {@link bytes}
   */
  readonly key_hash?: bytes$Input;

  /**
   * Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101,
   *
   * - files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
   * @type {int32} {@link int32}
   */
  readonly layer?: int32;
};

/**
 * The message was sent by a known user
 */
export type messageSenderUser = {
  _: "messageSenderUser";

  /**
   * Identifier of the user that sent the message
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link messageSenderUser} for method parameters.
 *
 * The message was sent by a known user
 */
export type messageSenderUser$Input = {
  readonly _: "messageSenderUser";

  /**
   * Identifier of the user that sent the message
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * The message was sent on behalf of a chat
 */
export type messageSenderChat = {
  _: "messageSenderChat";

  /**
   * Identifier of the chat that sent the message
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

/**
 * Version of {@link messageSenderChat} for method parameters.
 *
 * The message was sent on behalf of a chat
 */
export type messageSenderChat$Input = {
  readonly _: "messageSenderChat";

  /**
   * Identifier of the chat that sent the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Represents a list of message senders
 */
export type messageSenders = {
  _: "messageSenders";

  /**
   * Approximate total number of messages senders found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of message senders
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  senders: vector<MessageSender>;
};

/**
 * Version of {@link messageSenders} for method parameters.
 *
 * Represents a list of message senders
 */
export type messageSenders$Input = {
  readonly _: "messageSenders";

  /**
   * Approximate total number of messages senders found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of message senders
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly senders?: vector$Input<MessageSender$Input>;
};

/**
 * Represents a message sender, which can be used to send messages in a chat
 */
export type chatMessageSender = {
  _: "chatMessageSender";

  /**
   * The message sender
   * @type {MessageSender} {@link MessageSender}
   */
  sender: MessageSender;

  /**
   * True, if Telegram Premium is needed to use the message sender
   * @type {Bool} {@link Bool}
   */
  needs_premium: Bool;
};

/**
 * Version of {@link chatMessageSender} for method parameters.
 *
 * Represents a message sender, which can be used to send messages in a chat
 */
export type chatMessageSender$Input = {
  readonly _: "chatMessageSender";

  /**
   * The message sender
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender?: MessageSender$Input;

  /**
   * True, if Telegram Premium is needed to use the message sender
   * @type {Bool} {@link Bool}
   */
  readonly needs_premium?: Bool$Input;
};

/**
 * Represents a list of message senders, which can be used to send messages in a chat
 */
export type chatMessageSenders = {
  _: "chatMessageSenders";

  /**
   * List of available message senders
   * @type {vector<chatMessageSender>} {@link vector<chatMessageSender>}
   */
  senders: vector<chatMessageSender>;
};

/**
 * Version of {@link chatMessageSenders} for method parameters.
 *
 * Represents a list of message senders, which can be used to send messages in a chat
 */
export type chatMessageSenders$Input = {
  readonly _: "chatMessageSenders";

  /**
   * List of available message senders
   * @type {vector<chatMessageSender>} {@link vector<chatMessageSender>}
   */
  readonly senders?: vector$Input<chatMessageSender$Input>;
};

/**
 * Represents a viewer of a message
 */
export type messageViewer = {
  _: "messageViewer";

  /**
   * User identifier of the viewer
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Approximate point in time (Unix timestamp) when the message was viewed
   * @type {int32} {@link int32}
   */
  view_date: int32;
};

/**
 * Version of {@link messageViewer} for method parameters.
 *
 * Represents a viewer of a message
 */
export type messageViewer$Input = {
  readonly _: "messageViewer";

  /**
   * User identifier of the viewer
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Approximate point in time (Unix timestamp) when the message was viewed
   * @type {int32} {@link int32}
   */
  readonly view_date?: int32;
};

/**
 * Represents a list of message viewers
 */
export type messageViewers = {
  _: "messageViewers";

  /**
   * List of message viewers
   * @type {vector<messageViewer>} {@link vector<messageViewer>}
   */
  viewers: vector<messageViewer>;
};

/**
 * Version of {@link messageViewers} for method parameters.
 *
 * Represents a list of message viewers
 */
export type messageViewers$Input = {
  readonly _: "messageViewers";

  /**
   * List of message viewers
   * @type {vector<messageViewer>} {@link vector<messageViewer>}
   */
  readonly viewers?: vector$Input<messageViewer$Input>;
};

/**
 * The message was originally sent by a known user
 */
export type messageOriginUser = {
  _: "messageOriginUser";

  /**
   * Identifier of the user that originally sent the message
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;
};

/**
 * Version of {@link messageOriginUser} for method parameters.
 *
 * The message was originally sent by a known user
 */
export type messageOriginUser$Input = {
  readonly _: "messageOriginUser";

  /**
   * Identifier of the user that originally sent the message
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;
};

/**
 * The message was originally sent by a user, which is hidden by their privacy settings
 */
export type messageOriginHiddenUser = {
  _: "messageOriginHiddenUser";

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  sender_name: string;
};

/**
 * Version of {@link messageOriginHiddenUser} for method parameters.
 *
 * The message was originally sent by a user, which is hidden by their privacy settings
 */
export type messageOriginHiddenUser$Input = {
  readonly _: "messageOriginHiddenUser";

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;
};

/**
 * The message was originally sent on behalf of a chat
 */
export type messageOriginChat = {
  _: "messageOriginChat";

  /**
   * Identifier of the chat that originally sent the message
   * @type {int53} {@link int53}
   */
  sender_chat_id: int53;

  /**
   * For messages originally sent by an anonymous chat administrator, original message author signature
   * @type {string} {@link string}
   */
  author_signature: string;
};

/**
 * Version of {@link messageOriginChat} for method parameters.
 *
 * The message was originally sent on behalf of a chat
 */
export type messageOriginChat$Input = {
  readonly _: "messageOriginChat";

  /**
   * Identifier of the chat that originally sent the message
   * @type {int53} {@link int53}
   */
  readonly sender_chat_id?: int53;

  /**
   * For messages originally sent by an anonymous chat administrator, original message author signature
   * @type {string} {@link string}
   */
  readonly author_signature?: string;
};

/**
 * The message was originally a post in a channel
 */
export type messageOriginChannel = {
  _: "messageOriginChannel";

  /**
   * Identifier of the channel chat to which the message was originally sent
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier of the original message
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Original post author signature
   * @type {string} {@link string}
   */
  author_signature: string;
};

/**
 * Version of {@link messageOriginChannel} for method parameters.
 *
 * The message was originally a post in a channel
 */
export type messageOriginChannel$Input = {
  readonly _: "messageOriginChannel";

  /**
   * Identifier of the channel chat to which the message was originally sent
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the original message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Original post author signature
   * @type {string} {@link string}
   */
  readonly author_signature?: string;
};

/**
 * A reaction with an emoji
 */
export type reactionTypeEmoji = {
  _: "reactionTypeEmoji";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  emoji: string;
};

/**
 * Version of {@link reactionTypeEmoji} for method parameters.
 *
 * A reaction with an emoji
 */
export type reactionTypeEmoji$Input = {
  readonly _: "reactionTypeEmoji";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * A reaction with a custom emoji
 */
export type reactionTypeCustomEmoji = {
  _: "reactionTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

/**
 * Version of {@link reactionTypeCustomEmoji} for method parameters.
 *
 * A reaction with a custom emoji
 */
export type reactionTypeCustomEmoji$Input = {
  readonly _: "reactionTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;
};

/**
 * Contains information about a forwarded message
 */
export type messageForwardInfo = {
  _: "messageForwardInfo";

  /**
   * Origin of the forwarded message
   * @type {MessageOrigin} {@link MessageOrigin}
   */
  origin: MessageOrigin;

  /**
   * Point in time (Unix timestamp) when the message was originally sent
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * The type of a public service announcement for the forwarded message
   * @type {string} {@link string}
   */
  public_service_announcement_type: string;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  from_chat_id: int53;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  from_message_id: int53;
};

/**
 * Version of {@link messageForwardInfo} for method parameters.
 *
 * Contains information about a forwarded message
 */
export type messageForwardInfo$Input = {
  readonly _: "messageForwardInfo";

  /**
   * Origin of the forwarded message
   * @type {MessageOrigin} {@link MessageOrigin}
   */
  readonly origin?: MessageOrigin$Input;

  /**
   * Point in time (Unix timestamp) when the message was originally sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * The type of a public service announcement for the forwarded message
   * @type {string} {@link string}
   */
  readonly public_service_announcement_type?: string;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;
};

/**
 * Contains information about a message created with importMessages
 */
export type messageImportInfo = {
  _: "messageImportInfo";

  /**
   * Name of the original sender
   * @type {string} {@link string}
   */
  sender_name: string;

  /**
   * Point in time (Unix timestamp) when the message was originally sent
   * @type {int32} {@link int32}
   */
  date: int32;
};

/**
 * Version of {@link messageImportInfo} for method parameters.
 *
 * Contains information about a message created with importMessages
 */
export type messageImportInfo$Input = {
  readonly _: "messageImportInfo";

  /**
   * Name of the original sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;

  /**
   * Point in time (Unix timestamp) when the message was originally sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * Contains information about replies to a message
 */
export type messageReplyInfo = {
  _: "messageReplyInfo";

  /**
   * Number of times the message was directly or indirectly replied
   * @type {int32} {@link int32}
   */
  reply_count: int32;

  /**
   * Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  recent_replier_ids: vector<MessageSender>;

  /**
   * Identifier of the last read incoming reply to the message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * Identifier of the last read outgoing reply to the message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;

  /**
   * Identifier of the last reply to the message
   * @type {int53} {@link int53}
   */
  last_message_id: int53;
};

/**
 * Version of {@link messageReplyInfo} for method parameters.
 *
 * Contains information about replies to a message
 */
export type messageReplyInfo$Input = {
  readonly _: "messageReplyInfo";

  /**
   * Number of times the message was directly or indirectly replied
   * @type {int32} {@link int32}
   */
  readonly reply_count?: int32;

  /**
   * Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly recent_replier_ids?: vector$Input<MessageSender$Input>;

  /**
   * Identifier of the last read incoming reply to the message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * Identifier of the last read outgoing reply to the message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;

  /**
   * Identifier of the last reply to the message
   * @type {int53} {@link int53}
   */
  readonly last_message_id?: int53;
};

/**
 * Contains information about a reaction to a message
 */
export type messageReaction = {
  _: "messageReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * Number of times the reaction was added
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * True, if the reaction is chosen by the current user
   * @type {Bool} {@link Bool}
   */
  is_chosen: Bool;

  /**
   * Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen
   * @type {MessageSender} {@link MessageSender}
   */
  used_sender_id: MessageSender | null;

  /**
   * Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  recent_sender_ids: vector<MessageSender>;
};

/**
 * Version of {@link messageReaction} for method parameters.
 *
 * Contains information about a reaction to a message
 */
export type messageReaction$Input = {
  readonly _: "messageReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * Number of times the reaction was added
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * True, if the reaction is chosen by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_chosen?: Bool$Input;

  /**
   * Identifier of the message sender used by the current user to add the reaction; may be null if unknown or the reaction isn't chosen
   * @type {MessageSender} {@link MessageSender}
   */
  readonly used_sender_id?: MessageSender$Input | null;

  /**
   * Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly recent_sender_ids?: vector$Input<MessageSender$Input>;
};

/**
 * Contains information about interactions with a message
 */
export type messageInteractionInfo = {
  _: "messageInteractionInfo";

  /**
   * Number of times the message was viewed
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Number of times the message was forwarded
   * @type {int32} {@link int32}
   */
  forward_count: int32;

  /**
   * Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  reply_info: messageReplyInfo | null;

  /**
   * The list of reactions added to the message
   * @type {vector<messageReaction>} {@link vector<messageReaction>}
   */
  reactions: vector<messageReaction>;
};

/**
 * Version of {@link messageInteractionInfo} for method parameters.
 *
 * Contains information about interactions with a message
 */
export type messageInteractionInfo$Input = {
  readonly _: "messageInteractionInfo";

  /**
   * Number of times the message was viewed
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Number of times the message was forwarded
   * @type {int32} {@link int32}
   */
  readonly forward_count?: int32;

  /**
   * Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  readonly reply_info?: messageReplyInfo$Input | null;

  /**
   * The list of reactions added to the message
   * @type {vector<messageReaction>} {@link vector<messageReaction>}
   */
  readonly reactions?: vector$Input<messageReaction$Input>;
};

/**
 * Contains information about an unread reaction to a message
 */
export type unreadReaction = {
  _: "unreadReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * Identifier of the sender, added the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * True, if the reaction was added with a big animation
   * @type {Bool} {@link Bool}
   */
  is_big: Bool;
};

/**
 * Version of {@link unreadReaction} for method parameters.
 *
 * Contains information about an unread reaction to a message
 */
export type unreadReaction$Input = {
  readonly _: "unreadReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * Identifier of the sender, added the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * True, if the reaction was added with a big animation
   * @type {Bool} {@link Bool}
   */
  readonly is_big?: Bool$Input;
};

/**
 * The message is being sent now, but has not yet been delivered to the server
 */
export type messageSendingStatePending = {
  _: "messageSendingStatePending";

  /**
   * Non-persistent message sending identifier, specified by the application
   * @type {int32} {@link int32}
   */
  sending_id: int32;
};

/**
 * Version of {@link messageSendingStatePending} for method parameters.
 *
 * The message is being sent now, but has not yet been delivered to the server
 */
export type messageSendingStatePending$Input = {
  readonly _: "messageSendingStatePending";

  /**
   * Non-persistent message sending identifier, specified by the application
   * @type {int32} {@link int32}
   */
  readonly sending_id?: int32;
};

/**
 * The message failed to be sent
 */
export type messageSendingStateFailed = {
  _: "messageSendingStateFailed";

  /**
   * The cause of the message sending failure
   * @type {error} {@link error}
   */
  error: error;

  /**
   * True, if the message can be re-sent
   * @type {Bool} {@link Bool}
   */
  can_retry: Bool;

  /**
   * True, if the message can be re-sent only on behalf of a different sender
   * @type {Bool} {@link Bool}
   */
  need_another_sender: Bool;

  /**
   * True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
   * @type {Bool} {@link Bool}
   */
  need_another_reply_quote: Bool;

  /**
   * True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
   * @type {Bool} {@link Bool}
   */
  need_drop_reply: Bool;

  /**
   * Time left before the message can be re-sent, in seconds. No update is sent when this field changes
   * @type {double} {@link double}
   */
  retry_after: double;
};

/**
 * Version of {@link messageSendingStateFailed} for method parameters.
 *
 * The message failed to be sent
 */
export type messageSendingStateFailed$Input = {
  readonly _: "messageSendingStateFailed";

  /**
   * The cause of the message sending failure
   * @type {error} {@link error}
   */
  readonly error?: error$Input;

  /**
   * True, if the message can be re-sent
   * @type {Bool} {@link Bool}
   */
  readonly can_retry?: Bool$Input;

  /**
   * True, if the message can be re-sent only on behalf of a different sender
   * @type {Bool} {@link Bool}
   */
  readonly need_another_sender?: Bool$Input;

  /**
   * True, if the message can be re-sent only if another quote is chosen in the message that is replied by the given message
   * @type {Bool} {@link Bool}
   */
  readonly need_another_reply_quote?: Bool$Input;

  /**
   * True, if the message can be re-sent only if the message to be replied is removed. This will be done automatically by resendMessages
   * @type {Bool} {@link Bool}
   */
  readonly need_drop_reply?: Bool$Input;

  /**
   * Time left before the message can be re-sent, in seconds. No update is sent when this field changes
   * @type {double} {@link double}
   */
  readonly retry_after?: double;
};

/**
 * Describes manually or automatically chosen quote from another message
 */
export type textQuote = {
  _: "textQuote";

  /**
   * Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * Approximate quote position in the original message in UTF-16 code units as specified by the message sender
   * @type {int32} {@link int32}
   */
  position: int32;

  /**
   * True, if the quote was manually chosen by the message sender
   * @type {Bool} {@link Bool}
   */
  is_manual: Bool;
};

/**
 * Version of {@link textQuote} for method parameters.
 *
 * Describes manually or automatically chosen quote from another message
 */
export type textQuote$Input = {
  readonly _: "textQuote";

  /**
   * Text of the quote. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities can be present in the text
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Approximate quote position in the original message in UTF-16 code units as specified by the message sender
   * @type {int32} {@link int32}
   */
  readonly position?: int32;

  /**
   * True, if the quote was manually chosen by the message sender
   * @type {Bool} {@link Bool}
   */
  readonly is_manual?: Bool$Input;
};

/**
 * Describes manually chosen quote from another message
 */
export type inputTextQuote = {
  _: "inputTextQuote";

  /**
   * Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * Quote position in the original message in UTF-16 code units
   * @type {int32} {@link int32}
   */
  position: int32;
};

/**
 * Version of {@link inputTextQuote} for method parameters.
 *
 * Describes manually chosen quote from another message
 */
export type inputTextQuote$Input = {
  readonly _: "inputTextQuote";

  /**
   * Text of the quote; 0-getOption("message_reply_quote_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, and CustomEmoji entities are allowed to be kept and must be kept in the quote
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Quote position in the original message in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly position?: int32;
};

/**
 * Describes a message replied by a given message
 */
export type messageReplyToMessage = {
  _: "messageReplyToMessage";

  /**
   * The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The identifier of the message; may be 0 if the replied message is in unknown chat
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Chosen quote from the replied message; may be null if none
   * @type {textQuote} {@link textQuote}
   */
  quote: textQuote | null;

  /**
   * Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat
   * @type {MessageOrigin} {@link MessageOrigin}
   */
  origin: MessageOrigin | null;

  /**
   * Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat
   * @type {int32} {@link int32}
   */
  origin_send_date: int32;

  /**
   * Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media.
   *
   * - Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageInvoice, messageLocation,
   *
   * - messagePhoto, messagePoll, messagePremiumGiveaway, messagePremiumGiveawayWinners, messageSticker, messageStory, messageText (for link preview), messageVenue,
   *
   * - messageVideo, messageVideoNote, or messageVoiceNote
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent | null;
};

/**
 * Version of {@link messageReplyToMessage} for method parameters.
 *
 * Describes a message replied by a given message
 */
export type messageReplyToMessage$Input = {
  readonly _: "messageReplyToMessage";

  /**
   * The identifier of the chat to which the message belongs; may be 0 if the replied message is in unknown chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The identifier of the message; may be 0 if the replied message is in unknown chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Chosen quote from the replied message; may be null if none
   * @type {textQuote} {@link textQuote}
   */
  readonly quote?: textQuote$Input | null;

  /**
   * Information about origin of the message if the message was from another chat or topic; may be null for messages from the same chat
   * @type {MessageOrigin} {@link MessageOrigin}
   */
  readonly origin?: MessageOrigin$Input | null;

  /**
   * Point in time (Unix timestamp) when the message was sent if the message was from another chat or topic; 0 for messages from the same chat
   * @type {int32} {@link int32}
   */
  readonly origin_send_date?: int32;

  /**
   * Media content of the message if the message was from another chat or topic; may be null for messages from the same chat and messages without media.
   *
   * - Can be only one of the following types: messageAnimation, messageAudio, messageContact, messageDice, messageDocument, messageGame, messageInvoice, messageLocation,
   *
   * - messagePhoto, messagePoll, messagePremiumGiveaway, messagePremiumGiveawayWinners, messageSticker, messageStory, messageText (for link preview), messageVenue,
   *
   * - messageVideo, messageVideoNote, or messageVoiceNote
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input | null;
};

/**
 * Describes a story replied by a given message
 */
export type messageReplyToStory = {
  _: "messageReplyToStory";

  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  story_sender_chat_id: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link messageReplyToStory} for method parameters.
 *
 * Describes a story replied by a given message
 */
export type messageReplyToStory$Input = {
  readonly _: "messageReplyToStory";

  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Describes a message to be replied
 */
export type inputMessageReplyToMessage = {
  _: "inputMessageReplyToMessage";

  /**
   * The identifier of the chat to which the message to be replied belongs; pass 0 if the message to be replied is in the same chat. Must always be 0 for replies in secret chats. A message can be replied in another chat or topic only if message.can_be_replied_in_another_chat
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The identifier of the message to be replied in the same or the specified chat
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats
   * @type {inputTextQuote} {@link inputTextQuote}
   */
  quote: inputTextQuote | null;
};

/**
 * Version of {@link inputMessageReplyToMessage} for method parameters.
 *
 * Describes a message to be replied
 */
export type inputMessageReplyToMessage$Input = {
  readonly _: "inputMessageReplyToMessage";

  /**
   * The identifier of the chat to which the message to be replied belongs; pass 0 if the message to be replied is in the same chat. Must always be 0 for replies in secret chats. A message can be replied in another chat or topic only if message.can_be_replied_in_another_chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The identifier of the message to be replied in the same or the specified chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Quote from the message to be replied; pass null if none. Must always be null for replies in secret chats
   * @type {inputTextQuote} {@link inputTextQuote}
   */
  readonly quote?: inputTextQuote$Input | null;
};

/**
 * Describes a story to be replied
 */
export type inputMessageReplyToStory = {
  _: "inputMessageReplyToStory";

  /**
   * The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat
   * @type {int53} {@link int53}
   */
  story_sender_chat_id: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link inputMessageReplyToStory} for method parameters.
 *
 * Describes a story to be replied
 */
export type inputMessageReplyToStory$Input = {
  readonly _: "inputMessageReplyToStory";

  /**
   * The identifier of the sender of the story. Currently, stories can be replied only in the sender's chat
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Describes a message
 */
export type message = {
  _: "message";

  /**
   * Message identifier; unique for the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
   * @type {MessageSendingState} {@link MessageSendingState}
   */
  sending_state: MessageSendingState | null;

  /**
   * The scheduling state of the message; may be null if the message isn't scheduled
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  scheduling_state: MessageSchedulingState | null;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
   * @type {Bool} {@link Bool}
   */
  can_be_edited: Bool;

  /**
   * True, if the message can be forwarded
   * @type {Bool} {@link Bool}
   */
  can_be_forwarded: Bool;

  /**
   * True, if the message can be replied in another chat or topic
   * @type {Bool} {@link Bool}
   */
  can_be_replied_in_another_chat: Bool;

  /**
   * True, if content of the message can be saved locally or copied
   * @type {Bool} {@link Bool}
   */
  can_be_saved: Bool;

  /**
   * True, if the message can be deleted only for the current user while other users will continue to see it
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_only_for_self: Bool;

  /**
   * True, if the message can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_for_all_users: Bool;

  /**
   * True, if the list of added reactions is available through getMessageAddedReactions
   * @type {Bool} {@link Bool}
   */
  can_get_added_reactions: Bool;

  /**
   * True, if the message statistics are available through getMessageStatistics
   * @type {Bool} {@link Bool}
   */
  can_get_statistics: Bool;

  /**
   * True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
   * @type {Bool} {@link Bool}
   */
  can_get_message_thread: Bool;

  /**
   * True, if chat members already viewed the message can be received through getMessageViewers
   * @type {Bool} {@link Bool}
   */
  can_get_viewers: Bool;

  /**
   * True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink
   * @type {Bool} {@link Bool}
   */
  can_get_media_timestamp_links: Bool;

  /**
   * True, if reactions on the message can be reported through reportMessageReactions
   * @type {Bool} {@link Bool}
   */
  can_report_reactions: Bool;

  /**
   * True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
   * @type {Bool} {@link Bool}
   */
  has_timestamped_media: Bool;

  /**
   * True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
   * @type {Bool} {@link Bool}
   */
  is_channel_post: Bool;

  /**
   * True, if the message is a forum topic message
   * @type {Bool} {@link Bool}
   */
  is_topic_message: Bool;

  /**
   * True, if the message contains an unread mention for the current user
   * @type {Bool} {@link Bool}
   */
  contains_unread_mention: Bool;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Point in time (Unix timestamp) when the message was last edited
   * @type {int32} {@link int32}
   */
  edit_date: int32;

  /**
   * Information about the initial message sender; may be null if none or unknown
   * @type {messageForwardInfo} {@link messageForwardInfo}
   */
  forward_info: messageForwardInfo | null;

  /**
   * Information about the initial message for messages created with importMessages; may be null if the message isn't imported
   * @type {messageImportInfo} {@link messageImportInfo}
   */
  import_info: messageImportInfo | null;

  /**
   * Information about interactions with the message; may be null if none
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  interaction_info: messageInteractionInfo | null;

  /**
   * Information about unread reactions added to the message
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  unread_reactions: vector<unreadReaction>;

  /**
   * Information about the message or the story this message is replying to; may be null if none
   * @type {MessageReplyTo} {@link MessageReplyTo}
   */
  reply_to: MessageReplyTo | null;

  /**
   * If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * The message's self-destruct type; may be null if none
   * @type {MessageSelfDestructType} {@link MessageSelfDestructType}
   */
  self_destruct_type: MessageSelfDestructType | null;

  /**
   * Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
   * @type {double} {@link double}
   */
  self_destruct_in: double;

  /**
   * Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
   * @type {double} {@link double}
   */
  auto_delete_in: double;

  /**
   * If non-zero, the user identifier of the bot through which this message was sent
   * @type {int53} {@link int53}
   */
  via_bot_user_id: int53;

  /**
   * For channel posts and anonymous group messages, optional author signature
   * @type {string} {@link string}
   */
  author_signature: string;

  /**
   * Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
   * @type {int64} {@link int64}
   */
  media_album_id: int64;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this message must be restricted
   * @type {string} {@link string}
   */
  restriction_reason: string;

  /**
   * Content of the message
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent;

  /**
   * Reply markup for the message; may be null if none
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;
};

/**
 * Version of {@link message} for method parameters.
 *
 * Describes a message
 */
export type message$Input = {
  readonly _: "message";

  /**
   * Message identifier; unique for the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The sending state of the message; may be null if the message isn't being sent and didn't fail to be sent
   * @type {MessageSendingState} {@link MessageSendingState}
   */
  readonly sending_state?: MessageSendingState$Input | null;

  /**
   * The scheduling state of the message; may be null if the message isn't scheduled
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input | null;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
   * @type {Bool} {@link Bool}
   */
  readonly can_be_edited?: Bool$Input;

  /**
   * True, if the message can be forwarded
   * @type {Bool} {@link Bool}
   */
  readonly can_be_forwarded?: Bool$Input;

  /**
   * True, if the message can be replied in another chat or topic
   * @type {Bool} {@link Bool}
   */
  readonly can_be_replied_in_another_chat?: Bool$Input;

  /**
   * True, if content of the message can be saved locally or copied
   * @type {Bool} {@link Bool}
   */
  readonly can_be_saved?: Bool$Input;

  /**
   * True, if the message can be deleted only for the current user while other users will continue to see it
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_only_for_self?: Bool$Input;

  /**
   * True, if the message can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_for_all_users?: Bool$Input;

  /**
   * True, if the list of added reactions is available through getMessageAddedReactions
   * @type {Bool} {@link Bool}
   */
  readonly can_get_added_reactions?: Bool$Input;

  /**
   * True, if the message statistics are available through getMessageStatistics
   * @type {Bool} {@link Bool}
   */
  readonly can_get_statistics?: Bool$Input;

  /**
   * True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
   * @type {Bool} {@link Bool}
   */
  readonly can_get_message_thread?: Bool$Input;

  /**
   * True, if chat members already viewed the message can be received through getMessageViewers
   * @type {Bool} {@link Bool}
   */
  readonly can_get_viewers?: Bool$Input;

  /**
   * True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink
   * @type {Bool} {@link Bool}
   */
  readonly can_get_media_timestamp_links?: Bool$Input;

  /**
   * True, if reactions on the message can be reported through reportMessageReactions
   * @type {Bool} {@link Bool}
   */
  readonly can_report_reactions?: Bool$Input;

  /**
   * True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
   * @type {Bool} {@link Bool}
   */
  readonly has_timestamped_media?: Bool$Input;

  /**
   * True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
   * @type {Bool} {@link Bool}
   */
  readonly is_channel_post?: Bool$Input;

  /**
   * True, if the message is a forum topic message
   * @type {Bool} {@link Bool}
   */
  readonly is_topic_message?: Bool$Input;

  /**
   * True, if the message contains an unread mention for the current user
   * @type {Bool} {@link Bool}
   */
  readonly contains_unread_mention?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Point in time (Unix timestamp) when the message was last edited
   * @type {int32} {@link int32}
   */
  readonly edit_date?: int32;

  /**
   * Information about the initial message sender; may be null if none or unknown
   * @type {messageForwardInfo} {@link messageForwardInfo}
   */
  readonly forward_info?: messageForwardInfo$Input | null;

  /**
   * Information about the initial message for messages created with importMessages; may be null if the message isn't imported
   * @type {messageImportInfo} {@link messageImportInfo}
   */
  readonly import_info?: messageImportInfo$Input | null;

  /**
   * Information about interactions with the message; may be null if none
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  readonly interaction_info?: messageInteractionInfo$Input | null;

  /**
   * Information about unread reactions added to the message
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  readonly unread_reactions?: vector$Input<unreadReaction$Input>;

  /**
   * Information about the message or the story this message is replying to; may be null if none
   * @type {MessageReplyTo} {@link MessageReplyTo}
   */
  readonly reply_to?: MessageReplyTo$Input | null;

  /**
   * If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * The message's self-destruct type; may be null if none
   * @type {MessageSelfDestructType} {@link MessageSelfDestructType}
   */
  readonly self_destruct_type?: MessageSelfDestructType$Input | null;

  /**
   * Time left before the message self-destruct timer expires, in seconds; 0 if self-destruction isn't scheduled yet
   * @type {double} {@link double}
   */
  readonly self_destruct_in?: double;

  /**
   * Time left before the message will be automatically deleted by message_auto_delete_time setting of the chat, in seconds; 0 if never
   * @type {double} {@link double}
   */
  readonly auto_delete_in?: double;

  /**
   * If non-zero, the user identifier of the bot through which this message was sent
   * @type {int53} {@link int53}
   */
  readonly via_bot_user_id?: int53;

  /**
   * For channel posts and anonymous group messages, optional author signature
   * @type {string} {@link string}
   */
  readonly author_signature?: string;

  /**
   * Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
   * @type {int64} {@link int64}
   */
  readonly media_album_id?: int64$Input;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this message must be restricted
   * @type {string} {@link string}
   */
  readonly restriction_reason?: string;

  /**
   * Content of the message
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input;

  /**
   * Reply markup for the message; may be null if none
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Contains a list of messages
 */
export type messages = {
  _: "messages";

  /**
   * Approximate total number of messages found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of messages; messages may be null
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message> | null;
};

/**
 * Version of {@link messages} for method parameters.
 *
 * Contains a list of messages
 */
export type messages$Input = {
  readonly _: "messages";

  /**
   * Approximate total number of messages found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of messages; messages may be null
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input> | null;
};

/**
 * Contains a list of messages found by a search
 */
export type foundMessages = {
  _: "foundMessages";

  /**
   * Approximate total number of messages found; -1 if unknown
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of messages
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link foundMessages} for method parameters.
 *
 * Contains a list of messages found by a search
 */
export type foundMessages$Input = {
  readonly _: "foundMessages";

  /**
   * Approximate total number of messages found; -1 if unknown
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of messages
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Contains a list of messages found by a search in a given chat
 */
export type foundChatMessages = {
  _: "foundChatMessages";

  /**
   * Approximate total number of messages found; -1 if unknown
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of messages
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message>;

  /**
   * The offset for the next request. If 0, there are no more results
   * @type {int53} {@link int53}
   */
  next_from_message_id: int53;
};

/**
 * Version of {@link foundChatMessages} for method parameters.
 *
 * Contains a list of messages found by a search in a given chat
 */
export type foundChatMessages$Input = {
  readonly _: "foundChatMessages";

  /**
   * Approximate total number of messages found; -1 if unknown
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of messages
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input>;

  /**
   * The offset for the next request. If 0, there are no more results
   * @type {int53} {@link int53}
   */
  readonly next_from_message_id?: int53;
};

/**
 * Contains information about a message in a specific position
 */
export type messagePosition = {
  _: "messagePosition";

  /**
   * 0-based message position in the full list of suitable messages
   * @type {int32} {@link int32}
   */
  position: int32;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  date: int32;
};

/**
 * Version of {@link messagePosition} for method parameters.
 *
 * Contains information about a message in a specific position
 */
export type messagePosition$Input = {
  readonly _: "messagePosition";

  /**
   * 0-based message position in the full list of suitable messages
   * @type {int32} {@link int32}
   */
  readonly position?: int32;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * Contains a list of message positions
 */
export type messagePositions = {
  _: "messagePositions";

  /**
   * Total number of messages found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of message positions
   * @type {vector<messagePosition>} {@link vector<messagePosition>}
   */
  positions: vector<messagePosition>;
};

/**
 * Version of {@link messagePositions} for method parameters.
 *
 * Contains a list of message positions
 */
export type messagePositions$Input = {
  readonly _: "messagePositions";

  /**
   * Total number of messages found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of message positions
   * @type {vector<messagePosition>} {@link vector<messagePosition>}
   */
  readonly positions?: vector$Input<messagePosition$Input>;
};

/**
 * Contains information about found messages sent on a specific day
 */
export type messageCalendarDay = {
  _: "messageCalendarDay";

  /**
   * Total number of found messages sent on the day
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * First message sent on the day
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link messageCalendarDay} for method parameters.
 *
 * Contains information about found messages sent on a specific day
 */
export type messageCalendarDay$Input = {
  readonly _: "messageCalendarDay";

  /**
   * Total number of found messages sent on the day
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * First message sent on the day
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * Contains information about found messages, split by days according to the option "utc_time_offset"
 */
export type messageCalendar = {
  _: "messageCalendar";

  /**
   * Total number of found messages
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Information about messages sent
   * @type {vector<messageCalendarDay>} {@link vector<messageCalendarDay>}
   */
  days: vector<messageCalendarDay>;
};

/**
 * Version of {@link messageCalendar} for method parameters.
 *
 * Contains information about found messages, split by days according to the option "utc_time_offset"
 */
export type messageCalendar$Input = {
  readonly _: "messageCalendar";

  /**
   * Total number of found messages
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Information about messages sent
   * @type {vector<messageCalendarDay>} {@link vector<messageCalendarDay>}
   */
  readonly days?: vector$Input<messageCalendarDay$Input>;
};

/**
 * The message is from a chat history
 */
export type messageSourceChatHistory = {
  _: "messageSourceChatHistory";
};

/**
 * Version of {@link messageSourceChatHistory} for method parameters.
 *
 * The message is from a chat history
 */
export type messageSourceChatHistory$Input = {
  readonly _: "messageSourceChatHistory";
};

/**
 * The message is from a message thread history
 */
export type messageSourceMessageThreadHistory = {
  _: "messageSourceMessageThreadHistory";
};

/**
 * Version of {@link messageSourceMessageThreadHistory} for method parameters.
 *
 * The message is from a message thread history
 */
export type messageSourceMessageThreadHistory$Input = {
  readonly _: "messageSourceMessageThreadHistory";
};

/**
 * The message is from a forum topic history
 */
export type messageSourceForumTopicHistory = {
  _: "messageSourceForumTopicHistory";
};

/**
 * Version of {@link messageSourceForumTopicHistory} for method parameters.
 *
 * The message is from a forum topic history
 */
export type messageSourceForumTopicHistory$Input = {
  readonly _: "messageSourceForumTopicHistory";
};

/**
 * The message is from chat, message thread or forum topic history preview
 */
export type messageSourceHistoryPreview = {
  _: "messageSourceHistoryPreview";
};

/**
 * Version of {@link messageSourceHistoryPreview} for method parameters.
 *
 * The message is from chat, message thread or forum topic history preview
 */
export type messageSourceHistoryPreview$Input = {
  readonly _: "messageSourceHistoryPreview";
};

/**
 * The message is from a chat list or a forum topic list
 */
export type messageSourceChatList = {
  _: "messageSourceChatList";
};

/**
 * Version of {@link messageSourceChatList} for method parameters.
 *
 * The message is from a chat list or a forum topic list
 */
export type messageSourceChatList$Input = {
  readonly _: "messageSourceChatList";
};

/**
 * The message is from search results, including file downloads, local file list, outgoing document messages, calendar
 */
export type messageSourceSearch = {
  _: "messageSourceSearch";
};

/**
 * Version of {@link messageSourceSearch} for method parameters.
 *
 * The message is from search results, including file downloads, local file list, outgoing document messages, calendar
 */
export type messageSourceSearch$Input = {
  readonly _: "messageSourceSearch";
};

/**
 * The message is from a chat event log
 */
export type messageSourceChatEventLog = {
  _: "messageSourceChatEventLog";
};

/**
 * Version of {@link messageSourceChatEventLog} for method parameters.
 *
 * The message is from a chat event log
 */
export type messageSourceChatEventLog$Input = {
  readonly _: "messageSourceChatEventLog";
};

/**
 * The message is from a notification
 */
export type messageSourceNotification = {
  _: "messageSourceNotification";
};

/**
 * Version of {@link messageSourceNotification} for method parameters.
 *
 * The message is from a notification
 */
export type messageSourceNotification$Input = {
  readonly _: "messageSourceNotification";
};

/**
 * The message was screenshotted; the source must be used only if the message content was visible during the screenshot
 */
export type messageSourceScreenshot = {
  _: "messageSourceScreenshot";
};

/**
 * Version of {@link messageSourceScreenshot} for method parameters.
 *
 * The message was screenshotted; the source must be used only if the message content was visible during the screenshot
 */
export type messageSourceScreenshot$Input = {
  readonly _: "messageSourceScreenshot";
};

/**
 * The message is from some other source
 */
export type messageSourceOther = {
  _: "messageSourceOther";
};

/**
 * Version of {@link messageSourceOther} for method parameters.
 *
 * The message is from some other source
 */
export type messageSourceOther$Input = {
  readonly _: "messageSourceOther";
};

/**
 * The sponsor is a bot
 */
export type messageSponsorTypeBot = {
  _: "messageSponsorTypeBot";

  /**
   * User identifier of the bot
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * An internal link to be opened when the sponsored message is clicked
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  link: InternalLinkType;
};

/**
 * Version of {@link messageSponsorTypeBot} for method parameters.
 *
 * The sponsor is a bot
 */
export type messageSponsorTypeBot$Input = {
  readonly _: "messageSponsorTypeBot";

  /**
   * User identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * An internal link to be opened when the sponsored message is clicked
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly link?: InternalLinkType$Input;
};

/**
 * The sponsor is a web app
 */
export type messageSponsorTypeWebApp = {
  _: "messageSponsorTypeWebApp";

  /**
   * Web App title
   * @type {string} {@link string}
   */
  web_app_title: string;

  /**
   * An internal link to be opened when the sponsored message is clicked
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  link: InternalLinkType;
};

/**
 * Version of {@link messageSponsorTypeWebApp} for method parameters.
 *
 * The sponsor is a web app
 */
export type messageSponsorTypeWebApp$Input = {
  readonly _: "messageSponsorTypeWebApp";

  /**
   * Web App title
   * @type {string} {@link string}
   */
  readonly web_app_title?: string;

  /**
   * An internal link to be opened when the sponsored message is clicked
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly link?: InternalLinkType$Input;
};

/**
 * The sponsor is a public channel chat
 */
export type messageSponsorTypePublicChannel = {
  _: "messageSponsorTypePublicChannel";

  /**
   * Sponsor chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * An internal link to be opened when the sponsored message is clicked; may be null if the sponsor chat needs to be opened instead
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  link: InternalLinkType | null;
};

/**
 * Version of {@link messageSponsorTypePublicChannel} for method parameters.
 *
 * The sponsor is a public channel chat
 */
export type messageSponsorTypePublicChannel$Input = {
  readonly _: "messageSponsorTypePublicChannel";

  /**
   * Sponsor chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * An internal link to be opened when the sponsored message is clicked; may be null if the sponsor chat needs to be opened instead
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly link?: InternalLinkType$Input | null;
};

/**
 * The sponsor is a private channel chat
 */
export type messageSponsorTypePrivateChannel = {
  _: "messageSponsorTypePrivateChannel";

  /**
   * Title of the chat
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Invite link for the channel
   * @type {string} {@link string}
   */
  invite_link: string;
};

/**
 * Version of {@link messageSponsorTypePrivateChannel} for method parameters.
 *
 * The sponsor is a private channel chat
 */
export type messageSponsorTypePrivateChannel$Input = {
  readonly _: "messageSponsorTypePrivateChannel";

  /**
   * Title of the chat
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Invite link for the channel
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * The sponsor is a website
 */
export type messageSponsorTypeWebsite = {
  _: "messageSponsorTypeWebsite";

  /**
   * URL of the website
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Name of the website
   * @type {string} {@link string}
   */
  name: string;
};

/**
 * Version of {@link messageSponsorTypeWebsite} for method parameters.
 *
 * The sponsor is a website
 */
export type messageSponsorTypeWebsite$Input = {
  readonly _: "messageSponsorTypeWebsite";

  /**
   * URL of the website
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Name of the website
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Information about the sponsor of a message
 */
export type messageSponsor = {
  _: "messageSponsor";

  /**
   * Type of the sponsor
   * @type {MessageSponsorType} {@link MessageSponsorType}
   */
  type: MessageSponsorType;

  /**
   * Photo of the sponsor; may be null if must not be shown
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo | null;

  /**
   * Additional optional information about the sponsor to be shown along with the message
   * @type {string} {@link string}
   */
  info: string;
};

/**
 * Version of {@link messageSponsor} for method parameters.
 *
 * Information about the sponsor of a message
 */
export type messageSponsor$Input = {
  readonly _: "messageSponsor";

  /**
   * Type of the sponsor
   * @type {MessageSponsorType} {@link MessageSponsorType}
   */
  readonly type?: MessageSponsorType$Input;

  /**
   * Photo of the sponsor; may be null if must not be shown
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input | null;

  /**
   * Additional optional information about the sponsor to be shown along with the message
   * @type {string} {@link string}
   */
  readonly info?: string;
};

/**
 * Describes a sponsored message
 */
export type sponsoredMessage = {
  _: "sponsoredMessage";

  /**
   * Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * True, if the message needs to be labeled as "recommended" instead of "sponsored"
   * @type {Bool} {@link Bool}
   */
  is_recommended: Bool;

  /**
   * Content of the message. Currently, can be only of the type messageText
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent;

  /**
   * Information about the sponsor of the message
   * @type {messageSponsor} {@link messageSponsor}
   */
  sponsor: messageSponsor;

  /**
   * If non-empty, text for the message action button
   * @type {string} {@link string}
   */
  button_text: string;

  /**
   * If non-empty, additional information about the sponsored message to be shown along with the message
   * @type {string} {@link string}
   */
  additional_info: string;
};

/**
 * Version of {@link sponsoredMessage} for method parameters.
 *
 * Describes a sponsored message
 */
export type sponsoredMessage$Input = {
  readonly _: "sponsoredMessage";

  /**
   * Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * True, if the message needs to be labeled as "recommended" instead of "sponsored"
   * @type {Bool} {@link Bool}
   */
  readonly is_recommended?: Bool$Input;

  /**
   * Content of the message. Currently, can be only of the type messageText
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input;

  /**
   * Information about the sponsor of the message
   * @type {messageSponsor} {@link messageSponsor}
   */
  readonly sponsor?: messageSponsor$Input;

  /**
   * If non-empty, text for the message action button
   * @type {string} {@link string}
   */
  readonly button_text?: string;

  /**
   * If non-empty, additional information about the sponsored message to be shown along with the message
   * @type {string} {@link string}
   */
  readonly additional_info?: string;
};

/**
 * Contains a list of sponsored messages
 */
export type sponsoredMessages = {
  _: "sponsoredMessages";

  /**
   * List of sponsored messages
   * @type {vector<sponsoredMessage>} {@link vector<sponsoredMessage>}
   */
  messages: vector<sponsoredMessage>;

  /**
   * The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
   * @type {int32} {@link int32}
   */
  messages_between: int32;
};

/**
 * Version of {@link sponsoredMessages} for method parameters.
 *
 * Contains a list of sponsored messages
 */
export type sponsoredMessages$Input = {
  readonly _: "sponsoredMessages";

  /**
   * List of sponsored messages
   * @type {vector<sponsoredMessage>} {@link vector<sponsoredMessage>}
   */
  readonly messages?: vector$Input<sponsoredMessage$Input>;

  /**
   * The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
   * @type {int32} {@link int32}
   */
  readonly messages_between?: int32;
};

/**
 * Describes a file added to file download list
 */
export type fileDownload = {
  _: "fileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  file_id: int32;

  /**
   * The message with the file
   * @type {message} {@link message}
   */
  message: message;

  /**
   * Point in time (Unix timestamp) when the file was added to the download list
   * @type {int32} {@link int32}
   */
  add_date: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  complete_date: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  is_paused: Bool;
};

/**
 * Version of {@link fileDownload} for method parameters.
 *
 * Describes a file added to file download list
 */
export type fileDownload$Input = {
  readonly _: "fileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The message with the file
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * Point in time (Unix timestamp) when the file was added to the download list
   * @type {int32} {@link int32}
   */
  readonly add_date?: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  readonly complete_date?: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Contains number of being downloaded and recently downloaded files found
 */
export type downloadedFileCounts = {
  _: "downloadedFileCounts";

  /**
   * Number of active file downloads found, including paused
   * @type {int32} {@link int32}
   */
  active_count: int32;

  /**
   * Number of paused file downloads found
   * @type {int32} {@link int32}
   */
  paused_count: int32;

  /**
   * Number of completed file downloads found
   * @type {int32} {@link int32}
   */
  completed_count: int32;
};

/**
 * Version of {@link downloadedFileCounts} for method parameters.
 *
 * Contains number of being downloaded and recently downloaded files found
 */
export type downloadedFileCounts$Input = {
  readonly _: "downloadedFileCounts";

  /**
   * Number of active file downloads found, including paused
   * @type {int32} {@link int32}
   */
  readonly active_count?: int32;

  /**
   * Number of paused file downloads found
   * @type {int32} {@link int32}
   */
  readonly paused_count?: int32;

  /**
   * Number of completed file downloads found
   * @type {int32} {@link int32}
   */
  readonly completed_count?: int32;
};

/**
 * Contains a list of downloaded files, found by a search
 */
export type foundFileDownloads = {
  _: "foundFileDownloads";

  /**
   * Total number of suitable files, ignoring offset
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  total_counts: downloadedFileCounts;

  /**
   * The list of files
   * @type {vector<fileDownload>} {@link vector<fileDownload>}
   */
  files: vector<fileDownload>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link foundFileDownloads} for method parameters.
 *
 * Contains a list of downloaded files, found by a search
 */
export type foundFileDownloads$Input = {
  readonly _: "foundFileDownloads";

  /**
   * Total number of suitable files, ignoring offset
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly total_counts?: downloadedFileCounts$Input;

  /**
   * The list of files
   * @type {vector<fileDownload>} {@link vector<fileDownload>}
   */
  readonly files?: vector$Input<fileDownload$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
 */
export type notificationSettingsScopePrivateChats = {
  _: "notificationSettingsScopePrivateChats";
};

/**
 * Version of {@link notificationSettingsScopePrivateChats} for method parameters.
 *
 * Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
 */
export type notificationSettingsScopePrivateChats$Input = {
  readonly _: "notificationSettingsScopePrivateChats";
};

/**
 * Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
 */
export type notificationSettingsScopeGroupChats = {
  _: "notificationSettingsScopeGroupChats";
};

/**
 * Version of {@link notificationSettingsScopeGroupChats} for method parameters.
 *
 * Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value
 */
export type notificationSettingsScopeGroupChats$Input = {
  readonly _: "notificationSettingsScopeGroupChats";
};

/**
 * Notification settings applied to all channel chats when the corresponding chat setting has a default value
 */
export type notificationSettingsScopeChannelChats = {
  _: "notificationSettingsScopeChannelChats";
};

/**
 * Version of {@link notificationSettingsScopeChannelChats} for method parameters.
 *
 * Notification settings applied to all channel chats when the corresponding chat setting has a default value
 */
export type notificationSettingsScopeChannelChats$Input = {
  readonly _: "notificationSettingsScopeChannelChats";
};

/**
 * Contains information about notification settings for a chat or a forum topic
 */
export type chatNotificationSettings = {
  _: "chatNotificationSettings";

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
   * @type {Bool} {@link Bool}
   */
  use_default_mute_for: Bool;

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  mute_for: int32;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
   * @type {Bool} {@link Bool}
   */
  use_default_sound: Bool;

  /**
   * Identifier of the notification sound to be played for messages; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  sound_id: int64;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
   * @type {Bool} {@link Bool}
   */
  use_default_show_preview: Bool;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_preview: Bool;

  /**
   * If true, the value for the relevant type of chat is used instead of mute_stories
   * @type {Bool} {@link Bool}
   */
  use_default_mute_stories: Bool;

  /**
   * True, if story notifications are disabled for the chat
   * @type {Bool} {@link Bool}
   */
  mute_stories: Bool;

  /**
   * If true, the value for the relevant type of chat is used instead of story_sound_id
   * @type {Bool} {@link Bool}
   */
  use_default_story_sound: Bool;

  /**
   * Identifier of the notification sound to be played for stories; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  story_sound_id: int64;

  /**
   * If true, the value for the relevant type of chat is used instead of show_story_sender
   * @type {Bool} {@link Bool}
   */
  use_default_show_story_sender: Bool;

  /**
   * True, if the sender of stories must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_story_sender: Bool;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
   * @type {Bool} {@link Bool}
   */
  use_default_disable_pinned_message_notifications: Bool;

  /**
   * If true, notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_pinned_message_notifications: Bool;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
   * @type {Bool} {@link Bool}
   */
  use_default_disable_mention_notifications: Bool;

  /**
   * If true, notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_mention_notifications: Bool;
};

/**
 * Version of {@link chatNotificationSettings} for method parameters.
 *
 * Contains information about notification settings for a chat or a forum topic
 */
export type chatNotificationSettings$Input = {
  readonly _: "chatNotificationSettings";

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of mute_for
   * @type {Bool} {@link Bool}
   */
  readonly use_default_mute_for?: Bool$Input;

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  readonly mute_for?: int32;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of sound_id
   * @type {Bool} {@link Bool}
   */
  readonly use_default_sound?: Bool$Input;

  /**
   * Identifier of the notification sound to be played for messages; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly sound_id?: int64$Input;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of show_preview
   * @type {Bool} {@link Bool}
   */
  readonly use_default_show_preview?: Bool$Input;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_preview?: Bool$Input;

  /**
   * If true, the value for the relevant type of chat is used instead of mute_stories
   * @type {Bool} {@link Bool}
   */
  readonly use_default_mute_stories?: Bool$Input;

  /**
   * True, if story notifications are disabled for the chat
   * @type {Bool} {@link Bool}
   */
  readonly mute_stories?: Bool$Input;

  /**
   * If true, the value for the relevant type of chat is used instead of story_sound_id
   * @type {Bool} {@link Bool}
   */
  readonly use_default_story_sound?: Bool$Input;

  /**
   * Identifier of the notification sound to be played for stories; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly story_sound_id?: int64$Input;

  /**
   * If true, the value for the relevant type of chat is used instead of show_story_sender
   * @type {Bool} {@link Bool}
   */
  readonly use_default_show_story_sender?: Bool$Input;

  /**
   * True, if the sender of stories must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_story_sender?: Bool$Input;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of disable_pinned_message_notifications
   * @type {Bool} {@link Bool}
   */
  readonly use_default_disable_pinned_message_notifications?: Bool$Input;

  /**
   * If true, notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_pinned_message_notifications?: Bool$Input;

  /**
   * If true, the value for the relevant type of chat or the forum chat is used instead of disable_mention_notifications
   * @type {Bool} {@link Bool}
   */
  readonly use_default_disable_mention_notifications?: Bool$Input;

  /**
   * If true, notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_mention_notifications?: Bool$Input;
};

/**
 * Contains information about notification settings for several chats
 */
export type scopeNotificationSettings = {
  _: "scopeNotificationSettings";

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  mute_for: int32;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  sound_id: int64;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_preview: Bool;

  /**
   * If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
   * @type {Bool} {@link Bool}
   */
  use_default_mute_stories: Bool;

  /**
   * True, if story notifications are disabled
   * @type {Bool} {@link Bool}
   */
  mute_stories: Bool;

  /**
   * Identifier of the notification sound to be played for stories; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  story_sound_id: int64;

  /**
   * True, if the sender of stories must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_story_sender: Bool;

  /**
   * True, if notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_pinned_message_notifications: Bool;

  /**
   * True, if notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_mention_notifications: Bool;
};

/**
 * Version of {@link scopeNotificationSettings} for method parameters.
 *
 * Contains information about notification settings for several chats
 */
export type scopeNotificationSettings$Input = {
  readonly _: "scopeNotificationSettings";

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  readonly mute_for?: int32;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly sound_id?: int64$Input;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_preview?: Bool$Input;

  /**
   * If true, story notifications are received only for the first 5 chats from topChatCategoryUsers regardless of the value of mute_stories
   * @type {Bool} {@link Bool}
   */
  readonly use_default_mute_stories?: Bool$Input;

  /**
   * True, if story notifications are disabled
   * @type {Bool} {@link Bool}
   */
  readonly mute_stories?: Bool$Input;

  /**
   * Identifier of the notification sound to be played for stories; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly story_sound_id?: int64$Input;

  /**
   * True, if the sender of stories must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_story_sender?: Bool$Input;

  /**
   * True, if notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_pinned_message_notifications?: Bool$Input;

  /**
   * True, if notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_mention_notifications?: Bool$Input;
};

/**
 * Contains information about a message draft
 */
export type draftMessage = {
  _: "draftMessage";

  /**
   * Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none
   * @type {InputMessageReplyTo} {@link InputMessageReplyTo}
   */
  reply_to: InputMessageReplyTo | null;

  /**
   * Point in time (Unix timestamp) when the draft was created
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Content of the message draft; must be of the type inputMessageText
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_text: InputMessageContent;
};

/**
 * Version of {@link draftMessage} for method parameters.
 *
 * Contains information about a message draft
 */
export type draftMessage$Input = {
  readonly _: "draftMessage";

  /**
   * Information about the message to be replied; must be of the type inputMessageReplyToMessage; may be null if none
   * @type {InputMessageReplyTo} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Point in time (Unix timestamp) when the draft was created
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Content of the message draft; must be of the type inputMessageText
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_text?: InputMessageContent$Input;
};

/**
 * An ordinary chat with a user
 */
export type chatTypePrivate = {
  _: "chatTypePrivate";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link chatTypePrivate} for method parameters.
 *
 * An ordinary chat with a user
 */
export type chatTypePrivate$Input = {
  readonly _: "chatTypePrivate";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * A basic group (a chat with 0-200 other users)
 */
export type chatTypeBasicGroup = {
  _: "chatTypeBasicGroup";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  basic_group_id: int53;
};

/**
 * Version of {@link chatTypeBasicGroup} for method parameters.
 *
 * A basic group (a chat with 0-200 other users)
 */
export type chatTypeBasicGroup$Input = {
  readonly _: "chatTypeBasicGroup";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * A supergroup or channel (with unlimited members)
 */
export type chatTypeSupergroup = {
  _: "chatTypeSupergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  is_channel: Bool;
};

/**
 * Version of {@link chatTypeSupergroup} for method parameters.
 *
 * A supergroup or channel (with unlimited members)
 */
export type chatTypeSupergroup$Input = {
  readonly _: "chatTypeSupergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  readonly is_channel?: Bool$Input;
};

/**
 * A secret chat with a user
 */
export type chatTypeSecret = {
  _: "chatTypeSecret";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  secret_chat_id: int32;

  /**
   * User identifier of the other user in the secret chat
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link chatTypeSecret} for method parameters.
 *
 * A secret chat with a user
 */
export type chatTypeSecret$Input = {
  readonly _: "chatTypeSecret";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;

  /**
   * User identifier of the other user in the secret chat
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Represents an icon for a chat folder
 */
export type chatFolderIcon = {
  _: "chatFolderIcon";

  /**
   * The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown",
   *
   * - "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
   * @type {string} {@link string}
   */
  name: string;
};

/**
 * Version of {@link chatFolderIcon} for method parameters.
 *
 * Represents an icon for a chat folder
 */
export type chatFolderIcon$Input = {
  readonly _: "chatFolderIcon";

  /**
   * The chosen icon name for short folder representation; one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown",
   *
   * - "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Represents a folder for user chats
 */
export type chatFolder = {
  _: "chatFolder";

  /**
   * The title of the folder; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder
   * @type {chatFolderIcon} {@link chatFolderIcon}
   */
  icon: chatFolderIcon | null;

  /**
   * True, if at least one link has been created for the folder
   * @type {Bool} {@link Bool}
   */
  is_shareable: Bool;

  /**
   * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  pinned_chat_ids: vector<int53>;

  /**
   * The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  included_chat_ids: vector<int53>;

  /**
   * The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  excluded_chat_ids: vector<int53>;

  /**
   * True, if muted chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  exclude_muted: Bool;

  /**
   * True, if read chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  exclude_read: Bool;

  /**
   * True, if archived chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  exclude_archived: Bool;

  /**
   * True, if contacts need to be included
   * @type {Bool} {@link Bool}
   */
  include_contacts: Bool;

  /**
   * True, if non-contact users need to be included
   * @type {Bool} {@link Bool}
   */
  include_non_contacts: Bool;

  /**
   * True, if bots need to be included
   * @type {Bool} {@link Bool}
   */
  include_bots: Bool;

  /**
   * True, if basic groups and supergroups need to be included
   * @type {Bool} {@link Bool}
   */
  include_groups: Bool;

  /**
   * True, if channels need to be included
   * @type {Bool} {@link Bool}
   */
  include_channels: Bool;
};

/**
 * Version of {@link chatFolder} for method parameters.
 *
 * Represents a folder for user chats
 */
export type chatFolder$Input = {
  readonly _: "chatFolder";

  /**
   * The title of the folder; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The chosen icon for the chat folder; may be null. If null, use getChatFolderDefaultIconName to get default icon name for the folder
   * @type {chatFolderIcon} {@link chatFolderIcon}
   */
  readonly icon?: chatFolderIcon$Input | null;

  /**
   * True, if at least one link has been created for the folder
   * @type {Bool} {@link Bool}
   */
  readonly is_shareable?: Bool$Input;

  /**
   * The chat identifiers of pinned chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly pinned_chat_ids?: vector$Input<int53>;

  /**
   * The chat identifiers of always included chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly included_chat_ids?: vector$Input<int53>;

  /**
   * The chat identifiers of always excluded chats in the folder. There can be up to getOption("chat_folder_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly excluded_chat_ids?: vector$Input<int53>;

  /**
   * True, if muted chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  readonly exclude_muted?: Bool$Input;

  /**
   * True, if read chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  readonly exclude_read?: Bool$Input;

  /**
   * True, if archived chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  readonly exclude_archived?: Bool$Input;

  /**
   * True, if contacts need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_contacts?: Bool$Input;

  /**
   * True, if non-contact users need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_non_contacts?: Bool$Input;

  /**
   * True, if bots need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_bots?: Bool$Input;

  /**
   * True, if basic groups and supergroups need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_groups?: Bool$Input;

  /**
   * True, if channels need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_channels?: Bool$Input;
};

/**
 * Contains basic information about a chat folder
 */
export type chatFolderInfo = {
  _: "chatFolderInfo";

  /**
   * Unique chat folder identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * The title of the folder; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The chosen or default icon for the chat folder
   * @type {chatFolderIcon} {@link chatFolderIcon}
   */
  icon: chatFolderIcon;

  /**
   * True, if at least one link has been created for the folder
   * @type {Bool} {@link Bool}
   */
  is_shareable: Bool;

  /**
   * True, if the chat folder has invite links created by the current user
   * @type {Bool} {@link Bool}
   */
  has_my_invite_links: Bool;
};

/**
 * Version of {@link chatFolderInfo} for method parameters.
 *
 * Contains basic information about a chat folder
 */
export type chatFolderInfo$Input = {
  readonly _: "chatFolderInfo";

  /**
   * Unique chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * The title of the folder; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The chosen or default icon for the chat folder
   * @type {chatFolderIcon} {@link chatFolderIcon}
   */
  readonly icon?: chatFolderIcon$Input;

  /**
   * True, if at least one link has been created for the folder
   * @type {Bool} {@link Bool}
   */
  readonly is_shareable?: Bool$Input;

  /**
   * True, if the chat folder has invite links created by the current user
   * @type {Bool} {@link Bool}
   */
  readonly has_my_invite_links?: Bool$Input;
};

/**
 * Contains a chat folder invite link
 */
export type chatFolderInviteLink = {
  _: "chatFolderInviteLink";

  /**
   * The chat folder invite link
   * @type {string} {@link string}
   */
  invite_link: string;

  /**
   * Name of the link
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Identifiers of chats, included in the link
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

/**
 * Version of {@link chatFolderInviteLink} for method parameters.
 *
 * Contains a chat folder invite link
 */
export type chatFolderInviteLink$Input = {
  readonly _: "chatFolderInviteLink";

  /**
   * The chat folder invite link
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Name of the link
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Identifiers of chats, included in the link
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Represents a list of chat folder invite links
 */
export type chatFolderInviteLinks = {
  _: "chatFolderInviteLinks";

  /**
   * List of the invite links
   * @type {vector<chatFolderInviteLink>} {@link vector<chatFolderInviteLink>}
   */
  invite_links: vector<chatFolderInviteLink>;
};

/**
 * Version of {@link chatFolderInviteLinks} for method parameters.
 *
 * Represents a list of chat folder invite links
 */
export type chatFolderInviteLinks$Input = {
  readonly _: "chatFolderInviteLinks";

  /**
   * List of the invite links
   * @type {vector<chatFolderInviteLink>} {@link vector<chatFolderInviteLink>}
   */
  readonly invite_links?: vector$Input<chatFolderInviteLink$Input>;
};

/**
 * Contains information about an invite link to a chat folder
 */
export type chatFolderInviteLinkInfo = {
  _: "chatFolderInviteLinkInfo";

  /**
   * Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
   * @type {chatFolderInfo} {@link chatFolderInfo}
   */
  chat_folder_info: chatFolderInfo;

  /**
   * Identifiers of the chats from the link, which aren't added to the folder yet
   * @type {vector<int53>} {@link vector<int53>}
   */
  missing_chat_ids: vector<int53>;

  /**
   * Identifiers of the chats from the link, which are added to the folder already
   * @type {vector<int53>} {@link vector<int53>}
   */
  added_chat_ids: vector<int53>;
};

/**
 * Version of {@link chatFolderInviteLinkInfo} for method parameters.
 *
 * Contains information about an invite link to a chat folder
 */
export type chatFolderInviteLinkInfo$Input = {
  readonly _: "chatFolderInviteLinkInfo";

  /**
   * Basic information about the chat folder; chat folder identifier will be 0 if the user didn't have the chat folder yet
   * @type {chatFolderInfo} {@link chatFolderInfo}
   */
  readonly chat_folder_info?: chatFolderInfo$Input;

  /**
   * Identifiers of the chats from the link, which aren't added to the folder yet
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly missing_chat_ids?: vector$Input<int53>;

  /**
   * Identifiers of the chats from the link, which are added to the folder already
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly added_chat_ids?: vector$Input<int53>;
};

/**
 * Describes a recommended chat folder
 */
export type recommendedChatFolder = {
  _: "recommendedChatFolder";

  /**
   * The chat folder
   * @type {chatFolder} {@link chatFolder}
   */
  folder: chatFolder;

  /**
   * Describes a recommended chat folder
   * @type {string} {@link string}
   */
  description: string;
};

/**
 * Version of {@link recommendedChatFolder} for method parameters.
 *
 * Describes a recommended chat folder
 */
export type recommendedChatFolder$Input = {
  readonly _: "recommendedChatFolder";

  /**
   * The chat folder
   * @type {chatFolder} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;

  /**
   * Describes a recommended chat folder
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Contains a list of recommended chat folders
 */
export type recommendedChatFolders = {
  _: "recommendedChatFolders";

  /**
   * List of recommended chat folders
   * @type {vector<recommendedChatFolder>} {@link vector<recommendedChatFolder>}
   */
  chat_folders: vector<recommendedChatFolder>;
};

/**
 * Version of {@link recommendedChatFolders} for method parameters.
 *
 * Contains a list of recommended chat folders
 */
export type recommendedChatFolders$Input = {
  readonly _: "recommendedChatFolders";

  /**
   * List of recommended chat folders
   * @type {vector<recommendedChatFolder>} {@link vector<recommendedChatFolder>}
   */
  readonly chat_folders?: vector$Input<recommendedChatFolder$Input>;
};

/**
 * Contains settings for automatic moving of chats to and from the Archive chat lists
 */
export type archiveChatListSettings = {
  _: "archiveChatListSettings";

  /**
   * True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
   * @type {Bool} {@link Bool}
   */
  archive_and_mute_new_chats_from_unknown_users: Bool;

  /**
   * True, if unmuted chats will be kept in the Archive chat list when they get a new message
   * @type {Bool} {@link Bool}
   */
  keep_unmuted_chats_archived: Bool;

  /**
   * True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
   * @type {Bool} {@link Bool}
   */
  keep_chats_from_folders_archived: Bool;
};

/**
 * Version of {@link archiveChatListSettings} for method parameters.
 *
 * Contains settings for automatic moving of chats to and from the Archive chat lists
 */
export type archiveChatListSettings$Input = {
  readonly _: "archiveChatListSettings";

  /**
   * True, if new chats from non-contacts will be automatically archived and muted. Can be set to true only if the option "can_archive_and_mute_new_chats_from_unknown_users" is true
   * @type {Bool} {@link Bool}
   */
  readonly archive_and_mute_new_chats_from_unknown_users?: Bool$Input;

  /**
   * True, if unmuted chats will be kept in the Archive chat list when they get a new message
   * @type {Bool} {@link Bool}
   */
  readonly keep_unmuted_chats_archived?: Bool$Input;

  /**
   * True, if unmuted chats, that are always included or pinned in a folder, will be kept in the Archive chat list when they get a new message. Ignored if keep_unmuted_chats_archived == true
   * @type {Bool} {@link Bool}
   */
  readonly keep_chats_from_folders_archived?: Bool$Input;
};

/**
 * A main list of chats
 */
export type chatListMain = {
  _: "chatListMain";
};

/**
 * Version of {@link chatListMain} for method parameters.
 *
 * A main list of chats
 */
export type chatListMain$Input = {
  readonly _: "chatListMain";
};

/**
 * A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
 */
export type chatListArchive = {
  _: "chatListArchive";
};

/**
 * Version of {@link chatListArchive} for method parameters.
 *
 * A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
 */
export type chatListArchive$Input = {
  readonly _: "chatListArchive";
};

/**
 * A list of chats added to a chat folder
 */
export type chatListFolder = {
  _: "chatListFolder";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  chat_folder_id: int32;
};

/**
 * Version of {@link chatListFolder} for method parameters.
 *
 * A list of chats added to a chat folder
 */
export type chatListFolder$Input = {
  readonly _: "chatListFolder";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Contains a list of chat lists
 */
export type chatLists = {
  _: "chatLists";

  /**
   * List of chat lists
   * @type {vector<ChatList>} {@link vector<ChatList>}
   */
  chat_lists: vector<ChatList>;
};

/**
 * Version of {@link chatLists} for method parameters.
 *
 * Contains a list of chat lists
 */
export type chatLists$Input = {
  readonly _: "chatLists";

  /**
   * List of chat lists
   * @type {vector<ChatList>} {@link vector<ChatList>}
   */
  readonly chat_lists?: vector$Input<ChatList$Input>;
};

/**
 * The chat is sponsored by the user's MTProxy server
 */
export type chatSourceMtprotoProxy = {
  _: "chatSourceMtprotoProxy";
};

/**
 * Version of {@link chatSourceMtprotoProxy} for method parameters.
 *
 * The chat is sponsored by the user's MTProxy server
 */
export type chatSourceMtprotoProxy$Input = {
  readonly _: "chatSourceMtprotoProxy";
};

/**
 * The chat contains a public service announcement
 */
export type chatSourcePublicServiceAnnouncement = {
  _: "chatSourcePublicServiceAnnouncement";

  /**
   * The type of the announcement
   * @type {string} {@link string}
   */
  type: string;

  /**
   * The text of the announcement
   * @type {string} {@link string}
   */
  text: string;
};

/**
 * Version of {@link chatSourcePublicServiceAnnouncement} for method parameters.
 *
 * The chat contains a public service announcement
 */
export type chatSourcePublicServiceAnnouncement$Input = {
  readonly _: "chatSourcePublicServiceAnnouncement";

  /**
   * The type of the announcement
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * The text of the announcement
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Describes a position of a chat in a chat list
 */
export type chatPosition = {
  _: "chatPosition";

  /**
   * The chat list
   * @type {ChatList} {@link ChatList}
   */
  list: ChatList;

  /**
   * A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
   * @type {int64} {@link int64}
   */
  order: int64;

  /**
   * True, if the chat is pinned in the chat list
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * Source of the chat in the chat list; may be null
   * @type {ChatSource} {@link ChatSource}
   */
  source: ChatSource | null;
};

/**
 * Version of {@link chatPosition} for method parameters.
 *
 * Describes a position of a chat in a chat list
 */
export type chatPosition$Input = {
  readonly _: "chatPosition";

  /**
   * The chat list
   * @type {ChatList} {@link ChatList}
   */
  readonly list?: ChatList$Input;

  /**
   * A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
   * @type {int64} {@link int64}
   */
  readonly order?: int64$Input;

  /**
   * True, if the chat is pinned in the chat list
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * Source of the chat in the chat list; may be null
   * @type {ChatSource} {@link ChatSource}
   */
  readonly source?: ChatSource$Input | null;
};

/**
 * All reactions are available in the chat
 */
export type chatAvailableReactionsAll = {
  _: "chatAvailableReactionsAll";
};

/**
 * Version of {@link chatAvailableReactionsAll} for method parameters.
 *
 * All reactions are available in the chat
 */
export type chatAvailableReactionsAll$Input = {
  readonly _: "chatAvailableReactionsAll";
};

/**
 * Only specific reactions are available in the chat
 */
export type chatAvailableReactionsSome = {
  _: "chatAvailableReactionsSome";

  /**
   * The list of reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  reactions: vector<ReactionType>;
};

/**
 * Version of {@link chatAvailableReactionsSome} for method parameters.
 *
 * Only specific reactions are available in the chat
 */
export type chatAvailableReactionsSome$Input = {
  readonly _: "chatAvailableReactionsSome";

  /**
   * The list of reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  readonly reactions?: vector$Input<ReactionType$Input>;
};

/**
 * Describes a video chat
 */
export type videoChat = {
  _: "videoChat";

  /**
   * Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * True, if the video chat has participants
   * @type {Bool} {@link Bool}
   */
  has_participants: Bool;

  /**
   * Default group call participant identifier to join the video chat; may be null
   * @type {MessageSender} {@link MessageSender}
   */
  default_participant_id: MessageSender | null;
};

/**
 * Version of {@link videoChat} for method parameters.
 *
 * Describes a video chat
 */
export type videoChat$Input = {
  readonly _: "videoChat";

  /**
   * Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * True, if the video chat has participants
   * @type {Bool} {@link Bool}
   */
  readonly has_participants?: Bool$Input;

  /**
   * Default group call participant identifier to join the video chat; may be null
   * @type {MessageSender} {@link MessageSender}
   */
  readonly default_participant_id?: MessageSender$Input | null;
};

/**
 * A chat. (Can be a private chat, basic group, supergroup, or secret chat)
 */
export type chat = {
  _: "chat";

  /**
   * Chat unique identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Type of the chat
   * @type {ChatType} {@link ChatType}
   */
  type: ChatType;

  /**
   * Chat title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo | null;

  /**
   * Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
   * @type {int32} {@link int32}
   */
  accent_color_id: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none
   * @type {int64} {@link int64}
   */
  background_custom_emoji_id: int64;

  /**
   * Identifier of the profile accent color for the chat's profile; -1 if none
   * @type {int32} {@link int32}
   */
  profile_accent_color_id: int32;

  /**
   * Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none
   * @type {int64} {@link int64}
   */
  profile_background_custom_emoji_id: int64;

  /**
   * Actions that non-administrator chat members are allowed to take in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  permissions: chatPermissions;

  /**
   * Last message in the chat; may be null if none or unknown
   * @type {message} {@link message}
   */
  last_message: message | null;

  /**
   * Positions of the chat in chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  positions: vector<chatPosition>;

  /**
   * Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  message_sender_id: MessageSender | null;

  /**
   * Block list to which the chat is added; may be null if none
   * @type {BlockList} {@link BlockList}
   */
  block_list: BlockList | null;

  /**
   * True, if chat content can't be saved locally, forwarded, or copied
   * @type {Bool} {@link Bool}
   */
  has_protected_content: Bool;

  /**
   * True, if translation of all messages in the chat must be suggested to the user
   * @type {Bool} {@link Bool}
   */
  is_translatable: Bool;

  /**
   * True, if the chat is marked as unread
   * @type {Bool} {@link Bool}
   */
  is_marked_as_unread: Bool;

  /**
   * True, if the chat is a forum supergroup that must be shown in the "View as topics" mode
   * @type {Bool} {@link Bool}
   */
  view_as_topics: Bool;

  /**
   * True, if the chat has scheduled messages
   * @type {Bool} {@link Bool}
   */
  has_scheduled_messages: Bool;

  /**
   * True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_only_for_self: Bool;

  /**
   * True, if the chat messages can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_for_all_users: Bool;

  /**
   * True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
   * @type {Bool} {@link Bool}
   */
  can_be_reported: Bool;

  /**
   * Default value of the disable_notification parameter, used when a message is sent to the chat
   * @type {Bool} {@link Bool}
   */
  default_disable_notification: Bool;

  /**
   * Number of unread messages in the chat
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;

  /**
   * Number of unread messages with a mention/reply in the chat
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;

  /**
   * Number of messages with unread reactions in the chat
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;

  /**
   * Notification settings for the chat
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  notification_settings: chatNotificationSettings;

  /**
   * Types of reaction, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  available_reactions: ChatAvailableReactions;

  /**
   * Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
   * @type {int32} {@link int32}
   */
  message_auto_delete_time: int32;

  /**
   * Emoji status to be shown along with chat title; may be null
   * @type {emojiStatus} {@link emojiStatus}
   */
  emoji_status: emojiStatus | null;

  /**
   * Background set for the chat; may be null if none
   * @type {chatBackground} {@link chatBackground}
   */
  background: chatBackground | null;

  /**
   * If non-empty, name of a theme, set for the chat
   * @type {string} {@link string}
   */
  theme_name: string;

  /**
   * Information about actions which must be possible to do through the chat action bar; may be null if none
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  action_bar: ChatActionBar | null;

  /**
   * Information about video chat of the chat
   * @type {videoChat} {@link videoChat}
   */
  video_chat: videoChat;

  /**
   * Information about pending join requests; may be null if none
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  pending_join_requests: chatJoinRequestsInfo | null;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  reply_markup_message_id: int53;

  /**
   * A draft of a message in the chat; may be null if none
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage | null;

  /**
   * Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
   * @type {string} {@link string}
   */
  client_data: string;
};

/**
 * Version of {@link chat} for method parameters.
 *
 * A chat. (Can be a private chat, basic group, supergroup, or secret chat)
 */
export type chat$Input = {
  readonly _: "chat";

  /**
   * Chat unique identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Type of the chat
   * @type {ChatType} {@link ChatType}
   */
  readonly type?: ChatType$Input;

  /**
   * Chat title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input | null;

  /**
   * Identifier of the accent color for message sender name, and backgrounds of chat photo, reply header, and link preview
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background for messages sent by the chat; 0 if none
   * @type {int64} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;

  /**
   * Identifier of the profile accent color for the chat's profile; -1 if none
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the background of the chat's profile; 0 if none
   * @type {int64} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;

  /**
   * Actions that non-administrator chat members are allowed to take in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;

  /**
   * Last message in the chat; may be null if none or unknown
   * @type {message} {@link message}
   */
  readonly last_message?: message$Input | null;

  /**
   * Positions of the chat in chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  readonly positions?: vector$Input<chatPosition$Input>;

  /**
   * Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input | null;

  /**
   * Block list to which the chat is added; may be null if none
   * @type {BlockList} {@link BlockList}
   */
  readonly block_list?: BlockList$Input | null;

  /**
   * True, if chat content can't be saved locally, forwarded, or copied
   * @type {Bool} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;

  /**
   * True, if translation of all messages in the chat must be suggested to the user
   * @type {Bool} {@link Bool}
   */
  readonly is_translatable?: Bool$Input;

  /**
   * True, if the chat is marked as unread
   * @type {Bool} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;

  /**
   * True, if the chat is a forum supergroup that must be shown in the "View as topics" mode
   * @type {Bool} {@link Bool}
   */
  readonly view_as_topics?: Bool$Input;

  /**
   * True, if the chat has scheduled messages
   * @type {Bool} {@link Bool}
   */
  readonly has_scheduled_messages?: Bool$Input;

  /**
   * True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_only_for_self?: Bool$Input;

  /**
   * True, if the chat messages can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_for_all_users?: Bool$Input;

  /**
   * True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
   * @type {Bool} {@link Bool}
   */
  readonly can_be_reported?: Bool$Input;

  /**
   * Default value of the disable_notification parameter, used when a message is sent to the chat
   * @type {Bool} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;

  /**
   * Number of unread messages in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;

  /**
   * Number of unread messages with a mention/reply in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;

  /**
   * Number of messages with unread reactions in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;

  /**
   * Notification settings for the chat
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;

  /**
   * Types of reaction, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;

  /**
   * Current message auto-delete or self-destruct timer setting for the chat, in seconds; 0 if disabled. Self-destruct timer in secret chats starts after the message or its content is viewed. Auto-delete timer in other chats starts from the send date
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;

  /**
   * Emoji status to be shown along with chat title; may be null
   * @type {emojiStatus} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;

  /**
   * Background set for the chat; may be null if none
   * @type {chatBackground} {@link chatBackground}
   */
  readonly background?: chatBackground$Input | null;

  /**
   * If non-empty, name of a theme, set for the chat
   * @type {string} {@link string}
   */
  readonly theme_name?: string;

  /**
   * Information about actions which must be possible to do through the chat action bar; may be null if none
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  readonly action_bar?: ChatActionBar$Input | null;

  /**
   * Information about video chat of the chat
   * @type {videoChat} {@link videoChat}
   */
  readonly video_chat?: videoChat$Input;

  /**
   * Information about pending join requests; may be null if none
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  readonly pending_join_requests?: chatJoinRequestsInfo$Input | null;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  readonly reply_markup_message_id?: int53;

  /**
   * A draft of a message in the chat; may be null if none
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input | null;

  /**
   * Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
   * @type {string} {@link string}
   */
  readonly client_data?: string;
};

/**
 * Represents a list of chats
 */
export type chats = {
  _: "chats";

  /**
   * Approximate total number of chats found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of chat identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

/**
 * Version of {@link chats} for method parameters.
 *
 * Represents a list of chats
 */
export type chats$Input = {
  readonly _: "chats";

  /**
   * Approximate total number of chats found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of chat identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Describes a chat located nearby
 */
export type chatNearby = {
  _: "chatNearby";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Distance to the chat location, in meters
   * @type {int32} {@link int32}
   */
  distance: int32;
};

/**
 * Version of {@link chatNearby} for method parameters.
 *
 * Describes a chat located nearby
 */
export type chatNearby$Input = {
  readonly _: "chatNearby";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Distance to the chat location, in meters
   * @type {int32} {@link int32}
   */
  readonly distance?: int32;
};

/**
 * Represents a list of chats located nearby
 */
export type chatsNearby = {
  _: "chatsNearby";

  /**
   * List of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  users_nearby: vector<chatNearby>;

  /**
   * List of location-based supergroups nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  supergroups_nearby: vector<chatNearby>;
};

/**
 * Version of {@link chatsNearby} for method parameters.
 *
 * Represents a list of chats located nearby
 */
export type chatsNearby$Input = {
  readonly _: "chatsNearby";

  /**
   * List of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  readonly users_nearby?: vector$Input<chatNearby$Input>;

  /**
   * List of location-based supergroups nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  readonly supergroups_nearby?: vector$Input<chatNearby$Input>;
};

/**
 * The chat is public, because it has an active username
 */
export type publicChatTypeHasUsername = {
  _: "publicChatTypeHasUsername";
};

/**
 * Version of {@link publicChatTypeHasUsername} for method parameters.
 *
 * The chat is public, because it has an active username
 */
export type publicChatTypeHasUsername$Input = {
  readonly _: "publicChatTypeHasUsername";
};

/**
 * The chat is public, because it is a location-based supergroup
 */
export type publicChatTypeIsLocationBased = {
  _: "publicChatTypeIsLocationBased";
};

/**
 * Version of {@link publicChatTypeIsLocationBased} for method parameters.
 *
 * The chat is public, because it is a location-based supergroup
 */
export type publicChatTypeIsLocationBased$Input = {
  readonly _: "publicChatTypeIsLocationBased";
};

/**
 * The chat can be reported as spam using the method reportChat with the reason reportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
 */
export type chatActionBarReportSpam = {
  _: "chatActionBarReportSpam";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  can_unarchive: Bool;
};

/**
 * Version of {@link chatActionBarReportSpam} for method parameters.
 *
 * The chat can be reported as spam using the method reportChat with the reason reportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
 */
export type chatActionBarReportSpam$Input = {
  readonly _: "chatActionBarReportSpam";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  readonly can_unarchive?: Bool$Input;
};

/**
 * The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason reportReasonUnrelatedLocation
 */
export type chatActionBarReportUnrelatedLocation = {
  _: "chatActionBarReportUnrelatedLocation";
};

/**
 * Version of {@link chatActionBarReportUnrelatedLocation} for method parameters.
 *
 * The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason reportReasonUnrelatedLocation
 */
export type chatActionBarReportUnrelatedLocation$Input = {
  readonly _: "chatActionBarReportUnrelatedLocation";
};

/**
 * The chat is a recently created group chat to which new members can be invited
 */
export type chatActionBarInviteMembers = {
  _: "chatActionBarInviteMembers";
};

/**
 * Version of {@link chatActionBarInviteMembers} for method parameters.
 *
 * The chat is a recently created group chat to which new members can be invited
 */
export type chatActionBarInviteMembers$Input = {
  readonly _: "chatActionBarInviteMembers";
};

/**
 * The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList,
 *
 * - or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
 */
export type chatActionBarReportAddBlock = {
  _: "chatActionBarReportAddBlock";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  can_unarchive: Bool;

  /**
   * If non-negative, the current user was found by the other user through searchChatsNearby and this is the distance between the users
   * @type {int32} {@link int32}
   */
  distance: int32;
};

/**
 * Version of {@link chatActionBarReportAddBlock} for method parameters.
 *
 * The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method setMessageSenderBlockList,
 *
 * - or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown
 */
export type chatActionBarReportAddBlock$Input = {
  readonly _: "chatActionBarReportAddBlock";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  readonly can_unarchive?: Bool$Input;

  /**
   * If non-negative, the current user was found by the other user through searchChatsNearby and this is the distance between the users
   * @type {int32} {@link int32}
   */
  readonly distance?: int32;
};

/**
 * The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
 */
export type chatActionBarAddContact = {
  _: "chatActionBarAddContact";
};

/**
 * Version of {@link chatActionBarAddContact} for method parameters.
 *
 * The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
 */
export type chatActionBarAddContact$Input = {
  readonly _: "chatActionBarAddContact";
};

/**
 * The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
 */
export type chatActionBarSharePhoneNumber = {
  _: "chatActionBarSharePhoneNumber";
};

/**
 * Version of {@link chatActionBarSharePhoneNumber} for method parameters.
 *
 * The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
 */
export type chatActionBarSharePhoneNumber$Input = {
  readonly _: "chatActionBarSharePhoneNumber";
};

/**
 * The chat is a private chat with an administrator of a chat to which the user sent join request
 */
export type chatActionBarJoinRequest = {
  _: "chatActionBarJoinRequest";

  /**
   * Title of the chat to which the join request was sent
   * @type {string} {@link string}
   */
  title: string;

  /**
   * True, if the join request was sent to a channel chat
   * @type {Bool} {@link Bool}
   */
  is_channel: Bool;

  /**
   * Point in time (Unix timestamp) when the join request was sent
   * @type {int32} {@link int32}
   */
  request_date: int32;
};

/**
 * Version of {@link chatActionBarJoinRequest} for method parameters.
 *
 * The chat is a private chat with an administrator of a chat to which the user sent join request
 */
export type chatActionBarJoinRequest$Input = {
  readonly _: "chatActionBarJoinRequest";

  /**
   * Title of the chat to which the join request was sent
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * True, if the join request was sent to a channel chat
   * @type {Bool} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when the join request was sent
   * @type {int32} {@link int32}
   */
  readonly request_date?: int32;
};

/**
 * A simple button, with text that must be sent when the button is pressed
 */
export type keyboardButtonTypeText = {
  _: "keyboardButtonTypeText";
};

/**
 * Version of {@link keyboardButtonTypeText} for method parameters.
 *
 * A simple button, with text that must be sent when the button is pressed
 */
export type keyboardButtonTypeText$Input = {
  readonly _: "keyboardButtonTypeText";
};

/**
 * A button that sends the user's phone number when pressed; available only in private chats
 */
export type keyboardButtonTypeRequestPhoneNumber = {
  _: "keyboardButtonTypeRequestPhoneNumber";
};

/**
 * Version of {@link keyboardButtonTypeRequestPhoneNumber} for method parameters.
 *
 * A button that sends the user's phone number when pressed; available only in private chats
 */
export type keyboardButtonTypeRequestPhoneNumber$Input = {
  readonly _: "keyboardButtonTypeRequestPhoneNumber";
};

/**
 * A button that sends the user's location when pressed; available only in private chats
 */
export type keyboardButtonTypeRequestLocation = {
  _: "keyboardButtonTypeRequestLocation";
};

/**
 * Version of {@link keyboardButtonTypeRequestLocation} for method parameters.
 *
 * A button that sends the user's location when pressed; available only in private chats
 */
export type keyboardButtonTypeRequestLocation$Input = {
  readonly _: "keyboardButtonTypeRequestLocation";
};

/**
 * A button that allows the user to create and send a poll when pressed; available only in private chats
 */
export type keyboardButtonTypeRequestPoll = {
  _: "keyboardButtonTypeRequestPoll";

  /**
   * If true, only regular polls must be allowed to create
   * @type {Bool} {@link Bool}
   */
  force_regular: Bool;

  /**
   * If true, only polls in quiz mode must be allowed to create
   * @type {Bool} {@link Bool}
   */
  force_quiz: Bool;
};

/**
 * Version of {@link keyboardButtonTypeRequestPoll} for method parameters.
 *
 * A button that allows the user to create and send a poll when pressed; available only in private chats
 */
export type keyboardButtonTypeRequestPoll$Input = {
  readonly _: "keyboardButtonTypeRequestPoll";

  /**
   * If true, only regular polls must be allowed to create
   * @type {Bool} {@link Bool}
   */
  readonly force_regular?: Bool$Input;

  /**
   * If true, only polls in quiz mode must be allowed to create
   * @type {Bool} {@link Bool}
   */
  readonly force_quiz?: Bool$Input;
};

/**
 * A button that requests users to be shared by the current user; available only in private chats. Use the method shareUsersWithBot to complete the request
 */
export type keyboardButtonTypeRequestUsers = {
  _: "keyboardButtonTypeRequestUsers";

  /**
   * Unique button identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * True, if the shared users must or must not be bots
   * @type {Bool} {@link Bool}
   */
  restrict_user_is_bot: Bool;

  /**
   * True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
   * @type {Bool} {@link Bool}
   */
  user_is_bot: Bool;

  /**
   * True, if the shared users must or must not be Telegram Premium users
   * @type {Bool} {@link Bool}
   */
  restrict_user_is_premium: Bool;

  /**
   * True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
   * @type {Bool} {@link Bool}
   */
  user_is_premium: Bool;

  /**
   * The maximum number of users to share
   * @type {int32} {@link int32}
   */
  max_quantity: int32;
};

/**
 * Version of {@link keyboardButtonTypeRequestUsers} for method parameters.
 *
 * A button that requests users to be shared by the current user; available only in private chats. Use the method shareUsersWithBot to complete the request
 */
export type keyboardButtonTypeRequestUsers$Input = {
  readonly _: "keyboardButtonTypeRequestUsers";

  /**
   * Unique button identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * True, if the shared users must or must not be bots
   * @type {Bool} {@link Bool}
   */
  readonly restrict_user_is_bot?: Bool$Input;

  /**
   * True, if the shared users must be bots; otherwise, the shared users must not be bots. Ignored if restrict_user_is_bot is false
   * @type {Bool} {@link Bool}
   */
  readonly user_is_bot?: Bool$Input;

  /**
   * True, if the shared users must or must not be Telegram Premium users
   * @type {Bool} {@link Bool}
   */
  readonly restrict_user_is_premium?: Bool$Input;

  /**
   * True, if the shared users must be Telegram Premium users; otherwise, the shared users must not be Telegram Premium users. Ignored if restrict_user_is_premium is false
   * @type {Bool} {@link Bool}
   */
  readonly user_is_premium?: Bool$Input;

  /**
   * The maximum number of users to share
   * @type {int32} {@link int32}
   */
  readonly max_quantity?: int32;
};

/**
 * A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request
 */
export type keyboardButtonTypeRequestChat = {
  _: "keyboardButtonTypeRequestChat";

  /**
   * Unique button identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
   * @type {Bool} {@link Bool}
   */
  chat_is_channel: Bool;

  /**
   * True, if the chat must or must not be a forum supergroup
   * @type {Bool} {@link Bool}
   */
  restrict_chat_is_forum: Bool;

  /**
   * True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
   * @type {Bool} {@link Bool}
   */
  chat_is_forum: Bool;

  /**
   * True, if the chat must or must not have a username
   * @type {Bool} {@link Bool}
   */
  restrict_chat_has_username: Bool;

  /**
   * True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
   * @type {Bool} {@link Bool}
   */
  chat_has_username: Bool;

  /**
   * True, if the chat must be created by the current user
   * @type {Bool} {@link Bool}
   */
  chat_is_created: Bool;

  /**
   * Expected user administrator rights in the chat; may be null if they aren't restricted
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  user_administrator_rights: chatAdministratorRights | null;

  /**
   * Expected bot administrator rights in the chat; may be null if they aren't restricted
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  bot_administrator_rights: chatAdministratorRights | null;

  /**
   * True, if the bot must be a member of the chat; for basic group and supergroup chats only
   * @type {Bool} {@link Bool}
   */
  bot_is_member: Bool;
};

/**
 * Version of {@link keyboardButtonTypeRequestChat} for method parameters.
 *
 * A button that requests a chat to be shared by the current user; available only in private chats. Use the method shareChatWithBot to complete the request
 */
export type keyboardButtonTypeRequestChat$Input = {
  readonly _: "keyboardButtonTypeRequestChat";

  /**
   * Unique button identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * True, if the chat must be a channel; otherwise, a basic group or a supergroup chat is shared
   * @type {Bool} {@link Bool}
   */
  readonly chat_is_channel?: Bool$Input;

  /**
   * True, if the chat must or must not be a forum supergroup
   * @type {Bool} {@link Bool}
   */
  readonly restrict_chat_is_forum?: Bool$Input;

  /**
   * True, if the chat must be a forum supergroup; otherwise, the chat must not be a forum supergroup. Ignored if restrict_chat_is_forum is false
   * @type {Bool} {@link Bool}
   */
  readonly chat_is_forum?: Bool$Input;

  /**
   * True, if the chat must or must not have a username
   * @type {Bool} {@link Bool}
   */
  readonly restrict_chat_has_username?: Bool$Input;

  /**
   * True, if the chat must have a username; otherwise, the chat must not have a username. Ignored if restrict_chat_has_username is false
   * @type {Bool} {@link Bool}
   */
  readonly chat_has_username?: Bool$Input;

  /**
   * True, if the chat must be created by the current user
   * @type {Bool} {@link Bool}
   */
  readonly chat_is_created?: Bool$Input;

  /**
   * Expected user administrator rights in the chat; may be null if they aren't restricted
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly user_administrator_rights?: chatAdministratorRights$Input | null;

  /**
   * Expected bot administrator rights in the chat; may be null if they aren't restricted
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly bot_administrator_rights?: chatAdministratorRights$Input | null;

  /**
   * True, if the bot must be a member of the chat; for basic group and supergroup chats only
   * @type {Bool} {@link Bool}
   */
  readonly bot_is_member?: Bool$Input;
};

/**
 * A button that opens a Web App by calling getWebAppUrl
 */
export type keyboardButtonTypeWebApp = {
  _: "keyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to getWebAppUrl
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link keyboardButtonTypeWebApp} for method parameters.
 *
 * A button that opens a Web App by calling getWebAppUrl
 */
export type keyboardButtonTypeWebApp$Input = {
  readonly _: "keyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to getWebAppUrl
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Represents a single button in a bot keyboard
 */
export type keyboardButton = {
  _: "keyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Type of the button
   * @type {KeyboardButtonType} {@link KeyboardButtonType}
   */
  type: KeyboardButtonType;
};

/**
 * Version of {@link keyboardButton} for method parameters.
 *
 * Represents a single button in a bot keyboard
 */
export type keyboardButton$Input = {
  readonly _: "keyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Type of the button
   * @type {KeyboardButtonType} {@link KeyboardButtonType}
   */
  readonly type?: KeyboardButtonType$Input;
};

/**
 * A button that opens a specified URL
 */
export type inlineKeyboardButtonTypeUrl = {
  _: "inlineKeyboardButtonTypeUrl";

  /**
   * HTTP or tg:// URL to open
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link inlineKeyboardButtonTypeUrl} for method parameters.
 *
 * A button that opens a specified URL
 */
export type inlineKeyboardButtonTypeUrl$Input = {
  readonly _: "inlineKeyboardButtonTypeUrl";

  /**
   * HTTP or tg:// URL to open
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo
 */
export type inlineKeyboardButtonTypeLoginUrl = {
  _: "inlineKeyboardButtonTypeLoginUrl";

  /**
   * An HTTP URL to pass to getLoginUrlInfo
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Unique button identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * If non-empty, new text of the button in forwarded messages
   * @type {string} {@link string}
   */
  forward_text: string;
};

/**
 * Version of {@link inlineKeyboardButtonTypeLoginUrl} for method parameters.
 *
 * A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo
 */
export type inlineKeyboardButtonTypeLoginUrl$Input = {
  readonly _: "inlineKeyboardButtonTypeLoginUrl";

  /**
   * An HTTP URL to pass to getLoginUrlInfo
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Unique button identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * If non-empty, new text of the button in forwarded messages
   * @type {string} {@link string}
   */
  readonly forward_text?: string;
};

/**
 * A button that opens a Web App by calling openWebApp
 */
export type inlineKeyboardButtonTypeWebApp = {
  _: "inlineKeyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to openWebApp
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link inlineKeyboardButtonTypeWebApp} for method parameters.
 *
 * A button that opens a Web App by calling openWebApp
 */
export type inlineKeyboardButtonTypeWebApp$Input = {
  readonly _: "inlineKeyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to openWebApp
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * A button that sends a callback query to a bot
 */
export type inlineKeyboardButtonTypeCallback = {
  _: "inlineKeyboardButtonTypeCallback";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link inlineKeyboardButtonTypeCallback} for method parameters.
 *
 * A button that sends a callback query to a bot
 */
export type inlineKeyboardButtonTypeCallback$Input = {
  readonly _: "inlineKeyboardButtonTypeCallback";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot
 */
export type inlineKeyboardButtonTypeCallbackWithPassword = {
  _: "inlineKeyboardButtonTypeCallbackWithPassword";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link inlineKeyboardButtonTypeCallbackWithPassword} for method parameters.
 *
 * A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot
 */
export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {
  readonly _: "inlineKeyboardButtonTypeCallbackWithPassword";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
 */
export type inlineKeyboardButtonTypeCallbackGame = {
  _: "inlineKeyboardButtonTypeCallbackGame";
};

/**
 * Version of {@link inlineKeyboardButtonTypeCallbackGame} for method parameters.
 *
 * A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
 */
export type inlineKeyboardButtonTypeCallbackGame$Input = {
  readonly _: "inlineKeyboardButtonTypeCallbackGame";
};

/**
 * A button that forces an inline query to the bot to be inserted in the input field
 */
export type inlineKeyboardButtonTypeSwitchInline = {
  _: "inlineKeyboardButtonTypeSwitchInline";

  /**
   * Inline query to be sent to the bot
   * @type {string} {@link string}
   */
  query: string;

  /**
   * Target chat from which to send the inline query
   * @type {TargetChat} {@link TargetChat}
   */
  target_chat: TargetChat;
};

/**
 * Version of {@link inlineKeyboardButtonTypeSwitchInline} for method parameters.
 *
 * A button that forces an inline query to the bot to be inserted in the input field
 */
export type inlineKeyboardButtonTypeSwitchInline$Input = {
  readonly _: "inlineKeyboardButtonTypeSwitchInline";

  /**
   * Inline query to be sent to the bot
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Target chat from which to send the inline query
   * @type {TargetChat} {@link TargetChat}
   */
  readonly target_chat?: TargetChat$Input;
};

/**
 * A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
 */
export type inlineKeyboardButtonTypeBuy = {
  _: "inlineKeyboardButtonTypeBuy";
};

/**
 * Version of {@link inlineKeyboardButtonTypeBuy} for method parameters.
 *
 * A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
 */
export type inlineKeyboardButtonTypeBuy$Input = {
  readonly _: "inlineKeyboardButtonTypeBuy";
};

/**
 * A button with a user reference to be handled in the same way as textEntityTypeMentionName entities
 */
export type inlineKeyboardButtonTypeUser = {
  _: "inlineKeyboardButtonTypeUser";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link inlineKeyboardButtonTypeUser} for method parameters.
 *
 * A button with a user reference to be handled in the same way as textEntityTypeMentionName entities
 */
export type inlineKeyboardButtonTypeUser$Input = {
  readonly _: "inlineKeyboardButtonTypeUser";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Represents a single button in an inline keyboard
 */
export type inlineKeyboardButton = {
  _: "inlineKeyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Type of the button
   * @type {InlineKeyboardButtonType} {@link InlineKeyboardButtonType}
   */
  type: InlineKeyboardButtonType;
};

/**
 * Version of {@link inlineKeyboardButton} for method parameters.
 *
 * Represents a single button in an inline keyboard
 */
export type inlineKeyboardButton$Input = {
  readonly _: "inlineKeyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Type of the button
   * @type {InlineKeyboardButtonType} {@link InlineKeyboardButtonType}
   */
  readonly type?: InlineKeyboardButtonType$Input;
};

/**
 * Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent
 */
export type replyMarkupRemoveKeyboard = {
  _: "replyMarkupRemoveKeyboard";

  /**
   * True, if the keyboard is removed only for the mentioned users or the target user of a reply
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;
};

/**
 * Version of {@link replyMarkupRemoveKeyboard} for method parameters.
 *
 * Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, updateChatReplyMarkup with message_id == 0 will be sent
 */
export type replyMarkupRemoveKeyboard$Input = {
  readonly _: "replyMarkupRemoveKeyboard";

  /**
   * True, if the keyboard is removed only for the mentioned users or the target user of a reply
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;
};

/**
 * Instructs application to force a reply to this message
 */
export type replyMarkupForceReply = {
  _: "replyMarkupForceReply";

  /**
   * True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;

  /**
   * If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
   * @type {string} {@link string}
   */
  input_field_placeholder: string;
};

/**
 * Version of {@link replyMarkupForceReply} for method parameters.
 *
 * Instructs application to force a reply to this message
 */
export type replyMarkupForceReply$Input = {
  readonly _: "replyMarkupForceReply";

  /**
   * True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
   * @type {string} {@link string}
   */
  readonly input_field_placeholder?: string;
};

/**
 * Contains a custom keyboard layout to quickly reply to bots
 */
export type replyMarkupShowKeyboard = {
  _: "replyMarkupShowKeyboard";

  /**
   * A list of rows of bot keyboard buttons
   * @type {vector<vector<keyboardButton>>} {@link vector<vector<keyboardButton>>}
   */
  rows: vector<vector<keyboardButton>>;

  /**
   * True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden
   * @type {Bool} {@link Bool}
   */
  is_persistent: Bool;

  /**
   * True, if the application needs to resize the keyboard vertically
   * @type {Bool} {@link Bool}
   */
  resize_keyboard: Bool;

  /**
   * True, if the application needs to hide the keyboard after use
   * @type {Bool} {@link Bool}
   */
  one_time: Bool;

  /**
   * True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;

  /**
   * If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
   * @type {string} {@link string}
   */
  input_field_placeholder: string;
};

/**
 * Version of {@link replyMarkupShowKeyboard} for method parameters.
 *
 * Contains a custom keyboard layout to quickly reply to bots
 */
export type replyMarkupShowKeyboard$Input = {
  readonly _: "replyMarkupShowKeyboard";

  /**
   * A list of rows of bot keyboard buttons
   * @type {vector<vector<keyboardButton>>} {@link vector<vector<keyboardButton>>}
   */
  readonly rows?: vector$Input<vector$Input<keyboardButton$Input>>;

  /**
   * True, if the keyboard is supposed to always be shown when the ordinary keyboard is hidden
   * @type {Bool} {@link Bool}
   */
  readonly is_persistent?: Bool$Input;

  /**
   * True, if the application needs to resize the keyboard vertically
   * @type {Bool} {@link Bool}
   */
  readonly resize_keyboard?: Bool$Input;

  /**
   * True, if the application needs to hide the keyboard after use
   * @type {Bool} {@link Bool}
   */
  readonly one_time?: Bool$Input;

  /**
   * True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
   * @type {string} {@link string}
   */
  readonly input_field_placeholder?: string;
};

/**
 * Contains an inline keyboard layout
 */
export type replyMarkupInlineKeyboard = {
  _: "replyMarkupInlineKeyboard";

  /**
   * A list of rows of inline keyboard buttons
   * @type {vector<vector<inlineKeyboardButton>>} {@link vector<vector<inlineKeyboardButton>>}
   */
  rows: vector<vector<inlineKeyboardButton>>;
};

/**
 * Version of {@link replyMarkupInlineKeyboard} for method parameters.
 *
 * Contains an inline keyboard layout
 */
export type replyMarkupInlineKeyboard$Input = {
  readonly _: "replyMarkupInlineKeyboard";

  /**
   * A list of rows of inline keyboard buttons
   * @type {vector<vector<inlineKeyboardButton>>} {@link vector<vector<inlineKeyboardButton>>}
   */
  readonly rows?: vector$Input<vector$Input<inlineKeyboardButton$Input>>;
};

/**
 * An HTTP URL needs to be open
 */
export type loginUrlInfoOpen = {
  _: "loginUrlInfoOpen";

  /**
   * The URL to open
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if there is no need to show an ordinary open URL confirmation
   * @type {Bool} {@link Bool}
   */
  skip_confirmation: Bool;
};

/**
 * Version of {@link loginUrlInfoOpen} for method parameters.
 *
 * An HTTP URL needs to be open
 */
export type loginUrlInfoOpen$Input = {
  readonly _: "loginUrlInfoOpen";

  /**
   * The URL to open
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if there is no need to show an ordinary open URL confirmation
   * @type {Bool} {@link Bool}
   */
  readonly skip_confirmation?: Bool$Input;
};

/**
 * An authorization confirmation dialog needs to be shown to the user
 */
export type loginUrlInfoRequestConfirmation = {
  _: "loginUrlInfoRequestConfirmation";

  /**
   * An HTTP URL to be opened
   * @type {string} {@link string}
   */
  url: string;

  /**
   * A domain of the URL
   * @type {string} {@link string}
   */
  domain: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * True, if the user must be asked for the permission to the bot to send them messages
   * @type {Bool} {@link Bool}
   */
  request_write_access: Bool;
};

/**
 * Version of {@link loginUrlInfoRequestConfirmation} for method parameters.
 *
 * An authorization confirmation dialog needs to be shown to the user
 */
export type loginUrlInfoRequestConfirmation$Input = {
  readonly _: "loginUrlInfoRequestConfirmation";

  /**
   * An HTTP URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * A domain of the URL
   * @type {string} {@link string}
   */
  readonly domain?: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * True, if the user must be asked for the permission to the bot to send them messages
   * @type {Bool} {@link Bool}
   */
  readonly request_write_access?: Bool$Input;
};

/**
 * Contains information about a Web App found by its short name
 */
export type foundWebApp = {
  _: "foundWebApp";

  /**
   * The Web App
   * @type {webApp} {@link webApp}
   */
  web_app: webApp;

  /**
   * True, if the user must be asked for the permission to the bot to send them messages
   * @type {Bool} {@link Bool}
   */
  request_write_access: Bool;

  /**
   * True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
   * @type {Bool} {@link Bool}
   */
  skip_confirmation: Bool;
};

/**
 * Version of {@link foundWebApp} for method parameters.
 *
 * Contains information about a Web App found by its short name
 */
export type foundWebApp$Input = {
  readonly _: "foundWebApp";

  /**
   * The Web App
   * @type {webApp} {@link webApp}
   */
  readonly web_app?: webApp$Input;

  /**
   * True, if the user must be asked for the permission to the bot to send them messages
   * @type {Bool} {@link Bool}
   */
  readonly request_write_access?: Bool$Input;

  /**
   * True, if there is no need to show an ordinary open URL confirmation before opening the Web App. The field must be ignored and confirmation must be shown anyway if the Web App link was hidden
   * @type {Bool} {@link Bool}
   */
  readonly skip_confirmation?: Bool$Input;
};

/**
 * Contains information about a Web App
 */
export type webAppInfo = {
  _: "webAppInfo";

  /**
   * Unique identifier for the Web App launch
   * @type {int64} {@link int64}
   */
  launch_id: int64;

  /**
   * A Web App URL to open in a web view
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link webAppInfo} for method parameters.
 *
 * Contains information about a Web App
 */
export type webAppInfo$Input = {
  readonly _: "webAppInfo";

  /**
   * Unique identifier for the Web App launch
   * @type {int64} {@link int64}
   */
  readonly launch_id?: int64$Input;

  /**
   * A Web App URL to open in a web view
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Contains information about a message thread
 */
export type messageThreadInfo = {
  _: "messageThreadInfo";

  /**
   * Identifier of the chat to which the message thread belongs
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message thread identifier, unique within the chat
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * Information about the message thread; may be null for forum topic threads
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  reply_info: messageReplyInfo | null;

  /**
   * Approximate number of unread messages in the message thread
   * @type {int32} {@link int32}
   */
  unread_message_count: int32;

  /**
   * The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message>;

  /**
   * A draft of a message in the message thread; may be null if none
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage | null;
};

/**
 * Version of {@link messageThreadInfo} for method parameters.
 *
 * Contains information about a message thread
 */
export type messageThreadInfo$Input = {
  readonly _: "messageThreadInfo";

  /**
   * Identifier of the chat to which the message thread belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier, unique within the chat
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message thread; may be null for forum topic threads
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  readonly reply_info?: messageReplyInfo$Input | null;

  /**
   * Approximate number of unread messages in the message thread
   * @type {int32} {@link int32}
   */
  readonly unread_message_count?: int32;

  /**
   * The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input>;

  /**
   * A draft of a message in the message thread; may be null if none
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input | null;
};

/**
 * Describes a forum topic icon
 */
export type forumTopicIcon = {
  _: "forumTopicIcon";

  /**
   * Color of the topic icon in RGB format
   * @type {int32} {@link int32}
   */
  color: int32;

  /**
   * Unique identifier of the custom emoji shown on the topic icon; 0 if none
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

/**
 * Version of {@link forumTopicIcon} for method parameters.
 *
 * Describes a forum topic icon
 */
export type forumTopicIcon$Input = {
  readonly _: "forumTopicIcon";

  /**
   * Color of the topic icon in RGB format
   * @type {int32} {@link int32}
   */
  readonly color?: int32;

  /**
   * Unique identifier of the custom emoji shown on the topic icon; 0 if none
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;
};

/**
 * Contains basic information about a forum topic
 */
export type forumTopicInfo = {
  _: "forumTopicInfo";

  /**
   * Message thread identifier of the topic
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  icon: forumTopicIcon;

  /**
   * Point in time (Unix timestamp) when the topic was created
   * @type {int32} {@link int32}
   */
  creation_date: int32;

  /**
   * Identifier of the creator of the topic
   * @type {MessageSender} {@link MessageSender}
   */
  creator_id: MessageSender;

  /**
   * True, if the topic is the General topic list
   * @type {Bool} {@link Bool}
   */
  is_general: Bool;

  /**
   * True, if the topic was created by the current user
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * True, if the topic is closed
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;

  /**
   * True, if the topic is hidden above the topic list and closed; for General topic only
   * @type {Bool} {@link Bool}
   */
  is_hidden: Bool;
};

/**
 * Version of {@link forumTopicInfo} for method parameters.
 *
 * Contains basic information about a forum topic
 */
export type forumTopicInfo$Input = {
  readonly _: "forumTopicInfo";

  /**
   * Message thread identifier of the topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;

  /**
   * Point in time (Unix timestamp) when the topic was created
   * @type {int32} {@link int32}
   */
  readonly creation_date?: int32;

  /**
   * Identifier of the creator of the topic
   * @type {MessageSender} {@link MessageSender}
   */
  readonly creator_id?: MessageSender$Input;

  /**
   * True, if the topic is the General topic list
   * @type {Bool} {@link Bool}
   */
  readonly is_general?: Bool$Input;

  /**
   * True, if the topic was created by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * True, if the topic is closed
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;

  /**
   * True, if the topic is hidden above the topic list and closed; for General topic only
   * @type {Bool} {@link Bool}
   */
  readonly is_hidden?: Bool$Input;
};

/**
 * Describes a forum topic
 */
export type forumTopic = {
  _: "forumTopic";

  /**
   * Basic information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  info: forumTopicInfo;

  /**
   * Last message in the topic; may be null if unknown
   * @type {message} {@link message}
   */
  last_message: message | null;

  /**
   * True, if the topic is pinned in the topic list
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * Number of unread messages in the topic
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;

  /**
   * Number of unread messages with a mention/reply in the topic
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;

  /**
   * Number of messages with unread reactions in the topic
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;

  /**
   * Notification settings for the topic
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  notification_settings: chatNotificationSettings;

  /**
   * A draft of a message in the topic; may be null if none
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage | null;
};

/**
 * Version of {@link forumTopic} for method parameters.
 *
 * Describes a forum topic
 */
export type forumTopic$Input = {
  readonly _: "forumTopic";

  /**
   * Basic information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly info?: forumTopicInfo$Input;

  /**
   * Last message in the topic; may be null if unknown
   * @type {message} {@link message}
   */
  readonly last_message?: message$Input | null;

  /**
   * True, if the topic is pinned in the topic list
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * Number of unread messages in the topic
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;

  /**
   * Number of unread messages with a mention/reply in the topic
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;

  /**
   * Number of messages with unread reactions in the topic
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;

  /**
   * Notification settings for the topic
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;

  /**
   * A draft of a message in the topic; may be null if none
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input | null;
};

/**
 * Describes a list of forum topics
 */
export type forumTopics = {
  _: "forumTopics";

  /**
   * Approximate total number of forum topics found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of forum topics
   * @type {vector<forumTopic>} {@link vector<forumTopic>}
   */
  topics: vector<forumTopic>;

  /**
   * Offset date for the next getForumTopics request
   * @type {int32} {@link int32}
   */
  next_offset_date: int32;

  /**
   * Offset message identifier for the next getForumTopics request
   * @type {int53} {@link int53}
   */
  next_offset_message_id: int53;

  /**
   * Offset message thread identifier for the next getForumTopics request
   * @type {int53} {@link int53}
   */
  next_offset_message_thread_id: int53;
};

/**
 * Version of {@link forumTopics} for method parameters.
 *
 * Describes a list of forum topics
 */
export type forumTopics$Input = {
  readonly _: "forumTopics";

  /**
   * Approximate total number of forum topics found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of forum topics
   * @type {vector<forumTopic>} {@link vector<forumTopic>}
   */
  readonly topics?: vector$Input<forumTopic$Input>;

  /**
   * Offset date for the next getForumTopics request
   * @type {int32} {@link int32}
   */
  readonly next_offset_date?: int32;

  /**
   * Offset message identifier for the next getForumTopics request
   * @type {int53} {@link int53}
   */
  readonly next_offset_message_id?: int53;

  /**
   * Offset message thread identifier for the next getForumTopics request
   * @type {int53} {@link int53}
   */
  readonly next_offset_message_thread_id?: int53;
};

/**
 * Options to be used for generation of a link preview
 */
export type linkPreviewOptions = {
  _: "linkPreviewOptions";

  /**
   * True, if link preview must be disabled
   * @type {Bool} {@link Bool}
   */
  is_disabled: Bool;

  /**
   * URL to use for link preview. If empty, then the first URL found in the message text will be used
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
   * @type {Bool} {@link Bool}
   */
  force_small_media: Bool;

  /**
   * True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
   * @type {Bool} {@link Bool}
   */
  force_large_media: Bool;

  /**
   * True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
   * @type {Bool} {@link Bool}
   */
  show_above_text: Bool;
};

/**
 * Version of {@link linkPreviewOptions} for method parameters.
 *
 * Options to be used for generation of a link preview
 */
export type linkPreviewOptions$Input = {
  readonly _: "linkPreviewOptions";

  /**
   * True, if link preview must be disabled
   * @type {Bool} {@link Bool}
   */
  readonly is_disabled?: Bool$Input;

  /**
   * URL to use for link preview. If empty, then the first URL found in the message text will be used
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if shown media preview must be small; ignored in secret chats or if the URL isn't explicitly specified
   * @type {Bool} {@link Bool}
   */
  readonly force_small_media?: Bool$Input;

  /**
   * True, if shown media preview must be large; ignored in secret chats or if the URL isn't explicitly specified
   * @type {Bool} {@link Bool}
   */
  readonly force_large_media?: Bool$Input;

  /**
   * True, if link preview must be shown above message text; otherwise, the link preview will be shown below the message text; ignored in secret chats
   * @type {Bool} {@link Bool}
   */
  readonly show_above_text?: Bool$Input;
};

/**
 * A plain text
 */
export type richTextPlain = {
  _: "richTextPlain";

  /**
   * Text
   * @type {string} {@link string}
   */
  text: string;
};

/**
 * Version of {@link richTextPlain} for method parameters.
 *
 * A plain text
 */
export type richTextPlain$Input = {
  readonly _: "richTextPlain";

  /**
   * Text
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * A bold rich text
 */
export type richTextBold = {
  _: "richTextBold";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextBold} for method parameters.
 *
 * A bold rich text
 */
export type richTextBold$Input = {
  readonly _: "richTextBold";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * An italicized rich text
 */
export type richTextItalic = {
  _: "richTextItalic";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextItalic} for method parameters.
 *
 * An italicized rich text
 */
export type richTextItalic$Input = {
  readonly _: "richTextItalic";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * An underlined rich text
 */
export type richTextUnderline = {
  _: "richTextUnderline";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextUnderline} for method parameters.
 *
 * An underlined rich text
 */
export type richTextUnderline$Input = {
  readonly _: "richTextUnderline";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A strikethrough rich text
 */
export type richTextStrikethrough = {
  _: "richTextStrikethrough";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextStrikethrough} for method parameters.
 *
 * A strikethrough rich text
 */
export type richTextStrikethrough$Input = {
  readonly _: "richTextStrikethrough";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A fixed-width rich text
 */
export type richTextFixed = {
  _: "richTextFixed";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextFixed} for method parameters.
 *
 * A fixed-width rich text
 */
export type richTextFixed$Input = {
  readonly _: "richTextFixed";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A rich text URL link
 */
export type richTextUrl = {
  _: "richTextUrl";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if the URL has cached instant view server-side
   * @type {Bool} {@link Bool}
   */
  is_cached: Bool;
};

/**
 * Version of {@link richTextUrl} for method parameters.
 *
 * A rich text URL link
 */
export type richTextUrl$Input = {
  readonly _: "richTextUrl";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if the URL has cached instant view server-side
   * @type {Bool} {@link Bool}
   */
  readonly is_cached?: Bool$Input;
};

/**
 * A rich text email link
 */
export type richTextEmailAddress = {
  _: "richTextEmailAddress";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Email address
   * @type {string} {@link string}
   */
  email_address: string;
};

/**
 * Version of {@link richTextEmailAddress} for method parameters.
 *
 * A rich text email link
 */
export type richTextEmailAddress$Input = {
  readonly _: "richTextEmailAddress";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * A subscript rich text
 */
export type richTextSubscript = {
  _: "richTextSubscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextSubscript} for method parameters.
 *
 * A subscript rich text
 */
export type richTextSubscript$Input = {
  readonly _: "richTextSubscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A superscript rich text
 */
export type richTextSuperscript = {
  _: "richTextSuperscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextSuperscript} for method parameters.
 *
 * A superscript rich text
 */
export type richTextSuperscript$Input = {
  readonly _: "richTextSuperscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A marked rich text
 */
export type richTextMarked = {
  _: "richTextMarked";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link richTextMarked} for method parameters.
 *
 * A marked rich text
 */
export type richTextMarked$Input = {
  readonly _: "richTextMarked";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A rich text phone number
 */
export type richTextPhoneNumber = {
  _: "richTextPhoneNumber";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Phone number
   * @type {string} {@link string}
   */
  phone_number: string;
};

/**
 * Version of {@link richTextPhoneNumber} for method parameters.
 *
 * A rich text phone number
 */
export type richTextPhoneNumber$Input = {
  readonly _: "richTextPhoneNumber";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Phone number
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * A small image inside the text
 */
export type richTextIcon = {
  _: "richTextIcon";

  /**
   * The image represented as a document. The image can be in GIF, JPEG or PNG format
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Width of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Height of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;
};

/**
 * Version of {@link richTextIcon} for method parameters.
 *
 * A small image inside the text
 */
export type richTextIcon$Input = {
  readonly _: "richTextIcon";

  /**
   * The image represented as a document. The image can be in GIF, JPEG or PNG format
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Width of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Height of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;
};

/**
 * A reference to a richTexts object on the same web page
 */
export type richTextReference = {
  _: "richTextReference";

  /**
   * The text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * The name of a richTextAnchor object, which is the first element of the target richTexts object
   * @type {string} {@link string}
   */
  anchor_name: string;

  /**
   * An HTTP URL, opening the reference
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link richTextReference} for method parameters.
 *
 * A reference to a richTexts object on the same web page
 */
export type richTextReference$Input = {
  readonly _: "richTextReference";

  /**
   * The text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * The name of a richTextAnchor object, which is the first element of the target richTexts object
   * @type {string} {@link string}
   */
  readonly anchor_name?: string;

  /**
   * An HTTP URL, opening the reference
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * An anchor
 */
export type richTextAnchor = {
  _: "richTextAnchor";

  /**
   * Anchor name
   * @type {string} {@link string}
   */
  name: string;
};

/**
 * Version of {@link richTextAnchor} for method parameters.
 *
 * An anchor
 */
export type richTextAnchor$Input = {
  readonly _: "richTextAnchor";

  /**
   * Anchor name
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * A link to an anchor on the same web page
 */
export type richTextAnchorLink = {
  _: "richTextAnchorLink";

  /**
   * The link text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * The anchor name. If the name is empty, the link must bring back to top
   * @type {string} {@link string}
   */
  anchor_name: string;

  /**
   * An HTTP URL, opening the anchor
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link richTextAnchorLink} for method parameters.
 *
 * A link to an anchor on the same web page
 */
export type richTextAnchorLink$Input = {
  readonly _: "richTextAnchorLink";

  /**
   * The link text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * The anchor name. If the name is empty, the link must bring back to top
   * @type {string} {@link string}
   */
  readonly anchor_name?: string;

  /**
   * An HTTP URL, opening the anchor
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * A concatenation of rich texts
 */
export type richTexts = {
  _: "richTexts";

  /**
   * Texts
   * @type {vector<RichText>} {@link vector<RichText>}
   */
  texts: vector<RichText>;
};

/**
 * Version of {@link richTexts} for method parameters.
 *
 * A concatenation of rich texts
 */
export type richTexts$Input = {
  readonly _: "richTexts";

  /**
   * Texts
   * @type {vector<RichText>} {@link vector<RichText>}
   */
  readonly texts?: vector$Input<RichText$Input>;
};

/**
 * Contains a caption of an instant view web page block, consisting of a text and a trailing credit
 */
export type pageBlockCaption = {
  _: "pageBlockCaption";

  /**
   * Content of the caption
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Block credit (like HTML tag <cite>)
   * @type {RichText} {@link RichText}
   */
  credit: RichText;
};

/**
 * Version of {@link pageBlockCaption} for method parameters.
 *
 * Contains a caption of an instant view web page block, consisting of a text and a trailing credit
 */
export type pageBlockCaption$Input = {
  readonly _: "pageBlockCaption";

  /**
   * Content of the caption
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Block credit (like HTML tag <cite>)
   * @type {RichText} {@link RichText}
   */
  readonly credit?: RichText$Input;
};

/**
 * Describes an item of a list page block
 */
export type pageBlockListItem = {
  _: "pageBlockListItem";

  /**
   * Item label
   * @type {string} {@link string}
   */
  label: string;

  /**
   * Item blocks
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;
};

/**
 * Version of {@link pageBlockListItem} for method parameters.
 *
 * Describes an item of a list page block
 */
export type pageBlockListItem$Input = {
  readonly _: "pageBlockListItem";

  /**
   * Item label
   * @type {string} {@link string}
   */
  readonly label?: string;

  /**
   * Item blocks
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;
};

/**
 * The content must be left-aligned
 */
export type pageBlockHorizontalAlignmentLeft = {
  _: "pageBlockHorizontalAlignmentLeft";
};

/**
 * Version of {@link pageBlockHorizontalAlignmentLeft} for method parameters.
 *
 * The content must be left-aligned
 */
export type pageBlockHorizontalAlignmentLeft$Input = {
  readonly _: "pageBlockHorizontalAlignmentLeft";
};

/**
 * The content must be center-aligned
 */
export type pageBlockHorizontalAlignmentCenter = {
  _: "pageBlockHorizontalAlignmentCenter";
};

/**
 * Version of {@link pageBlockHorizontalAlignmentCenter} for method parameters.
 *
 * The content must be center-aligned
 */
export type pageBlockHorizontalAlignmentCenter$Input = {
  readonly _: "pageBlockHorizontalAlignmentCenter";
};

/**
 * The content must be right-aligned
 */
export type pageBlockHorizontalAlignmentRight = {
  _: "pageBlockHorizontalAlignmentRight";
};

/**
 * Version of {@link pageBlockHorizontalAlignmentRight} for method parameters.
 *
 * The content must be right-aligned
 */
export type pageBlockHorizontalAlignmentRight$Input = {
  readonly _: "pageBlockHorizontalAlignmentRight";
};

/**
 * The content must be top-aligned
 */
export type pageBlockVerticalAlignmentTop = {
  _: "pageBlockVerticalAlignmentTop";
};

/**
 * Version of {@link pageBlockVerticalAlignmentTop} for method parameters.
 *
 * The content must be top-aligned
 */
export type pageBlockVerticalAlignmentTop$Input = {
  readonly _: "pageBlockVerticalAlignmentTop";
};

/**
 * The content must be middle-aligned
 */
export type pageBlockVerticalAlignmentMiddle = {
  _: "pageBlockVerticalAlignmentMiddle";
};

/**
 * Version of {@link pageBlockVerticalAlignmentMiddle} for method parameters.
 *
 * The content must be middle-aligned
 */
export type pageBlockVerticalAlignmentMiddle$Input = {
  readonly _: "pageBlockVerticalAlignmentMiddle";
};

/**
 * The content must be bottom-aligned
 */
export type pageBlockVerticalAlignmentBottom = {
  _: "pageBlockVerticalAlignmentBottom";
};

/**
 * Version of {@link pageBlockVerticalAlignmentBottom} for method parameters.
 *
 * The content must be bottom-aligned
 */
export type pageBlockVerticalAlignmentBottom$Input = {
  readonly _: "pageBlockVerticalAlignmentBottom";
};

/**
 * Represents a cell of a table
 */
export type pageBlockTableCell = {
  _: "pageBlockTableCell";

  /**
   * Cell text; may be null. If the text is null, then the cell must be invisible
   * @type {RichText} {@link RichText}
   */
  text: RichText | null;

  /**
   * True, if it is a header cell
   * @type {Bool} {@link Bool}
   */
  is_header: Bool;

  /**
   * The number of columns the cell spans
   * @type {int32} {@link int32}
   */
  colspan: int32;

  /**
   * The number of rows the cell spans
   * @type {int32} {@link int32}
   */
  rowspan: int32;

  /**
   * Horizontal cell content alignment
   * @type {PageBlockHorizontalAlignment} {@link PageBlockHorizontalAlignment}
   */
  align: PageBlockHorizontalAlignment;

  /**
   * Vertical cell content alignment
   * @type {PageBlockVerticalAlignment} {@link PageBlockVerticalAlignment}
   */
  valign: PageBlockVerticalAlignment;
};

/**
 * Version of {@link pageBlockTableCell} for method parameters.
 *
 * Represents a cell of a table
 */
export type pageBlockTableCell$Input = {
  readonly _: "pageBlockTableCell";

  /**
   * Cell text; may be null. If the text is null, then the cell must be invisible
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input | null;

  /**
   * True, if it is a header cell
   * @type {Bool} {@link Bool}
   */
  readonly is_header?: Bool$Input;

  /**
   * The number of columns the cell spans
   * @type {int32} {@link int32}
   */
  readonly colspan?: int32;

  /**
   * The number of rows the cell spans
   * @type {int32} {@link int32}
   */
  readonly rowspan?: int32;

  /**
   * Horizontal cell content alignment
   * @type {PageBlockHorizontalAlignment} {@link PageBlockHorizontalAlignment}
   */
  readonly align?: PageBlockHorizontalAlignment$Input;

  /**
   * Vertical cell content alignment
   * @type {PageBlockVerticalAlignment} {@link PageBlockVerticalAlignment}
   */
  readonly valign?: PageBlockVerticalAlignment$Input;
};

/**
 * Contains information about a related article
 */
export type pageBlockRelatedArticle = {
  _: "pageBlockRelatedArticle";

  /**
   * Related article URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Article title; may be empty
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Contains information about a related article
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Article photo; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * Article author; may be empty
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  publish_date: int32;
};

/**
 * Version of {@link pageBlockRelatedArticle} for method parameters.
 *
 * Contains information about a related article
 */
export type pageBlockRelatedArticle$Input = {
  readonly _: "pageBlockRelatedArticle";

  /**
   * Related article URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Article title; may be empty
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Contains information about a related article
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Article photo; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * Article author; may be empty
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly publish_date?: int32;
};

/**
 * The title of a page
 */
export type pageBlockTitle = {
  _: "pageBlockTitle";

  /**
   * Title
   * @type {RichText} {@link RichText}
   */
  title: RichText;
};

/**
 * Version of {@link pageBlockTitle} for method parameters.
 *
 * The title of a page
 */
export type pageBlockTitle$Input = {
  readonly _: "pageBlockTitle";

  /**
   * Title
   * @type {RichText} {@link RichText}
   */
  readonly title?: RichText$Input;
};

/**
 * The subtitle of a page
 */
export type pageBlockSubtitle = {
  _: "pageBlockSubtitle";

  /**
   * Subtitle
   * @type {RichText} {@link RichText}
   */
  subtitle: RichText;
};

/**
 * Version of {@link pageBlockSubtitle} for method parameters.
 *
 * The subtitle of a page
 */
export type pageBlockSubtitle$Input = {
  readonly _: "pageBlockSubtitle";

  /**
   * Subtitle
   * @type {RichText} {@link RichText}
   */
  readonly subtitle?: RichText$Input;
};

/**
 * The author and publishing date of a page
 */
export type pageBlockAuthorDate = {
  _: "pageBlockAuthorDate";

  /**
   * Author
   * @type {RichText} {@link RichText}
   */
  author: RichText;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  publish_date: int32;
};

/**
 * Version of {@link pageBlockAuthorDate} for method parameters.
 *
 * The author and publishing date of a page
 */
export type pageBlockAuthorDate$Input = {
  readonly _: "pageBlockAuthorDate";

  /**
   * Author
   * @type {RichText} {@link RichText}
   */
  readonly author?: RichText$Input;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly publish_date?: int32;
};

/**
 * A header
 */
export type pageBlockHeader = {
  _: "pageBlockHeader";

  /**
   * Header
   * @type {RichText} {@link RichText}
   */
  header: RichText;
};

/**
 * Version of {@link pageBlockHeader} for method parameters.
 *
 * A header
 */
export type pageBlockHeader$Input = {
  readonly _: "pageBlockHeader";

  /**
   * Header
   * @type {RichText} {@link RichText}
   */
  readonly header?: RichText$Input;
};

/**
 * A subheader
 */
export type pageBlockSubheader = {
  _: "pageBlockSubheader";

  /**
   * Subheader
   * @type {RichText} {@link RichText}
   */
  subheader: RichText;
};

/**
 * Version of {@link pageBlockSubheader} for method parameters.
 *
 * A subheader
 */
export type pageBlockSubheader$Input = {
  readonly _: "pageBlockSubheader";

  /**
   * Subheader
   * @type {RichText} {@link RichText}
   */
  readonly subheader?: RichText$Input;
};

/**
 * A kicker
 */
export type pageBlockKicker = {
  _: "pageBlockKicker";

  /**
   * Kicker
   * @type {RichText} {@link RichText}
   */
  kicker: RichText;
};

/**
 * Version of {@link pageBlockKicker} for method parameters.
 *
 * A kicker
 */
export type pageBlockKicker$Input = {
  readonly _: "pageBlockKicker";

  /**
   * Kicker
   * @type {RichText} {@link RichText}
   */
  readonly kicker?: RichText$Input;
};

/**
 * A text paragraph
 */
export type pageBlockParagraph = {
  _: "pageBlockParagraph";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

/**
 * Version of {@link pageBlockParagraph} for method parameters.
 *
 * A text paragraph
 */
export type pageBlockParagraph$Input = {
  readonly _: "pageBlockParagraph";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/**
 * A preformatted text paragraph
 */
export type pageBlockPreformatted = {
  _: "pageBlockPreformatted";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Programming language for which the text needs to be formatted
   * @type {string} {@link string}
   */
  language: string;
};

/**
 * Version of {@link pageBlockPreformatted} for method parameters.
 *
 * A preformatted text paragraph
 */
export type pageBlockPreformatted$Input = {
  readonly _: "pageBlockPreformatted";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Programming language for which the text needs to be formatted
   * @type {string} {@link string}
   */
  readonly language?: string;
};

/**
 * The footer of a page
 */
export type pageBlockFooter = {
  _: "pageBlockFooter";

  /**
   * Footer
   * @type {RichText} {@link RichText}
   */
  footer: RichText;
};

/**
 * Version of {@link pageBlockFooter} for method parameters.
 *
 * The footer of a page
 */
export type pageBlockFooter$Input = {
  readonly _: "pageBlockFooter";

  /**
   * Footer
   * @type {RichText} {@link RichText}
   */
  readonly footer?: RichText$Input;
};

/**
 * An empty block separating a page
 */
export type pageBlockDivider = {
  _: "pageBlockDivider";
};

/**
 * Version of {@link pageBlockDivider} for method parameters.
 *
 * An empty block separating a page
 */
export type pageBlockDivider$Input = {
  readonly _: "pageBlockDivider";
};

/**
 * An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
 */
export type pageBlockAnchor = {
  _: "pageBlockAnchor";

  /**
   * Name of the anchor
   * @type {string} {@link string}
   */
  name: string;
};

/**
 * Version of {@link pageBlockAnchor} for method parameters.
 *
 * An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
 */
export type pageBlockAnchor$Input = {
  readonly _: "pageBlockAnchor";

  /**
   * Name of the anchor
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * A list of data blocks
 */
export type pageBlockList = {
  _: "pageBlockList";

  /**
   * The items of the list
   * @type {vector<pageBlockListItem>} {@link vector<pageBlockListItem>}
   */
  items: vector<pageBlockListItem>;
};

/**
 * Version of {@link pageBlockList} for method parameters.
 *
 * A list of data blocks
 */
export type pageBlockList$Input = {
  readonly _: "pageBlockList";

  /**
   * The items of the list
   * @type {vector<pageBlockListItem>} {@link vector<pageBlockListItem>}
   */
  readonly items?: vector$Input<pageBlockListItem$Input>;
};

/**
 * A block quote
 */
export type pageBlockBlockQuote = {
  _: "pageBlockBlockQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  credit: RichText;
};

/**
 * Version of {@link pageBlockBlockQuote} for method parameters.
 *
 * A block quote
 */
export type pageBlockBlockQuote$Input = {
  readonly _: "pageBlockBlockQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  readonly credit?: RichText$Input;
};

/**
 * A pull quote
 */
export type pageBlockPullQuote = {
  _: "pageBlockPullQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  credit: RichText;
};

/**
 * Version of {@link pageBlockPullQuote} for method parameters.
 *
 * A pull quote
 */
export type pageBlockPullQuote$Input = {
  readonly _: "pageBlockPullQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  readonly credit?: RichText$Input;
};

/**
 * An animation
 */
export type pageBlockAnimation = {
  _: "pageBlockAnimation";

  /**
   * Animation file; may be null
   * @type {animation} {@link animation}
   */
  animation: animation | null;

  /**
   * Animation caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * True, if the animation must be played automatically
   * @type {Bool} {@link Bool}
   */
  need_autoplay: Bool;
};

/**
 * Version of {@link pageBlockAnimation} for method parameters.
 *
 * An animation
 */
export type pageBlockAnimation$Input = {
  readonly _: "pageBlockAnimation";

  /**
   * Animation file; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input | null;

  /**
   * Animation caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * True, if the animation must be played automatically
   * @type {Bool} {@link Bool}
   */
  readonly need_autoplay?: Bool$Input;
};

/**
 * An audio file
 */
export type pageBlockAudio = {
  _: "pageBlockAudio";

  /**
   * Audio file; may be null
   * @type {audio} {@link audio}
   */
  audio: audio | null;

  /**
   * Audio file caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

/**
 * Version of {@link pageBlockAudio} for method parameters.
 *
 * An audio file
 */
export type pageBlockAudio$Input = {
  readonly _: "pageBlockAudio";

  /**
   * Audio file; may be null
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input | null;

  /**
   * Audio file caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/**
 * A photo
 */
export type pageBlockPhoto = {
  _: "pageBlockPhoto";

  /**
   * Photo file; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * Photo caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * URL that needs to be opened when the photo is clicked
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link pageBlockPhoto} for method parameters.
 *
 * A photo
 */
export type pageBlockPhoto$Input = {
  readonly _: "pageBlockPhoto";

  /**
   * Photo file; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * Photo caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * URL that needs to be opened when the photo is clicked
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * A video
 */
export type pageBlockVideo = {
  _: "pageBlockVideo";

  /**
   * Video file; may be null
   * @type {video} {@link video}
   */
  video: video | null;

  /**
   * Video caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * True, if the video must be played automatically
   * @type {Bool} {@link Bool}
   */
  need_autoplay: Bool;

  /**
   * True, if the video must be looped
   * @type {Bool} {@link Bool}
   */
  is_looped: Bool;
};

/**
 * Version of {@link pageBlockVideo} for method parameters.
 *
 * A video
 */
export type pageBlockVideo$Input = {
  readonly _: "pageBlockVideo";

  /**
   * Video file; may be null
   * @type {video} {@link video}
   */
  readonly video?: video$Input | null;

  /**
   * Video caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * True, if the video must be played automatically
   * @type {Bool} {@link Bool}
   */
  readonly need_autoplay?: Bool$Input;

  /**
   * True, if the video must be looped
   * @type {Bool} {@link Bool}
   */
  readonly is_looped?: Bool$Input;
};

/**
 * A voice note
 */
export type pageBlockVoiceNote = {
  _: "pageBlockVoiceNote";

  /**
   * Voice note; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote | null;

  /**
   * Voice note caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

/**
 * Version of {@link pageBlockVoiceNote} for method parameters.
 *
 * A voice note
 */
export type pageBlockVoiceNote$Input = {
  readonly _: "pageBlockVoiceNote";

  /**
   * Voice note; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input | null;

  /**
   * Voice note caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/**
 * A page cover
 */
export type pageBlockCover = {
  _: "pageBlockCover";

  /**
   * Cover
   * @type {PageBlock} {@link PageBlock}
   */
  cover: PageBlock;
};

/**
 * Version of {@link pageBlockCover} for method parameters.
 *
 * A page cover
 */
export type pageBlockCover$Input = {
  readonly _: "pageBlockCover";

  /**
   * Cover
   * @type {PageBlock} {@link PageBlock}
   */
  readonly cover?: PageBlock$Input;
};

/**
 * An embedded web page
 */
export type pageBlockEmbedded = {
  _: "pageBlockEmbedded";

  /**
   * Web page URL, if available
   * @type {string} {@link string}
   */
  url: string;

  /**
   * HTML-markup of the embedded page
   * @type {string} {@link string}
   */
  html: string;

  /**
   * Poster photo, if available; may be null
   * @type {photo} {@link photo}
   */
  poster_photo: photo | null;

  /**
   * Block width; 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Block height; 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * True, if the block must be full width
   * @type {Bool} {@link Bool}
   */
  is_full_width: Bool;

  /**
   * True, if scrolling needs to be allowed
   * @type {Bool} {@link Bool}
   */
  allow_scrolling: Bool;
};

/**
 * Version of {@link pageBlockEmbedded} for method parameters.
 *
 * An embedded web page
 */
export type pageBlockEmbedded$Input = {
  readonly _: "pageBlockEmbedded";

  /**
   * Web page URL, if available
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * HTML-markup of the embedded page
   * @type {string} {@link string}
   */
  readonly html?: string;

  /**
   * Poster photo, if available; may be null
   * @type {photo} {@link photo}
   */
  readonly poster_photo?: photo$Input | null;

  /**
   * Block width; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Block height; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * True, if the block must be full width
   * @type {Bool} {@link Bool}
   */
  readonly is_full_width?: Bool$Input;

  /**
   * True, if scrolling needs to be allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_scrolling?: Bool$Input;
};

/**
 * An embedded post
 */
export type pageBlockEmbeddedPost = {
  _: "pageBlockEmbeddedPost";

  /**
   * Web page URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Post author
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Post author photo; may be null
   * @type {photo} {@link photo}
   */
  author_photo: photo | null;

  /**
   * Point in time (Unix timestamp) when the post was created; 0 if unknown
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Post content
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Post caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

/**
 * Version of {@link pageBlockEmbeddedPost} for method parameters.
 *
 * An embedded post
 */
export type pageBlockEmbeddedPost$Input = {
  readonly _: "pageBlockEmbeddedPost";

  /**
   * Web page URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Post author
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Post author photo; may be null
   * @type {photo} {@link photo}
   */
  readonly author_photo?: photo$Input | null;

  /**
   * Point in time (Unix timestamp) when the post was created; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Post content
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Post caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/**
 * A collage
 */
export type pageBlockCollage = {
  _: "pageBlockCollage";

  /**
   * Collage item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

/**
 * Version of {@link pageBlockCollage} for method parameters.
 *
 * A collage
 */
export type pageBlockCollage$Input = {
  readonly _: "pageBlockCollage";

  /**
   * Collage item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/**
 * A slideshow
 */
export type pageBlockSlideshow = {
  _: "pageBlockSlideshow";

  /**
   * Slideshow item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

/**
 * Version of {@link pageBlockSlideshow} for method parameters.
 *
 * A slideshow
 */
export type pageBlockSlideshow$Input = {
  readonly _: "pageBlockSlideshow";

  /**
   * Slideshow item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/**
 * A link to a chat
 */
export type pageBlockChatLink = {
  _: "pageBlockChatLink";

  /**
   * Chat title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo | null;

  /**
   * Identifier of the accent color for chat title and background of chat photo
   * @type {int32} {@link int32}
   */
  accent_color_id: int32;

  /**
   * Chat username by which all other information about the chat can be resolved
   * @type {string} {@link string}
   */
  username: string;
};

/**
 * Version of {@link pageBlockChatLink} for method parameters.
 *
 * A link to a chat
 */
export type pageBlockChatLink$Input = {
  readonly _: "pageBlockChatLink";

  /**
   * Chat title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input | null;

  /**
   * Identifier of the accent color for chat title and background of chat photo
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Chat username by which all other information about the chat can be resolved
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * A table
 */
export type pageBlockTable = {
  _: "pageBlockTable";

  /**
   * Table caption
   * @type {RichText} {@link RichText}
   */
  caption: RichText;

  /**
   * Table cells
   * @type {vector<vector<pageBlockTableCell>>} {@link vector<vector<pageBlockTableCell>>}
   */
  cells: vector<vector<pageBlockTableCell>>;

  /**
   * True, if the table is bordered
   * @type {Bool} {@link Bool}
   */
  is_bordered: Bool;

  /**
   * True, if the table is striped
   * @type {Bool} {@link Bool}
   */
  is_striped: Bool;
};

/**
 * Version of {@link pageBlockTable} for method parameters.
 *
 * A table
 */
export type pageBlockTable$Input = {
  readonly _: "pageBlockTable";

  /**
   * Table caption
   * @type {RichText} {@link RichText}
   */
  readonly caption?: RichText$Input;

  /**
   * Table cells
   * @type {vector<vector<pageBlockTableCell>>} {@link vector<vector<pageBlockTableCell>>}
   */
  readonly cells?: vector$Input<vector$Input<pageBlockTableCell$Input>>;

  /**
   * True, if the table is bordered
   * @type {Bool} {@link Bool}
   */
  readonly is_bordered?: Bool$Input;

  /**
   * True, if the table is striped
   * @type {Bool} {@link Bool}
   */
  readonly is_striped?: Bool$Input;
};

/**
 * A collapsible block
 */
export type pageBlockDetails = {
  _: "pageBlockDetails";

  /**
   * Always visible heading for the block
   * @type {RichText} {@link RichText}
   */
  header: RichText;

  /**
   * Block contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * True, if the block is open by default
   * @type {Bool} {@link Bool}
   */
  is_open: Bool;
};

/**
 * Version of {@link pageBlockDetails} for method parameters.
 *
 * A collapsible block
 */
export type pageBlockDetails$Input = {
  readonly _: "pageBlockDetails";

  /**
   * Always visible heading for the block
   * @type {RichText} {@link RichText}
   */
  readonly header?: RichText$Input;

  /**
   * Block contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * True, if the block is open by default
   * @type {Bool} {@link Bool}
   */
  readonly is_open?: Bool$Input;
};

/**
 * Related articles
 */
export type pageBlockRelatedArticles = {
  _: "pageBlockRelatedArticles";

  /**
   * Block header
   * @type {RichText} {@link RichText}
   */
  header: RichText;

  /**
   * List of related articles
   * @type {vector<pageBlockRelatedArticle>} {@link vector<pageBlockRelatedArticle>}
   */
  articles: vector<pageBlockRelatedArticle>;
};

/**
 * Version of {@link pageBlockRelatedArticles} for method parameters.
 *
 * Related articles
 */
export type pageBlockRelatedArticles$Input = {
  readonly _: "pageBlockRelatedArticles";

  /**
   * Block header
   * @type {RichText} {@link RichText}
   */
  readonly header?: RichText$Input;

  /**
   * List of related articles
   * @type {vector<pageBlockRelatedArticle>} {@link vector<pageBlockRelatedArticle>}
   */
  readonly articles?: vector$Input<pageBlockRelatedArticle$Input>;
};

/**
 * A map
 */
export type pageBlockMap = {
  _: "pageBlockMap";

  /**
   * Location of the map center
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Map zoom level
   * @type {int32} {@link int32}
   */
  zoom: int32;

  /**
   * Map width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Map height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

/**
 * Version of {@link pageBlockMap} for method parameters.
 *
 * A map
 */
export type pageBlockMap$Input = {
  readonly _: "pageBlockMap";

  /**
   * Location of the map center
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Map zoom level
   * @type {int32} {@link int32}
   */
  readonly zoom?: int32;

  /**
   * Map width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Map height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/**
 * Describes an instant view page for a web page
 */
export type webPageInstantView = {
  _: "webPageInstantView";

  /**
   * Content of the web page
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Number of the instant view views; 0 if unknown
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Version of the instant view; currently, can be 1 or 2
   * @type {int32} {@link int32}
   */
  version: int32;

  /**
   * True, if the instant view must be shown from right to left
   * @type {Bool} {@link Bool}
   */
  is_rtl: Bool;

  /**
   * True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
   * @type {Bool} {@link Bool}
   */
  is_full: Bool;

  /**
   * An internal link to be opened to leave feedback about the instant view
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  feedback_link: InternalLinkType;
};

/**
 * Version of {@link webPageInstantView} for method parameters.
 *
 * Describes an instant view page for a web page
 */
export type webPageInstantView$Input = {
  readonly _: "webPageInstantView";

  /**
   * Content of the web page
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Number of the instant view views; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Version of the instant view; currently, can be 1 or 2
   * @type {int32} {@link int32}
   */
  readonly version?: int32;

  /**
   * True, if the instant view must be shown from right to left
   * @type {Bool} {@link Bool}
   */
  readonly is_rtl?: Bool$Input;

  /**
   * True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
   * @type {Bool} {@link Bool}
   */
  readonly is_full?: Bool$Input;

  /**
   * An internal link to be opened to leave feedback about the instant view
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly feedback_link?: InternalLinkType$Input;
};

/**
 * Describes a link preview
 */
export type webPage = {
  _: "webPage";

  /**
   * Original URL of the link
   * @type {string} {@link string}
   */
  url: string;

  /**
   * URL to display
   * @type {string} {@link string}
   */
  display_url: string;

  /**
   * Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
   * @type {string} {@link string}
   */
  type: string;

  /**
   * Short name of the site (e.g., Google Docs, App Store)
   * @type {string} {@link string}
   */
  site_name: string;

  /**
   * Title of the content
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Describes a link preview
   * @type {formattedText} {@link formattedText}
   */
  description: formattedText;

  /**
   * Image representing the content; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * URL to show in the embedded preview
   * @type {string} {@link string}
   */
  embed_url: string;

  /**
   * MIME type of the embedded preview, (e.g., text/html or video/mp4)
   * @type {string} {@link string}
   */
  embed_type: string;

  /**
   * Width of the embedded preview
   * @type {int32} {@link int32}
   */
  embed_width: int32;

  /**
   * Height of the embedded preview
   * @type {int32} {@link int32}
   */
  embed_height: int32;

  /**
   * Duration of the content, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Author of the content
   * @type {string} {@link string}
   */
  author: string;

  /**
   * True, if size of media in the preview can be changed
   * @type {Bool} {@link Bool}
   */
  has_large_media: Bool;

  /**
   * True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
   * @type {Bool} {@link Bool}
   */
  show_large_media: Bool;

  /**
   * True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
   * @type {Bool} {@link Bool}
   */
  skip_confirmation: Bool;

  /**
   * True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
   * @type {Bool} {@link Bool}
   */
  show_above_text: Bool;

  /**
   * Preview of the content as an animation, if available; may be null
   * @type {animation} {@link animation}
   */
  animation: animation | null;

  /**
   * Preview of the content as an audio file, if available; may be null
   * @type {audio} {@link audio}
   */
  audio: audio | null;

  /**
   * Preview of the content as a document, if available; may be null
   * @type {document} {@link document}
   */
  document: document | null;

  /**
   * Preview of the content as a sticker for small WEBP files, if available; may be null
   * @type {sticker} {@link sticker}
   */
  sticker: sticker | null;

  /**
   * Preview of the content as a video, if available; may be null
   * @type {video} {@link video}
   */
  video: video | null;

  /**
   * Preview of the content as a video note, if available; may be null
   * @type {videoNote} {@link videoNote}
   */
  video_note: videoNote | null;

  /**
   * Preview of the content as a voice note, if available; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote | null;

  /**
   * The identifier of the sender of the previewed story; 0 if none
   * @type {int53} {@link int53}
   */
  story_sender_chat_id: int53;

  /**
   * The identifier of the previewed story; 0 if none
   * @type {int32} {@link int32}
   */
  story_id: int32;

  /**
   * Version of web page instant view (currently, can be 1 or 2); 0 if none
   * @type {int32} {@link int32}
   */
  instant_view_version: int32;
};

/**
 * Version of {@link webPage} for method parameters.
 *
 * Describes a link preview
 */
export type webPage$Input = {
  readonly _: "webPage";

  /**
   * Original URL of the link
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * URL to display
   * @type {string} {@link string}
   */
  readonly display_url?: string;

  /**
   * Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Short name of the site (e.g., Google Docs, App Store)
   * @type {string} {@link string}
   */
  readonly site_name?: string;

  /**
   * Title of the content
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Describes a link preview
   * @type {formattedText} {@link formattedText}
   */
  readonly description?: formattedText$Input;

  /**
   * Image representing the content; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * URL to show in the embedded preview
   * @type {string} {@link string}
   */
  readonly embed_url?: string;

  /**
   * MIME type of the embedded preview, (e.g., text/html or video/mp4)
   * @type {string} {@link string}
   */
  readonly embed_type?: string;

  /**
   * Width of the embedded preview
   * @type {int32} {@link int32}
   */
  readonly embed_width?: int32;

  /**
   * Height of the embedded preview
   * @type {int32} {@link int32}
   */
  readonly embed_height?: int32;

  /**
   * Duration of the content, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Author of the content
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * True, if size of media in the preview can be changed
   * @type {Bool} {@link Bool}
   */
  readonly has_large_media?: Bool$Input;

  /**
   * True, if large media preview must be shown; otherwise, the media preview must be shown small and only the first frame must be shown for videos
   * @type {Bool} {@link Bool}
   */
  readonly show_large_media?: Bool$Input;

  /**
   * True, if there is no need to show an ordinary open URL confirmation, when opening the URL from the preview, because the URL is shown in the message text in clear
   * @type {Bool} {@link Bool}
   */
  readonly skip_confirmation?: Bool$Input;

  /**
   * True, if the link preview must be shown above message text; otherwise, the link preview must be shown below the message text
   * @type {Bool} {@link Bool}
   */
  readonly show_above_text?: Bool$Input;

  /**
   * Preview of the content as an animation, if available; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input | null;

  /**
   * Preview of the content as an audio file, if available; may be null
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input | null;

  /**
   * Preview of the content as a document, if available; may be null
   * @type {document} {@link document}
   */
  readonly document?: document$Input | null;

  /**
   * Preview of the content as a sticker for small WEBP files, if available; may be null
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input | null;

  /**
   * Preview of the content as a video, if available; may be null
   * @type {video} {@link video}
   */
  readonly video?: video$Input | null;

  /**
   * Preview of the content as a video note, if available; may be null
   * @type {videoNote} {@link videoNote}
   */
  readonly video_note?: videoNote$Input | null;

  /**
   * Preview of the content as a voice note, if available; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input | null;

  /**
   * The identifier of the sender of the previewed story; 0 if none
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the previewed story; 0 if none
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Version of web page instant view (currently, can be 1 or 2); 0 if none
   * @type {int32} {@link int32}
   */
  readonly instant_view_version?: int32;
};

/**
 * Contains information about a country
 */
export type countryInfo = {
  _: "countryInfo";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  country_code: string;

  /**
   * Native name of the country
   * @type {string} {@link string}
   */
  name: string;

  /**
   * English name of the country
   * @type {string} {@link string}
   */
  english_name: string;

  /**
   * True, if the country must be hidden from the list of all countries
   * @type {Bool} {@link Bool}
   */
  is_hidden: Bool;

  /**
   * List of country calling codes
   * @type {vector<string>} {@link vector<string>}
   */
  calling_codes: vector<string>;
};

/**
 * Version of {@link countryInfo} for method parameters.
 *
 * Contains information about a country
 */
export type countryInfo$Input = {
  readonly _: "countryInfo";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;

  /**
   * Native name of the country
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * English name of the country
   * @type {string} {@link string}
   */
  readonly english_name?: string;

  /**
   * True, if the country must be hidden from the list of all countries
   * @type {Bool} {@link Bool}
   */
  readonly is_hidden?: Bool$Input;

  /**
   * List of country calling codes
   * @type {vector<string>} {@link vector<string>}
   */
  readonly calling_codes?: vector$Input<string>;
};

/**
 * Contains information about countries
 */
export type countries = {
  _: "countries";

  /**
   * The list of countries
   * @type {vector<countryInfo>} {@link vector<countryInfo>}
   */
  countries: vector<countryInfo>;
};

/**
 * Version of {@link countries} for method parameters.
 *
 * Contains information about countries
 */
export type countries$Input = {
  readonly _: "countries";

  /**
   * The list of countries
   * @type {vector<countryInfo>} {@link vector<countryInfo>}
   */
  readonly countries?: vector$Input<countryInfo$Input>;
};

/**
 * Contains information about a phone number
 */
export type phoneNumberInfo = {
  _: "phoneNumberInfo";

  /**
   * Information about the country to which the phone number belongs; may be null
   * @type {countryInfo} {@link countryInfo}
   */
  country: countryInfo | null;

  /**
   * The part of the phone number denoting country calling code or its part
   * @type {string} {@link string}
   */
  country_calling_code: string;

  /**
   * The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
   * @type {string} {@link string}
   */
  formatted_phone_number: string;

  /**
   * True, if the phone number was bought on Fragment and isn't tied to a SIM card
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;
};

/**
 * Version of {@link phoneNumberInfo} for method parameters.
 *
 * Contains information about a phone number
 */
export type phoneNumberInfo$Input = {
  readonly _: "phoneNumberInfo";

  /**
   * Information about the country to which the phone number belongs; may be null
   * @type {countryInfo} {@link countryInfo}
   */
  readonly country?: countryInfo$Input | null;

  /**
   * The part of the phone number denoting country calling code or its part
   * @type {string} {@link string}
   */
  readonly country_calling_code?: string;

  /**
   * The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
   * @type {string} {@link string}
   */
  readonly formatted_phone_number?: string;

  /**
   * True, if the phone number was bought on Fragment and isn't tied to a SIM card
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;
};

/**
 * Describes an action associated with a bank card number
 */
export type bankCardActionOpenUrl = {
  _: "bankCardActionOpenUrl";

  /**
   * Action text
   * @type {string} {@link string}
   */
  text: string;

  /**
   * The URL to be opened
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link bankCardActionOpenUrl} for method parameters.
 *
 * Describes an action associated with a bank card number
 */
export type bankCardActionOpenUrl$Input = {
  readonly _: "bankCardActionOpenUrl";

  /**
   * Action text
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * The URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Information about a bank card
 */
export type bankCardInfo = {
  _: "bankCardInfo";

  /**
   * Title of the bank card description
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Actions that can be done with the bank card number
   * @type {vector<bankCardActionOpenUrl>} {@link vector<bankCardActionOpenUrl>}
   */
  actions: vector<bankCardActionOpenUrl>;
};

/**
 * Version of {@link bankCardInfo} for method parameters.
 *
 * Information about a bank card
 */
export type bankCardInfo$Input = {
  readonly _: "bankCardInfo";

  /**
   * Title of the bank card description
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Actions that can be done with the bank card number
   * @type {vector<bankCardActionOpenUrl>} {@link vector<bankCardActionOpenUrl>}
   */
  readonly actions?: vector$Input<bankCardActionOpenUrl$Input>;
};

/**
 * Describes an address
 */
export type address = {
  _: "address";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  country_code: string;

  /**
   * State, if applicable
   * @type {string} {@link string}
   */
  state: string;

  /**
   * City
   * @type {string} {@link string}
   */
  city: string;

  /**
   * First line of the address
   * @type {string} {@link string}
   */
  street_line1: string;

  /**
   * Second line of the address
   * @type {string} {@link string}
   */
  street_line2: string;

  /**
   * Address postal code
   * @type {string} {@link string}
   */
  postal_code: string;
};

/**
 * Version of {@link address} for method parameters.
 *
 * Describes an address
 */
export type address$Input = {
  readonly _: "address";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;

  /**
   * State, if applicable
   * @type {string} {@link string}
   */
  readonly state?: string;

  /**
   * City
   * @type {string} {@link string}
   */
  readonly city?: string;

  /**
   * First line of the address
   * @type {string} {@link string}
   */
  readonly street_line1?: string;

  /**
   * Second line of the address
   * @type {string} {@link string}
   */
  readonly street_line2?: string;

  /**
   * Address postal code
   * @type {string} {@link string}
   */
  readonly postal_code?: string;
};

/**
 * Contains parameters of the application theme
 */
export type themeParameters = {
  _: "themeParameters";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  background_color: int32;

  /**
   * A secondary color for the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  secondary_background_color: int32;

  /**
   * A color of the header background in the RGB24 format
   * @type {int32} {@link int32}
   */
  header_background_color: int32;

  /**
   * A color of the section background in the RGB24 format
   * @type {int32} {@link int32}
   */
  section_background_color: int32;

  /**
   * A color of text in the RGB24 format
   * @type {int32} {@link int32}
   */
  text_color: int32;

  /**
   * An accent color of the text in the RGB24 format
   * @type {int32} {@link int32}
   */
  accent_text_color: int32;

  /**
   * A color of text on the section headers in the RGB24 format
   * @type {int32} {@link int32}
   */
  section_header_text_color: int32;

  /**
   * A color of the subtitle text in the RGB24 format
   * @type {int32} {@link int32}
   */
  subtitle_text_color: int32;

  /**
   * A color of the text for destructive actions in the RGB24 format
   * @type {int32} {@link int32}
   */
  destructive_text_color: int32;

  /**
   * A color of hints in the RGB24 format
   * @type {int32} {@link int32}
   */
  hint_color: int32;

  /**
   * A color of links in the RGB24 format
   * @type {int32} {@link int32}
   */
  link_color: int32;

  /**
   * A color of the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  button_color: int32;

  /**
   * A color of text on the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  button_text_color: int32;
};

/**
 * Version of {@link themeParameters} for method parameters.
 *
 * Contains parameters of the application theme
 */
export type themeParameters$Input = {
  readonly _: "themeParameters";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly background_color?: int32;

  /**
   * A secondary color for the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly secondary_background_color?: int32;

  /**
   * A color of the header background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly header_background_color?: int32;

  /**
   * A color of the section background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly section_background_color?: int32;

  /**
   * A color of text in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly text_color?: int32;

  /**
   * An accent color of the text in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly accent_text_color?: int32;

  /**
   * A color of text on the section headers in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly section_header_text_color?: int32;

  /**
   * A color of the subtitle text in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly subtitle_text_color?: int32;

  /**
   * A color of the text for destructive actions in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly destructive_text_color?: int32;

  /**
   * A color of hints in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly hint_color?: int32;

  /**
   * A color of links in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly link_color?: int32;

  /**
   * A color of the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly button_color?: int32;

  /**
   * A color of text on the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly button_text_color?: int32;
};

/**
 * Portion of the price of a product (e.g., "delivery cost", "tax amount")
 */
export type labeledPricePart = {
  _: "labeledPricePart";

  /**
   * Label for this portion of the product price
   * @type {string} {@link string}
   */
  label: string;

  /**
   * Currency amount in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;
};

/**
 * Version of {@link labeledPricePart} for method parameters.
 *
 * Portion of the price of a product (e.g., "delivery cost", "tax amount")
 */
export type labeledPricePart$Input = {
  readonly _: "labeledPricePart";

  /**
   * Label for this portion of the product price
   * @type {string} {@link string}
   */
  readonly label?: string;

  /**
   * Currency amount in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;
};

/**
 * Product invoice
 */
export type invoice = {
  _: "invoice";

  /**
   * ISO 4217 currency code
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * A list of objects used to calculate the total price of the product
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  price_parts: vector<labeledPricePart>;

  /**
   * The maximum allowed amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  max_tip_amount: int53;

  /**
   * Suggested amounts of tip in the smallest units of the currency
   * @type {vector<int53>} {@link vector<int53>}
   */
  suggested_tip_amounts: vector<int53>;

  /**
   * An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
   * @type {string} {@link string}
   */
  recurring_payment_terms_of_service_url: string;

  /**
   * An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
   * @type {string} {@link string}
   */
  terms_of_service_url: string;

  /**
   * True, if the payment is a test payment
   * @type {Bool} {@link Bool}
   */
  is_test: Bool;

  /**
   * True, if the user's name is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_name: Bool;

  /**
   * True, if the user's phone number is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_phone_number: Bool;

  /**
   * True, if the user's email address is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_email_address: Bool;

  /**
   * True, if the user's shipping address is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_shipping_address: Bool;

  /**
   * True, if the user's phone number will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  send_phone_number_to_provider: Bool;

  /**
   * True, if the user's email address will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  send_email_address_to_provider: Bool;

  /**
   * True, if the total price depends on the shipping method
   * @type {Bool} {@link Bool}
   */
  is_flexible: Bool;
};

/**
 * Version of {@link invoice} for method parameters.
 *
 * Product invoice
 */
export type invoice$Input = {
  readonly _: "invoice";

  /**
   * ISO 4217 currency code
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * A list of objects used to calculate the total price of the product
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  readonly price_parts?: vector$Input<labeledPricePart$Input>;

  /**
   * The maximum allowed amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly max_tip_amount?: int53;

  /**
   * Suggested amounts of tip in the smallest units of the currency
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly suggested_tip_amounts?: vector$Input<int53>;

  /**
   * An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
   * @type {string} {@link string}
   */
  readonly recurring_payment_terms_of_service_url?: string;

  /**
   * An HTTP URL with terms of service for non-recurring payments. If non-empty, then the user must accept the terms of service before allowed to pay
   * @type {string} {@link string}
   */
  readonly terms_of_service_url?: string;

  /**
   * True, if the payment is a test payment
   * @type {Bool} {@link Bool}
   */
  readonly is_test?: Bool$Input;

  /**
   * True, if the user's name is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_name?: Bool$Input;

  /**
   * True, if the user's phone number is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_phone_number?: Bool$Input;

  /**
   * True, if the user's email address is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_email_address?: Bool$Input;

  /**
   * True, if the user's shipping address is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_shipping_address?: Bool$Input;

  /**
   * True, if the user's phone number will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  readonly send_phone_number_to_provider?: Bool$Input;

  /**
   * True, if the user's email address will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  readonly send_email_address_to_provider?: Bool$Input;

  /**
   * True, if the total price depends on the shipping method
   * @type {Bool} {@link Bool}
   */
  readonly is_flexible?: Bool$Input;
};

/**
 * Order information
 */
export type orderInfo = {
  _: "orderInfo";

  /**
   * Name of the user
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * Email address of the user
   * @type {string} {@link string}
   */
  email_address: string;

  /**
   * Shipping address for this order; may be null
   * @type {address} {@link address}
   */
  shipping_address: address | null;
};

/**
 * Version of {@link orderInfo} for method parameters.
 *
 * Order information
 */
export type orderInfo$Input = {
  readonly _: "orderInfo";

  /**
   * Name of the user
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Email address of the user
   * @type {string} {@link string}
   */
  readonly email_address?: string;

  /**
   * Shipping address for this order; may be null
   * @type {address} {@link address}
   */
  readonly shipping_address?: address$Input | null;
};

/**
 * One shipping option
 */
export type shippingOption = {
  _: "shippingOption";

  /**
   * Shipping option identifier
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Option title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * A list of objects used to calculate the total shipping costs
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  price_parts: vector<labeledPricePart>;
};

/**
 * Version of {@link shippingOption} for method parameters.
 *
 * One shipping option
 */
export type shippingOption$Input = {
  readonly _: "shippingOption";

  /**
   * Shipping option identifier
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Option title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * A list of objects used to calculate the total shipping costs
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  readonly price_parts?: vector$Input<labeledPricePart$Input>;
};

/**
 * Contains information about saved payment credentials
 */
export type savedCredentials = {
  _: "savedCredentials";

  /**
   * Unique identifier of the saved credentials
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the saved credentials
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link savedCredentials} for method parameters.
 *
 * Contains information about saved payment credentials
 */
export type savedCredentials$Input = {
  readonly _: "savedCredentials";

  /**
   * Unique identifier of the saved credentials
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the saved credentials
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
 */
export type inputCredentialsSaved = {
  _: "inputCredentialsSaved";

  /**
   * Identifier of the saved credentials
   * @type {string} {@link string}
   */
  saved_credentials_id: string;
};

/**
 * Version of {@link inputCredentialsSaved} for method parameters.
 *
 * Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
 */
export type inputCredentialsSaved$Input = {
  readonly _: "inputCredentialsSaved";

  /**
   * Identifier of the saved credentials
   * @type {string} {@link string}
   */
  readonly saved_credentials_id?: string;
};

/**
 * Applies if a user enters new credentials on a payment provider website
 */
export type inputCredentialsNew = {
  _: "inputCredentialsNew";

  /**
   * JSON-encoded data with the credential identifier from the payment provider
   * @type {string} {@link string}
   */
  data: string;

  /**
   * True, if the credential identifier can be saved on the server side
   * @type {Bool} {@link Bool}
   */
  allow_save: Bool;
};

/**
 * Version of {@link inputCredentialsNew} for method parameters.
 *
 * Applies if a user enters new credentials on a payment provider website
 */
export type inputCredentialsNew$Input = {
  readonly _: "inputCredentialsNew";

  /**
   * JSON-encoded data with the credential identifier from the payment provider
   * @type {string} {@link string}
   */
  readonly data?: string;

  /**
   * True, if the credential identifier can be saved on the server side
   * @type {Bool} {@link Bool}
   */
  readonly allow_save?: Bool$Input;
};

/**
 * Applies if a user enters new credentials using Apple Pay
 */
export type inputCredentialsApplePay = {
  _: "inputCredentialsApplePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  data: string;
};

/**
 * Version of {@link inputCredentialsApplePay} for method parameters.
 *
 * Applies if a user enters new credentials using Apple Pay
 */
export type inputCredentialsApplePay$Input = {
  readonly _: "inputCredentialsApplePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Applies if a user enters new credentials using Google Pay
 */
export type inputCredentialsGooglePay = {
  _: "inputCredentialsGooglePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  data: string;
};

/**
 * Version of {@link inputCredentialsGooglePay} for method parameters.
 *
 * Applies if a user enters new credentials using Google Pay
 */
export type inputCredentialsGooglePay$Input = {
  readonly _: "inputCredentialsGooglePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Smart Glocal payment provider
 */
export type paymentProviderSmartGlocal = {
  _: "paymentProviderSmartGlocal";

  /**
   * Public payment token
   * @type {string} {@link string}
   */
  public_token: string;

  /**
   * URL for sending card tokenization requests
   * @type {string} {@link string}
   */
  tokenize_url: string;
};

/**
 * Version of {@link paymentProviderSmartGlocal} for method parameters.
 *
 * Smart Glocal payment provider
 */
export type paymentProviderSmartGlocal$Input = {
  readonly _: "paymentProviderSmartGlocal";

  /**
   * Public payment token
   * @type {string} {@link string}
   */
  readonly public_token?: string;

  /**
   * URL for sending card tokenization requests
   * @type {string} {@link string}
   */
  readonly tokenize_url?: string;
};

/**
 * Stripe payment provider
 */
export type paymentProviderStripe = {
  _: "paymentProviderStripe";

  /**
   * Stripe API publishable key
   * @type {string} {@link string}
   */
  publishable_key: string;

  /**
   * True, if the user country must be provided
   * @type {Bool} {@link Bool}
   */
  need_country: Bool;

  /**
   * True, if the user ZIP/postal code must be provided
   * @type {Bool} {@link Bool}
   */
  need_postal_code: Bool;

  /**
   * True, if the cardholder name must be provided
   * @type {Bool} {@link Bool}
   */
  need_cardholder_name: Bool;
};

/**
 * Version of {@link paymentProviderStripe} for method parameters.
 *
 * Stripe payment provider
 */
export type paymentProviderStripe$Input = {
  readonly _: "paymentProviderStripe";

  /**
   * Stripe API publishable key
   * @type {string} {@link string}
   */
  readonly publishable_key?: string;

  /**
   * True, if the user country must be provided
   * @type {Bool} {@link Bool}
   */
  readonly need_country?: Bool$Input;

  /**
   * True, if the user ZIP/postal code must be provided
   * @type {Bool} {@link Bool}
   */
  readonly need_postal_code?: Bool$Input;

  /**
   * True, if the cardholder name must be provided
   * @type {Bool} {@link Bool}
   */
  readonly need_cardholder_name?: Bool$Input;
};

/**
 * Some other payment provider, for which a web payment form must be shown
 */
export type paymentProviderOther = {
  _: "paymentProviderOther";

  /**
   * Payment form URL
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link paymentProviderOther} for method parameters.
 *
 * Some other payment provider, for which a web payment form must be shown
 */
export type paymentProviderOther$Input = {
  readonly _: "paymentProviderOther";

  /**
   * Payment form URL
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Describes an additional payment option
 */
export type paymentOption = {
  _: "paymentOption";

  /**
   * Title for the payment option
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Payment form URL to be opened in a web view
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link paymentOption} for method parameters.
 *
 * Describes an additional payment option
 */
export type paymentOption$Input = {
  readonly _: "paymentOption";

  /**
   * Title for the payment option
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Payment form URL to be opened in a web view
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Contains information about an invoice payment form
 */
export type paymentForm = {
  _: "paymentForm";

  /**
   * The payment form identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Full information about the invoice
   * @type {invoice} {@link invoice}
   */
  invoice: invoice;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  seller_bot_user_id: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  payment_provider_user_id: int53;

  /**
   * Information about the payment provider
   * @type {PaymentProvider} {@link PaymentProvider}
   */
  payment_provider: PaymentProvider;

  /**
   * The list of additional payment options
   * @type {vector<paymentOption>} {@link vector<paymentOption>}
   */
  additional_payment_options: vector<paymentOption>;

  /**
   * Saved server-side order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  saved_order_info: orderInfo | null;

  /**
   * The list of saved payment credentials
   * @type {vector<savedCredentials>} {@link vector<savedCredentials>}
   */
  saved_credentials: vector<savedCredentials>;

  /**
   * True, if the user can choose to save credentials
   * @type {Bool} {@link Bool}
   */
  can_save_credentials: Bool;

  /**
   * True, if the user will be able to save credentials, if sets up a 2-step verification password
   * @type {Bool} {@link Bool}
   */
  need_password: Bool;

  /**
   * Product title
   * @type {string} {@link string}
   */
  product_title: string;

  /**
   * Product description
   * @type {formattedText} {@link formattedText}
   */
  product_description: formattedText;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  product_photo: photo | null;
};

/**
 * Version of {@link paymentForm} for method parameters.
 *
 * Contains information about an invoice payment form
 */
export type paymentForm$Input = {
  readonly _: "paymentForm";

  /**
   * The payment form identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Full information about the invoice
   * @type {invoice} {@link invoice}
   */
  readonly invoice?: invoice$Input;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  readonly seller_bot_user_id?: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  readonly payment_provider_user_id?: int53;

  /**
   * Information about the payment provider
   * @type {PaymentProvider} {@link PaymentProvider}
   */
  readonly payment_provider?: PaymentProvider$Input;

  /**
   * The list of additional payment options
   * @type {vector<paymentOption>} {@link vector<paymentOption>}
   */
  readonly additional_payment_options?: vector$Input<paymentOption$Input>;

  /**
   * Saved server-side order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly saved_order_info?: orderInfo$Input | null;

  /**
   * The list of saved payment credentials
   * @type {vector<savedCredentials>} {@link vector<savedCredentials>}
   */
  readonly saved_credentials?: vector$Input<savedCredentials$Input>;

  /**
   * True, if the user can choose to save credentials
   * @type {Bool} {@link Bool}
   */
  readonly can_save_credentials?: Bool$Input;

  /**
   * True, if the user will be able to save credentials, if sets up a 2-step verification password
   * @type {Bool} {@link Bool}
   */
  readonly need_password?: Bool$Input;

  /**
   * Product title
   * @type {string} {@link string}
   */
  readonly product_title?: string;

  /**
   * Product description
   * @type {formattedText} {@link formattedText}
   */
  readonly product_description?: formattedText$Input;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  readonly product_photo?: photo$Input | null;
};

/**
 * Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options
 */
export type validatedOrderInfo = {
  _: "validatedOrderInfo";

  /**
   * Temporary identifier of the order information
   * @type {string} {@link string}
   */
  order_info_id: string;

  /**
   * Available shipping options
   * @type {vector<shippingOption>} {@link vector<shippingOption>}
   */
  shipping_options: vector<shippingOption>;
};

/**
 * Version of {@link validatedOrderInfo} for method parameters.
 *
 * Contains a temporary identifier of validated order information, which is stored for one hour, and the available shipping options
 */
export type validatedOrderInfo$Input = {
  readonly _: "validatedOrderInfo";

  /**
   * Temporary identifier of the order information
   * @type {string} {@link string}
   */
  readonly order_info_id?: string;

  /**
   * Available shipping options
   * @type {vector<shippingOption>} {@link vector<shippingOption>}
   */
  readonly shipping_options?: vector$Input<shippingOption$Input>;
};

/**
 * Contains the result of a payment request
 */
export type paymentResult = {
  _: "paymentResult";

  /**
   * True, if the payment request was successful; otherwise, the verification_url will be non-empty
   * @type {Bool} {@link Bool}
   */
  success: Bool;

  /**
   * URL for additional payment credentials verification
   * @type {string} {@link string}
   */
  verification_url: string;
};

/**
 * Version of {@link paymentResult} for method parameters.
 *
 * Contains the result of a payment request
 */
export type paymentResult$Input = {
  readonly _: "paymentResult";

  /**
   * True, if the payment request was successful; otherwise, the verification_url will be non-empty
   * @type {Bool} {@link Bool}
   */
  readonly success?: Bool$Input;

  /**
   * URL for additional payment credentials verification
   * @type {string} {@link string}
   */
  readonly verification_url?: string;
};

/**
 * Contains information about a successful payment
 */
export type paymentReceipt = {
  _: "paymentReceipt";

  /**
   * Product title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Contains information about a successful payment
   * @type {formattedText} {@link formattedText}
   */
  description: formattedText;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * Point in time (Unix timestamp) when the payment was made
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  seller_bot_user_id: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  payment_provider_user_id: int53;

  /**
   * Information about the invoice
   * @type {invoice} {@link invoice}
   */
  invoice: invoice;

  /**
   * Order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  order_info: orderInfo | null;

  /**
   * Chosen shipping option; may be null
   * @type {shippingOption} {@link shippingOption}
   */
  shipping_option: shippingOption | null;

  /**
   * Title of the saved credentials chosen by the buyer
   * @type {string} {@link string}
   */
  credentials_title: string;

  /**
   * The amount of tip chosen by the buyer in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  tip_amount: int53;
};

/**
 * Version of {@link paymentReceipt} for method parameters.
 *
 * Contains information about a successful payment
 */
export type paymentReceipt$Input = {
  readonly _: "paymentReceipt";

  /**
   * Product title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Contains information about a successful payment
   * @type {formattedText} {@link formattedText}
   */
  readonly description?: formattedText$Input;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * Point in time (Unix timestamp) when the payment was made
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  readonly seller_bot_user_id?: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  readonly payment_provider_user_id?: int53;

  /**
   * Information about the invoice
   * @type {invoice} {@link invoice}
   */
  readonly invoice?: invoice$Input;

  /**
   * Order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input | null;

  /**
   * Chosen shipping option; may be null
   * @type {shippingOption} {@link shippingOption}
   */
  readonly shipping_option?: shippingOption$Input | null;

  /**
   * Title of the saved credentials chosen by the buyer
   * @type {string} {@link string}
   */
  readonly credentials_title?: string;

  /**
   * The amount of tip chosen by the buyer in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly tip_amount?: int53;
};

/**
 * An invoice from a message of the type messageInvoice
 */
export type inputInvoiceMessage = {
  _: "inputInvoiceMessage";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link inputInvoiceMessage} for method parameters.
 *
 * An invoice from a message of the type messageInvoice
 */
export type inputInvoiceMessage$Input = {
  readonly _: "inputInvoiceMessage";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * An invoice from a link of the type internalLinkTypeInvoice
 */
export type inputInvoiceName = {
  _: "inputInvoiceName";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  name: string;
};

/**
 * Version of {@link inputInvoiceName} for method parameters.
 *
 * An invoice from a link of the type internalLinkTypeInvoice
 */
export type inputInvoiceName$Input = {
  readonly _: "inputInvoiceName";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * An invoice for a payment toward Telegram; must not be used in the in-store apps
 */
export type inputInvoiceTelegram = {
  _: "inputInvoiceTelegram";

  /**
   * Transaction purpose
   * @type {TelegramPaymentPurpose} {@link TelegramPaymentPurpose}
   */
  purpose: TelegramPaymentPurpose;
};

/**
 * Version of {@link inputInvoiceTelegram} for method parameters.
 *
 * An invoice for a payment toward Telegram; must not be used in the in-store apps
 */
export type inputInvoiceTelegram$Input = {
  readonly _: "inputInvoiceTelegram";

  /**
   * Transaction purpose
   * @type {TelegramPaymentPurpose} {@link TelegramPaymentPurpose}
   */
  readonly purpose?: TelegramPaymentPurpose$Input;
};

/**
 * The media is hidden until the invoice is paid
 */
export type messageExtendedMediaPreview = {
  _: "messageExtendedMediaPreview";

  /**
   * Media width; 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Media height; 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Media duration; 0 if unknown
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Media minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link messageExtendedMediaPreview} for method parameters.
 *
 * The media is hidden until the invoice is paid
 */
export type messageExtendedMediaPreview$Input = {
  readonly _: "messageExtendedMediaPreview";

  /**
   * Media width; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Media height; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Media duration; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Media minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * The media is a photo
 */
export type messageExtendedMediaPhoto = {
  _: "messageExtendedMediaPhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link messageExtendedMediaPhoto} for method parameters.
 *
 * The media is a photo
 */
export type messageExtendedMediaPhoto$Input = {
  readonly _: "messageExtendedMediaPhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * The media is a video
 */
export type messageExtendedMediaVideo = {
  _: "messageExtendedMediaVideo";

  /**
   * The video
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link messageExtendedMediaVideo} for method parameters.
 *
 * The media is a video
 */
export type messageExtendedMediaVideo$Input = {
  readonly _: "messageExtendedMediaVideo";

  /**
   * The video
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * The media is unsupported
 */
export type messageExtendedMediaUnsupported = {
  _: "messageExtendedMediaUnsupported";

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link messageExtendedMediaUnsupported} for method parameters.
 *
 * The media is unsupported
 */
export type messageExtendedMediaUnsupported$Input = {
  readonly _: "messageExtendedMediaUnsupported";

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * Describes parameters of a Telegram Premium giveaway
 */
export type premiumGiveawayParameters = {
  _: "premiumGiveawayParameters";

  /**
   * Identifier of the channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Premium subscription
   * @type {int53} {@link int53}
   */
  boosted_chat_id: int53;

  /**
   * Identifiers of other channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
   * @type {vector<int53>} {@link vector<int53>}
   */
  additional_chat_ids: vector<int53>;

  /**
   * Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
   * @type {int32} {@link int32}
   */
  winners_selection_date: int32;

  /**
   * True, if only new members of the chats will be eligible for the giveaway
   * @type {Bool} {@link Bool}
   */
  only_new_members: Bool;

  /**
   * True, if the list of winners of the giveaway will be available to everyone
   * @type {Bool} {@link Bool}
   */
  has_public_winners: Bool;

  /**
   * The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway.
   *
   * - There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought on Fragment can participate in any giveaway and the country code "FT" must not be specified in the list
   * @type {vector<string>} {@link vector<string>}
   */
  country_codes: vector<string>;

  /**
   * Additional description of the giveaway prize; 0-128 characters
   * @type {string} {@link string}
   */
  prize_description: string;
};

/**
 * Version of {@link premiumGiveawayParameters} for method parameters.
 *
 * Describes parameters of a Telegram Premium giveaway
 */
export type premiumGiveawayParameters$Input = {
  readonly _: "premiumGiveawayParameters";

  /**
   * Identifier of the channel chat, which will be automatically boosted by the winners of the giveaway for duration of the Premium subscription
   * @type {int53} {@link int53}
   */
  readonly boosted_chat_id?: int53;

  /**
   * Identifiers of other channel chats that must be subscribed by the users to be eligible for the giveaway. There can be up to getOption("giveaway_additional_chat_count_max") additional chats
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly additional_chat_ids?: vector$Input<int53>;

  /**
   * Point in time (Unix timestamp) when the giveaway is expected to be performed; must be 60-getOption("giveaway_duration_max") seconds in the future in scheduled giveaways
   * @type {int32} {@link int32}
   */
  readonly winners_selection_date?: int32;

  /**
   * True, if only new members of the chats will be eligible for the giveaway
   * @type {Bool} {@link Bool}
   */
  readonly only_new_members?: Bool$Input;

  /**
   * True, if the list of winners of the giveaway will be available to everyone
   * @type {Bool} {@link Bool}
   */
  readonly has_public_winners?: Bool$Input;

  /**
   * The list of two-letter ISO 3166-1 alpha-2 codes of countries, users from which will be eligible for the giveaway. If empty, then all users can participate in the giveaway.
   *
   * - There can be up to getOption("giveaway_country_count_max") chosen countries. Users with phone number that was bought on Fragment can participate in any giveaway and the country code "FT" must not be specified in the list
   * @type {vector<string>} {@link vector<string>}
   */
  readonly country_codes?: vector$Input<string>;

  /**
   * Additional description of the giveaway prize; 0-128 characters
   * @type {string} {@link string}
   */
  readonly prize_description?: string;
};

/**
 * File with the date it was uploaded
 */
export type datedFile = {
  _: "datedFile";

  /**
   * The file
   * @type {file} {@link file}
   */
  file: file;

  /**
   * Point in time (Unix timestamp) when the file was uploaded
   * @type {int32} {@link int32}
   */
  date: int32;
};

/**
 * Version of {@link datedFile} for method parameters.
 *
 * File with the date it was uploaded
 */
export type datedFile$Input = {
  readonly _: "datedFile";

  /**
   * The file
   * @type {file} {@link file}
   */
  readonly file?: file$Input;

  /**
   * Point in time (Unix timestamp) when the file was uploaded
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * A Telegram Passport element containing the user's personal details
 */
export type passportElementTypePersonalDetails = {
  _: "passportElementTypePersonalDetails";
};

/**
 * Version of {@link passportElementTypePersonalDetails} for method parameters.
 *
 * A Telegram Passport element containing the user's personal details
 */
export type passportElementTypePersonalDetails$Input = {
  readonly _: "passportElementTypePersonalDetails";
};

/**
 * A Telegram Passport element containing the user's passport
 */
export type passportElementTypePassport = {
  _: "passportElementTypePassport";
};

/**
 * Version of {@link passportElementTypePassport} for method parameters.
 *
 * A Telegram Passport element containing the user's passport
 */
export type passportElementTypePassport$Input = {
  readonly _: "passportElementTypePassport";
};

/**
 * A Telegram Passport element containing the user's driver license
 */
export type passportElementTypeDriverLicense = {
  _: "passportElementTypeDriverLicense";
};

/**
 * Version of {@link passportElementTypeDriverLicense} for method parameters.
 *
 * A Telegram Passport element containing the user's driver license
 */
export type passportElementTypeDriverLicense$Input = {
  readonly _: "passportElementTypeDriverLicense";
};

/**
 * A Telegram Passport element containing the user's identity card
 */
export type passportElementTypeIdentityCard = {
  _: "passportElementTypeIdentityCard";
};

/**
 * Version of {@link passportElementTypeIdentityCard} for method parameters.
 *
 * A Telegram Passport element containing the user's identity card
 */
export type passportElementTypeIdentityCard$Input = {
  readonly _: "passportElementTypeIdentityCard";
};

/**
 * A Telegram Passport element containing the user's internal passport
 */
export type passportElementTypeInternalPassport = {
  _: "passportElementTypeInternalPassport";
};

/**
 * Version of {@link passportElementTypeInternalPassport} for method parameters.
 *
 * A Telegram Passport element containing the user's internal passport
 */
export type passportElementTypeInternalPassport$Input = {
  readonly _: "passportElementTypeInternalPassport";
};

/**
 * A Telegram Passport element containing the user's address
 */
export type passportElementTypeAddress = {
  _: "passportElementTypeAddress";
};

/**
 * Version of {@link passportElementTypeAddress} for method parameters.
 *
 * A Telegram Passport element containing the user's address
 */
export type passportElementTypeAddress$Input = {
  readonly _: "passportElementTypeAddress";
};

/**
 * A Telegram Passport element containing the user's utility bill
 */
export type passportElementTypeUtilityBill = {
  _: "passportElementTypeUtilityBill";
};

/**
 * Version of {@link passportElementTypeUtilityBill} for method parameters.
 *
 * A Telegram Passport element containing the user's utility bill
 */
export type passportElementTypeUtilityBill$Input = {
  readonly _: "passportElementTypeUtilityBill";
};

/**
 * A Telegram Passport element containing the user's bank statement
 */
export type passportElementTypeBankStatement = {
  _: "passportElementTypeBankStatement";
};

/**
 * Version of {@link passportElementTypeBankStatement} for method parameters.
 *
 * A Telegram Passport element containing the user's bank statement
 */
export type passportElementTypeBankStatement$Input = {
  readonly _: "passportElementTypeBankStatement";
};

/**
 * A Telegram Passport element containing the user's rental agreement
 */
export type passportElementTypeRentalAgreement = {
  _: "passportElementTypeRentalAgreement";
};

/**
 * Version of {@link passportElementTypeRentalAgreement} for method parameters.
 *
 * A Telegram Passport element containing the user's rental agreement
 */
export type passportElementTypeRentalAgreement$Input = {
  readonly _: "passportElementTypeRentalAgreement";
};

/**
 * A Telegram Passport element containing the registration page of the user's passport
 */
export type passportElementTypePassportRegistration = {
  _: "passportElementTypePassportRegistration";
};

/**
 * Version of {@link passportElementTypePassportRegistration} for method parameters.
 *
 * A Telegram Passport element containing the registration page of the user's passport
 */
export type passportElementTypePassportRegistration$Input = {
  readonly _: "passportElementTypePassportRegistration";
};

/**
 * A Telegram Passport element containing the user's temporary registration
 */
export type passportElementTypeTemporaryRegistration = {
  _: "passportElementTypeTemporaryRegistration";
};

/**
 * Version of {@link passportElementTypeTemporaryRegistration} for method parameters.
 *
 * A Telegram Passport element containing the user's temporary registration
 */
export type passportElementTypeTemporaryRegistration$Input = {
  readonly _: "passportElementTypeTemporaryRegistration";
};

/**
 * A Telegram Passport element containing the user's phone number
 */
export type passportElementTypePhoneNumber = {
  _: "passportElementTypePhoneNumber";
};

/**
 * Version of {@link passportElementTypePhoneNumber} for method parameters.
 *
 * A Telegram Passport element containing the user's phone number
 */
export type passportElementTypePhoneNumber$Input = {
  readonly _: "passportElementTypePhoneNumber";
};

/**
 * A Telegram Passport element containing the user's email address
 */
export type passportElementTypeEmailAddress = {
  _: "passportElementTypeEmailAddress";
};

/**
 * Version of {@link passportElementTypeEmailAddress} for method parameters.
 *
 * A Telegram Passport element containing the user's email address
 */
export type passportElementTypeEmailAddress$Input = {
  readonly _: "passportElementTypeEmailAddress";
};

/**
 * Represents a date according to the Gregorian calendar
 */
export type date = {
  _: "date";

  /**
   * Day of the month; 1-31
   * @type {int32} {@link int32}
   */
  day: int32;

  /**
   * Month; 1-12
   * @type {int32} {@link int32}
   */
  month: int32;

  /**
   * Year; 1-9999
   * @type {int32} {@link int32}
   */
  year: int32;
};

/**
 * Version of {@link date} for method parameters.
 *
 * Represents a date according to the Gregorian calendar
 */
export type date$Input = {
  readonly _: "date";

  /**
   * Day of the month; 1-31
   * @type {int32} {@link int32}
   */
  readonly day?: int32;

  /**
   * Month; 1-12
   * @type {int32} {@link int32}
   */
  readonly month?: int32;

  /**
   * Year; 1-9999
   * @type {int32} {@link int32}
   */
  readonly year?: int32;
};

/**
 * Contains the user's personal details
 */
export type personalDetails = {
  _: "personalDetails";

  /**
   * First name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  first_name: string;

  /**
   * Middle name of the user written in English; 0-255 characters
   * @type {string} {@link string}
   */
  middle_name: string;

  /**
   * Last name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  last_name: string;

  /**
   * Native first name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  native_first_name: string;

  /**
   * Native middle name of the user; 0-255 characters
   * @type {string} {@link string}
   */
  native_middle_name: string;

  /**
   * Native last name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  native_last_name: string;

  /**
   * Birthdate of the user
   * @type {date} {@link date}
   */
  birthdate: date;

  /**
   * Gender of the user, "male" or "female"
   * @type {string} {@link string}
   */
  gender: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's country
   * @type {string} {@link string}
   */
  country_code: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
   * @type {string} {@link string}
   */
  residence_country_code: string;
};

/**
 * Version of {@link personalDetails} for method parameters.
 *
 * Contains the user's personal details
 */
export type personalDetails$Input = {
  readonly _: "personalDetails";

  /**
   * First name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * Middle name of the user written in English; 0-255 characters
   * @type {string} {@link string}
   */
  readonly middle_name?: string;

  /**
   * Last name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;

  /**
   * Native first name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  readonly native_first_name?: string;

  /**
   * Native middle name of the user; 0-255 characters
   * @type {string} {@link string}
   */
  readonly native_middle_name?: string;

  /**
   * Native last name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  readonly native_last_name?: string;

  /**
   * Birthdate of the user
   * @type {date} {@link date}
   */
  readonly birthdate?: date$Input;

  /**
   * Gender of the user, "male" or "female"
   * @type {string} {@link string}
   */
  readonly gender?: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's country
   * @type {string} {@link string}
   */
  readonly country_code?: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
   * @type {string} {@link string}
   */
  readonly residence_country_code?: string;
};

/**
 * An identity document
 */
export type identityDocument = {
  _: "identityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  number: string;

  /**
   * Document expiration date; may be null if not applicable
   * @type {date} {@link date}
   */
  expiration_date: date | null;

  /**
   * Front side of the document
   * @type {datedFile} {@link datedFile}
   */
  front_side: datedFile;

  /**
   * Reverse side of the document; only for driver license and identity card; may be null
   * @type {datedFile} {@link datedFile}
   */
  reverse_side: datedFile | null;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  selfie: datedFile | null;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  translation: vector<datedFile>;
};

/**
 * Version of {@link identityDocument} for method parameters.
 *
 * An identity document
 */
export type identityDocument$Input = {
  readonly _: "identityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  readonly number?: string;

  /**
   * Document expiration date; may be null if not applicable
   * @type {date} {@link date}
   */
  readonly expiration_date?: date$Input | null;

  /**
   * Front side of the document
   * @type {datedFile} {@link datedFile}
   */
  readonly front_side?: datedFile$Input;

  /**
   * Reverse side of the document; only for driver license and identity card; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly reverse_side?: datedFile$Input | null;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly selfie?: datedFile$Input | null;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly translation?: vector$Input<datedFile$Input>;
};

/**
 * An identity document to be saved to Telegram Passport
 */
export type inputIdentityDocument = {
  _: "inputIdentityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  number: string;

  /**
   * Document expiration date; pass null if not applicable
   * @type {date} {@link date}
   */
  expiration_date: date | null;

  /**
   * Front side of the document
   * @type {InputFile} {@link InputFile}
   */
  front_side: InputFile;

  /**
   * Reverse side of the document; only for driver license and identity card; pass null otherwise
   * @type {InputFile} {@link InputFile}
   */
  reverse_side: InputFile | null;

  /**
   * Selfie with the document; pass null if unavailable
   * @type {InputFile} {@link InputFile}
   */
  selfie: InputFile | null;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  translation: vector<InputFile>;
};

/**
 * Version of {@link inputIdentityDocument} for method parameters.
 *
 * An identity document to be saved to Telegram Passport
 */
export type inputIdentityDocument$Input = {
  readonly _: "inputIdentityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  readonly number?: string;

  /**
   * Document expiration date; pass null if not applicable
   * @type {date} {@link date}
   */
  readonly expiration_date?: date$Input | null;

  /**
   * Front side of the document
   * @type {InputFile} {@link InputFile}
   */
  readonly front_side?: InputFile$Input;

  /**
   * Reverse side of the document; only for driver license and identity card; pass null otherwise
   * @type {InputFile} {@link InputFile}
   */
  readonly reverse_side?: InputFile$Input | null;

  /**
   * Selfie with the document; pass null if unavailable
   * @type {InputFile} {@link InputFile}
   */
  readonly selfie?: InputFile$Input | null;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  readonly translation?: vector$Input<InputFile$Input>;
};

/**
 * A personal document, containing some information about a user
 */
export type personalDocument = {
  _: "personalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  files: vector<datedFile>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  translation: vector<datedFile>;
};

/**
 * Version of {@link personalDocument} for method parameters.
 *
 * A personal document, containing some information about a user
 */
export type personalDocument$Input = {
  readonly _: "personalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly files?: vector$Input<datedFile$Input>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly translation?: vector$Input<datedFile$Input>;
};

/**
 * A personal document to be saved to Telegram Passport
 */
export type inputPersonalDocument = {
  _: "inputPersonalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  files: vector<InputFile>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  translation: vector<InputFile>;
};

/**
 * Version of {@link inputPersonalDocument} for method parameters.
 *
 * A personal document to be saved to Telegram Passport
 */
export type inputPersonalDocument$Input = {
  readonly _: "inputPersonalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  readonly files?: vector$Input<InputFile$Input>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  readonly translation?: vector$Input<InputFile$Input>;
};

/**
 * A Telegram Passport element containing the user's personal details
 */
export type passportElementPersonalDetails = {
  _: "passportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  personal_details: personalDetails;
};

/**
 * Version of {@link passportElementPersonalDetails} for method parameters.
 *
 * A Telegram Passport element containing the user's personal details
 */
export type passportElementPersonalDetails$Input = {
  readonly _: "passportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  readonly personal_details?: personalDetails$Input;
};

/**
 * A Telegram Passport element containing the user's passport
 */
export type passportElementPassport = {
  _: "passportElementPassport";

  /**
   * Passport
   * @type {identityDocument} {@link identityDocument}
   */
  passport: identityDocument;
};

/**
 * Version of {@link passportElementPassport} for method parameters.
 *
 * A Telegram Passport element containing the user's passport
 */
export type passportElementPassport$Input = {
  readonly _: "passportElementPassport";

  /**
   * Passport
   * @type {identityDocument} {@link identityDocument}
   */
  readonly passport?: identityDocument$Input;
};

/**
 * A Telegram Passport element containing the user's driver license
 */
export type passportElementDriverLicense = {
  _: "passportElementDriverLicense";

  /**
   * Driver license
   * @type {identityDocument} {@link identityDocument}
   */
  driver_license: identityDocument;
};

/**
 * Version of {@link passportElementDriverLicense} for method parameters.
 *
 * A Telegram Passport element containing the user's driver license
 */
export type passportElementDriverLicense$Input = {
  readonly _: "passportElementDriverLicense";

  /**
   * Driver license
   * @type {identityDocument} {@link identityDocument}
   */
  readonly driver_license?: identityDocument$Input;
};

/**
 * A Telegram Passport element containing the user's identity card
 */
export type passportElementIdentityCard = {
  _: "passportElementIdentityCard";

  /**
   * Identity card
   * @type {identityDocument} {@link identityDocument}
   */
  identity_card: identityDocument;
};

/**
 * Version of {@link passportElementIdentityCard} for method parameters.
 *
 * A Telegram Passport element containing the user's identity card
 */
export type passportElementIdentityCard$Input = {
  readonly _: "passportElementIdentityCard";

  /**
   * Identity card
   * @type {identityDocument} {@link identityDocument}
   */
  readonly identity_card?: identityDocument$Input;
};

/**
 * A Telegram Passport element containing the user's internal passport
 */
export type passportElementInternalPassport = {
  _: "passportElementInternalPassport";

  /**
   * Internal passport
   * @type {identityDocument} {@link identityDocument}
   */
  internal_passport: identityDocument;
};

/**
 * Version of {@link passportElementInternalPassport} for method parameters.
 *
 * A Telegram Passport element containing the user's internal passport
 */
export type passportElementInternalPassport$Input = {
  readonly _: "passportElementInternalPassport";

  /**
   * Internal passport
   * @type {identityDocument} {@link identityDocument}
   */
  readonly internal_passport?: identityDocument$Input;
};

/**
 * A Telegram Passport element containing the user's address
 */
export type passportElementAddress = {
  _: "passportElementAddress";

  /**
   * Address
   * @type {address} {@link address}
   */
  address: address;
};

/**
 * Version of {@link passportElementAddress} for method parameters.
 *
 * A Telegram Passport element containing the user's address
 */
export type passportElementAddress$Input = {
  readonly _: "passportElementAddress";

  /**
   * Address
   * @type {address} {@link address}
   */
  readonly address?: address$Input;
};

/**
 * A Telegram Passport element containing the user's utility bill
 */
export type passportElementUtilityBill = {
  _: "passportElementUtilityBill";

  /**
   * Utility bill
   * @type {personalDocument} {@link personalDocument}
   */
  utility_bill: personalDocument;
};

/**
 * Version of {@link passportElementUtilityBill} for method parameters.
 *
 * A Telegram Passport element containing the user's utility bill
 */
export type passportElementUtilityBill$Input = {
  readonly _: "passportElementUtilityBill";

  /**
   * Utility bill
   * @type {personalDocument} {@link personalDocument}
   */
  readonly utility_bill?: personalDocument$Input;
};

/**
 * A Telegram Passport element containing the user's bank statement
 */
export type passportElementBankStatement = {
  _: "passportElementBankStatement";

  /**
   * Bank statement
   * @type {personalDocument} {@link personalDocument}
   */
  bank_statement: personalDocument;
};

/**
 * Version of {@link passportElementBankStatement} for method parameters.
 *
 * A Telegram Passport element containing the user's bank statement
 */
export type passportElementBankStatement$Input = {
  readonly _: "passportElementBankStatement";

  /**
   * Bank statement
   * @type {personalDocument} {@link personalDocument}
   */
  readonly bank_statement?: personalDocument$Input;
};

/**
 * A Telegram Passport element containing the user's rental agreement
 */
export type passportElementRentalAgreement = {
  _: "passportElementRentalAgreement";

  /**
   * Rental agreement
   * @type {personalDocument} {@link personalDocument}
   */
  rental_agreement: personalDocument;
};

/**
 * Version of {@link passportElementRentalAgreement} for method parameters.
 *
 * A Telegram Passport element containing the user's rental agreement
 */
export type passportElementRentalAgreement$Input = {
  readonly _: "passportElementRentalAgreement";

  /**
   * Rental agreement
   * @type {personalDocument} {@link personalDocument}
   */
  readonly rental_agreement?: personalDocument$Input;
};

/**
 * A Telegram Passport element containing the user's passport registration pages
 */
export type passportElementPassportRegistration = {
  _: "passportElementPassportRegistration";

  /**
   * Passport registration pages
   * @type {personalDocument} {@link personalDocument}
   */
  passport_registration: personalDocument;
};

/**
 * Version of {@link passportElementPassportRegistration} for method parameters.
 *
 * A Telegram Passport element containing the user's passport registration pages
 */
export type passportElementPassportRegistration$Input = {
  readonly _: "passportElementPassportRegistration";

  /**
   * Passport registration pages
   * @type {personalDocument} {@link personalDocument}
   */
  readonly passport_registration?: personalDocument$Input;
};

/**
 * A Telegram Passport element containing the user's temporary registration
 */
export type passportElementTemporaryRegistration = {
  _: "passportElementTemporaryRegistration";

  /**
   * Temporary registration
   * @type {personalDocument} {@link personalDocument}
   */
  temporary_registration: personalDocument;
};

/**
 * Version of {@link passportElementTemporaryRegistration} for method parameters.
 *
 * A Telegram Passport element containing the user's temporary registration
 */
export type passportElementTemporaryRegistration$Input = {
  readonly _: "passportElementTemporaryRegistration";

  /**
   * Temporary registration
   * @type {personalDocument} {@link personalDocument}
   */
  readonly temporary_registration?: personalDocument$Input;
};

/**
 * A Telegram Passport element containing the user's phone number
 */
export type passportElementPhoneNumber = {
  _: "passportElementPhoneNumber";

  /**
   * Phone number
   * @type {string} {@link string}
   */
  phone_number: string;
};

/**
 * Version of {@link passportElementPhoneNumber} for method parameters.
 *
 * A Telegram Passport element containing the user's phone number
 */
export type passportElementPhoneNumber$Input = {
  readonly _: "passportElementPhoneNumber";

  /**
   * Phone number
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * A Telegram Passport element containing the user's email address
 */
export type passportElementEmailAddress = {
  _: "passportElementEmailAddress";

  /**
   * Email address
   * @type {string} {@link string}
   */
  email_address: string;
};

/**
 * Version of {@link passportElementEmailAddress} for method parameters.
 *
 * A Telegram Passport element containing the user's email address
 */
export type passportElementEmailAddress$Input = {
  readonly _: "passportElementEmailAddress";

  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * A Telegram Passport element to be saved containing the user's personal details
 */
export type inputPassportElementPersonalDetails = {
  _: "inputPassportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  personal_details: personalDetails;
};

/**
 * Version of {@link inputPassportElementPersonalDetails} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's personal details
 */
export type inputPassportElementPersonalDetails$Input = {
  readonly _: "inputPassportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  readonly personal_details?: personalDetails$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's passport
 */
export type inputPassportElementPassport = {
  _: "inputPassportElementPassport";

  /**
   * The passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  passport: inputIdentityDocument;
};

/**
 * Version of {@link inputPassportElementPassport} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's passport
 */
export type inputPassportElementPassport$Input = {
  readonly _: "inputPassportElementPassport";

  /**
   * The passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly passport?: inputIdentityDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's driver license
 */
export type inputPassportElementDriverLicense = {
  _: "inputPassportElementDriverLicense";

  /**
   * The driver license to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  driver_license: inputIdentityDocument;
};

/**
 * Version of {@link inputPassportElementDriverLicense} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's driver license
 */
export type inputPassportElementDriverLicense$Input = {
  readonly _: "inputPassportElementDriverLicense";

  /**
   * The driver license to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly driver_license?: inputIdentityDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's identity card
 */
export type inputPassportElementIdentityCard = {
  _: "inputPassportElementIdentityCard";

  /**
   * The identity card to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  identity_card: inputIdentityDocument;
};

/**
 * Version of {@link inputPassportElementIdentityCard} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's identity card
 */
export type inputPassportElementIdentityCard$Input = {
  readonly _: "inputPassportElementIdentityCard";

  /**
   * The identity card to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly identity_card?: inputIdentityDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's internal passport
 */
export type inputPassportElementInternalPassport = {
  _: "inputPassportElementInternalPassport";

  /**
   * The internal passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  internal_passport: inputIdentityDocument;
};

/**
 * Version of {@link inputPassportElementInternalPassport} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's internal passport
 */
export type inputPassportElementInternalPassport$Input = {
  readonly _: "inputPassportElementInternalPassport";

  /**
   * The internal passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly internal_passport?: inputIdentityDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's address
 */
export type inputPassportElementAddress = {
  _: "inputPassportElementAddress";

  /**
   * The address to be saved
   * @type {address} {@link address}
   */
  address: address;
};

/**
 * Version of {@link inputPassportElementAddress} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's address
 */
export type inputPassportElementAddress$Input = {
  readonly _: "inputPassportElementAddress";

  /**
   * The address to be saved
   * @type {address} {@link address}
   */
  readonly address?: address$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's utility bill
 */
export type inputPassportElementUtilityBill = {
  _: "inputPassportElementUtilityBill";

  /**
   * The utility bill to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  utility_bill: inputPersonalDocument;
};

/**
 * Version of {@link inputPassportElementUtilityBill} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's utility bill
 */
export type inputPassportElementUtilityBill$Input = {
  readonly _: "inputPassportElementUtilityBill";

  /**
   * The utility bill to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly utility_bill?: inputPersonalDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's bank statement
 */
export type inputPassportElementBankStatement = {
  _: "inputPassportElementBankStatement";

  /**
   * The bank statement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  bank_statement: inputPersonalDocument;
};

/**
 * Version of {@link inputPassportElementBankStatement} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's bank statement
 */
export type inputPassportElementBankStatement$Input = {
  readonly _: "inputPassportElementBankStatement";

  /**
   * The bank statement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly bank_statement?: inputPersonalDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's rental agreement
 */
export type inputPassportElementRentalAgreement = {
  _: "inputPassportElementRentalAgreement";

  /**
   * The rental agreement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  rental_agreement: inputPersonalDocument;
};

/**
 * Version of {@link inputPassportElementRentalAgreement} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's rental agreement
 */
export type inputPassportElementRentalAgreement$Input = {
  readonly _: "inputPassportElementRentalAgreement";

  /**
   * The rental agreement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly rental_agreement?: inputPersonalDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's passport registration
 */
export type inputPassportElementPassportRegistration = {
  _: "inputPassportElementPassportRegistration";

  /**
   * The passport registration page to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  passport_registration: inputPersonalDocument;
};

/**
 * Version of {@link inputPassportElementPassportRegistration} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's passport registration
 */
export type inputPassportElementPassportRegistration$Input = {
  readonly _: "inputPassportElementPassportRegistration";

  /**
   * The passport registration page to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly passport_registration?: inputPersonalDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's temporary registration
 */
export type inputPassportElementTemporaryRegistration = {
  _: "inputPassportElementTemporaryRegistration";

  /**
   * The temporary registration document to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  temporary_registration: inputPersonalDocument;
};

/**
 * Version of {@link inputPassportElementTemporaryRegistration} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's temporary registration
 */
export type inputPassportElementTemporaryRegistration$Input = {
  readonly _: "inputPassportElementTemporaryRegistration";

  /**
   * The temporary registration document to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly temporary_registration?: inputPersonalDocument$Input;
};

/**
 * A Telegram Passport element to be saved containing the user's phone number
 */
export type inputPassportElementPhoneNumber = {
  _: "inputPassportElementPhoneNumber";

  /**
   * The phone number to be saved
   * @type {string} {@link string}
   */
  phone_number: string;
};

/**
 * Version of {@link inputPassportElementPhoneNumber} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's phone number
 */
export type inputPassportElementPhoneNumber$Input = {
  readonly _: "inputPassportElementPhoneNumber";

  /**
   * The phone number to be saved
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * A Telegram Passport element to be saved containing the user's email address
 */
export type inputPassportElementEmailAddress = {
  _: "inputPassportElementEmailAddress";

  /**
   * The email address to be saved
   * @type {string} {@link string}
   */
  email_address: string;
};

/**
 * Version of {@link inputPassportElementEmailAddress} for method parameters.
 *
 * A Telegram Passport element to be saved containing the user's email address
 */
export type inputPassportElementEmailAddress$Input = {
  readonly _: "inputPassportElementEmailAddress";

  /**
   * The email address to be saved
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Contains information about saved Telegram Passport elements
 */
export type passportElements = {
  _: "passportElements";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  elements: vector<PassportElement>;
};

/**
 * Version of {@link passportElements} for method parameters.
 *
 * Contains information about saved Telegram Passport elements
 */
export type passportElements$Input = {
  readonly _: "passportElements";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  readonly elements?: vector$Input<PassportElement$Input>;
};

/**
 * The element contains an error in an unspecified place. The error will be considered resolved when new data is added
 */
export type passportElementErrorSourceUnspecified = {
  _: "passportElementErrorSourceUnspecified";
};

/**
 * Version of {@link passportElementErrorSourceUnspecified} for method parameters.
 *
 * The element contains an error in an unspecified place. The error will be considered resolved when new data is added
 */
export type passportElementErrorSourceUnspecified$Input = {
  readonly _: "passportElementErrorSourceUnspecified";
};

/**
 * One of the data fields contains an error. The error will be considered resolved when the value of the field changes
 */
export type passportElementErrorSourceDataField = {
  _: "passportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  field_name: string;
};

/**
 * Version of {@link passportElementErrorSourceDataField} for method parameters.
 *
 * One of the data fields contains an error. The error will be considered resolved when the value of the field changes
 */
export type passportElementErrorSourceDataField$Input = {
  readonly _: "passportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  readonly field_name?: string;
};

/**
 * The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
 */
export type passportElementErrorSourceFrontSide = {
  _: "passportElementErrorSourceFrontSide";
};

/**
 * Version of {@link passportElementErrorSourceFrontSide} for method parameters.
 *
 * The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
 */
export type passportElementErrorSourceFrontSide$Input = {
  readonly _: "passportElementErrorSourceFrontSide";
};

/**
 * The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
 */
export type passportElementErrorSourceReverseSide = {
  _: "passportElementErrorSourceReverseSide";
};

/**
 * Version of {@link passportElementErrorSourceReverseSide} for method parameters.
 *
 * The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
 */
export type passportElementErrorSourceReverseSide$Input = {
  readonly _: "passportElementErrorSourceReverseSide";
};

/**
 * The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
 */
export type passportElementErrorSourceSelfie = {
  _: "passportElementErrorSourceSelfie";
};

/**
 * Version of {@link passportElementErrorSourceSelfie} for method parameters.
 *
 * The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
 */
export type passportElementErrorSourceSelfie$Input = {
  readonly _: "passportElementErrorSourceSelfie";
};

/**
 * One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
 */
export type passportElementErrorSourceTranslationFile = {
  _: "passportElementErrorSourceTranslationFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  file_index: int32;
};

/**
 * Version of {@link passportElementErrorSourceTranslationFile} for method parameters.
 *
 * One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
 */
export type passportElementErrorSourceTranslationFile$Input = {
  readonly _: "passportElementErrorSourceTranslationFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  readonly file_index?: int32;
};

/**
 * The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
 */
export type passportElementErrorSourceTranslationFiles = {
  _: "passportElementErrorSourceTranslationFiles";
};

/**
 * Version of {@link passportElementErrorSourceTranslationFiles} for method parameters.
 *
 * The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
 */
export type passportElementErrorSourceTranslationFiles$Input = {
  readonly _: "passportElementErrorSourceTranslationFiles";
};

/**
 * The file contains an error. The error will be considered resolved when the file changes
 */
export type passportElementErrorSourceFile = {
  _: "passportElementErrorSourceFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  file_index: int32;
};

/**
 * Version of {@link passportElementErrorSourceFile} for method parameters.
 *
 * The file contains an error. The error will be considered resolved when the file changes
 */
export type passportElementErrorSourceFile$Input = {
  readonly _: "passportElementErrorSourceFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  readonly file_index?: int32;
};

/**
 * The list of attached files contains an error. The error will be considered resolved when the list of files changes
 */
export type passportElementErrorSourceFiles = {
  _: "passportElementErrorSourceFiles";
};

/**
 * Version of {@link passportElementErrorSourceFiles} for method parameters.
 *
 * The list of attached files contains an error. The error will be considered resolved when the list of files changes
 */
export type passportElementErrorSourceFiles$Input = {
  readonly _: "passportElementErrorSourceFiles";
};

/**
 * Contains the description of an error in a Telegram Passport element
 */
export type passportElementError = {
  _: "passportElementError";

  /**
   * Type of the Telegram Passport element which has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * Error message
   * @type {string} {@link string}
   */
  message: string;

  /**
   * Error source
   * @type {PassportElementErrorSource} {@link PassportElementErrorSource}
   */
  source: PassportElementErrorSource;
};

/**
 * Version of {@link passportElementError} for method parameters.
 *
 * Contains the description of an error in a Telegram Passport element
 */
export type passportElementError$Input = {
  readonly _: "passportElementError";

  /**
   * Type of the Telegram Passport element which has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * Error message
   * @type {string} {@link string}
   */
  readonly message?: string;

  /**
   * Error source
   * @type {PassportElementErrorSource} {@link PassportElementErrorSource}
   */
  readonly source?: PassportElementErrorSource$Input;
};

/**
 * Contains information about a Telegram Passport element that was requested by a service
 */
export type passportSuitableElement = {
  _: "passportSuitableElement";

  /**
   * Type of the element
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * True, if a selfie is required with the identity document
   * @type {Bool} {@link Bool}
   */
  is_selfie_required: Bool;

  /**
   * True, if a certified English translation is required with the document
   * @type {Bool} {@link Bool}
   */
  is_translation_required: Bool;

  /**
   * True, if personal details must include the user's name in the language of their country of residence
   * @type {Bool} {@link Bool}
   */
  is_native_name_required: Bool;
};

/**
 * Version of {@link passportSuitableElement} for method parameters.
 *
 * Contains information about a Telegram Passport element that was requested by a service
 */
export type passportSuitableElement$Input = {
  readonly _: "passportSuitableElement";

  /**
   * Type of the element
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * True, if a selfie is required with the identity document
   * @type {Bool} {@link Bool}
   */
  readonly is_selfie_required?: Bool$Input;

  /**
   * True, if a certified English translation is required with the document
   * @type {Bool} {@link Bool}
   */
  readonly is_translation_required?: Bool$Input;

  /**
   * True, if personal details must include the user's name in the language of their country of residence
   * @type {Bool} {@link Bool}
   */
  readonly is_native_name_required?: Bool$Input;
};

/**
 * Contains a description of the required Telegram Passport element that was requested by a service
 */
export type passportRequiredElement = {
  _: "passportRequiredElement";

  /**
   * List of Telegram Passport elements any of which is enough to provide
   * @type {vector<passportSuitableElement>} {@link vector<passportSuitableElement>}
   */
  suitable_elements: vector<passportSuitableElement>;
};

/**
 * Version of {@link passportRequiredElement} for method parameters.
 *
 * Contains a description of the required Telegram Passport element that was requested by a service
 */
export type passportRequiredElement$Input = {
  readonly _: "passportRequiredElement";

  /**
   * List of Telegram Passport elements any of which is enough to provide
   * @type {vector<passportSuitableElement>} {@link vector<passportSuitableElement>}
   */
  readonly suitable_elements?: vector$Input<passportSuitableElement$Input>;
};

/**
 * Contains information about a Telegram Passport authorization form that was requested
 */
export type passportAuthorizationForm = {
  _: "passportAuthorizationForm";

  /**
   * Unique identifier of the authorization form
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Telegram Passport elements that must be provided to complete the form
   * @type {vector<passportRequiredElement>} {@link vector<passportRequiredElement>}
   */
  required_elements: vector<passportRequiredElement>;

  /**
   * URL for the privacy policy of the service; may be empty
   * @type {string} {@link string}
   */
  privacy_policy_url: string;
};

/**
 * Version of {@link passportAuthorizationForm} for method parameters.
 *
 * Contains information about a Telegram Passport authorization form that was requested
 */
export type passportAuthorizationForm$Input = {
  readonly _: "passportAuthorizationForm";

  /**
   * Unique identifier of the authorization form
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Telegram Passport elements that must be provided to complete the form
   * @type {vector<passportRequiredElement>} {@link vector<passportRequiredElement>}
   */
  readonly required_elements?: vector$Input<passportRequiredElement$Input>;

  /**
   * URL for the privacy policy of the service; may be empty
   * @type {string} {@link string}
   */
  readonly privacy_policy_url?: string;
};

/**
 * Contains information about a Telegram Passport elements and corresponding errors
 */
export type passportElementsWithErrors = {
  _: "passportElementsWithErrors";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  elements: vector<PassportElement>;

  /**
   * Errors in the elements that are already available
   * @type {vector<passportElementError>} {@link vector<passportElementError>}
   */
  errors: vector<passportElementError>;
};

/**
 * Version of {@link passportElementsWithErrors} for method parameters.
 *
 * Contains information about a Telegram Passport elements and corresponding errors
 */
export type passportElementsWithErrors$Input = {
  readonly _: "passportElementsWithErrors";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  readonly elements?: vector$Input<PassportElement$Input>;

  /**
   * Errors in the elements that are already available
   * @type {vector<passportElementError>} {@link vector<passportElementError>}
   */
  readonly errors?: vector$Input<passportElementError$Input>;
};

/**
 * Contains encrypted Telegram Passport data credentials
 */
export type encryptedCredentials = {
  _: "encryptedCredentials";

  /**
   * The encrypted credentials
   * @type {bytes} {@link bytes}
   */
  data: bytes;

  /**
   * The decrypted data hash
   * @type {bytes} {@link bytes}
   */
  hash: bytes;

  /**
   * Secret for data decryption, encrypted with the service's public key
   * @type {bytes} {@link bytes}
   */
  secret: bytes;
};

/**
 * Version of {@link encryptedCredentials} for method parameters.
 *
 * Contains encrypted Telegram Passport data credentials
 */
export type encryptedCredentials$Input = {
  readonly _: "encryptedCredentials";

  /**
   * The encrypted credentials
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;

  /**
   * The decrypted data hash
   * @type {bytes} {@link bytes}
   */
  readonly hash?: bytes$Input;

  /**
   * Secret for data decryption, encrypted with the service's public key
   * @type {bytes} {@link bytes}
   */
  readonly secret?: bytes$Input;
};

/**
 * Contains information about an encrypted Telegram Passport element; for bots only
 */
export type encryptedPassportElement = {
  _: "encryptedPassportElement";

  /**
   * Type of Telegram Passport element
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * Encrypted JSON-encoded data about the user
   * @type {bytes} {@link bytes}
   */
  data: bytes;

  /**
   * The front side of an identity document
   * @type {datedFile} {@link datedFile}
   */
  front_side: datedFile;

  /**
   * The reverse side of an identity document; may be null
   * @type {datedFile} {@link datedFile}
   */
  reverse_side: datedFile | null;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  selfie: datedFile | null;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  translation: vector<datedFile>;

  /**
   * List of attached files
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  files: vector<datedFile>;

  /**
   * Unencrypted data, phone number or email address
   * @type {string} {@link string}
   */
  value: string;

  /**
   * Hash of the entire element
   * @type {string} {@link string}
   */
  hash: string;
};

/**
 * Version of {@link encryptedPassportElement} for method parameters.
 *
 * Contains information about an encrypted Telegram Passport element; for bots only
 */
export type encryptedPassportElement$Input = {
  readonly _: "encryptedPassportElement";

  /**
   * Type of Telegram Passport element
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * Encrypted JSON-encoded data about the user
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;

  /**
   * The front side of an identity document
   * @type {datedFile} {@link datedFile}
   */
  readonly front_side?: datedFile$Input;

  /**
   * The reverse side of an identity document; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly reverse_side?: datedFile$Input | null;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly selfie?: datedFile$Input | null;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly translation?: vector$Input<datedFile$Input>;

  /**
   * List of attached files
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly files?: vector$Input<datedFile$Input>;

  /**
   * Unencrypted data, phone number or email address
   * @type {string} {@link string}
   */
  readonly value?: string;

  /**
   * Hash of the entire element
   * @type {string} {@link string}
   */
  readonly hash?: string;
};

/**
 * The element contains an error in an unspecified place. The error will be considered resolved when new data is added
 */
export type inputPassportElementErrorSourceUnspecified = {
  _: "inputPassportElementErrorSourceUnspecified";

  /**
   * Current hash of the entire element
   * @type {bytes} {@link bytes}
   */
  element_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceUnspecified} for method parameters.
 *
 * The element contains an error in an unspecified place. The error will be considered resolved when new data is added
 */
export type inputPassportElementErrorSourceUnspecified$Input = {
  readonly _: "inputPassportElementErrorSourceUnspecified";

  /**
   * Current hash of the entire element
   * @type {bytes} {@link bytes}
   */
  readonly element_hash?: bytes$Input;
};

/**
 * A data field contains an error. The error is considered resolved when the field's value changes
 */
export type inputPassportElementErrorSourceDataField = {
  _: "inputPassportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  field_name: string;

  /**
   * Current data hash
   * @type {bytes} {@link bytes}
   */
  data_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceDataField} for method parameters.
 *
 * A data field contains an error. The error is considered resolved when the field's value changes
 */
export type inputPassportElementErrorSourceDataField$Input = {
  readonly _: "inputPassportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  readonly field_name?: string;

  /**
   * Current data hash
   * @type {bytes} {@link bytes}
   */
  readonly data_hash?: bytes$Input;
};

/**
 * The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
 */
export type inputPassportElementErrorSourceFrontSide = {
  _: "inputPassportElementErrorSourceFrontSide";

  /**
   * Current hash of the file containing the front side
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceFrontSide} for method parameters.
 *
 * The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
 */
export type inputPassportElementErrorSourceFrontSide$Input = {
  readonly _: "inputPassportElementErrorSourceFrontSide";

  /**
   * Current hash of the file containing the front side
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes$Input;
};

/**
 * The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
 */
export type inputPassportElementErrorSourceReverseSide = {
  _: "inputPassportElementErrorSourceReverseSide";

  /**
   * Current hash of the file containing the reverse side
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceReverseSide} for method parameters.
 *
 * The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
 */
export type inputPassportElementErrorSourceReverseSide$Input = {
  readonly _: "inputPassportElementErrorSourceReverseSide";

  /**
   * Current hash of the file containing the reverse side
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes$Input;
};

/**
 * The selfie contains an error. The error is considered resolved when the file with the selfie changes
 */
export type inputPassportElementErrorSourceSelfie = {
  _: "inputPassportElementErrorSourceSelfie";

  /**
   * Current hash of the file containing the selfie
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceSelfie} for method parameters.
 *
 * The selfie contains an error. The error is considered resolved when the file with the selfie changes
 */
export type inputPassportElementErrorSourceSelfie$Input = {
  readonly _: "inputPassportElementErrorSourceSelfie";

  /**
   * Current hash of the file containing the selfie
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes$Input;
};

/**
 * One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
 */
export type inputPassportElementErrorSourceTranslationFile = {
  _: "inputPassportElementErrorSourceTranslationFile";

  /**
   * Current hash of the file containing the translation
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceTranslationFile} for method parameters.
 *
 * One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
 */
export type inputPassportElementErrorSourceTranslationFile$Input = {
  readonly _: "inputPassportElementErrorSourceTranslationFile";

  /**
   * Current hash of the file containing the translation
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes$Input;
};

/**
 * The translation of the document contains an error. The error is considered resolved when the list of files changes
 */
export type inputPassportElementErrorSourceTranslationFiles = {
  _: "inputPassportElementErrorSourceTranslationFiles";

  /**
   * Current hashes of all files with the translation
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  file_hashes: vector<bytes>;
};

/**
 * Version of {@link inputPassportElementErrorSourceTranslationFiles} for method parameters.
 *
 * The translation of the document contains an error. The error is considered resolved when the list of files changes
 */
export type inputPassportElementErrorSourceTranslationFiles$Input = {
  readonly _: "inputPassportElementErrorSourceTranslationFiles";

  /**
   * Current hashes of all files with the translation
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  readonly file_hashes?: vector$Input<bytes$Input>;
};

/**
 * The file contains an error. The error is considered resolved when the file changes
 */
export type inputPassportElementErrorSourceFile = {
  _: "inputPassportElementErrorSourceFile";

  /**
   * Current hash of the file which has the error
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

/**
 * Version of {@link inputPassportElementErrorSourceFile} for method parameters.
 *
 * The file contains an error. The error is considered resolved when the file changes
 */
export type inputPassportElementErrorSourceFile$Input = {
  readonly _: "inputPassportElementErrorSourceFile";

  /**
   * Current hash of the file which has the error
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes$Input;
};

/**
 * The list of attached files contains an error. The error is considered resolved when the file list changes
 */
export type inputPassportElementErrorSourceFiles = {
  _: "inputPassportElementErrorSourceFiles";

  /**
   * Current hashes of all attached files
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  file_hashes: vector<bytes>;
};

/**
 * Version of {@link inputPassportElementErrorSourceFiles} for method parameters.
 *
 * The list of attached files contains an error. The error is considered resolved when the file list changes
 */
export type inputPassportElementErrorSourceFiles$Input = {
  readonly _: "inputPassportElementErrorSourceFiles";

  /**
   * Current hashes of all attached files
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  readonly file_hashes?: vector$Input<bytes$Input>;
};

/**
 * Contains the description of an error in a Telegram Passport element; for bots only
 */
export type inputPassportElementError = {
  _: "inputPassportElementError";

  /**
   * Type of Telegram Passport element that has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * Error message
   * @type {string} {@link string}
   */
  message: string;

  /**
   * Error source
   * @type {InputPassportElementErrorSource} {@link InputPassportElementErrorSource}
   */
  source: InputPassportElementErrorSource;
};

/**
 * Version of {@link inputPassportElementError} for method parameters.
 *
 * Contains the description of an error in a Telegram Passport element; for bots only
 */
export type inputPassportElementError$Input = {
  readonly _: "inputPassportElementError";

  /**
   * Type of Telegram Passport element that has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * Error message
   * @type {string} {@link string}
   */
  readonly message?: string;

  /**
   * Error source
   * @type {InputPassportElementErrorSource} {@link InputPassportElementErrorSource}
   */
  readonly source?: InputPassportElementErrorSource$Input;
};

/**
 * A text message
 */
export type messageText = {
  _: "messageText";

  /**
   * Text of the message
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * A link preview attached to the message; may be null
   * @type {webPage} {@link webPage}
   */
  web_page: webPage | null;

  /**
   * Options which were used for generation of the link preview; may be null if default options were used
   * @type {linkPreviewOptions} {@link linkPreviewOptions}
   */
  link_preview_options: linkPreviewOptions | null;
};

/**
 * Version of {@link messageText} for method parameters.
 *
 * A text message
 */
export type messageText$Input = {
  readonly _: "messageText";

  /**
   * Text of the message
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * A link preview attached to the message; may be null
   * @type {webPage} {@link webPage}
   */
  readonly web_page?: webPage$Input | null;

  /**
   * Options which were used for generation of the link preview; may be null if default options were used
   * @type {linkPreviewOptions} {@link linkPreviewOptions}
   */
  readonly link_preview_options?: linkPreviewOptions$Input | null;
};

/**
 * An animation message (GIF-style).
 */
export type messageAnimation = {
  _: "messageAnimation";

  /**
   * The animation description
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Animation caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if the animation preview must be covered by a spoiler animation
   * @type {Bool} {@link Bool}
   */
  has_spoiler: Bool;

  /**
   * True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

/**
 * Version of {@link messageAnimation} for method parameters.
 *
 * An animation message (GIF-style).
 */
export type messageAnimation$Input = {
  readonly _: "messageAnimation";

  /**
   * The animation description
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Animation caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if the animation preview must be covered by a spoiler animation
   * @type {Bool} {@link Bool}
   */
  readonly has_spoiler?: Bool$Input;

  /**
   * True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/**
 * An audio message
 */
export type messageAudio = {
  _: "messageAudio";

  /**
   * The audio description
   * @type {audio} {@link audio}
   */
  audio: audio;

  /**
   * Audio caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link messageAudio} for method parameters.
 *
 * An audio message
 */
export type messageAudio$Input = {
  readonly _: "messageAudio";

  /**
   * The audio description
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;

  /**
   * Audio caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * A document message (general file)
 */
export type messageDocument = {
  _: "messageDocument";

  /**
   * The document description
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Document caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link messageDocument} for method parameters.
 *
 * A document message (general file)
 */
export type messageDocument$Input = {
  readonly _: "messageDocument";

  /**
   * The document description
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Document caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * A photo message
 */
export type messagePhoto = {
  _: "messagePhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if the photo preview must be covered by a spoiler animation
   * @type {Bool} {@link Bool}
   */
  has_spoiler: Bool;

  /**
   * True, if the photo must be blurred and must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

/**
 * Version of {@link messagePhoto} for method parameters.
 *
 * A photo message
 */
export type messagePhoto$Input = {
  readonly _: "messagePhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if the photo preview must be covered by a spoiler animation
   * @type {Bool} {@link Bool}
   */
  readonly has_spoiler?: Bool$Input;

  /**
   * True, if the photo must be blurred and must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/**
 * A self-destructed photo message
 */
export type messageExpiredPhoto = {
  _: "messageExpiredPhoto";
};

/**
 * Version of {@link messageExpiredPhoto} for method parameters.
 *
 * A self-destructed photo message
 */
export type messageExpiredPhoto$Input = {
  readonly _: "messageExpiredPhoto";
};

/**
 * A sticker message
 */
export type messageSticker = {
  _: "messageSticker";

  /**
   * The sticker description
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;

  /**
   * True, if premium animation of the sticker must be played
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;
};

/**
 * Version of {@link messageSticker} for method parameters.
 *
 * A sticker message
 */
export type messageSticker$Input = {
  readonly _: "messageSticker";

  /**
   * The sticker description
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;

  /**
   * True, if premium animation of the sticker must be played
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;
};

/**
 * A video message
 */
export type messageVideo = {
  _: "messageVideo";

  /**
   * The video description
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Video caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if the video preview must be covered by a spoiler animation
   * @type {Bool} {@link Bool}
   */
  has_spoiler: Bool;

  /**
   * True, if the video thumbnail must be blurred and the video must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

/**
 * Version of {@link messageVideo} for method parameters.
 *
 * A video message
 */
export type messageVideo$Input = {
  readonly _: "messageVideo";

  /**
   * The video description
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Video caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if the video preview must be covered by a spoiler animation
   * @type {Bool} {@link Bool}
   */
  readonly has_spoiler?: Bool$Input;

  /**
   * True, if the video thumbnail must be blurred and the video must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/**
 * A self-destructed video message
 */
export type messageExpiredVideo = {
  _: "messageExpiredVideo";
};

/**
 * Version of {@link messageExpiredVideo} for method parameters.
 *
 * A self-destructed video message
 */
export type messageExpiredVideo$Input = {
  readonly _: "messageExpiredVideo";
};

/**
 * A video note message
 */
export type messageVideoNote = {
  _: "messageVideoNote";

  /**
   * The video note description
   * @type {videoNote} {@link videoNote}
   */
  video_note: videoNote;

  /**
   * True, if at least one of the recipients has viewed the video note
   * @type {Bool} {@link Bool}
   */
  is_viewed: Bool;

  /**
   * True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

/**
 * Version of {@link messageVideoNote} for method parameters.
 *
 * A video note message
 */
export type messageVideoNote$Input = {
  readonly _: "messageVideoNote";

  /**
   * The video note description
   * @type {videoNote} {@link videoNote}
   */
  readonly video_note?: videoNote$Input;

  /**
   * True, if at least one of the recipients has viewed the video note
   * @type {Bool} {@link Bool}
   */
  readonly is_viewed?: Bool$Input;

  /**
   * True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/**
 * A voice note message
 */
export type messageVoiceNote = {
  _: "messageVoiceNote";

  /**
   * The voice note description
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * Voice note caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if at least one of the recipients has listened to the voice note
   * @type {Bool} {@link Bool}
   */
  is_listened: Bool;
};

/**
 * Version of {@link messageVoiceNote} for method parameters.
 *
 * A voice note message
 */
export type messageVoiceNote$Input = {
  readonly _: "messageVoiceNote";

  /**
   * The voice note description
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * Voice note caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if at least one of the recipients has listened to the voice note
   * @type {Bool} {@link Bool}
   */
  readonly is_listened?: Bool$Input;
};

/**
 * A message with a location
 */
export type messageLocation = {
  _: "messageLocation";

  /**
   * The location description
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Time relative to the message send date, for which the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  live_period: int32;

  /**
   * Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
   * @type {int32} {@link int32}
   */
  expires_in: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
   * @type {int32} {@link int32}
   */
  heading: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
   * @type {int32} {@link int32}
   */
  proximity_alert_radius: int32;
};

/**
 * Version of {@link messageLocation} for method parameters.
 *
 * A message with a location
 */
export type messageLocation$Input = {
  readonly _: "messageLocation";

  /**
   * The location description
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Time relative to the message send date, for which the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  readonly live_period?: int32;

  /**
   * Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
   * @type {int32} {@link int32}
   */
  readonly expires_in?: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only to the message sender
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * A message with information about a venue
 */
export type messageVenue = {
  _: "messageVenue";

  /**
   * The venue description
   * @type {venue} {@link venue}
   */
  venue: venue;
};

/**
 * Version of {@link messageVenue} for method parameters.
 *
 * A message with information about a venue
 */
export type messageVenue$Input = {
  readonly _: "messageVenue";

  /**
   * The venue description
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;
};

/**
 * A message with a user contact
 */
export type messageContact = {
  _: "messageContact";

  /**
   * The contact description
   * @type {contact} {@link contact}
   */
  contact: contact;
};

/**
 * Version of {@link messageContact} for method parameters.
 *
 * A message with a user contact
 */
export type messageContact$Input = {
  readonly _: "messageContact";

  /**
   * The contact description
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;
};

/**
 * A message with an animated emoji
 */
export type messageAnimatedEmoji = {
  _: "messageAnimatedEmoji";

  /**
   * The animated emoji
   * @type {animatedEmoji} {@link animatedEmoji}
   */
  animated_emoji: animatedEmoji;

  /**
   * The corresponding emoji
   * @type {string} {@link string}
   */
  emoji: string;
};

/**
 * Version of {@link messageAnimatedEmoji} for method parameters.
 *
 * A message with an animated emoji
 */
export type messageAnimatedEmoji$Input = {
  readonly _: "messageAnimatedEmoji";

  /**
   * The animated emoji
   * @type {animatedEmoji} {@link animatedEmoji}
   */
  readonly animated_emoji?: animatedEmoji$Input;

  /**
   * The corresponding emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * A dice message. The dice value is randomly generated by the server
 */
export type messageDice = {
  _: "messageDice";

  /**
   * The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  initial_state: DiceStickers | null;

  /**
   * The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  final_state: DiceStickers | null;

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * The dice value. If the value is 0, the dice don't have final state yet
   * @type {int32} {@link int32}
   */
  value: int32;

  /**
   * Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
   * @type {int32} {@link int32}
   */
  success_animation_frame_number: int32;
};

/**
 * Version of {@link messageDice} for method parameters.
 *
 * A dice message. The dice value is randomly generated by the server
 */
export type messageDice$Input = {
  readonly _: "messageDice";

  /**
   * The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  readonly initial_state?: DiceStickers$Input | null;

  /**
   * The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  readonly final_state?: DiceStickers$Input | null;

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * The dice value. If the value is 0, the dice don't have final state yet
   * @type {int32} {@link int32}
   */
  readonly value?: int32;

  /**
   * Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
   * @type {int32} {@link int32}
   */
  readonly success_animation_frame_number?: int32;
};

/**
 * A message with a game
 */
export type messageGame = {
  _: "messageGame";

  /**
   * The game description
   * @type {game} {@link game}
   */
  game: game;
};

/**
 * Version of {@link messageGame} for method parameters.
 *
 * A message with a game
 */
export type messageGame$Input = {
  readonly _: "messageGame";

  /**
   * The game description
   * @type {game} {@link game}
   */
  readonly game?: game$Input;
};

/**
 * A message with a poll
 */
export type messagePoll = {
  _: "messagePoll";

  /**
   * The poll description
   * @type {poll} {@link poll}
   */
  poll: poll;
};

/**
 * Version of {@link messagePoll} for method parameters.
 *
 * A message with a poll
 */
export type messagePoll$Input = {
  readonly _: "messagePoll";

  /**
   * The poll description
   * @type {poll} {@link poll}
   */
  readonly poll?: poll$Input;
};

/**
 * A message with a forwarded story
 */
export type messageStory = {
  _: "messageStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  story_sender_chat_id: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  story_id: int32;

  /**
   * True, if the story was automatically forwarded because of a mention of the user
   * @type {Bool} {@link Bool}
   */
  via_mention: Bool;
};

/**
 * Version of {@link messageStory} for method parameters.
 *
 * A message with a forwarded story
 */
export type messageStory$Input = {
  readonly _: "messageStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * True, if the story was automatically forwarded because of a mention of the user
   * @type {Bool} {@link Bool}
   */
  readonly via_mention?: Bool$Input;
};

/**
 * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
 */
export type messageInvoice = {
  _: "messageInvoice";

  /**
   * Product title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
   * @type {formattedText} {@link formattedText}
   */
  description: formattedText;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Product total price in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * Unique invoice bot start_parameter to be passed to getInternalLink
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * True, if the invoice is a test invoice
   * @type {Bool} {@link Bool}
   */
  is_test: Bool;

  /**
   * True, if the shipping address must be specified
   * @type {Bool} {@link Bool}
   */
  need_shipping_address: Bool;

  /**
   * The identifier of the message with the receipt, after the product has been purchased
   * @type {int53} {@link int53}
   */
  receipt_message_id: int53;

  /**
   * Extended media attached to the invoice; may be null
   * @type {MessageExtendedMedia} {@link MessageExtendedMedia}
   */
  extended_media: MessageExtendedMedia | null;
};

/**
 * Version of {@link messageInvoice} for method parameters.
 *
 * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
 */
export type messageInvoice$Input = {
  readonly _: "messageInvoice";

  /**
   * Product title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * A message with an invoice from a bot. Use getInternalLink with internalLinkTypeBotStart to share the invoice
   * @type {formattedText} {@link formattedText}
   */
  readonly description?: formattedText$Input;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Product total price in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * Unique invoice bot start_parameter to be passed to getInternalLink
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * True, if the invoice is a test invoice
   * @type {Bool} {@link Bool}
   */
  readonly is_test?: Bool$Input;

  /**
   * True, if the shipping address must be specified
   * @type {Bool} {@link Bool}
   */
  readonly need_shipping_address?: Bool$Input;

  /**
   * The identifier of the message with the receipt, after the product has been purchased
   * @type {int53} {@link int53}
   */
  readonly receipt_message_id?: int53;

  /**
   * Extended media attached to the invoice; may be null
   * @type {MessageExtendedMedia} {@link MessageExtendedMedia}
   */
  readonly extended_media?: MessageExtendedMedia$Input | null;
};

/**
 * A message with information about an ended call
 */
export type messageCall = {
  _: "messageCall";

  /**
   * True, if the call was a video call
   * @type {Bool} {@link Bool}
   */
  is_video: Bool;

  /**
   * Reason why the call was discarded
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  discard_reason: CallDiscardReason;

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;
};

/**
 * Version of {@link messageCall} for method parameters.
 *
 * A message with information about an ended call
 */
export type messageCall$Input = {
  readonly _: "messageCall";

  /**
   * True, if the call was a video call
   * @type {Bool} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Reason why the call was discarded
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  readonly discard_reason?: CallDiscardReason$Input;

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/**
 * A new video chat was scheduled
 */
export type messageVideoChatScheduled = {
  _: "messageVideoChatScheduled";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
   * @type {int32} {@link int32}
   */
  start_date: int32;
};

/**
 * Version of {@link messageVideoChatScheduled} for method parameters.
 *
 * A new video chat was scheduled
 */
export type messageVideoChatScheduled$Input = {
  readonly _: "messageVideoChatScheduled";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;
};

/**
 * A newly created video chat
 */
export type messageVideoChatStarted = {
  _: "messageVideoChatStarted";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;
};

/**
 * Version of {@link messageVideoChatStarted} for method parameters.
 *
 * A newly created video chat
 */
export type messageVideoChatStarted$Input = {
  readonly _: "messageVideoChatStarted";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * A message with information about an ended video chat
 */
export type messageVideoChatEnded = {
  _: "messageVideoChatEnded";

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;
};

/**
 * Version of {@link messageVideoChatEnded} for method parameters.
 *
 * A message with information about an ended video chat
 */
export type messageVideoChatEnded$Input = {
  readonly _: "messageVideoChatEnded";

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/**
 * A message with information about an invite to a video chat
 */
export type messageInviteVideoChatParticipants = {
  _: "messageInviteVideoChatParticipants";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * Invited user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link messageInviteVideoChatParticipants} for method parameters.
 *
 * A message with information about an invite to a video chat
 */
export type messageInviteVideoChatParticipants$Input = {
  readonly _: "messageInviteVideoChatParticipants";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Invited user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * A newly created basic group
 */
export type messageBasicGroupChatCreate = {
  _: "messageBasicGroupChatCreate";

  /**
   * Title of the basic group
   * @type {string} {@link string}
   */
  title: string;

  /**
   * User identifiers of members in the basic group
   * @type {vector<int53>} {@link vector<int53>}
   */
  member_user_ids: vector<int53>;
};

/**
 * Version of {@link messageBasicGroupChatCreate} for method parameters.
 *
 * A newly created basic group
 */
export type messageBasicGroupChatCreate$Input = {
  readonly _: "messageBasicGroupChatCreate";

  /**
   * Title of the basic group
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * User identifiers of members in the basic group
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly member_user_ids?: vector$Input<int53>;
};

/**
 * A newly created supergroup or channel
 */
export type messageSupergroupChatCreate = {
  _: "messageSupergroupChatCreate";

  /**
   * Title of the supergroup or channel
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link messageSupergroupChatCreate} for method parameters.
 *
 * A newly created supergroup or channel
 */
export type messageSupergroupChatCreate$Input = {
  readonly _: "messageSupergroupChatCreate";

  /**
   * Title of the supergroup or channel
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * An updated chat title
 */
export type messageChatChangeTitle = {
  _: "messageChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link messageChatChangeTitle} for method parameters.
 *
 * An updated chat title
 */
export type messageChatChangeTitle$Input = {
  readonly _: "messageChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * An updated chat photo
 */
export type messageChatChangePhoto = {
  _: "messageChatChangePhoto";

  /**
   * New chat photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto;
};

/**
 * Version of {@link messageChatChangePhoto} for method parameters.
 *
 * An updated chat photo
 */
export type messageChatChangePhoto$Input = {
  readonly _: "messageChatChangePhoto";

  /**
   * New chat photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input;
};

/**
 * A deleted chat photo
 */
export type messageChatDeletePhoto = {
  _: "messageChatDeletePhoto";
};

/**
 * Version of {@link messageChatDeletePhoto} for method parameters.
 *
 * A deleted chat photo
 */
export type messageChatDeletePhoto$Input = {
  readonly _: "messageChatDeletePhoto";
};

/**
 * New chat members were added
 */
export type messageChatAddMembers = {
  _: "messageChatAddMembers";

  /**
   * User identifiers of the new members
   * @type {vector<int53>} {@link vector<int53>}
   */
  member_user_ids: vector<int53>;
};

/**
 * Version of {@link messageChatAddMembers} for method parameters.
 *
 * New chat members were added
 */
export type messageChatAddMembers$Input = {
  readonly _: "messageChatAddMembers";

  /**
   * User identifiers of the new members
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly member_user_ids?: vector$Input<int53>;
};

/**
 * A new member joined the chat via an invite link
 */
export type messageChatJoinByLink = {
  _: "messageChatJoinByLink";
};

/**
 * Version of {@link messageChatJoinByLink} for method parameters.
 *
 * A new member joined the chat via an invite link
 */
export type messageChatJoinByLink$Input = {
  readonly _: "messageChatJoinByLink";
};

/**
 * A new member was accepted to the chat by an administrator
 */
export type messageChatJoinByRequest = {
  _: "messageChatJoinByRequest";
};

/**
 * Version of {@link messageChatJoinByRequest} for method parameters.
 *
 * A new member was accepted to the chat by an administrator
 */
export type messageChatJoinByRequest$Input = {
  readonly _: "messageChatJoinByRequest";
};

/**
 * A chat member was deleted
 */
export type messageChatDeleteMember = {
  _: "messageChatDeleteMember";

  /**
   * User identifier of the deleted chat member
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link messageChatDeleteMember} for method parameters.
 *
 * A chat member was deleted
 */
export type messageChatDeleteMember$Input = {
  readonly _: "messageChatDeleteMember";

  /**
   * User identifier of the deleted chat member
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * A basic group was upgraded to a supergroup and was deactivated as the result
 */
export type messageChatUpgradeTo = {
  _: "messageChatUpgradeTo";

  /**
   * Identifier of the supergroup to which the basic group was upgraded
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;
};

/**
 * Version of {@link messageChatUpgradeTo} for method parameters.
 *
 * A basic group was upgraded to a supergroup and was deactivated as the result
 */
export type messageChatUpgradeTo$Input = {
  readonly _: "messageChatUpgradeTo";

  /**
   * Identifier of the supergroup to which the basic group was upgraded
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * A supergroup has been created from a basic group
 */
export type messageChatUpgradeFrom = {
  _: "messageChatUpgradeFrom";

  /**
   * Title of the newly created supergroup
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The identifier of the original basic group
   * @type {int53} {@link int53}
   */
  basic_group_id: int53;
};

/**
 * Version of {@link messageChatUpgradeFrom} for method parameters.
 *
 * A supergroup has been created from a basic group
 */
export type messageChatUpgradeFrom$Input = {
  readonly _: "messageChatUpgradeFrom";

  /**
   * Title of the newly created supergroup
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The identifier of the original basic group
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * A message has been pinned
 */
export type messagePinMessage = {
  _: "messagePinMessage";

  /**
   * Identifier of the pinned message, can be an identifier of a deleted message or 0
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link messagePinMessage} for method parameters.
 *
 * A message has been pinned
 */
export type messagePinMessage$Input = {
  readonly _: "messagePinMessage";

  /**
   * Identifier of the pinned message, can be an identifier of a deleted message or 0
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * A screenshot of a message in the chat has been taken
 */
export type messageScreenshotTaken = {
  _: "messageScreenshotTaken";
};

/**
 * Version of {@link messageScreenshotTaken} for method parameters.
 *
 * A screenshot of a message in the chat has been taken
 */
export type messageScreenshotTaken$Input = {
  readonly _: "messageScreenshotTaken";
};

/**
 * A new background was set in the chat
 */
export type messageChatSetBackground = {
  _: "messageChatSetBackground";

  /**
   * Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  old_background_message_id: int53;

  /**
   * The new background
   * @type {chatBackground} {@link chatBackground}
   */
  background: chatBackground;

  /**
   * True, if the background was set only for self
   * @type {Bool} {@link Bool}
   */
  only_for_self: Bool;
};

/**
 * Version of {@link messageChatSetBackground} for method parameters.
 *
 * A new background was set in the chat
 */
export type messageChatSetBackground$Input = {
  readonly _: "messageChatSetBackground";

  /**
   * Identifier of the message with a previously set same background; 0 if none. Can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly old_background_message_id?: int53;

  /**
   * The new background
   * @type {chatBackground} {@link chatBackground}
   */
  readonly background?: chatBackground$Input;

  /**
   * True, if the background was set only for self
   * @type {Bool} {@link Bool}
   */
  readonly only_for_self?: Bool$Input;
};

/**
 * A theme in the chat has been changed
 */
export type messageChatSetTheme = {
  _: "messageChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
   * @type {string} {@link string}
   */
  theme_name: string;
};

/**
 * Version of {@link messageChatSetTheme} for method parameters.
 *
 * A theme in the chat has been changed
 */
export type messageChatSetTheme$Input = {
  readonly _: "messageChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise, chat theme was reset to the default one
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * The auto-delete or self-destruct timer for messages in the chat has been changed
 */
export type messageChatSetMessageAutoDeleteTime = {
  _: "messageChatSetMessageAutoDeleteTime";

  /**
   * New value auto-delete or self-destruct time, in seconds; 0 if disabled
   * @type {int32} {@link int32}
   */
  message_auto_delete_time: int32;

  /**
   * If not 0, a user identifier, which default setting was automatically applied
   * @type {int53} {@link int53}
   */
  from_user_id: int53;
};

/**
 * Version of {@link messageChatSetMessageAutoDeleteTime} for method parameters.
 *
 * The auto-delete or self-destruct timer for messages in the chat has been changed
 */
export type messageChatSetMessageAutoDeleteTime$Input = {
  readonly _: "messageChatSetMessageAutoDeleteTime";

  /**
   * New value auto-delete or self-destruct time, in seconds; 0 if disabled
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;

  /**
   * If not 0, a user identifier, which default setting was automatically applied
   * @type {int53} {@link int53}
   */
  readonly from_user_id?: int53;
};

/**
 * A forum topic has been created
 */
export type messageForumTopicCreated = {
  _: "messageForumTopicCreated";

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  icon: forumTopicIcon;
};

/**
 * Version of {@link messageForumTopicCreated} for method parameters.
 *
 * A forum topic has been created
 */
export type messageForumTopicCreated$Input = {
  readonly _: "messageForumTopicCreated";

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;
};

/**
 * A forum topic has been edited
 */
export type messageForumTopicEdited = {
  _: "messageForumTopicEdited";

  /**
   * If non-empty, the new name of the topic
   * @type {string} {@link string}
   */
  name: string;

  /**
   * True, if icon's custom_emoji_id is changed
   * @type {Bool} {@link Bool}
   */
  edit_icon_custom_emoji_id: Bool;

  /**
   * New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
   * @type {int64} {@link int64}
   */
  icon_custom_emoji_id: int64;
};

/**
 * Version of {@link messageForumTopicEdited} for method parameters.
 *
 * A forum topic has been edited
 */
export type messageForumTopicEdited$Input = {
  readonly _: "messageForumTopicEdited";

  /**
   * If non-empty, the new name of the topic
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * True, if icon's custom_emoji_id is changed
   * @type {Bool} {@link Bool}
   */
  readonly edit_icon_custom_emoji_id?: Bool$Input;

  /**
   * New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
   * @type {int64} {@link int64}
   */
  readonly icon_custom_emoji_id?: int64$Input;
};

/**
 * A forum topic has been closed or opened
 */
export type messageForumTopicIsClosedToggled = {
  _: "messageForumTopicIsClosedToggled";

  /**
   * True, if the topic was closed; otherwise, the topic was reopened
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

/**
 * Version of {@link messageForumTopicIsClosedToggled} for method parameters.
 *
 * A forum topic has been closed or opened
 */
export type messageForumTopicIsClosedToggled$Input = {
  readonly _: "messageForumTopicIsClosedToggled";

  /**
   * True, if the topic was closed; otherwise, the topic was reopened
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/**
 * A General forum topic has been hidden or unhidden
 */
export type messageForumTopicIsHiddenToggled = {
  _: "messageForumTopicIsHiddenToggled";

  /**
   * True, if the topic was hidden; otherwise, the topic was unhidden
   * @type {Bool} {@link Bool}
   */
  is_hidden: Bool;
};

/**
 * Version of {@link messageForumTopicIsHiddenToggled} for method parameters.
 *
 * A General forum topic has been hidden or unhidden
 */
export type messageForumTopicIsHiddenToggled$Input = {
  readonly _: "messageForumTopicIsHiddenToggled";

  /**
   * True, if the topic was hidden; otherwise, the topic was unhidden
   * @type {Bool} {@link Bool}
   */
  readonly is_hidden?: Bool$Input;
};

/**
 * A profile photo was suggested to a user in a private chat
 */
export type messageSuggestProfilePhoto = {
  _: "messageSuggestProfilePhoto";

  /**
   * The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto;
};

/**
 * Version of {@link messageSuggestProfilePhoto} for method parameters.
 *
 * A profile photo was suggested to a user in a private chat
 */
export type messageSuggestProfilePhoto$Input = {
  readonly _: "messageSuggestProfilePhoto";

  /**
   * The suggested chat photo. Use the method setProfilePhoto with inputChatPhotoPrevious to apply the photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input;
};

/**
 * A non-standard action has happened in the chat
 */
export type messageCustomServiceAction = {
  _: "messageCustomServiceAction";

  /**
   * Message text to be shown in the chat
   * @type {string} {@link string}
   */
  text: string;
};

/**
 * Version of {@link messageCustomServiceAction} for method parameters.
 *
 * A non-standard action has happened in the chat
 */
export type messageCustomServiceAction$Input = {
  readonly _: "messageCustomServiceAction";

  /**
   * Message text to be shown in the chat
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * A new high score was achieved in a game
 */
export type messageGameScore = {
  _: "messageGameScore";

  /**
   * Identifier of the message with the game, can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  game_message_id: int53;

  /**
   * Identifier of the game; may be different from the games presented in the message with the game
   * @type {int64} {@link int64}
   */
  game_id: int64;

  /**
   * New score
   * @type {int32} {@link int32}
   */
  score: int32;
};

/**
 * Version of {@link messageGameScore} for method parameters.
 *
 * A new high score was achieved in a game
 */
export type messageGameScore$Input = {
  readonly _: "messageGameScore";

  /**
   * Identifier of the message with the game, can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly game_message_id?: int53;

  /**
   * Identifier of the game; may be different from the games presented in the message with the game
   * @type {int64} {@link int64}
   */
  readonly game_id?: int64$Input;

  /**
   * New score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;
};

/**
 * A payment has been completed
 */
export type messagePaymentSuccessful = {
  _: "messagePaymentSuccessful";

  /**
   * Identifier of the chat, containing the corresponding invoice message
   * @type {int53} {@link int53}
   */
  invoice_chat_id: int53;

  /**
   * Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  invoice_message_id: int53;

  /**
   * Currency for the price of the product
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  is_recurring: Bool;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  is_first_recurring: Bool;

  /**
   * Name of the invoice; may be empty if unknown
   * @type {string} {@link string}
   */
  invoice_name: string;
};

/**
 * Version of {@link messagePaymentSuccessful} for method parameters.
 *
 * A payment has been completed
 */
export type messagePaymentSuccessful$Input = {
  readonly _: "messagePaymentSuccessful";

  /**
   * Identifier of the chat, containing the corresponding invoice message
   * @type {int53} {@link int53}
   */
  readonly invoice_chat_id?: int53;

  /**
   * Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly invoice_message_id?: int53;

  /**
   * Currency for the price of the product
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_recurring?: Bool$Input;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_first_recurring?: Bool$Input;

  /**
   * Name of the invoice; may be empty if unknown
   * @type {string} {@link string}
   */
  readonly invoice_name?: string;
};

/**
 * A payment has been completed; for bots only
 */
export type messagePaymentSuccessfulBot = {
  _: "messagePaymentSuccessfulBot";

  /**
   * Currency for price of the product
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  is_recurring: Bool;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  is_first_recurring: Bool;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  invoice_payload: bytes;

  /**
   * Identifier of the shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  shipping_option_id: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  order_info: orderInfo | null;

  /**
   * Telegram payment identifier
   * @type {string} {@link string}
   */
  telegram_payment_charge_id: string;

  /**
   * Provider payment identifier
   * @type {string} {@link string}
   */
  provider_payment_charge_id: string;
};

/**
 * Version of {@link messagePaymentSuccessfulBot} for method parameters.
 *
 * A payment has been completed; for bots only
 */
export type messagePaymentSuccessfulBot$Input = {
  readonly _: "messagePaymentSuccessfulBot";

  /**
   * Currency for price of the product
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_recurring?: Bool$Input;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_first_recurring?: Bool$Input;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  readonly invoice_payload?: bytes$Input;

  /**
   * Identifier of the shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input | null;

  /**
   * Telegram payment identifier
   * @type {string} {@link string}
   */
  readonly telegram_payment_charge_id?: string;

  /**
   * Provider payment identifier
   * @type {string} {@link string}
   */
  readonly provider_payment_charge_id?: string;
};

/**
 * Telegram Premium was gifted to the user
 */
export type messageGiftedPremium = {
  _: "messageGiftedPremium";

  /**
   * The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous
   * @type {int53} {@link int53}
   */
  gifter_user_id: int53;

  /**
   * Currency for the paid amount
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * The paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Cryptocurrency used to pay for the gift; may be empty if none
   * @type {string} {@link string}
   */
  cryptocurrency: string;

  /**
   * The paid amount, in the smallest units of the cryptocurrency; 0 if none
   * @type {int64} {@link int64}
   */
  cryptocurrency_amount: int64;

  /**
   * Number of months the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  sticker: sticker | null;
};

/**
 * Version of {@link messageGiftedPremium} for method parameters.
 *
 * Telegram Premium was gifted to the user
 */
export type messageGiftedPremium$Input = {
  readonly _: "messageGiftedPremium";

  /**
   * The identifier of a user that gifted Telegram Premium; 0 if the gift was anonymous
   * @type {int53} {@link int53}
   */
  readonly gifter_user_id?: int53;

  /**
   * Currency for the paid amount
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * The paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Cryptocurrency used to pay for the gift; may be empty if none
   * @type {string} {@link string}
   */
  readonly cryptocurrency?: string;

  /**
   * The paid amount, in the smallest units of the cryptocurrency; 0 if none
   * @type {int64} {@link int64}
   */
  readonly cryptocurrency_amount?: int64$Input;

  /**
   * Number of months the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input | null;
};

/**
 * A Telegram Premium gift code was created for the user
 */
export type messagePremiumGiftCode = {
  _: "messagePremiumGiftCode";

  /**
   * Identifier of a chat or a user that created the gift code; may be null if unknown
   * @type {MessageSender} {@link MessageSender}
   */
  creator_id: MessageSender | null;

  /**
   * True, if the gift code was created for a giveaway
   * @type {Bool} {@link Bool}
   */
  is_from_giveaway: Bool;

  /**
   * True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
   * @type {Bool} {@link Bool}
   */
  is_unclaimed: Bool;

  /**
   * Currency for the paid amount; empty if unknown
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * The paid amount, in the smallest units of the currency; 0 if unknown
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Cryptocurrency used to pay for the gift; may be empty if none or unknown
   * @type {string} {@link string}
   */
  cryptocurrency: string;

  /**
   * The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
   * @type {int64} {@link int64}
   */
  cryptocurrency_amount: int64;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  sticker: sticker | null;

  /**
   * The gift code
   * @type {string} {@link string}
   */
  code: string;
};

/**
 * Version of {@link messagePremiumGiftCode} for method parameters.
 *
 * A Telegram Premium gift code was created for the user
 */
export type messagePremiumGiftCode$Input = {
  readonly _: "messagePremiumGiftCode";

  /**
   * Identifier of a chat or a user that created the gift code; may be null if unknown
   * @type {MessageSender} {@link MessageSender}
   */
  readonly creator_id?: MessageSender$Input | null;

  /**
   * True, if the gift code was created for a giveaway
   * @type {Bool} {@link Bool}
   */
  readonly is_from_giveaway?: Bool$Input;

  /**
   * True, if the winner for the corresponding Telegram Premium subscription wasn't chosen
   * @type {Bool} {@link Bool}
   */
  readonly is_unclaimed?: Bool$Input;

  /**
   * Currency for the paid amount; empty if unknown
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * The paid amount, in the smallest units of the currency; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Cryptocurrency used to pay for the gift; may be empty if none or unknown
   * @type {string} {@link string}
   */
  readonly cryptocurrency?: string;

  /**
   * The paid amount, in the smallest units of the cryptocurrency; 0 if unknown
   * @type {int64} {@link int64}
   */
  readonly cryptocurrency_amount?: int64$Input;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input | null;

  /**
   * The gift code
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * A Telegram Premium giveaway was created for the chat
 */
export type messagePremiumGiveawayCreated = {
  _: "messagePremiumGiveawayCreated";
};

/**
 * Version of {@link messagePremiumGiveawayCreated} for method parameters.
 *
 * A Telegram Premium giveaway was created for the chat
 */
export type messagePremiumGiveawayCreated$Input = {
  readonly _: "messagePremiumGiveawayCreated";
};

/**
 * A Telegram Premium giveaway
 */
export type messagePremiumGiveaway = {
  _: "messagePremiumGiveaway";

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters} {@link premiumGiveawayParameters}
   */
  parameters: premiumGiveawayParameters;

  /**
   * Number of users which will receive Telegram Premium subscription gift codes
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  sticker: sticker | null;
};

/**
 * Version of {@link messagePremiumGiveaway} for method parameters.
 *
 * A Telegram Premium giveaway
 */
export type messagePremiumGiveaway$Input = {
  readonly _: "messagePremiumGiveaway";

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters} {@link premiumGiveawayParameters}
   */
  readonly parameters?: premiumGiveawayParameters$Input;

  /**
   * Number of users which will receive Telegram Premium subscription gift codes
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input | null;
};

/**
 * A Telegram Premium giveaway without public winners has been completed for the chat
 */
export type messagePremiumGiveawayCompleted = {
  _: "messagePremiumGiveawayCompleted";

  /**
   * Identifier of the message with the giveaway; can be 0 if the message was deleted
   * @type {int53} {@link int53}
   */
  giveaway_message_id: int53;

  /**
   * Number of winners in the giveaway
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Number of undistributed prizes
   * @type {int32} {@link int32}
   */
  unclaimed_prize_count: int32;
};

/**
 * Version of {@link messagePremiumGiveawayCompleted} for method parameters.
 *
 * A Telegram Premium giveaway without public winners has been completed for the chat
 */
export type messagePremiumGiveawayCompleted$Input = {
  readonly _: "messagePremiumGiveawayCompleted";

  /**
   * Identifier of the message with the giveaway; can be 0 if the message was deleted
   * @type {int53} {@link int53}
   */
  readonly giveaway_message_id?: int53;

  /**
   * Number of winners in the giveaway
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Number of undistributed prizes
   * @type {int32} {@link int32}
   */
  readonly unclaimed_prize_count?: int32;
};

/**
 * A Telegram Premium giveaway with public winners has been completed for the chat
 */
export type messagePremiumGiveawayWinners = {
  _: "messagePremiumGiveawayWinners";

  /**
   * Identifier of the channel chat, which was automatically boosted by the winners of the giveaway for duration of the Premium subscription
   * @type {int53} {@link int53}
   */
  boosted_chat_id: int53;

  /**
   * Identifier of the message with the giveaway in the boosted chat
   * @type {int53} {@link int53}
   */
  giveaway_message_id: int53;

  /**
   * Number of other chats that participated in the giveaway
   * @type {int32} {@link int32}
   */
  additional_chat_count: int32;

  /**
   * Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
   * @type {int32} {@link int32}
   */
  actual_winners_selection_date: int32;

  /**
   * True, if only new members of the chats were eligible for the giveaway
   * @type {Bool} {@link Bool}
   */
  only_new_members: Bool;

  /**
   * True, if the giveaway was canceled and was fully refunded
   * @type {Bool} {@link Bool}
   */
  was_refunded: Bool;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * Additional description of the giveaway prize
   * @type {string} {@link string}
   */
  prize_description: string;

  /**
   * Total number of winners in the giveaway
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Up to 100 user identifiers of the winners of the giveaway
   * @type {vector<int53>} {@link vector<int53>}
   */
  winner_user_ids: vector<int53>;

  /**
   * Number of undistributed prizes
   * @type {int32} {@link int32}
   */
  unclaimed_prize_count: int32;
};

/**
 * Version of {@link messagePremiumGiveawayWinners} for method parameters.
 *
 * A Telegram Premium giveaway with public winners has been completed for the chat
 */
export type messagePremiumGiveawayWinners$Input = {
  readonly _: "messagePremiumGiveawayWinners";

  /**
   * Identifier of the channel chat, which was automatically boosted by the winners of the giveaway for duration of the Premium subscription
   * @type {int53} {@link int53}
   */
  readonly boosted_chat_id?: int53;

  /**
   * Identifier of the message with the giveaway in the boosted chat
   * @type {int53} {@link int53}
   */
  readonly giveaway_message_id?: int53;

  /**
   * Number of other chats that participated in the giveaway
   * @type {int32} {@link int32}
   */
  readonly additional_chat_count?: int32;

  /**
   * Point in time (Unix timestamp) when the winners were selected. May be bigger than winners selection date specified in parameters of the giveaway
   * @type {int32} {@link int32}
   */
  readonly actual_winners_selection_date?: int32;

  /**
   * True, if only new members of the chats were eligible for the giveaway
   * @type {Bool} {@link Bool}
   */
  readonly only_new_members?: Bool$Input;

  /**
   * True, if the giveaway was canceled and was fully refunded
   * @type {Bool} {@link Bool}
   */
  readonly was_refunded?: Bool$Input;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * Additional description of the giveaway prize
   * @type {string} {@link string}
   */
  readonly prize_description?: string;

  /**
   * Total number of winners in the giveaway
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Up to 100 user identifiers of the winners of the giveaway
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly winner_user_ids?: vector$Input<int53>;

  /**
   * Number of undistributed prizes
   * @type {int32} {@link int32}
   */
  readonly unclaimed_prize_count?: int32;
};

/**
 * A contact has registered with Telegram
 */
export type messageContactRegistered = {
  _: "messageContactRegistered";
};

/**
 * Version of {@link messageContactRegistered} for method parameters.
 *
 * A contact has registered with Telegram
 */
export type messageContactRegistered$Input = {
  readonly _: "messageContactRegistered";
};

/**
 * The current user shared users, which were requested by the bot
 */
export type messageUsersShared = {
  _: "messageUsersShared";

  /**
   * Identifier of the shared users
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;

  /**
   * Identifier of the keyboard button with the request
   * @type {int32} {@link int32}
   */
  button_id: int32;
};

/**
 * Version of {@link messageUsersShared} for method parameters.
 *
 * The current user shared users, which were requested by the bot
 */
export type messageUsersShared$Input = {
  readonly _: "messageUsersShared";

  /**
   * Identifier of the shared users
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * Identifier of the keyboard button with the request
   * @type {int32} {@link int32}
   */
  readonly button_id?: int32;
};

/**
 * The current user shared a chat, which was requested by the bot
 */
export type messageChatShared = {
  _: "messageChatShared";

  /**
   * Identifier of the shared chat
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the keyboard button with the request
   * @type {int32} {@link int32}
   */
  button_id: int32;
};

/**
 * Version of {@link messageChatShared} for method parameters.
 *
 * The current user shared a chat, which was requested by the bot
 */
export type messageChatShared$Input = {
  readonly _: "messageChatShared";

  /**
   * Identifier of the shared chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the keyboard button with the request
   * @type {int32} {@link int32}
   */
  readonly button_id?: int32;
};

/**
 * The user allowed the bot to send messages
 */
export type messageBotWriteAccessAllowed = {
  _: "messageBotWriteAccessAllowed";

  /**
   * The reason why the bot was allowed to write messages
   * @type {BotWriteAccessAllowReason} {@link BotWriteAccessAllowReason}
   */
  reason: BotWriteAccessAllowReason;
};

/**
 * Version of {@link messageBotWriteAccessAllowed} for method parameters.
 *
 * The user allowed the bot to send messages
 */
export type messageBotWriteAccessAllowed$Input = {
  readonly _: "messageBotWriteAccessAllowed";

  /**
   * The reason why the bot was allowed to write messages
   * @type {BotWriteAccessAllowReason} {@link BotWriteAccessAllowReason}
   */
  readonly reason?: BotWriteAccessAllowReason$Input;
};

/**
 * Data from a Web App has been sent to a bot
 */
export type messageWebAppDataSent = {
  _: "messageWebAppDataSent";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  button_text: string;
};

/**
 * Version of {@link messageWebAppDataSent} for method parameters.
 *
 * Data from a Web App has been sent to a bot
 */
export type messageWebAppDataSent$Input = {
  readonly _: "messageWebAppDataSent";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;
};

/**
 * Data from a Web App has been received; for bots only
 */
export type messageWebAppDataReceived = {
  _: "messageWebAppDataReceived";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  button_text: string;

  /**
   * The data
   * @type {string} {@link string}
   */
  data: string;
};

/**
 * Version of {@link messageWebAppDataReceived} for method parameters.
 *
 * Data from a Web App has been received; for bots only
 */
export type messageWebAppDataReceived$Input = {
  readonly _: "messageWebAppDataReceived";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;

  /**
   * The data
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Telegram Passport data has been sent to a bot
 */
export type messagePassportDataSent = {
  _: "messagePassportDataSent";

  /**
   * List of Telegram Passport element types sent
   * @type {vector<PassportElementType>} {@link vector<PassportElementType>}
   */
  types: vector<PassportElementType>;
};

/**
 * Version of {@link messagePassportDataSent} for method parameters.
 *
 * Telegram Passport data has been sent to a bot
 */
export type messagePassportDataSent$Input = {
  readonly _: "messagePassportDataSent";

  /**
   * List of Telegram Passport element types sent
   * @type {vector<PassportElementType>} {@link vector<PassportElementType>}
   */
  readonly types?: vector$Input<PassportElementType$Input>;
};

/**
 * Telegram Passport data has been received; for bots only
 */
export type messagePassportDataReceived = {
  _: "messagePassportDataReceived";

  /**
   * List of received Telegram Passport elements
   * @type {vector<encryptedPassportElement>} {@link vector<encryptedPassportElement>}
   */
  elements: vector<encryptedPassportElement>;

  /**
   * Encrypted data credentials
   * @type {encryptedCredentials} {@link encryptedCredentials}
   */
  credentials: encryptedCredentials;
};

/**
 * Version of {@link messagePassportDataReceived} for method parameters.
 *
 * Telegram Passport data has been received; for bots only
 */
export type messagePassportDataReceived$Input = {
  readonly _: "messagePassportDataReceived";

  /**
   * List of received Telegram Passport elements
   * @type {vector<encryptedPassportElement>} {@link vector<encryptedPassportElement>}
   */
  readonly elements?: vector$Input<encryptedPassportElement$Input>;

  /**
   * Encrypted data credentials
   * @type {encryptedCredentials} {@link encryptedCredentials}
   */
  readonly credentials?: encryptedCredentials$Input;
};

/**
 * A user in the chat came within proximity alert range
 */
export type messageProximityAlertTriggered = {
  _: "messageProximityAlertTriggered";

  /**
   * The identifier of a user or chat that triggered the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  traveler_id: MessageSender;

  /**
   * The identifier of a user or chat that subscribed for the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  watcher_id: MessageSender;

  /**
   * The distance between the users
   * @type {int32} {@link int32}
   */
  distance: int32;
};

/**
 * Version of {@link messageProximityAlertTriggered} for method parameters.
 *
 * A user in the chat came within proximity alert range
 */
export type messageProximityAlertTriggered$Input = {
  readonly _: "messageProximityAlertTriggered";

  /**
   * The identifier of a user or chat that triggered the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  readonly traveler_id?: MessageSender$Input;

  /**
   * The identifier of a user or chat that subscribed for the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  readonly watcher_id?: MessageSender$Input;

  /**
   * The distance between the users
   * @type {int32} {@link int32}
   */
  readonly distance?: int32;
};

/**
 * A message content that is not supported in the current TDLib version
 */
export type messageUnsupported = {
  _: "messageUnsupported";
};

/**
 * Version of {@link messageUnsupported} for method parameters.
 *
 * A message content that is not supported in the current TDLib version
 */
export type messageUnsupported$Input = {
  readonly _: "messageUnsupported";
};

/**
 * A mention of a user, a supergroup, or a channel by their username
 */
export type textEntityTypeMention = {
  _: "textEntityTypeMention";
};

/**
 * Version of {@link textEntityTypeMention} for method parameters.
 *
 * A mention of a user, a supergroup, or a channel by their username
 */
export type textEntityTypeMention$Input = {
  readonly _: "textEntityTypeMention";
};

/**
 * A hashtag text, beginning with "#"
 */
export type textEntityTypeHashtag = {
  _: "textEntityTypeHashtag";
};

/**
 * Version of {@link textEntityTypeHashtag} for method parameters.
 *
 * A hashtag text, beginning with "#"
 */
export type textEntityTypeHashtag$Input = {
  readonly _: "textEntityTypeHashtag";
};

/**
 * A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD")
 */
export type textEntityTypeCashtag = {
  _: "textEntityTypeCashtag";
};

/**
 * Version of {@link textEntityTypeCashtag} for method parameters.
 *
 * A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD")
 */
export type textEntityTypeCashtag$Input = {
  readonly _: "textEntityTypeCashtag";
};

/**
 * A bot command, beginning with "/"
 */
export type textEntityTypeBotCommand = {
  _: "textEntityTypeBotCommand";
};

/**
 * Version of {@link textEntityTypeBotCommand} for method parameters.
 *
 * A bot command, beginning with "/"
 */
export type textEntityTypeBotCommand$Input = {
  readonly _: "textEntityTypeBotCommand";
};

/**
 * An HTTP URL
 */
export type textEntityTypeUrl = {
  _: "textEntityTypeUrl";
};

/**
 * Version of {@link textEntityTypeUrl} for method parameters.
 *
 * An HTTP URL
 */
export type textEntityTypeUrl$Input = {
  readonly _: "textEntityTypeUrl";
};

/**
 * An email address
 */
export type textEntityTypeEmailAddress = {
  _: "textEntityTypeEmailAddress";
};

/**
 * Version of {@link textEntityTypeEmailAddress} for method parameters.
 *
 * An email address
 */
export type textEntityTypeEmailAddress$Input = {
  readonly _: "textEntityTypeEmailAddress";
};

/**
 * A phone number
 */
export type textEntityTypePhoneNumber = {
  _: "textEntityTypePhoneNumber";
};

/**
 * Version of {@link textEntityTypePhoneNumber} for method parameters.
 *
 * A phone number
 */
export type textEntityTypePhoneNumber$Input = {
  readonly _: "textEntityTypePhoneNumber";
};

/**
 * A bank card number. The getBankCardInfo method can be used to get information about the bank card
 */
export type textEntityTypeBankCardNumber = {
  _: "textEntityTypeBankCardNumber";
};

/**
 * Version of {@link textEntityTypeBankCardNumber} for method parameters.
 *
 * A bank card number. The getBankCardInfo method can be used to get information about the bank card
 */
export type textEntityTypeBankCardNumber$Input = {
  readonly _: "textEntityTypeBankCardNumber";
};

/**
 * A bold text
 */
export type textEntityTypeBold = {
  _: "textEntityTypeBold";
};

/**
 * Version of {@link textEntityTypeBold} for method parameters.
 *
 * A bold text
 */
export type textEntityTypeBold$Input = {
  readonly _: "textEntityTypeBold";
};

/**
 * An italic text
 */
export type textEntityTypeItalic = {
  _: "textEntityTypeItalic";
};

/**
 * Version of {@link textEntityTypeItalic} for method parameters.
 *
 * An italic text
 */
export type textEntityTypeItalic$Input = {
  readonly _: "textEntityTypeItalic";
};

/**
 * An underlined text
 */
export type textEntityTypeUnderline = {
  _: "textEntityTypeUnderline";
};

/**
 * Version of {@link textEntityTypeUnderline} for method parameters.
 *
 * An underlined text
 */
export type textEntityTypeUnderline$Input = {
  readonly _: "textEntityTypeUnderline";
};

/**
 * A strikethrough text
 */
export type textEntityTypeStrikethrough = {
  _: "textEntityTypeStrikethrough";
};

/**
 * Version of {@link textEntityTypeStrikethrough} for method parameters.
 *
 * A strikethrough text
 */
export type textEntityTypeStrikethrough$Input = {
  readonly _: "textEntityTypeStrikethrough";
};

/**
 * A spoiler text
 */
export type textEntityTypeSpoiler = {
  _: "textEntityTypeSpoiler";
};

/**
 * Version of {@link textEntityTypeSpoiler} for method parameters.
 *
 * A spoiler text
 */
export type textEntityTypeSpoiler$Input = {
  readonly _: "textEntityTypeSpoiler";
};

/**
 * Text that must be formatted as if inside a code HTML tag
 */
export type textEntityTypeCode = {
  _: "textEntityTypeCode";
};

/**
 * Version of {@link textEntityTypeCode} for method parameters.
 *
 * Text that must be formatted as if inside a code HTML tag
 */
export type textEntityTypeCode$Input = {
  readonly _: "textEntityTypeCode";
};

/**
 * Text that must be formatted as if inside a pre HTML tag
 */
export type textEntityTypePre = {
  _: "textEntityTypePre";
};

/**
 * Version of {@link textEntityTypePre} for method parameters.
 *
 * Text that must be formatted as if inside a pre HTML tag
 */
export type textEntityTypePre$Input = {
  readonly _: "textEntityTypePre";
};

/**
 * Text that must be formatted as if inside pre, and code HTML tags
 */
export type textEntityTypePreCode = {
  _: "textEntityTypePreCode";

  /**
   * Programming language of the code; as defined by the sender
   * @type {string} {@link string}
   */
  language: string;
};

/**
 * Version of {@link textEntityTypePreCode} for method parameters.
 *
 * Text that must be formatted as if inside pre, and code HTML tags
 */
export type textEntityTypePreCode$Input = {
  readonly _: "textEntityTypePreCode";

  /**
   * Programming language of the code; as defined by the sender
   * @type {string} {@link string}
   */
  readonly language?: string;
};

/**
 * Text that must be formatted as if inside a blockquote HTML tag
 */
export type textEntityTypeBlockQuote = {
  _: "textEntityTypeBlockQuote";
};

/**
 * Version of {@link textEntityTypeBlockQuote} for method parameters.
 *
 * Text that must be formatted as if inside a blockquote HTML tag
 */
export type textEntityTypeBlockQuote$Input = {
  readonly _: "textEntityTypeBlockQuote";
};

/**
 * A text description shown instead of a raw URL
 */
export type textEntityTypeTextUrl = {
  _: "textEntityTypeTextUrl";

  /**
   * HTTP or tg:// URL to be opened when the link is clicked
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link textEntityTypeTextUrl} for method parameters.
 *
 * A text description shown instead of a raw URL
 */
export type textEntityTypeTextUrl$Input = {
  readonly _: "textEntityTypeTextUrl";

  /**
   * HTTP or tg:// URL to be opened when the link is clicked
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * A text shows instead of a raw mention of the user (e.g., when the user has no username)
 */
export type textEntityTypeMentionName = {
  _: "textEntityTypeMentionName";

  /**
   * Identifier of the mentioned user
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link textEntityTypeMentionName} for method parameters.
 *
 * A text shows instead of a raw mention of the user (e.g., when the user has no username)
 */
export type textEntityTypeMentionName$Input = {
  readonly _: "textEntityTypeMentionName";

  /**
   * Identifier of the mentioned user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji
 */
export type textEntityTypeCustomEmoji = {
  _: "textEntityTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

/**
 * Version of {@link textEntityTypeCustomEmoji} for method parameters.
 *
 * A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji
 */
export type textEntityTypeCustomEmoji$Input = {
  readonly _: "textEntityTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;
};

/**
 * A media timestamp
 */
export type textEntityTypeMediaTimestamp = {
  _: "textEntityTypeMediaTimestamp";

  /**
   * Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message
   * @type {int32} {@link int32}
   */
  media_timestamp: int32;
};

/**
 * Version of {@link textEntityTypeMediaTimestamp} for method parameters.
 *
 * A media timestamp
 */
export type textEntityTypeMediaTimestamp$Input = {
  readonly _: "textEntityTypeMediaTimestamp";

  /**
   * Timestamp from which a video/audio/video note/voice note/story playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;
};

/**
 * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
 */
export type inputThumbnail = {
  _: "inputThumbnail";

  /**
   * Thumbnail file to send. Sending thumbnails by file_id is currently not supported
   * @type {InputFile} {@link InputFile}
   */
  thumbnail: InputFile;

  /**
   * Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;
};

/**
 * Version of {@link inputThumbnail} for method parameters.
 *
 * A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
 */
export type inputThumbnail$Input = {
  readonly _: "inputThumbnail";

  /**
   * Thumbnail file to send. Sending thumbnails by file_id is currently not supported
   * @type {InputFile} {@link InputFile}
   */
  readonly thumbnail?: InputFile$Input;

  /**
   * Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;
};

/**
 * The message will be sent at the specified date
 */
export type messageSchedulingStateSendAtDate = {
  _: "messageSchedulingStateSendAtDate";

  /**
   * Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
   * @type {int32} {@link int32}
   */
  send_date: int32;
};

/**
 * Version of {@link messageSchedulingStateSendAtDate} for method parameters.
 *
 * The message will be sent at the specified date
 */
export type messageSchedulingStateSendAtDate$Input = {
  readonly _: "messageSchedulingStateSendAtDate";

  /**
   * Point in time (Unix timestamp) when the message will be sent. The date must be within 367 days in the future
   * @type {int32} {@link int32}
   */
  readonly send_date?: int32;
};

/**
 * The message will be sent when the other user is online. Applicable to private chats only and when the exact online status of the other user is known
 */
export type messageSchedulingStateSendWhenOnline = {
  _: "messageSchedulingStateSendWhenOnline";
};

/**
 * Version of {@link messageSchedulingStateSendWhenOnline} for method parameters.
 *
 * The message will be sent when the other user is online. Applicable to private chats only and when the exact online status of the other user is known
 */
export type messageSchedulingStateSendWhenOnline$Input = {
  readonly _: "messageSchedulingStateSendWhenOnline";
};

/**
 * The message will be self-destructed in the specified time after its content was opened
 */
export type messageSelfDestructTypeTimer = {
  _: "messageSelfDestructTypeTimer";

  /**
   * The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
   * @type {int32} {@link int32}
   */
  self_destruct_time: int32;
};

/**
 * Version of {@link messageSelfDestructTypeTimer} for method parameters.
 *
 * The message will be self-destructed in the specified time after its content was opened
 */
export type messageSelfDestructTypeTimer$Input = {
  readonly _: "messageSelfDestructTypeTimer";

  /**
   * The message's self-destruct time, in seconds; must be between 0 and 60 in private chats
   * @type {int32} {@link int32}
   */
  readonly self_destruct_time?: int32;
};

/**
 * The message can be opened only once and will be self-destructed once closed
 */
export type messageSelfDestructTypeImmediately = {
  _: "messageSelfDestructTypeImmediately";
};

/**
 * Version of {@link messageSelfDestructTypeImmediately} for method parameters.
 *
 * The message can be opened only once and will be self-destructed once closed
 */
export type messageSelfDestructTypeImmediately$Input = {
  readonly _: "messageSelfDestructTypeImmediately";
};

/**
 * Options to be used when a message is sent
 */
export type messageSendOptions = {
  _: "messageSendOptions";

  /**
   * Pass true to disable notification for the message
   * @type {Bool} {@link Bool}
   */
  disable_notification: Bool;

  /**
   * Pass true if the message is sent from the background
   * @type {Bool} {@link Bool}
   */
  from_background: Bool;

  /**
   * Pass true if the content of the message must be protected from forwarding and saving; for bots only
   * @type {Bool} {@link Bool}
   */
  protect_content: Bool;

  /**
   * Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
   * @type {Bool} {@link Bool}
   */
  update_order_of_installed_sticker_sets: Bool;

  /**
   * Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  scheduling_state: MessageSchedulingState | null;

  /**
   * Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
   * @type {int32} {@link int32}
   */
  sending_id: int32;

  /**
   * Pass true to get a fake message instead of actually sending them
   * @type {Bool} {@link Bool}
   */
  only_preview: Bool;
};

/**
 * Version of {@link messageSendOptions} for method parameters.
 *
 * Options to be used when a message is sent
 */
export type messageSendOptions$Input = {
  readonly _: "messageSendOptions";

  /**
   * Pass true to disable notification for the message
   * @type {Bool} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * Pass true if the message is sent from the background
   * @type {Bool} {@link Bool}
   */
  readonly from_background?: Bool$Input;

  /**
   * Pass true if the content of the message must be protected from forwarding and saving; for bots only
   * @type {Bool} {@link Bool}
   */
  readonly protect_content?: Bool$Input;

  /**
   * Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
   * @type {Bool} {@link Bool}
   */
  readonly update_order_of_installed_sticker_sets?: Bool$Input;

  /**
   * Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input | null;

  /**
   * Non-persistent identifier, which will be returned back in messageSendingStatePending object and can be used to match sent messages and corresponding updateNewMessage updates
   * @type {int32} {@link int32}
   */
  readonly sending_id?: int32;

  /**
   * Pass true to get a fake message instead of actually sending them
   * @type {Bool} {@link Bool}
   */
  readonly only_preview?: Bool$Input;
};

/**
 * Options to be used when a message content is copied without reference to the original sender. Service messages, messages with messageInvoice, messagePremiumGiveaway, or messagePremiumGiveawayWinners content can't be copied
 */
export type messageCopyOptions = {
  _: "messageCopyOptions";

  /**
   * True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
   * @type {Bool} {@link Bool}
   */
  send_copy: Bool;

  /**
   * True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
   * @type {Bool} {@link Bool}
   */
  replace_caption: Bool;

  /**
   * New message caption; pass null to copy message without caption. Ignored if replace_caption is false
   * @type {formattedText} {@link formattedText}
   */
  new_caption: formattedText | null;
};

/**
 * Version of {@link messageCopyOptions} for method parameters.
 *
 * Options to be used when a message content is copied without reference to the original sender. Service messages, messages with messageInvoice, messagePremiumGiveaway, or messagePremiumGiveawayWinners content can't be copied
 */
export type messageCopyOptions$Input = {
  readonly _: "messageCopyOptions";

  /**
   * True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
   * @type {Bool} {@link Bool}
   */
  readonly send_copy?: Bool$Input;

  /**
   * True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
   * @type {Bool} {@link Bool}
   */
  readonly replace_caption?: Bool$Input;

  /**
   * New message caption; pass null to copy message without caption. Ignored if replace_caption is false
   * @type {formattedText} {@link formattedText}
   */
  readonly new_caption?: formattedText$Input | null;
};

/**
 * A text message
 */
export type inputMessageText = {
  _: "inputMessageText";

  /**
   * Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * Options to be used for generation of a link preview; pass null to use default link preview options
   * @type {linkPreviewOptions} {@link linkPreviewOptions}
   */
  link_preview_options: linkPreviewOptions | null;

  /**
   * True, if a chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  clear_draft: Bool;
};

/**
 * Version of {@link inputMessageText} for method parameters.
 *
 * A text message
 */
export type inputMessageText$Input = {
  readonly _: "inputMessageText";

  /**
   * Formatted text to be sent; 0-getOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Options to be used for generation of a link preview; pass null to use default link preview options
   * @type {linkPreviewOptions} {@link linkPreviewOptions}
   */
  readonly link_preview_options?: linkPreviewOptions$Input | null;

  /**
   * True, if a chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  readonly clear_draft?: Bool$Input;
};

/**
 * An animation message (GIF-style).
 */
export type inputMessageAnimation = {
  _: "inputMessageAnimation";

  /**
   * Animation file to be sent
   * @type {InputFile} {@link InputFile}
   */
  animation: InputFile;

  /**
   * Animation thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail | null;

  /**
   * File identifiers of the stickers added to the animation, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Duration of the animation, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Width of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Height of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText | null;

  /**
   * True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
   * @type {Bool} {@link Bool}
   */
  has_spoiler: Bool;
};

/**
 * Version of {@link inputMessageAnimation} for method parameters.
 *
 * An animation message (GIF-style).
 */
export type inputMessageAnimation$Input = {
  readonly _: "inputMessageAnimation";

  /**
   * Animation file to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly animation?: InputFile$Input;

  /**
   * Animation thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input | null;

  /**
   * File identifiers of the stickers added to the animation, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Duration of the animation, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Width of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Height of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Animation caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;

  /**
   * True, if the animation preview must be covered by a spoiler animation; not supported in secret chats
   * @type {Bool} {@link Bool}
   */
  readonly has_spoiler?: Bool$Input;
};

/**
 * An audio message
 */
export type inputMessageAudio = {
  _: "inputMessageAudio";

  /**
   * Audio file to be sent
   * @type {InputFile} {@link InputFile}
   */
  audio: InputFile;

  /**
   * Thumbnail of the cover for the album; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  album_cover_thumbnail: inputThumbnail | null;

  /**
   * Duration of the audio, in seconds; may be replaced by the server
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Title of the audio; 0-64 characters; may be replaced by the server
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Performer of the audio; 0-64 characters, may be replaced by the server
   * @type {string} {@link string}
   */
  performer: string;

  /**
   * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText | null;
};

/**
 * Version of {@link inputMessageAudio} for method parameters.
 *
 * An audio message
 */
export type inputMessageAudio$Input = {
  readonly _: "inputMessageAudio";

  /**
   * Audio file to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly audio?: InputFile$Input;

  /**
   * Thumbnail of the cover for the album; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly album_cover_thumbnail?: inputThumbnail$Input | null;

  /**
   * Duration of the audio, in seconds; may be replaced by the server
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Title of the audio; 0-64 characters; may be replaced by the server
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Performer of the audio; 0-64 characters, may be replaced by the server
   * @type {string} {@link string}
   */
  readonly performer?: string;

  /**
   * Audio caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * A document message (general file)
 */
export type inputMessageDocument = {
  _: "inputMessageDocument";

  /**
   * Document to be sent
   * @type {InputFile} {@link InputFile}
   */
  document: InputFile;

  /**
   * Document thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail | null;

  /**
   * Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
   * @type {Bool} {@link Bool}
   */
  disable_content_type_detection: Bool;

  /**
   * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText | null;
};

/**
 * Version of {@link inputMessageDocument} for method parameters.
 *
 * A document message (general file)
 */
export type inputMessageDocument$Input = {
  readonly _: "inputMessageDocument";

  /**
   * Document to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly document?: InputFile$Input;

  /**
   * Document thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input | null;

  /**
   * Pass true to disable automatic file type detection and send the document as a file. Always true for files sent to secret chats
   * @type {Bool} {@link Bool}
   */
  readonly disable_content_type_detection?: Bool$Input;

  /**
   * Document caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * A photo message
 */
export type inputMessagePhoto = {
  _: "inputMessagePhoto";

  /**
   * Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
   * @type {InputFile} {@link InputFile}
   */
  photo: InputFile;

  /**
   * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail | null;

  /**
   * File identifiers of the stickers added to the photo, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Photo width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Photo height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText | null;

  /**
   * Photo self-destruct type; pass null if none; private chats only
   * @type {MessageSelfDestructType} {@link MessageSelfDestructType}
   */
  self_destruct_type: MessageSelfDestructType | null;

  /**
   * True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
   * @type {Bool} {@link Bool}
   */
  has_spoiler: Bool;
};

/**
 * Version of {@link inputMessagePhoto} for method parameters.
 *
 * A photo message
 */
export type inputMessagePhoto$Input = {
  readonly _: "inputMessagePhoto";

  /**
   * Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
   * @type {InputFile} {@link InputFile}
   */
  readonly photo?: InputFile$Input;

  /**
   * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input | null;

  /**
   * File identifiers of the stickers added to the photo, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Photo width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Photo height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Photo caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;

  /**
   * Photo self-destruct type; pass null if none; private chats only
   * @type {MessageSelfDestructType} {@link MessageSelfDestructType}
   */
  readonly self_destruct_type?: MessageSelfDestructType$Input | null;

  /**
   * True, if the photo preview must be covered by a spoiler animation; not supported in secret chats
   * @type {Bool} {@link Bool}
   */
  readonly has_spoiler?: Bool$Input;
};

/**
 * A sticker message
 */
export type inputMessageSticker = {
  _: "inputMessageSticker";

  /**
   * Sticker to be sent
   * @type {InputFile} {@link InputFile}
   */
  sticker: InputFile;

  /**
   * Sticker thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail | null;

  /**
   * Sticker width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Sticker height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Emoji used to choose the sticker
   * @type {string} {@link string}
   */
  emoji: string;
};

/**
 * Version of {@link inputMessageSticker} for method parameters.
 *
 * A sticker message
 */
export type inputMessageSticker$Input = {
  readonly _: "inputMessageSticker";

  /**
   * Sticker to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * Sticker thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input | null;

  /**
   * Sticker width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Sticker height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Emoji used to choose the sticker
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * A video message
 */
export type inputMessageVideo = {
  _: "inputMessageVideo";

  /**
   * Video to be sent
   * @type {InputFile} {@link InputFile}
   */
  video: InputFile;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail | null;

  /**
   * File identifiers of the stickers added to the video, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Video width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Video height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  supports_streaming: Bool;

  /**
   * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText | null;

  /**
   * Video self-destruct type; pass null if none; private chats only
   * @type {MessageSelfDestructType} {@link MessageSelfDestructType}
   */
  self_destruct_type: MessageSelfDestructType | null;

  /**
   * True, if the video preview must be covered by a spoiler animation; not supported in secret chats
   * @type {Bool} {@link Bool}
   */
  has_spoiler: Bool;
};

/**
 * Version of {@link inputMessageVideo} for method parameters.
 *
 * A video message
 */
export type inputMessageVideo$Input = {
  readonly _: "inputMessageVideo";

  /**
   * Video to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly video?: InputFile$Input;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input | null;

  /**
   * File identifiers of the stickers added to the video, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Video width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Video height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  readonly supports_streaming?: Bool$Input;

  /**
   * Video caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;

  /**
   * Video self-destruct type; pass null if none; private chats only
   * @type {MessageSelfDestructType} {@link MessageSelfDestructType}
   */
  readonly self_destruct_type?: MessageSelfDestructType$Input | null;

  /**
   * True, if the video preview must be covered by a spoiler animation; not supported in secret chats
   * @type {Bool} {@link Bool}
   */
  readonly has_spoiler?: Bool$Input;
};

/**
 * A video note message
 */
export type inputMessageVideoNote = {
  _: "inputMessageVideoNote";

  /**
   * Video note to be sent
   * @type {InputFile} {@link InputFile}
   */
  video_note: InputFile;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail | null;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Video width and height; must be positive and not greater than 640
   * @type {int32} {@link int32}
   */
  length: int32;
};

/**
 * Version of {@link inputMessageVideoNote} for method parameters.
 *
 * A video note message
 */
export type inputMessageVideoNote$Input = {
  readonly _: "inputMessageVideoNote";

  /**
   * Video note to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly video_note?: InputFile$Input;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input | null;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Video width and height; must be positive and not greater than 640
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/**
 * A voice note message
 */
export type inputMessageVoiceNote = {
  _: "inputMessageVoiceNote";

  /**
   * Voice note to be sent
   * @type {InputFile} {@link InputFile}
   */
  voice_note: InputFile;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  waveform: bytes;

  /**
   * Voice note caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText | null;
};

/**
 * Version of {@link inputMessageVoiceNote} for method parameters.
 *
 * A voice note message
 */
export type inputMessageVoiceNote$Input = {
  readonly _: "inputMessageVoiceNote";

  /**
   * Voice note to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly voice_note?: InputFile$Input;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  readonly waveform?: bytes$Input;

  /**
   * Voice note caption; pass null to use an empty caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * A message with a location
 */
export type inputMessageLocation = {
  _: "inputMessageLocation";

  /**
   * Location to be sent
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise
   * @type {int32} {@link int32}
   */
  live_period: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  heading: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
   * @type {int32} {@link int32}
   */
  proximity_alert_radius: int32;
};

/**
 * Version of {@link inputMessageLocation} for method parameters.
 *
 * A message with a location
 */
export type inputMessageLocation$Input = {
  readonly _: "inputMessageLocation";

  /**
   * Location to be sent
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise
   * @type {int32} {@link int32}
   */
  readonly live_period?: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * A message with information about a venue
 */
export type inputMessageVenue = {
  _: "inputMessageVenue";

  /**
   * Venue to send
   * @type {venue} {@link venue}
   */
  venue: venue;
};

/**
 * Version of {@link inputMessageVenue} for method parameters.
 *
 * A message with information about a venue
 */
export type inputMessageVenue$Input = {
  readonly _: "inputMessageVenue";

  /**
   * Venue to send
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;
};

/**
 * A message containing a user contact
 */
export type inputMessageContact = {
  _: "inputMessageContact";

  /**
   * Contact to send
   * @type {contact} {@link contact}
   */
  contact: contact;
};

/**
 * Version of {@link inputMessageContact} for method parameters.
 *
 * A message containing a user contact
 */
export type inputMessageContact$Input = {
  readonly _: "inputMessageContact";

  /**
   * Contact to send
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;
};

/**
 * A dice message
 */
export type inputMessageDice = {
  _: "inputMessageDice";

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * True, if the chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  clear_draft: Bool;
};

/**
 * Version of {@link inputMessageDice} for method parameters.
 *
 * A dice message
 */
export type inputMessageDice$Input = {
  readonly _: "inputMessageDice";

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * True, if the chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  readonly clear_draft?: Bool$Input;
};

/**
 * A message with a game; not supported for channels or secret chats
 */
export type inputMessageGame = {
  _: "inputMessageGame";

  /**
   * User identifier of the bot that owns the game
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  game_short_name: string;
};

/**
 * Version of {@link inputMessageGame} for method parameters.
 *
 * A message with a game; not supported for channels or secret chats
 */
export type inputMessageGame$Input = {
  readonly _: "inputMessageGame";

  /**
   * User identifier of the bot that owns the game
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;
};

/**
 * A message with an invoice; can be used only by bots
 */
export type inputMessageInvoice = {
  _: "inputMessageInvoice";

  /**
   * Invoice
   * @type {invoice} {@link invoice}
   */
  invoice: invoice;

  /**
   * Product title; 1-32 characters
   * @type {string} {@link string}
   */
  title: string;

  /**
   * A message with an invoice; can be used only by bots
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Product photo URL; optional
   * @type {string} {@link string}
   */
  photo_url: string;

  /**
   * Product photo size
   * @type {int32} {@link int32}
   */
  photo_size: int32;

  /**
   * Product photo width
   * @type {int32} {@link int32}
   */
  photo_width: int32;

  /**
   * Product photo height
   * @type {int32} {@link int32}
   */
  photo_height: int32;

  /**
   * The invoice payload
   * @type {bytes} {@link bytes}
   */
  payload: bytes;

  /**
   * Payment provider token
   * @type {string} {@link string}
   */
  provider_token: string;

  /**
   * JSON-encoded data about the invoice, which will be shared with the payment provider
   * @type {string} {@link string}
   */
  provider_data: string;

  /**
   * Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * The content of extended media attached to the invoice. The content of the message to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  extended_media_content: InputMessageContent;
};

/**
 * Version of {@link inputMessageInvoice} for method parameters.
 *
 * A message with an invoice; can be used only by bots
 */
export type inputMessageInvoice$Input = {
  readonly _: "inputMessageInvoice";

  /**
   * Invoice
   * @type {invoice} {@link invoice}
   */
  readonly invoice?: invoice$Input;

  /**
   * Product title; 1-32 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * A message with an invoice; can be used only by bots
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Product photo URL; optional
   * @type {string} {@link string}
   */
  readonly photo_url?: string;

  /**
   * Product photo size
   * @type {int32} {@link int32}
   */
  readonly photo_size?: int32;

  /**
   * Product photo width
   * @type {int32} {@link int32}
   */
  readonly photo_width?: int32;

  /**
   * Product photo height
   * @type {int32} {@link int32}
   */
  readonly photo_height?: int32;

  /**
   * The invoice payload
   * @type {bytes} {@link bytes}
   */
  readonly payload?: bytes$Input;

  /**
   * Payment provider token
   * @type {string} {@link string}
   */
  readonly provider_token?: string;

  /**
   * JSON-encoded data about the invoice, which will be shared with the payment provider
   * @type {string} {@link string}
   */
  readonly provider_data?: string;

  /**
   * Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * The content of extended media attached to the invoice. The content of the message to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly extended_media_content?: InputMessageContent$Input;
};

/**
 * A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
 */
export type inputMessagePoll = {
  _: "inputMessagePoll";

  /**
   * Poll question; 1-255 characters (up to 300 characters for bots)
   * @type {string} {@link string}
   */
  question: string;

  /**
   * List of poll answer options, 2-10 strings 1-100 characters each
   * @type {vector<string>} {@link vector<string>}
   */
  options: vector<string>;

  /**
   * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  type: PollType;

  /**
   * Amount of time the poll will be active after creation, in seconds; for bots only
   * @type {int32} {@link int32}
   */
  open_period: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
   * @type {int32} {@link int32}
   */
  close_date: int32;

  /**
   * True, if the poll needs to be sent already closed; for bots only
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

/**
 * Version of {@link inputMessagePoll} for method parameters.
 *
 * A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
 */
export type inputMessagePoll$Input = {
  readonly _: "inputMessagePoll";

  /**
   * Poll question; 1-255 characters (up to 300 characters for bots)
   * @type {string} {@link string}
   */
  readonly question?: string;

  /**
   * List of poll answer options, 2-10 strings 1-100 characters each
   * @type {vector<string>} {@link vector<string>}
   */
  readonly options?: vector$Input<string>;

  /**
   * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  readonly type?: PollType$Input;

  /**
   * Amount of time the poll will be active after creation, in seconds; for bots only
   * @type {int32} {@link int32}
   */
  readonly open_period?: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
   * @type {int32} {@link int32}
   */
  readonly close_date?: int32;

  /**
   * True, if the poll needs to be sent already closed; for bots only
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/**
 * A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded
 */
export type inputMessageStory = {
  _: "inputMessageStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  story_sender_chat_id: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link inputMessageStory} for method parameters.
 *
 * A message with a forwarded story. Stories can't be sent to secret chats. A story can be forwarded only if story.can_be_forwarded
 */
export type inputMessageStory$Input = {
  readonly _: "inputMessageStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * A forwarded message
 */
export type inputMessageForwarded = {
  _: "inputMessageForwarded";

  /**
   * Identifier for the chat this forwarded message came from
   * @type {int53} {@link int53}
   */
  from_chat_id: int53;

  /**
   * Identifier of the message to forward. A message can be forwarded only if message.can_be_forwarded
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * True, if a game message is being shared from a launched game; applies only to game messages
   * @type {Bool} {@link Bool}
   */
  in_game_share: Bool;

  /**
   * Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
   * @type {messageCopyOptions} {@link messageCopyOptions}
   */
  copy_options: messageCopyOptions | null;
};

/**
 * Version of {@link inputMessageForwarded} for method parameters.
 *
 * A forwarded message
 */
export type inputMessageForwarded$Input = {
  readonly _: "inputMessageForwarded";

  /**
   * Identifier for the chat this forwarded message came from
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * Identifier of the message to forward. A message can be forwarded only if message.can_be_forwarded
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * True, if a game message is being shared from a launched game; applies only to game messages
   * @type {Bool} {@link Bool}
   */
  readonly in_game_share?: Bool$Input;

  /**
   * Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
   * @type {messageCopyOptions} {@link messageCopyOptions}
   */
  readonly copy_options?: messageCopyOptions$Input | null;
};

/**
 * Returns all found messages, no filter is applied
 */
export type searchMessagesFilterEmpty = {
  _: "searchMessagesFilterEmpty";
};

/**
 * Version of {@link searchMessagesFilterEmpty} for method parameters.
 *
 * Returns all found messages, no filter is applied
 */
export type searchMessagesFilterEmpty$Input = {
  readonly _: "searchMessagesFilterEmpty";
};

/**
 * Returns only animation messages
 */
export type searchMessagesFilterAnimation = {
  _: "searchMessagesFilterAnimation";
};

/**
 * Version of {@link searchMessagesFilterAnimation} for method parameters.
 *
 * Returns only animation messages
 */
export type searchMessagesFilterAnimation$Input = {
  readonly _: "searchMessagesFilterAnimation";
};

/**
 * Returns only audio messages
 */
export type searchMessagesFilterAudio = {
  _: "searchMessagesFilterAudio";
};

/**
 * Version of {@link searchMessagesFilterAudio} for method parameters.
 *
 * Returns only audio messages
 */
export type searchMessagesFilterAudio$Input = {
  readonly _: "searchMessagesFilterAudio";
};

/**
 * Returns only document messages
 */
export type searchMessagesFilterDocument = {
  _: "searchMessagesFilterDocument";
};

/**
 * Version of {@link searchMessagesFilterDocument} for method parameters.
 *
 * Returns only document messages
 */
export type searchMessagesFilterDocument$Input = {
  readonly _: "searchMessagesFilterDocument";
};

/**
 * Returns only photo messages
 */
export type searchMessagesFilterPhoto = {
  _: "searchMessagesFilterPhoto";
};

/**
 * Version of {@link searchMessagesFilterPhoto} for method parameters.
 *
 * Returns only photo messages
 */
export type searchMessagesFilterPhoto$Input = {
  readonly _: "searchMessagesFilterPhoto";
};

/**
 * Returns only video messages
 */
export type searchMessagesFilterVideo = {
  _: "searchMessagesFilterVideo";
};

/**
 * Version of {@link searchMessagesFilterVideo} for method parameters.
 *
 * Returns only video messages
 */
export type searchMessagesFilterVideo$Input = {
  readonly _: "searchMessagesFilterVideo";
};

/**
 * Returns only voice note messages
 */
export type searchMessagesFilterVoiceNote = {
  _: "searchMessagesFilterVoiceNote";
};

/**
 * Version of {@link searchMessagesFilterVoiceNote} for method parameters.
 *
 * Returns only voice note messages
 */
export type searchMessagesFilterVoiceNote$Input = {
  readonly _: "searchMessagesFilterVoiceNote";
};

/**
 * Returns only photo and video messages
 */
export type searchMessagesFilterPhotoAndVideo = {
  _: "searchMessagesFilterPhotoAndVideo";
};

/**
 * Version of {@link searchMessagesFilterPhotoAndVideo} for method parameters.
 *
 * Returns only photo and video messages
 */
export type searchMessagesFilterPhotoAndVideo$Input = {
  readonly _: "searchMessagesFilterPhotoAndVideo";
};

/**
 * Returns only messages containing URLs
 */
export type searchMessagesFilterUrl = {
  _: "searchMessagesFilterUrl";
};

/**
 * Version of {@link searchMessagesFilterUrl} for method parameters.
 *
 * Returns only messages containing URLs
 */
export type searchMessagesFilterUrl$Input = {
  readonly _: "searchMessagesFilterUrl";
};

/**
 * Returns only messages containing chat photos
 */
export type searchMessagesFilterChatPhoto = {
  _: "searchMessagesFilterChatPhoto";
};

/**
 * Version of {@link searchMessagesFilterChatPhoto} for method parameters.
 *
 * Returns only messages containing chat photos
 */
export type searchMessagesFilterChatPhoto$Input = {
  readonly _: "searchMessagesFilterChatPhoto";
};

/**
 * Returns only video note messages
 */
export type searchMessagesFilterVideoNote = {
  _: "searchMessagesFilterVideoNote";
};

/**
 * Version of {@link searchMessagesFilterVideoNote} for method parameters.
 *
 * Returns only video note messages
 */
export type searchMessagesFilterVideoNote$Input = {
  readonly _: "searchMessagesFilterVideoNote";
};

/**
 * Returns only voice and video note messages
 */
export type searchMessagesFilterVoiceAndVideoNote = {
  _: "searchMessagesFilterVoiceAndVideoNote";
};

/**
 * Version of {@link searchMessagesFilterVoiceAndVideoNote} for method parameters.
 *
 * Returns only voice and video note messages
 */
export type searchMessagesFilterVoiceAndVideoNote$Input = {
  readonly _: "searchMessagesFilterVoiceAndVideoNote";
};

/**
 * Returns only messages with mentions of the current user, or messages that are replies to their messages
 */
export type searchMessagesFilterMention = {
  _: "searchMessagesFilterMention";
};

/**
 * Version of {@link searchMessagesFilterMention} for method parameters.
 *
 * Returns only messages with mentions of the current user, or messages that are replies to their messages
 */
export type searchMessagesFilterMention$Input = {
  readonly _: "searchMessagesFilterMention";
};

/**
 * Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
 */
export type searchMessagesFilterUnreadMention = {
  _: "searchMessagesFilterUnreadMention";
};

/**
 * Version of {@link searchMessagesFilterUnreadMention} for method parameters.
 *
 * Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
 */
export type searchMessagesFilterUnreadMention$Input = {
  readonly _: "searchMessagesFilterUnreadMention";
};

/**
 * Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
 */
export type searchMessagesFilterUnreadReaction = {
  _: "searchMessagesFilterUnreadReaction";
};

/**
 * Version of {@link searchMessagesFilterUnreadReaction} for method parameters.
 *
 * Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
 */
export type searchMessagesFilterUnreadReaction$Input = {
  readonly _: "searchMessagesFilterUnreadReaction";
};

/**
 * Returns only failed to send messages. This filter can be used only if the message database is used
 */
export type searchMessagesFilterFailedToSend = {
  _: "searchMessagesFilterFailedToSend";
};

/**
 * Version of {@link searchMessagesFilterFailedToSend} for method parameters.
 *
 * Returns only failed to send messages. This filter can be used only if the message database is used
 */
export type searchMessagesFilterFailedToSend$Input = {
  readonly _: "searchMessagesFilterFailedToSend";
};

/**
 * Returns only pinned messages
 */
export type searchMessagesFilterPinned = {
  _: "searchMessagesFilterPinned";
};

/**
 * Version of {@link searchMessagesFilterPinned} for method parameters.
 *
 * Returns only pinned messages
 */
export type searchMessagesFilterPinned$Input = {
  readonly _: "searchMessagesFilterPinned";
};

/**
 * The user is typing a message
 */
export type chatActionTyping = {
  _: "chatActionTyping";
};

/**
 * Version of {@link chatActionTyping} for method parameters.
 *
 * The user is typing a message
 */
export type chatActionTyping$Input = {
  readonly _: "chatActionTyping";
};

/**
 * The user is recording a video
 */
export type chatActionRecordingVideo = {
  _: "chatActionRecordingVideo";
};

/**
 * Version of {@link chatActionRecordingVideo} for method parameters.
 *
 * The user is recording a video
 */
export type chatActionRecordingVideo$Input = {
  readonly _: "chatActionRecordingVideo";
};

/**
 * The user is uploading a video
 */
export type chatActionUploadingVideo = {
  _: "chatActionUploadingVideo";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

/**
 * Version of {@link chatActionUploadingVideo} for method parameters.
 *
 * The user is uploading a video
 */
export type chatActionUploadingVideo$Input = {
  readonly _: "chatActionUploadingVideo";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/**
 * The user is recording a voice note
 */
export type chatActionRecordingVoiceNote = {
  _: "chatActionRecordingVoiceNote";
};

/**
 * Version of {@link chatActionRecordingVoiceNote} for method parameters.
 *
 * The user is recording a voice note
 */
export type chatActionRecordingVoiceNote$Input = {
  readonly _: "chatActionRecordingVoiceNote";
};

/**
 * The user is uploading a voice note
 */
export type chatActionUploadingVoiceNote = {
  _: "chatActionUploadingVoiceNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

/**
 * Version of {@link chatActionUploadingVoiceNote} for method parameters.
 *
 * The user is uploading a voice note
 */
export type chatActionUploadingVoiceNote$Input = {
  readonly _: "chatActionUploadingVoiceNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/**
 * The user is uploading a photo
 */
export type chatActionUploadingPhoto = {
  _: "chatActionUploadingPhoto";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

/**
 * Version of {@link chatActionUploadingPhoto} for method parameters.
 *
 * The user is uploading a photo
 */
export type chatActionUploadingPhoto$Input = {
  readonly _: "chatActionUploadingPhoto";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/**
 * The user is uploading a document
 */
export type chatActionUploadingDocument = {
  _: "chatActionUploadingDocument";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

/**
 * Version of {@link chatActionUploadingDocument} for method parameters.
 *
 * The user is uploading a document
 */
export type chatActionUploadingDocument$Input = {
  readonly _: "chatActionUploadingDocument";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/**
 * The user is picking a sticker to send
 */
export type chatActionChoosingSticker = {
  _: "chatActionChoosingSticker";
};

/**
 * Version of {@link chatActionChoosingSticker} for method parameters.
 *
 * The user is picking a sticker to send
 */
export type chatActionChoosingSticker$Input = {
  readonly _: "chatActionChoosingSticker";
};

/**
 * The user is picking a location or venue to send
 */
export type chatActionChoosingLocation = {
  _: "chatActionChoosingLocation";
};

/**
 * Version of {@link chatActionChoosingLocation} for method parameters.
 *
 * The user is picking a location or venue to send
 */
export type chatActionChoosingLocation$Input = {
  readonly _: "chatActionChoosingLocation";
};

/**
 * The user is picking a contact to send
 */
export type chatActionChoosingContact = {
  _: "chatActionChoosingContact";
};

/**
 * Version of {@link chatActionChoosingContact} for method parameters.
 *
 * The user is picking a contact to send
 */
export type chatActionChoosingContact$Input = {
  readonly _: "chatActionChoosingContact";
};

/**
 * The user has started to play a game
 */
export type chatActionStartPlayingGame = {
  _: "chatActionStartPlayingGame";
};

/**
 * Version of {@link chatActionStartPlayingGame} for method parameters.
 *
 * The user has started to play a game
 */
export type chatActionStartPlayingGame$Input = {
  readonly _: "chatActionStartPlayingGame";
};

/**
 * The user is recording a video note
 */
export type chatActionRecordingVideoNote = {
  _: "chatActionRecordingVideoNote";
};

/**
 * Version of {@link chatActionRecordingVideoNote} for method parameters.
 *
 * The user is recording a video note
 */
export type chatActionRecordingVideoNote$Input = {
  readonly _: "chatActionRecordingVideoNote";
};

/**
 * The user is uploading a video note
 */
export type chatActionUploadingVideoNote = {
  _: "chatActionUploadingVideoNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

/**
 * Version of {@link chatActionUploadingVideoNote} for method parameters.
 *
 * The user is uploading a video note
 */
export type chatActionUploadingVideoNote$Input = {
  readonly _: "chatActionUploadingVideoNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/**
 * The user is watching animations sent by the other party by clicking on an animated emoji
 */
export type chatActionWatchingAnimations = {
  _: "chatActionWatchingAnimations";

  /**
   * The animated emoji
   * @type {string} {@link string}
   */
  emoji: string;
};

/**
 * Version of {@link chatActionWatchingAnimations} for method parameters.
 *
 * The user is watching animations sent by the other party by clicking on an animated emoji
 */
export type chatActionWatchingAnimations$Input = {
  readonly _: "chatActionWatchingAnimations";

  /**
   * The animated emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * The user has canceled the previous action
 */
export type chatActionCancel = {
  _: "chatActionCancel";
};

/**
 * Version of {@link chatActionCancel} for method parameters.
 *
 * The user has canceled the previous action
 */
export type chatActionCancel$Input = {
  readonly _: "chatActionCancel";
};

/**
 * The user status was never changed
 */
export type userStatusEmpty = {
  _: "userStatusEmpty";
};

/**
 * Version of {@link userStatusEmpty} for method parameters.
 *
 * The user status was never changed
 */
export type userStatusEmpty$Input = {
  readonly _: "userStatusEmpty";
};

/**
 * The user is online
 */
export type userStatusOnline = {
  _: "userStatusOnline";

  /**
   * Point in time (Unix timestamp) when the user's online status will expire
   * @type {int32} {@link int32}
   */
  expires: int32;
};

/**
 * Version of {@link userStatusOnline} for method parameters.
 *
 * The user is online
 */
export type userStatusOnline$Input = {
  readonly _: "userStatusOnline";

  /**
   * Point in time (Unix timestamp) when the user's online status will expire
   * @type {int32} {@link int32}
   */
  readonly expires?: int32;
};

/**
 * The user is offline
 */
export type userStatusOffline = {
  _: "userStatusOffline";

  /**
   * Point in time (Unix timestamp) when the user was last online
   * @type {int32} {@link int32}
   */
  was_online: int32;
};

/**
 * Version of {@link userStatusOffline} for method parameters.
 *
 * The user is offline
 */
export type userStatusOffline$Input = {
  readonly _: "userStatusOffline";

  /**
   * Point in time (Unix timestamp) when the user was last online
   * @type {int32} {@link int32}
   */
  readonly was_online?: int32;
};

/**
 * The user was online recently
 */
export type userStatusRecently = {
  _: "userStatusRecently";
};

/**
 * Version of {@link userStatusRecently} for method parameters.
 *
 * The user was online recently
 */
export type userStatusRecently$Input = {
  readonly _: "userStatusRecently";
};

/**
 * The user is offline, but was online last week
 */
export type userStatusLastWeek = {
  _: "userStatusLastWeek";
};

/**
 * Version of {@link userStatusLastWeek} for method parameters.
 *
 * The user is offline, but was online last week
 */
export type userStatusLastWeek$Input = {
  readonly _: "userStatusLastWeek";
};

/**
 * The user is offline, but was online last month
 */
export type userStatusLastMonth = {
  _: "userStatusLastMonth";
};

/**
 * Version of {@link userStatusLastMonth} for method parameters.
 *
 * The user is offline, but was online last month
 */
export type userStatusLastMonth$Input = {
  readonly _: "userStatusLastMonth";
};

/**
 * Represents a list of stickers
 */
export type stickers = {
  _: "stickers";

  /**
   * List of stickers
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  stickers: vector<sticker>;
};

/**
 * Version of {@link stickers} for method parameters.
 *
 * Represents a list of stickers
 */
export type stickers$Input = {
  readonly _: "stickers";

  /**
   * List of stickers
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  readonly stickers?: vector$Input<sticker$Input>;
};

/**
 * Represents a list of emoji
 */
export type emojis = {
  _: "emojis";

  /**
   * List of emojis
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

/**
 * Version of {@link emojis} for method parameters.
 *
 * Represents a list of emoji
 */
export type emojis$Input = {
  readonly _: "emojis";

  /**
   * List of emojis
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/**
 * Represents a sticker set
 */
export type stickerSet = {
  _: "stickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  thumbnail_outline: vector<closedVectorPath>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  is_installed: Bool;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  is_archived: Bool;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  is_official: Bool;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  sticker_format: StickerFormat;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  needs_repainting: Bool;

  /**
   * True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  is_allowed_as_chat_emoji_status: Bool;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  is_viewed: Bool;

  /**
   * List of stickers in this set
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  stickers: vector<sticker>;

  /**
   * A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
   * @type {vector<emojis>} {@link vector<emojis>}
   */
  emojis: vector<emojis>;
};

/**
 * Version of {@link stickerSet} for method parameters.
 *
 * Represents a sticker set
 */
export type stickerSet$Input = {
  readonly _: "stickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  readonly thumbnail_outline?: vector$Input<closedVectorPath$Input>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  readonly is_archived?: Bool$Input;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  readonly is_official?: Bool$Input;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  readonly needs_repainting?: Bool$Input;

  /**
   * True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  readonly is_allowed_as_chat_emoji_status?: Bool$Input;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  readonly is_viewed?: Bool$Input;

  /**
   * List of stickers in this set
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  readonly stickers?: vector$Input<sticker$Input>;

  /**
   * A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
   * @type {vector<emojis>} {@link vector<emojis>}
   */
  readonly emojis?: vector$Input<emojis$Input>;
};

/**
 * Represents short information about a sticker set
 */
export type stickerSetInfo = {
  _: "stickerSetInfo";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  thumbnail_outline: vector<closedVectorPath>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  is_installed: Bool;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  is_archived: Bool;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  is_official: Bool;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  sticker_format: StickerFormat;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  needs_repainting: Bool;

  /**
   * True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  is_allowed_as_chat_emoji_status: Bool;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  is_viewed: Bool;

  /**
   * Total number of stickers in the set
   * @type {int32} {@link int32}
   */
  size: int32;

  /**
   * Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  covers: vector<sticker>;
};

/**
 * Version of {@link stickerSetInfo} for method parameters.
 *
 * Represents short information about a sticker set
 */
export type stickerSetInfo$Input = {
  readonly _: "stickerSetInfo";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  readonly thumbnail_outline?: vector$Input<closedVectorPath$Input>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  readonly is_archived?: Bool$Input;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  readonly is_official?: Bool$Input;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * True, if stickers in the sticker set are custom emoji that must be repainted; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  readonly needs_repainting?: Bool$Input;

  /**
   * True, if stickers in the sticker set are custom emoji that can be used as chat emoji status; for custom emoji sticker sets only
   * @type {Bool} {@link Bool}
   */
  readonly is_allowed_as_chat_emoji_status?: Bool$Input;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  readonly is_viewed?: Bool$Input;

  /**
   * Total number of stickers in the set
   * @type {int32} {@link int32}
   */
  readonly size?: int32;

  /**
   * Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  readonly covers?: vector$Input<sticker$Input>;
};

/**
 * Represents a list of sticker sets
 */
export type stickerSets = {
  _: "stickerSets";

  /**
   * Approximate total number of sticker sets found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  sets: vector<stickerSetInfo>;
};

/**
 * Version of {@link stickerSets} for method parameters.
 *
 * Represents a list of sticker sets
 */
export type stickerSets$Input = {
  readonly _: "stickerSets";

  /**
   * Approximate total number of sticker sets found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  readonly sets?: vector$Input<stickerSetInfo$Input>;
};

/**
 * Represents a list of trending sticker sets
 */
export type trendingStickerSets = {
  _: "trendingStickerSets";

  /**
   * Approximate total number of trending sticker sets
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of trending sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  sets: vector<stickerSetInfo>;

  /**
   * True, if the list contains sticker sets with premium stickers
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;
};

/**
 * Version of {@link trendingStickerSets} for method parameters.
 *
 * Represents a list of trending sticker sets
 */
export type trendingStickerSets$Input = {
  readonly _: "trendingStickerSets";

  /**
   * Approximate total number of trending sticker sets
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of trending sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  readonly sets?: vector$Input<stickerSetInfo$Input>;

  /**
   * True, if the list contains sticker sets with premium stickers
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;
};

/**
 * Contains a list of similar emoji to search for in getStickers and searchStickers
 */
export type emojiCategory = {
  _: "emojiCategory";

  /**
   * Name of the category
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Custom emoji sticker, which represents icon of the category
   * @type {sticker} {@link sticker}
   */
  icon: sticker;

  /**
   * List of emojis in the category
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

/**
 * Version of {@link emojiCategory} for method parameters.
 *
 * Contains a list of similar emoji to search for in getStickers and searchStickers
 */
export type emojiCategory$Input = {
  readonly _: "emojiCategory";

  /**
   * Name of the category
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Custom emoji sticker, which represents icon of the category
   * @type {sticker} {@link sticker}
   */
  readonly icon?: sticker$Input;

  /**
   * List of emojis in the category
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/**
 * Represents a list of emoji categories
 */
export type emojiCategories = {
  _: "emojiCategories";

  /**
   * List of categories
   * @type {vector<emojiCategory>} {@link vector<emojiCategory>}
   */
  categories: vector<emojiCategory>;
};

/**
 * Version of {@link emojiCategories} for method parameters.
 *
 * Represents a list of emoji categories
 */
export type emojiCategories$Input = {
  readonly _: "emojiCategories";

  /**
   * List of categories
   * @type {vector<emojiCategory>} {@link vector<emojiCategory>}
   */
  readonly categories?: vector$Input<emojiCategory$Input>;
};

/**
 * The category must be used by default
 */
export type emojiCategoryTypeDefault = {
  _: "emojiCategoryTypeDefault";
};

/**
 * Version of {@link emojiCategoryTypeDefault} for method parameters.
 *
 * The category must be used by default
 */
export type emojiCategoryTypeDefault$Input = {
  readonly _: "emojiCategoryTypeDefault";
};

/**
 * The category must be used for emoji status selection
 */
export type emojiCategoryTypeEmojiStatus = {
  _: "emojiCategoryTypeEmojiStatus";
};

/**
 * Version of {@link emojiCategoryTypeEmojiStatus} for method parameters.
 *
 * The category must be used for emoji status selection
 */
export type emojiCategoryTypeEmojiStatus$Input = {
  readonly _: "emojiCategoryTypeEmojiStatus";
};

/**
 * The category must be used for chat photo emoji selection
 */
export type emojiCategoryTypeChatPhoto = {
  _: "emojiCategoryTypeChatPhoto";
};

/**
 * Version of {@link emojiCategoryTypeChatPhoto} for method parameters.
 *
 * The category must be used for chat photo emoji selection
 */
export type emojiCategoryTypeChatPhoto$Input = {
  readonly _: "emojiCategoryTypeChatPhoto";
};

/**
 * Describes position of a clickable rectangle area on a story media
 */
export type storyAreaPosition = {
  _: "storyAreaPosition";

  /**
   * The abscissa of the rectangle's center, as a percentage of the media width
   * @type {double} {@link double}
   */
  x_percentage: double;

  /**
   * The ordinate of the rectangle's center, as a percentage of the media height
   * @type {double} {@link double}
   */
  y_percentage: double;

  /**
   * The width of the rectangle, as a percentage of the media width
   * @type {double} {@link double}
   */
  width_percentage: double;

  /**
   * The height of the rectangle, as a percentage of the media height
   * @type {double} {@link double}
   */
  height_percentage: double;

  /**
   * Clockwise rotation angle of the rectangle, in degrees; 0-360
   * @type {double} {@link double}
   */
  rotation_angle: double;
};

/**
 * Version of {@link storyAreaPosition} for method parameters.
 *
 * Describes position of a clickable rectangle area on a story media
 */
export type storyAreaPosition$Input = {
  readonly _: "storyAreaPosition";

  /**
   * The abscissa of the rectangle's center, as a percentage of the media width
   * @type {double} {@link double}
   */
  readonly x_percentage?: double;

  /**
   * The ordinate of the rectangle's center, as a percentage of the media height
   * @type {double} {@link double}
   */
  readonly y_percentage?: double;

  /**
   * The width of the rectangle, as a percentage of the media width
   * @type {double} {@link double}
   */
  readonly width_percentage?: double;

  /**
   * The height of the rectangle, as a percentage of the media height
   * @type {double} {@link double}
   */
  readonly height_percentage?: double;

  /**
   * Clockwise rotation angle of the rectangle, in degrees; 0-360
   * @type {double} {@link double}
   */
  readonly rotation_angle?: double;
};

/**
 * An area pointing to a location
 */
export type storyAreaTypeLocation = {
  _: "storyAreaTypeLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  location: location;
};

/**
 * Version of {@link storyAreaTypeLocation} for method parameters.
 *
 * An area pointing to a location
 */
export type storyAreaTypeLocation$Input = {
  readonly _: "storyAreaTypeLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * An area pointing to a venue
 */
export type storyAreaTypeVenue = {
  _: "storyAreaTypeVenue";

  /**
   * Information about the venue
   * @type {venue} {@link venue}
   */
  venue: venue;
};

/**
 * Version of {@link storyAreaTypeVenue} for method parameters.
 *
 * An area pointing to a venue
 */
export type storyAreaTypeVenue$Input = {
  readonly _: "storyAreaTypeVenue";

  /**
   * Information about the venue
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;
};

/**
 * An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked
 */
export type storyAreaTypeSuggestedReaction = {
  _: "storyAreaTypeSuggestedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  reaction_type: ReactionType;

  /**
   * Number of times the reaction was added
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * True, if reaction has a dark background
   * @type {Bool} {@link Bool}
   */
  is_dark: Bool;

  /**
   * True, if reaction corner is flipped
   * @type {Bool} {@link Bool}
   */
  is_flipped: Bool;
};

/**
 * Version of {@link storyAreaTypeSuggestedReaction} for method parameters.
 *
 * An area pointing to a suggested reaction. App needs to show a clickable reaction on the area and call setStoryReaction when the are is clicked
 */
export type storyAreaTypeSuggestedReaction$Input = {
  readonly _: "storyAreaTypeSuggestedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;

  /**
   * Number of times the reaction was added
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * True, if reaction has a dark background
   * @type {Bool} {@link Bool}
   */
  readonly is_dark?: Bool$Input;

  /**
   * True, if reaction corner is flipped
   * @type {Bool} {@link Bool}
   */
  readonly is_flipped?: Bool$Input;
};

/**
 * An area pointing to a message
 */
export type storyAreaTypeMessage = {
  _: "storyAreaTypeMessage";

  /**
   * Identifier of the chat with the message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link storyAreaTypeMessage} for method parameters.
 *
 * An area pointing to a message
 */
export type storyAreaTypeMessage$Input = {
  readonly _: "storyAreaTypeMessage";

  /**
   * Identifier of the chat with the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Describes a clickable rectangle area on a story media
 */
export type storyArea = {
  _: "storyArea";

  /**
   * Position of the area
   * @type {storyAreaPosition} {@link storyAreaPosition}
   */
  position: storyAreaPosition;

  /**
   * Type of the area
   * @type {StoryAreaType} {@link StoryAreaType}
   */
  type: StoryAreaType;
};

/**
 * Version of {@link storyArea} for method parameters.
 *
 * Describes a clickable rectangle area on a story media
 */
export type storyArea$Input = {
  readonly _: "storyArea";

  /**
   * Position of the area
   * @type {storyAreaPosition} {@link storyAreaPosition}
   */
  readonly position?: storyAreaPosition$Input;

  /**
   * Type of the area
   * @type {StoryAreaType} {@link StoryAreaType}
   */
  readonly type?: StoryAreaType$Input;
};

/**
 * An area pointing to a location
 */
export type inputStoryAreaTypeLocation = {
  _: "inputStoryAreaTypeLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  location: location;
};

/**
 * Version of {@link inputStoryAreaTypeLocation} for method parameters.
 *
 * An area pointing to a location
 */
export type inputStoryAreaTypeLocation$Input = {
  readonly _: "inputStoryAreaTypeLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * An area pointing to a venue found by the bot getOption("venue_search_bot_username")
 */
export type inputStoryAreaTypeFoundVenue = {
  _: "inputStoryAreaTypeFoundVenue";

  /**
   * Identifier of the inline query, used to found the venue
   * @type {int64} {@link int64}
   */
  query_id: int64;

  /**
   * Identifier of the inline query result
   * @type {string} {@link string}
   */
  result_id: string;
};

/**
 * Version of {@link inputStoryAreaTypeFoundVenue} for method parameters.
 *
 * An area pointing to a venue found by the bot getOption("venue_search_bot_username")
 */
export type inputStoryAreaTypeFoundVenue$Input = {
  readonly _: "inputStoryAreaTypeFoundVenue";

  /**
   * Identifier of the inline query, used to found the venue
   * @type {int64} {@link int64}
   */
  readonly query_id?: int64$Input;

  /**
   * Identifier of the inline query result
   * @type {string} {@link string}
   */
  readonly result_id?: string;
};

/**
 * An area pointing to a venue already added to the story
 */
export type inputStoryAreaTypePreviousVenue = {
  _: "inputStoryAreaTypePreviousVenue";

  /**
   * Provider of the venue
   * @type {string} {@link string}
   */
  venue_provider: string;

  /**
   * Identifier of the venue in the provider database
   * @type {string} {@link string}
   */
  venue_id: string;
};

/**
 * Version of {@link inputStoryAreaTypePreviousVenue} for method parameters.
 *
 * An area pointing to a venue already added to the story
 */
export type inputStoryAreaTypePreviousVenue$Input = {
  readonly _: "inputStoryAreaTypePreviousVenue";

  /**
   * Provider of the venue
   * @type {string} {@link string}
   */
  readonly venue_provider?: string;

  /**
   * Identifier of the venue in the provider database
   * @type {string} {@link string}
   */
  readonly venue_id?: string;
};

/**
 * An area pointing to a suggested reaction
 */
export type inputStoryAreaTypeSuggestedReaction = {
  _: "inputStoryAreaTypeSuggestedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  reaction_type: ReactionType;

  /**
   * True, if reaction has a dark background
   * @type {Bool} {@link Bool}
   */
  is_dark: Bool;

  /**
   * True, if reaction corner is flipped
   * @type {Bool} {@link Bool}
   */
  is_flipped: Bool;
};

/**
 * Version of {@link inputStoryAreaTypeSuggestedReaction} for method parameters.
 *
 * An area pointing to a suggested reaction
 */
export type inputStoryAreaTypeSuggestedReaction$Input = {
  readonly _: "inputStoryAreaTypeSuggestedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;

  /**
   * True, if reaction has a dark background
   * @type {Bool} {@link Bool}
   */
  readonly is_dark?: Bool$Input;

  /**
   * True, if reaction corner is flipped
   * @type {Bool} {@link Bool}
   */
  readonly is_flipped?: Bool$Input;
};

/**
 * An area pointing to a message
 */
export type inputStoryAreaTypeMessage = {
  _: "inputStoryAreaTypeMessage";

  /**
   * Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message. Only successfully sent non-scheduled messages can be specified
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link inputStoryAreaTypeMessage} for method parameters.
 *
 * An area pointing to a message
 */
export type inputStoryAreaTypeMessage$Input = {
  readonly _: "inputStoryAreaTypeMessage";

  /**
   * Identifier of the chat with the message. Currently, the chat must be a supergroup or a channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message. Only successfully sent non-scheduled messages can be specified
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Describes a clickable rectangle area on a story media to be added
 */
export type inputStoryArea = {
  _: "inputStoryArea";

  /**
   * Position of the area
   * @type {storyAreaPosition} {@link storyAreaPosition}
   */
  position: storyAreaPosition;

  /**
   * Type of the area
   * @type {InputStoryAreaType} {@link InputStoryAreaType}
   */
  type: InputStoryAreaType;
};

/**
 * Version of {@link inputStoryArea} for method parameters.
 *
 * Describes a clickable rectangle area on a story media to be added
 */
export type inputStoryArea$Input = {
  readonly _: "inputStoryArea";

  /**
   * Position of the area
   * @type {storyAreaPosition} {@link storyAreaPosition}
   */
  readonly position?: storyAreaPosition$Input;

  /**
   * Type of the area
   * @type {InputStoryAreaType} {@link InputStoryAreaType}
   */
  readonly type?: InputStoryAreaType$Input;
};

/**
 * Contains a list of story areas to be added
 */
export type inputStoryAreas = {
  _: "inputStoryAreas";

  /**
   * List of input story areas. Currently, a story can have
   *
   * - up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas,
   *
   * - up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, and up to 1 inputStoryAreaTypeMessage area
   * @type {vector<inputStoryArea>} {@link vector<inputStoryArea>}
   */
  areas: vector<inputStoryArea>;
};

/**
 * Version of {@link inputStoryAreas} for method parameters.
 *
 * Contains a list of story areas to be added
 */
export type inputStoryAreas$Input = {
  readonly _: "inputStoryAreas";

  /**
   * List of input story areas. Currently, a story can have
   *
   * - up to 10 inputStoryAreaTypeLocation, inputStoryAreaTypeFoundVenue, and inputStoryAreaTypePreviousVenue areas,
   *
   * - up to getOption("story_suggested_reaction_area_count_max") inputStoryAreaTypeSuggestedReaction areas, and up to 1 inputStoryAreaTypeMessage area
   * @type {vector<inputStoryArea>} {@link vector<inputStoryArea>}
   */
  readonly areas?: vector$Input<inputStoryArea$Input>;
};

/**
 * Describes a video file sent in a story
 */
export type storyVideo = {
  _: "storyVideo";

  /**
   * Duration of the video, in seconds
   * @type {double} {@link double}
   */
  duration: double;

  /**
   * Video width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Video height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * True, if the video has no sound
   * @type {Bool} {@link Bool}
   */
  is_animation: Bool;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail | null;

  /**
   * Video thumbnail in JPEG or MPEG4 format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;

  /**
   * Size of file prefix, which is supposed to be preloaded, in bytes
   * @type {int32} {@link int32}
   */
  preload_prefix_size: int32;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  video: file;
};

/**
 * Version of {@link storyVideo} for method parameters.
 *
 * Describes a video file sent in a story
 */
export type storyVideo$Input = {
  readonly _: "storyVideo";

  /**
   * Duration of the video, in seconds
   * @type {double} {@link double}
   */
  readonly duration?: double;

  /**
   * Video width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Video height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * True, if the video has no sound
   * @type {Bool} {@link Bool}
   */
  readonly is_animation?: Bool$Input;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input | null;

  /**
   * Video thumbnail in JPEG or MPEG4 format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;

  /**
   * Size of file prefix, which is supposed to be preloaded, in bytes
   * @type {int32} {@link int32}
   */
  readonly preload_prefix_size?: int32;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  readonly video?: file$Input;
};

/**
 * A photo story
 */
export type storyContentPhoto = {
  _: "storyContentPhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  photo: photo;
};

/**
 * Version of {@link storyContentPhoto} for method parameters.
 *
 * A photo story
 */
export type storyContentPhoto$Input = {
  readonly _: "storyContentPhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;
};

/**
 * A video story
 */
export type storyContentVideo = {
  _: "storyContentVideo";

  /**
   * The video in MPEG4 format
   * @type {storyVideo} {@link storyVideo}
   */
  video: storyVideo;

  /**
   * Alternative version of the video in MPEG4 format, encoded by x264 codec; may be null
   * @type {storyVideo} {@link storyVideo}
   */
  alternative_video: storyVideo | null;
};

/**
 * Version of {@link storyContentVideo} for method parameters.
 *
 * A video story
 */
export type storyContentVideo$Input = {
  readonly _: "storyContentVideo";

  /**
   * The video in MPEG4 format
   * @type {storyVideo} {@link storyVideo}
   */
  readonly video?: storyVideo$Input;

  /**
   * Alternative version of the video in MPEG4 format, encoded by x264 codec; may be null
   * @type {storyVideo} {@link storyVideo}
   */
  readonly alternative_video?: storyVideo$Input | null;
};

/**
 * A story content that is not supported in the current TDLib version
 */
export type storyContentUnsupported = {
  _: "storyContentUnsupported";
};

/**
 * Version of {@link storyContentUnsupported} for method parameters.
 *
 * A story content that is not supported in the current TDLib version
 */
export type storyContentUnsupported$Input = {
  readonly _: "storyContentUnsupported";
};

/**
 * A photo story
 */
export type inputStoryContentPhoto = {
  _: "inputStoryContentPhoto";

  /**
   * Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920
   * @type {InputFile} {@link InputFile}
   */
  photo: InputFile;

  /**
   * File identifiers of the stickers added to the photo, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;
};

/**
 * Version of {@link inputStoryContentPhoto} for method parameters.
 *
 * A photo story
 */
export type inputStoryContentPhoto$Input = {
  readonly _: "inputStoryContentPhoto";

  /**
   * Photo to send. The photo must be at most 10 MB in size. The photo size must be 1080x1920
   * @type {InputFile} {@link InputFile}
   */
  readonly photo?: InputFile$Input;

  /**
   * File identifiers of the stickers added to the photo, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;
};

/**
 * A video story
 */
export type inputStoryContentVideo = {
  _: "inputStoryContentVideo";

  /**
   * Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with x265 codec and key frames added each second
   * @type {InputFile} {@link InputFile}
   */
  video: InputFile;

  /**
   * File identifiers of the stickers added to the video, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Precise duration of the video, in seconds; 0-60
   * @type {double} {@link double}
   */
  duration: double;

  /**
   * True, if the video has no sound
   * @type {Bool} {@link Bool}
   */
  is_animation: Bool;
};

/**
 * Version of {@link inputStoryContentVideo} for method parameters.
 *
 * A video story
 */
export type inputStoryContentVideo$Input = {
  readonly _: "inputStoryContentVideo";

  /**
   * Video to be sent. The video size must be 720x1280. The video must be streamable and stored in MPEG4 format, after encoding with x265 codec and key frames added each second
   * @type {InputFile} {@link InputFile}
   */
  readonly video?: InputFile$Input;

  /**
   * File identifiers of the stickers added to the video, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Precise duration of the video, in seconds; 0-60
   * @type {double} {@link double}
   */
  readonly duration?: double;

  /**
   * True, if the video has no sound
   * @type {Bool} {@link Bool}
   */
  readonly is_animation?: Bool$Input;
};

/**
 * The list of stories, shown in the main chat list and folder chat lists
 */
export type storyListMain = {
  _: "storyListMain";
};

/**
 * Version of {@link storyListMain} for method parameters.
 *
 * The list of stories, shown in the main chat list and folder chat lists
 */
export type storyListMain$Input = {
  readonly _: "storyListMain";
};

/**
 * The list of stories, shown in the Arvhive chat list
 */
export type storyListArchive = {
  _: "storyListArchive";
};

/**
 * Version of {@link storyListArchive} for method parameters.
 *
 * The list of stories, shown in the Arvhive chat list
 */
export type storyListArchive$Input = {
  readonly _: "storyListArchive";
};

/**
 * The original story was a public story with known sender
 */
export type storyOriginPublicStory = {
  _: "storyOriginPublicStory";

  /**
   * Identifier of the chat that posted original story
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Story identifier of the original story
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link storyOriginPublicStory} for method parameters.
 *
 * The original story was a public story with known sender
 */
export type storyOriginPublicStory$Input = {
  readonly _: "storyOriginPublicStory";

  /**
   * Identifier of the chat that posted original story
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Story identifier of the original story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * The original story was sent by an unknown user
 */
export type storyOriginHiddenUser = {
  _: "storyOriginHiddenUser";

  /**
   * Name of the story sender
   * @type {string} {@link string}
   */
  sender_name: string;
};

/**
 * Version of {@link storyOriginHiddenUser} for method parameters.
 *
 * The original story was sent by an unknown user
 */
export type storyOriginHiddenUser$Input = {
  readonly _: "storyOriginHiddenUser";

  /**
   * Name of the story sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;
};

/**
 * Contains information about original story that was reposted
 */
export type storyRepostInfo = {
  _: "storyRepostInfo";

  /**
   * Origin of the story that was reposted
   * @type {StoryOrigin} {@link StoryOrigin}
   */
  origin: StoryOrigin;

  /**
   * True, if story content was modified during reposting; otherwise, story wasn't modified
   * @type {Bool} {@link Bool}
   */
  is_content_modified: Bool;
};

/**
 * Version of {@link storyRepostInfo} for method parameters.
 *
 * Contains information about original story that was reposted
 */
export type storyRepostInfo$Input = {
  readonly _: "storyRepostInfo";

  /**
   * Origin of the story that was reposted
   * @type {StoryOrigin} {@link StoryOrigin}
   */
  readonly origin?: StoryOrigin$Input;

  /**
   * True, if story content was modified during reposting; otherwise, story wasn't modified
   * @type {Bool} {@link Bool}
   */
  readonly is_content_modified?: Bool$Input;
};

/**
 * Contains information about interactions with a story
 */
export type storyInteractionInfo = {
  _: "storyInteractionInfo";

  /**
   * Number of times the story was viewed
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Number of times the story was forwarded; 0 if none or unknown
   * @type {int32} {@link int32}
   */
  forward_count: int32;

  /**
   * Number of reactions added to the story; 0 if none or unknown
   * @type {int32} {@link int32}
   */
  reaction_count: int32;

  /**
   * Identifiers of at most 3 recent viewers of the story
   * @type {vector<int53>} {@link vector<int53>}
   */
  recent_viewer_user_ids: vector<int53>;
};

/**
 * Version of {@link storyInteractionInfo} for method parameters.
 *
 * Contains information about interactions with a story
 */
export type storyInteractionInfo$Input = {
  readonly _: "storyInteractionInfo";

  /**
   * Number of times the story was viewed
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Number of times the story was forwarded; 0 if none or unknown
   * @type {int32} {@link int32}
   */
  readonly forward_count?: int32;

  /**
   * Number of reactions added to the story; 0 if none or unknown
   * @type {int32} {@link int32}
   */
  readonly reaction_count?: int32;

  /**
   * Identifiers of at most 3 recent viewers of the story
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly recent_viewer_user_ids?: vector$Input<int53>;
};

/**
 * Represents a story
 */
export type story = {
  _: "story";

  /**
   * Unique story identifier among stories of the given sender
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  sender_chat_id: int53;

  /**
   * Point in time (Unix timestamp) when the story was published
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * True, if the story is being sent by the current user
   * @type {Bool} {@link Bool}
   */
  is_being_sent: Bool;

  /**
   * True, if the story is being edited by the current user
   * @type {Bool} {@link Bool}
   */
  is_being_edited: Bool;

  /**
   * True, if the story was edited
   * @type {Bool} {@link Bool}
   */
  is_edited: Bool;

  /**
   * True, if the story is saved in the sender's profile and will be available there after expiration
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * True, if the story is visible only for the current user
   * @type {Bool} {@link Bool}
   */
  is_visible_only_for_self: Bool;

  /**
   * True, if the story can be deleted
   * @type {Bool} {@link Bool}
   */
  can_be_deleted: Bool;

  /**
   * True, if the story can be edited
   * @type {Bool} {@link Bool}
   */
  can_be_edited: Bool;

  /**
   * True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
   * @type {Bool} {@link Bool}
   */
  can_be_forwarded: Bool;

  /**
   * True, if the story can be replied in the chat with the story sender
   * @type {Bool} {@link Bool}
   */
  can_be_replied: Bool;

  /**
   * True, if the story's is_pinned value can be changed
   * @type {Bool} {@link Bool}
   */
  can_toggle_is_pinned: Bool;

  /**
   * True, if the story statistics are available through getStoryStatistics
   * @type {Bool} {@link Bool}
   */
  can_get_statistics: Bool;

  /**
   * True, if interactions with the story can be received through getStoryInteractions
   * @type {Bool} {@link Bool}
   */
  can_get_interactions: Bool;

  /**
   * True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
   * @type {Bool} {@link Bool}
   */
  has_expired_viewers: Bool;

  /**
   * Information about the original story; may be null if the story wasn't reposted
   * @type {storyRepostInfo} {@link storyRepostInfo}
   */
  repost_info: storyRepostInfo | null;

  /**
   * Information about interactions with the story; may be null if the story isn't owned or there were no interactions
   * @type {storyInteractionInfo} {@link storyInteractionInfo}
   */
  interaction_info: storyInteractionInfo | null;

  /**
   * Type of the chosen reaction; may be null if none
   * @type {ReactionType} {@link ReactionType}
   */
  chosen_reaction_type: ReactionType | null;

  /**
   * Privacy rules affecting story visibility; may be approximate for non-owned stories
   * @type {StoryPrivacySettings} {@link StoryPrivacySettings}
   */
  privacy_settings: StoryPrivacySettings;

  /**
   * Content of the story
   * @type {StoryContent} {@link StoryContent}
   */
  content: StoryContent;

  /**
   * Clickable areas to be shown on the story content
   * @type {vector<storyArea>} {@link vector<storyArea>}
   */
  areas: vector<storyArea>;

  /**
   * Caption of the story
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

/**
 * Version of {@link story} for method parameters.
 *
 * Represents a story
 */
export type story$Input = {
  readonly _: "story";

  /**
   * Unique story identifier among stories of the given sender
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly sender_chat_id?: int53;

  /**
   * Point in time (Unix timestamp) when the story was published
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * True, if the story is being sent by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_being_sent?: Bool$Input;

  /**
   * True, if the story is being edited by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_being_edited?: Bool$Input;

  /**
   * True, if the story was edited
   * @type {Bool} {@link Bool}
   */
  readonly is_edited?: Bool$Input;

  /**
   * True, if the story is saved in the sender's profile and will be available there after expiration
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * True, if the story is visible only for the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_visible_only_for_self?: Bool$Input;

  /**
   * True, if the story can be deleted
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted?: Bool$Input;

  /**
   * True, if the story can be edited
   * @type {Bool} {@link Bool}
   */
  readonly can_be_edited?: Bool$Input;

  /**
   * True, if the story can be forwarded as a message. Otherwise, screenshots and saving of the story content must be also forbidden
   * @type {Bool} {@link Bool}
   */
  readonly can_be_forwarded?: Bool$Input;

  /**
   * True, if the story can be replied in the chat with the story sender
   * @type {Bool} {@link Bool}
   */
  readonly can_be_replied?: Bool$Input;

  /**
   * True, if the story's is_pinned value can be changed
   * @type {Bool} {@link Bool}
   */
  readonly can_toggle_is_pinned?: Bool$Input;

  /**
   * True, if the story statistics are available through getStoryStatistics
   * @type {Bool} {@link Bool}
   */
  readonly can_get_statistics?: Bool$Input;

  /**
   * True, if interactions with the story can be received through getStoryInteractions
   * @type {Bool} {@link Bool}
   */
  readonly can_get_interactions?: Bool$Input;

  /**
   * True, if users viewed the story can't be received, because the story has expired more than getOption("story_viewers_expiration_delay") seconds ago
   * @type {Bool} {@link Bool}
   */
  readonly has_expired_viewers?: Bool$Input;

  /**
   * Information about the original story; may be null if the story wasn't reposted
   * @type {storyRepostInfo} {@link storyRepostInfo}
   */
  readonly repost_info?: storyRepostInfo$Input | null;

  /**
   * Information about interactions with the story; may be null if the story isn't owned or there were no interactions
   * @type {storyInteractionInfo} {@link storyInteractionInfo}
   */
  readonly interaction_info?: storyInteractionInfo$Input | null;

  /**
   * Type of the chosen reaction; may be null if none
   * @type {ReactionType} {@link ReactionType}
   */
  readonly chosen_reaction_type?: ReactionType$Input | null;

  /**
   * Privacy rules affecting story visibility; may be approximate for non-owned stories
   * @type {StoryPrivacySettings} {@link StoryPrivacySettings}
   */
  readonly privacy_settings?: StoryPrivacySettings$Input;

  /**
   * Content of the story
   * @type {StoryContent} {@link StoryContent}
   */
  readonly content?: StoryContent$Input;

  /**
   * Clickable areas to be shown on the story content
   * @type {vector<storyArea>} {@link vector<storyArea>}
   */
  readonly areas?: vector$Input<storyArea$Input>;

  /**
   * Caption of the story
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * Represents a list of stories
 */
export type stories = {
  _: "stories";

  /**
   * Approximate total number of stories found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * The list of stories
   * @type {vector<story>} {@link vector<story>}
   */
  stories: vector<story>;
};

/**
 * Version of {@link stories} for method parameters.
 *
 * Represents a list of stories
 */
export type stories$Input = {
  readonly _: "stories";

  /**
   * Approximate total number of stories found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * The list of stories
   * @type {vector<story>} {@link vector<story>}
   */
  readonly stories?: vector$Input<story$Input>;
};

/**
 * Contains identifier of a story along with identifier of its sender
 */
export type storyFullId = {
  _: "storyFullId";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  sender_chat_id: int53;

  /**
   * Unique story identifier among stories of the given sender
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link storyFullId} for method parameters.
 *
 * Contains identifier of a story along with identifier of its sender
 */
export type storyFullId$Input = {
  readonly _: "storyFullId";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly sender_chat_id?: int53;

  /**
   * Unique story identifier among stories of the given sender
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Contains basic information about a story
 */
export type storyInfo = {
  _: "storyInfo";

  /**
   * Unique story identifier among stories of the given sender
   * @type {int32} {@link int32}
   */
  story_id: int32;

  /**
   * Point in time (Unix timestamp) when the story was published
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * True, if the story is available only to close friends
   * @type {Bool} {@link Bool}
   */
  is_for_close_friends: Bool;
};

/**
 * Version of {@link storyInfo} for method parameters.
 *
 * Contains basic information about a story
 */
export type storyInfo$Input = {
  readonly _: "storyInfo";

  /**
   * Unique story identifier among stories of the given sender
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Point in time (Unix timestamp) when the story was published
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * True, if the story is available only to close friends
   * @type {Bool} {@link Bool}
   */
  readonly is_for_close_friends?: Bool$Input;
};

/**
 * Describes active stories posted by a chat
 */
export type chatActiveStories = {
  _: "chatActiveStories";

  /**
   * Identifier of the chat that posted the stories
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list
   * @type {StoryList} {@link StoryList}
   */
  list: StoryList | null;

  /**
   * A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
   * @type {int53} {@link int53}
   */
  order: int53;

  /**
   * Identifier of the last read active story
   * @type {int32} {@link int32}
   */
  max_read_story_id: int32;

  /**
   * Basic information about the stories; use getStory to get full information about the stories. The stories are in a chronological order (i.e., in order of increasing story identifiers)
   * @type {vector<storyInfo>} {@link vector<storyInfo>}
   */
  stories: vector<storyInfo>;
};

/**
 * Version of {@link chatActiveStories} for method parameters.
 *
 * Describes active stories posted by a chat
 */
export type chatActiveStories$Input = {
  readonly _: "chatActiveStories";

  /**
   * Identifier of the chat that posted the stories
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the story list in which the stories are shown; may be null if the stories aren't shown in a story list
   * @type {StoryList} {@link StoryList}
   */
  readonly list?: StoryList$Input | null;

  /**
   * A parameter used to determine order of the stories in the story list; 0 if the stories doesn't need to be shown in the story list. Stories must be sorted by the pair (order, story_sender_chat_id) in descending order
   * @type {int53} {@link int53}
   */
  readonly order?: int53;

  /**
   * Identifier of the last read active story
   * @type {int32} {@link int32}
   */
  readonly max_read_story_id?: int32;

  /**
   * Basic information about the stories; use getStory to get full information about the stories. The stories are in a chronological order (i.e., in order of increasing story identifiers)
   * @type {vector<storyInfo>} {@link vector<storyInfo>}
   */
  readonly stories?: vector$Input<storyInfo$Input>;
};

/**
 * A view of the story
 */
export type storyInteractionTypeView = {
  _: "storyInteractionTypeView";

  /**
   * Type of the reaction that was chosen by the viewer; may be null if none
   * @type {ReactionType} {@link ReactionType}
   */
  chosen_reaction_type: ReactionType | null;
};

/**
 * Version of {@link storyInteractionTypeView} for method parameters.
 *
 * A view of the story
 */
export type storyInteractionTypeView$Input = {
  readonly _: "storyInteractionTypeView";

  /**
   * Type of the reaction that was chosen by the viewer; may be null if none
   * @type {ReactionType} {@link ReactionType}
   */
  readonly chosen_reaction_type?: ReactionType$Input | null;
};

/**
 * A forward of the story as a message
 */
export type storyInteractionTypeForward = {
  _: "storyInteractionTypeForward";

  /**
   * The message with story forward
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link storyInteractionTypeForward} for method parameters.
 *
 * A forward of the story as a message
 */
export type storyInteractionTypeForward$Input = {
  readonly _: "storyInteractionTypeForward";

  /**
   * The message with story forward
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * A repost of the story as a story
 */
export type storyInteractionTypeRepost = {
  _: "storyInteractionTypeRepost";

  /**
   * The reposted story
   * @type {story} {@link story}
   */
  story: story;
};

/**
 * Version of {@link storyInteractionTypeRepost} for method parameters.
 *
 * A repost of the story as a story
 */
export type storyInteractionTypeRepost$Input = {
  readonly _: "storyInteractionTypeRepost";

  /**
   * The reposted story
   * @type {story} {@link story}
   */
  readonly story?: story$Input;
};

/**
 * Represents interaction with a story
 */
export type storyInteraction = {
  _: "storyInteraction";

  /**
   * Identifier of the user or chat that made the interaction
   * @type {MessageSender} {@link MessageSender}
   */
  actor_id: MessageSender;

  /**
   * Approximate point in time (Unix timestamp) when the interaction happenned
   * @type {int32} {@link int32}
   */
  interaction_date: int32;

  /**
   * Block list to which the actor is added; may be null if none or for chat stories
   * @type {BlockList} {@link BlockList}
   */
  block_list: BlockList | null;

  /**
   * Type of the interaction
   * @type {StoryInteractionType} {@link StoryInteractionType}
   */
  type: StoryInteractionType;
};

/**
 * Version of {@link storyInteraction} for method parameters.
 *
 * Represents interaction with a story
 */
export type storyInteraction$Input = {
  readonly _: "storyInteraction";

  /**
   * Identifier of the user or chat that made the interaction
   * @type {MessageSender} {@link MessageSender}
   */
  readonly actor_id?: MessageSender$Input;

  /**
   * Approximate point in time (Unix timestamp) when the interaction happenned
   * @type {int32} {@link int32}
   */
  readonly interaction_date?: int32;

  /**
   * Block list to which the actor is added; may be null if none or for chat stories
   * @type {BlockList} {@link BlockList}
   */
  readonly block_list?: BlockList$Input | null;

  /**
   * Type of the interaction
   * @type {StoryInteractionType} {@link StoryInteractionType}
   */
  readonly type?: StoryInteractionType$Input;
};

/**
 * Represents a list of interactions with a story
 */
export type storyInteractions = {
  _: "storyInteractions";

  /**
   * Approximate total number of interactions found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Approximate total number of found forwards and reposts; always 0 for chat stories
   * @type {int32} {@link int32}
   */
  total_forward_count: int32;

  /**
   * Approximate total number of found reactions; always 0 for chat stories
   * @type {int32} {@link int32}
   */
  total_reaction_count: int32;

  /**
   * List of story interactions
   * @type {vector<storyInteraction>} {@link vector<storyInteraction>}
   */
  interactions: vector<storyInteraction>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link storyInteractions} for method parameters.
 *
 * Represents a list of interactions with a story
 */
export type storyInteractions$Input = {
  readonly _: "storyInteractions";

  /**
   * Approximate total number of interactions found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Approximate total number of found forwards and reposts; always 0 for chat stories
   * @type {int32} {@link int32}
   */
  readonly total_forward_count?: int32;

  /**
   * Approximate total number of found reactions; always 0 for chat stories
   * @type {int32} {@link int32}
   */
  readonly total_reaction_count?: int32;

  /**
   * List of story interactions
   * @type {vector<storyInteraction>} {@link vector<storyInteraction>}
   */
  readonly interactions?: vector$Input<storyInteraction$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Contains a public forward as a message
 */
export type publicForwardMessage = {
  _: "publicForwardMessage";

  /**
   * Information about the message
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link publicForwardMessage} for method parameters.
 *
 * Contains a public forward as a message
 */
export type publicForwardMessage$Input = {
  readonly _: "publicForwardMessage";

  /**
   * Information about the message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * Contains a public repost to a story
 */
export type publicForwardStory = {
  _: "publicForwardStory";

  /**
   * Information about the story
   * @type {story} {@link story}
   */
  story: story;
};

/**
 * Version of {@link publicForwardStory} for method parameters.
 *
 * Contains a public repost to a story
 */
export type publicForwardStory$Input = {
  readonly _: "publicForwardStory";

  /**
   * Information about the story
   * @type {story} {@link story}
   */
  readonly story?: story$Input;
};

/**
 * Represents a list of public forwards and reposts as a story of a message or a story
 */
export type publicForwards = {
  _: "publicForwards";

  /**
   * Approximate total number of messages and stories found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of found public forwards and reposts
   * @type {vector<PublicForward>} {@link vector<PublicForward>}
   */
  forwards: vector<PublicForward>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link publicForwards} for method parameters.
 *
 * Represents a list of public forwards and reposts as a story of a message or a story
 */
export type publicForwards$Input = {
  readonly _: "publicForwards";

  /**
   * Approximate total number of messages and stories found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of found public forwards and reposts
   * @type {vector<PublicForward>} {@link vector<PublicForward>}
   */
  readonly forwards?: vector$Input<PublicForward$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Contains a list of features available on a specific chat boost level
 */
export type chatBoostLevelFeatures = {
  _: "chatBoostLevelFeatures";

  /**
   * Target chat boost level
   * @type {int32} {@link int32}
   */
  level: int32;

  /**
   * Number of stories that the chat can publish daily
   * @type {int32} {@link int32}
   */
  story_per_day_count: int32;

  /**
   * Number of custom emoji reactions that can be added to the list of available reactions
   * @type {int32} {@link int32}
   */
  custom_emoji_reaction_count: int32;

  /**
   * Number of custom colors for chat title
   * @type {int32} {@link int32}
   */
  title_color_count: int32;

  /**
   * Number of custom colors for profile photo background
   * @type {int32} {@link int32}
   */
  profile_accent_color_count: int32;

  /**
   * True, if custom emoji for profile background can be set
   * @type {Bool} {@link Bool}
   */
  can_set_profile_background_custom_emoji: Bool;

  /**
   * Number of custom colors for background of empty chat photo, replies to messages and link previews
   * @type {int32} {@link int32}
   */
  accent_color_count: int32;

  /**
   * True, if custom emoji for reply header and link preview background can be set
   * @type {Bool} {@link Bool}
   */
  can_set_background_custom_emoji: Bool;

  /**
   * True, if emoji status can be set
   * @type {Bool} {@link Bool}
   */
  can_set_emoji_status: Bool;

  /**
   * Number of chat theme backgrounds that can be set as chat background
   * @type {int32} {@link int32}
   */
  chat_theme_background_count: int32;

  /**
   * True, if custom background can be set in the chat for all users
   * @type {Bool} {@link Bool}
   */
  can_set_custom_background: Bool;
};

/**
 * Version of {@link chatBoostLevelFeatures} for method parameters.
 *
 * Contains a list of features available on a specific chat boost level
 */
export type chatBoostLevelFeatures$Input = {
  readonly _: "chatBoostLevelFeatures";

  /**
   * Target chat boost level
   * @type {int32} {@link int32}
   */
  readonly level?: int32;

  /**
   * Number of stories that the chat can publish daily
   * @type {int32} {@link int32}
   */
  readonly story_per_day_count?: int32;

  /**
   * Number of custom emoji reactions that can be added to the list of available reactions
   * @type {int32} {@link int32}
   */
  readonly custom_emoji_reaction_count?: int32;

  /**
   * Number of custom colors for chat title
   * @type {int32} {@link int32}
   */
  readonly title_color_count?: int32;

  /**
   * Number of custom colors for profile photo background
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_count?: int32;

  /**
   * True, if custom emoji for profile background can be set
   * @type {Bool} {@link Bool}
   */
  readonly can_set_profile_background_custom_emoji?: Bool$Input;

  /**
   * Number of custom colors for background of empty chat photo, replies to messages and link previews
   * @type {int32} {@link int32}
   */
  readonly accent_color_count?: int32;

  /**
   * True, if custom emoji for reply header and link preview background can be set
   * @type {Bool} {@link Bool}
   */
  readonly can_set_background_custom_emoji?: Bool$Input;

  /**
   * True, if emoji status can be set
   * @type {Bool} {@link Bool}
   */
  readonly can_set_emoji_status?: Bool$Input;

  /**
   * Number of chat theme backgrounds that can be set as chat background
   * @type {int32} {@link int32}
   */
  readonly chat_theme_background_count?: int32;

  /**
   * True, if custom background can be set in the chat for all users
   * @type {Bool} {@link Bool}
   */
  readonly can_set_custom_background?: Bool$Input;
};

/**
 * Contains a list of features available on the first chat boost levels
 */
export type chatBoostFeatures = {
  _: "chatBoostFeatures";

  /**
   * The list of features
   * @type {vector<chatBoostLevelFeatures>} {@link vector<chatBoostLevelFeatures>}
   */
  features: vector<chatBoostLevelFeatures>;
};

/**
 * Version of {@link chatBoostFeatures} for method parameters.
 *
 * Contains a list of features available on the first chat boost levels
 */
export type chatBoostFeatures$Input = {
  readonly _: "chatBoostFeatures";

  /**
   * The list of features
   * @type {vector<chatBoostLevelFeatures>} {@link vector<chatBoostLevelFeatures>}
   */
  readonly features?: vector$Input<chatBoostLevelFeatures$Input>;
};

/**
 * The chat created a Telegram Premium gift code for a user
 */
export type chatBoostSourceGiftCode = {
  _: "chatBoostSourceGiftCode";

  /**
   * Identifier of a user, for which the gift code was created
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
   * @type {string} {@link string}
   */
  gift_code: string;
};

/**
 * Version of {@link chatBoostSourceGiftCode} for method parameters.
 *
 * The chat created a Telegram Premium gift code for a user
 */
export type chatBoostSourceGiftCode$Input = {
  readonly _: "chatBoostSourceGiftCode";

  /**
   * Identifier of a user, for which the gift code was created
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The created Telegram Premium gift code, which is known only if this is a gift code for the current user, or it has already been claimed
   * @type {string} {@link string}
   */
  readonly gift_code?: string;
};

/**
 * The chat created a Telegram Premium giveaway
 */
export type chatBoostSourceGiveaway = {
  _: "chatBoostSourceGiveaway";

  /**
   * Identifier of a user that won in the giveaway; 0 if none
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise
   * @type {string} {@link string}
   */
  gift_code: string;

  /**
   * Identifier of the corresponding giveaway message; can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  giveaway_message_id: int53;

  /**
   * True, if the winner for the corresponding Telegram Premium subscription wasn't chosen, because there were not enough participants
   * @type {Bool} {@link Bool}
   */
  is_unclaimed: Bool;
};

/**
 * Version of {@link chatBoostSourceGiveaway} for method parameters.
 *
 * The chat created a Telegram Premium giveaway
 */
export type chatBoostSourceGiveaway$Input = {
  readonly _: "chatBoostSourceGiveaway";

  /**
   * Identifier of a user that won in the giveaway; 0 if none
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The created Telegram Premium gift code if it was used by the user or can be claimed by the current user; an empty string otherwise
   * @type {string} {@link string}
   */
  readonly gift_code?: string;

  /**
   * Identifier of the corresponding giveaway message; can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly giveaway_message_id?: int53;

  /**
   * True, if the winner for the corresponding Telegram Premium subscription wasn't chosen, because there were not enough participants
   * @type {Bool} {@link Bool}
   */
  readonly is_unclaimed?: Bool$Input;
};

/**
 * A user with Telegram Premium subscription or gifted Telegram Premium boosted the chat
 */
export type chatBoostSourcePremium = {
  _: "chatBoostSourcePremium";

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link chatBoostSourcePremium} for method parameters.
 *
 * A user with Telegram Premium subscription or gifted Telegram Premium boosted the chat
 */
export type chatBoostSourcePremium$Input = {
  readonly _: "chatBoostSourcePremium";

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Describes a prepaid Telegram Premium giveaway
 */
export type prepaidPremiumGiveaway = {
  _: "prepaidPremiumGiveaway";

  /**
   * Unique identifier of the prepaid giveaway
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Number of users which will receive Telegram Premium subscription gift codes
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * Point in time (Unix timestamp) when the giveaway was paid
   * @type {int32} {@link int32}
   */
  payment_date: int32;
};

/**
 * Version of {@link prepaidPremiumGiveaway} for method parameters.
 *
 * Describes a prepaid Telegram Premium giveaway
 */
export type prepaidPremiumGiveaway$Input = {
  readonly _: "prepaidPremiumGiveaway";

  /**
   * Unique identifier of the prepaid giveaway
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Number of users which will receive Telegram Premium subscription gift codes
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * Point in time (Unix timestamp) when the giveaway was paid
   * @type {int32} {@link int32}
   */
  readonly payment_date?: int32;
};

/**
 * Describes current boost status of a chat
 */
export type chatBoostStatus = {
  _: "chatBoostStatus";

  /**
   * An HTTP URL, which can be used to boost the chat
   * @type {string} {@link string}
   */
  boost_url: string;

  /**
   * Identifiers of boost slots of the current user applied to the chat
   * @type {vector<int32>} {@link vector<int32>}
   */
  applied_slot_ids: vector<int32>;

  /**
   * Current boost level of the chat
   * @type {int32} {@link int32}
   */
  level: int32;

  /**
   * The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
   * @type {int32} {@link int32}
   */
  gift_code_boost_count: int32;

  /**
   * The number of boosts received by the chat
   * @type {int32} {@link int32}
   */
  boost_count: int32;

  /**
   * The number of boosts added to reach the current level
   * @type {int32} {@link int32}
   */
  current_level_boost_count: int32;

  /**
   * The number of boosts needed to reach the next level; 0 if the next level isn't available
   * @type {int32} {@link int32}
   */
  next_level_boost_count: int32;

  /**
   * Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
   * @type {int32} {@link int32}
   */
  premium_member_count: int32;

  /**
   * A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
   * @type {double} {@link double}
   */
  premium_member_percentage: double;

  /**
   * The list of prepaid giveaways available for the chat; only for chat administrators
   * @type {vector<prepaidPremiumGiveaway>} {@link vector<prepaidPremiumGiveaway>}
   */
  prepaid_giveaways: vector<prepaidPremiumGiveaway>;
};

/**
 * Version of {@link chatBoostStatus} for method parameters.
 *
 * Describes current boost status of a chat
 */
export type chatBoostStatus$Input = {
  readonly _: "chatBoostStatus";

  /**
   * An HTTP URL, which can be used to boost the chat
   * @type {string} {@link string}
   */
  readonly boost_url?: string;

  /**
   * Identifiers of boost slots of the current user applied to the chat
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly applied_slot_ids?: vector$Input<int32>;

  /**
   * Current boost level of the chat
   * @type {int32} {@link int32}
   */
  readonly level?: int32;

  /**
   * The number of boosts received by the chat from created Telegram Premium gift codes and giveaways; always 0 if the current user isn't an administrator in the chat
   * @type {int32} {@link int32}
   */
  readonly gift_code_boost_count?: int32;

  /**
   * The number of boosts received by the chat
   * @type {int32} {@link int32}
   */
  readonly boost_count?: int32;

  /**
   * The number of boosts added to reach the current level
   * @type {int32} {@link int32}
   */
  readonly current_level_boost_count?: int32;

  /**
   * The number of boosts needed to reach the next level; 0 if the next level isn't available
   * @type {int32} {@link int32}
   */
  readonly next_level_boost_count?: int32;

  /**
   * Approximate number of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
   * @type {int32} {@link int32}
   */
  readonly premium_member_count?: int32;

  /**
   * A percentage of Telegram Premium subscribers joined the chat; always 0 if the current user isn't an administrator in the chat
   * @type {double} {@link double}
   */
  readonly premium_member_percentage?: double;

  /**
   * The list of prepaid giveaways available for the chat; only for chat administrators
   * @type {vector<prepaidPremiumGiveaway>} {@link vector<prepaidPremiumGiveaway>}
   */
  readonly prepaid_giveaways?: vector$Input<prepaidPremiumGiveaway$Input>;
};

/**
 * Describes a boost applied to a chat
 */
export type chatBoost = {
  _: "chatBoost";

  /**
   * Unique identifier of the boost
   * @type {string} {@link string}
   */
  id: string;

  /**
   * The number of identical boosts applied
   * @type {int32} {@link int32}
   */
  count: int32;

  /**
   * Source of the boost
   * @type {ChatBoostSource} {@link ChatBoostSource}
   */
  source: ChatBoostSource;

  /**
   * Point in time (Unix timestamp) when the chat was boosted
   * @type {int32} {@link int32}
   */
  start_date: int32;

  /**
   * Point in time (Unix timestamp) when the boost will expire
   * @type {int32} {@link int32}
   */
  expiration_date: int32;
};

/**
 * Version of {@link chatBoost} for method parameters.
 *
 * Describes a boost applied to a chat
 */
export type chatBoost$Input = {
  readonly _: "chatBoost";

  /**
   * Unique identifier of the boost
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * The number of identical boosts applied
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * Source of the boost
   * @type {ChatBoostSource} {@link ChatBoostSource}
   */
  readonly source?: ChatBoostSource$Input;

  /**
   * Point in time (Unix timestamp) when the chat was boosted
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Point in time (Unix timestamp) when the boost will expire
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;
};

/**
 * Contains a list of boosts applied to a chat
 */
export type foundChatBoosts = {
  _: "foundChatBoosts";

  /**
   * Total number of boosts applied to the chat
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of boosts
   * @type {vector<chatBoost>} {@link vector<chatBoost>}
   */
  boosts: vector<chatBoost>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link foundChatBoosts} for method parameters.
 *
 * Contains a list of boosts applied to a chat
 */
export type foundChatBoosts$Input = {
  readonly _: "foundChatBoosts";

  /**
   * Total number of boosts applied to the chat
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of boosts
   * @type {vector<chatBoost>} {@link vector<chatBoost>}
   */
  readonly boosts?: vector$Input<chatBoost$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Describes a slot for chat boost
 */
export type chatBoostSlot = {
  _: "chatBoostSlot";

  /**
   * Unique identifier of the slot
   * @type {int32} {@link int32}
   */
  slot_id: int32;

  /**
   * Identifier of the currently boosted chat; 0 if none
   * @type {int53} {@link int53}
   */
  currently_boosted_chat_id: int53;

  /**
   * Point in time (Unix timestamp) when the chat was boosted; 0 if none
   * @type {int32} {@link int32}
   */
  start_date: int32;

  /**
   * Point in time (Unix timestamp) when the boost will expire
   * @type {int32} {@link int32}
   */
  expiration_date: int32;

  /**
   * Point in time (Unix timestamp) after which the boost can be used for another chat
   * @type {int32} {@link int32}
   */
  cooldown_until_date: int32;
};

/**
 * Version of {@link chatBoostSlot} for method parameters.
 *
 * Describes a slot for chat boost
 */
export type chatBoostSlot$Input = {
  readonly _: "chatBoostSlot";

  /**
   * Unique identifier of the slot
   * @type {int32} {@link int32}
   */
  readonly slot_id?: int32;

  /**
   * Identifier of the currently boosted chat; 0 if none
   * @type {int53} {@link int53}
   */
  readonly currently_boosted_chat_id?: int53;

  /**
   * Point in time (Unix timestamp) when the chat was boosted; 0 if none
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Point in time (Unix timestamp) when the boost will expire
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * Point in time (Unix timestamp) after which the boost can be used for another chat
   * @type {int32} {@link int32}
   */
  readonly cooldown_until_date?: int32;
};

/**
 * Contains a list of chat boost slots
 */
export type chatBoostSlots = {
  _: "chatBoostSlots";

  /**
   * List of boost slots
   * @type {vector<chatBoostSlot>} {@link vector<chatBoostSlot>}
   */
  slots: vector<chatBoostSlot>;
};

/**
 * Version of {@link chatBoostSlots} for method parameters.
 *
 * Contains a list of chat boost slots
 */
export type chatBoostSlots$Input = {
  readonly _: "chatBoostSlots";

  /**
   * List of boost slots
   * @type {vector<chatBoostSlot>} {@link vector<chatBoostSlot>}
   */
  readonly slots?: vector$Input<chatBoostSlot$Input>;
};

/**
 * The call wasn't discarded, or the reason is unknown
 */
export type callDiscardReasonEmpty = {
  _: "callDiscardReasonEmpty";
};

/**
 * Version of {@link callDiscardReasonEmpty} for method parameters.
 *
 * The call wasn't discarded, or the reason is unknown
 */
export type callDiscardReasonEmpty$Input = {
  readonly _: "callDiscardReasonEmpty";
};

/**
 * The call was ended before the conversation started. It was canceled by the caller or missed by the other party
 */
export type callDiscardReasonMissed = {
  _: "callDiscardReasonMissed";
};

/**
 * Version of {@link callDiscardReasonMissed} for method parameters.
 *
 * The call was ended before the conversation started. It was canceled by the caller or missed by the other party
 */
export type callDiscardReasonMissed$Input = {
  readonly _: "callDiscardReasonMissed";
};

/**
 * The call was ended before the conversation started. It was declined by the other party
 */
export type callDiscardReasonDeclined = {
  _: "callDiscardReasonDeclined";
};

/**
 * Version of {@link callDiscardReasonDeclined} for method parameters.
 *
 * The call was ended before the conversation started. It was declined by the other party
 */
export type callDiscardReasonDeclined$Input = {
  readonly _: "callDiscardReasonDeclined";
};

/**
 * The call was ended during the conversation because the users were disconnected
 */
export type callDiscardReasonDisconnected = {
  _: "callDiscardReasonDisconnected";
};

/**
 * Version of {@link callDiscardReasonDisconnected} for method parameters.
 *
 * The call was ended during the conversation because the users were disconnected
 */
export type callDiscardReasonDisconnected$Input = {
  readonly _: "callDiscardReasonDisconnected";
};

/**
 * The call was ended because one of the parties hung up
 */
export type callDiscardReasonHungUp = {
  _: "callDiscardReasonHungUp";
};

/**
 * Version of {@link callDiscardReasonHungUp} for method parameters.
 *
 * The call was ended because one of the parties hung up
 */
export type callDiscardReasonHungUp$Input = {
  readonly _: "callDiscardReasonHungUp";
};

/**
 * Specifies the supported call protocols
 */
export type callProtocol = {
  _: "callProtocol";

  /**
   * True, if UDP peer-to-peer connections are supported
   * @type {Bool} {@link Bool}
   */
  udp_p2p: Bool;

  /**
   * True, if connection through UDP reflectors is supported
   * @type {Bool} {@link Bool}
   */
  udp_reflector: Bool;

  /**
   * The minimum supported API layer; use 65
   * @type {int32} {@link int32}
   */
  min_layer: int32;

  /**
   * The maximum supported API layer; use 92
   * @type {int32} {@link int32}
   */
  max_layer: int32;

  /**
   * List of supported tgcalls versions
   * @type {vector<string>} {@link vector<string>}
   */
  library_versions: vector<string>;
};

/**
 * Version of {@link callProtocol} for method parameters.
 *
 * Specifies the supported call protocols
 */
export type callProtocol$Input = {
  readonly _: "callProtocol";

  /**
   * True, if UDP peer-to-peer connections are supported
   * @type {Bool} {@link Bool}
   */
  readonly udp_p2p?: Bool$Input;

  /**
   * True, if connection through UDP reflectors is supported
   * @type {Bool} {@link Bool}
   */
  readonly udp_reflector?: Bool$Input;

  /**
   * The minimum supported API layer; use 65
   * @type {int32} {@link int32}
   */
  readonly min_layer?: int32;

  /**
   * The maximum supported API layer; use 92
   * @type {int32} {@link int32}
   */
  readonly max_layer?: int32;

  /**
   * List of supported tgcalls versions
   * @type {vector<string>} {@link vector<string>}
   */
  readonly library_versions?: vector$Input<string>;
};

/**
 * A Telegram call reflector
 */
export type callServerTypeTelegramReflector = {
  _: "callServerTypeTelegramReflector";

  /**
   * A peer tag to be used with the reflector
   * @type {bytes} {@link bytes}
   */
  peer_tag: bytes;

  /**
   * True, if the server uses TCP instead of UDP
   * @type {Bool} {@link Bool}
   */
  is_tcp: Bool;
};

/**
 * Version of {@link callServerTypeTelegramReflector} for method parameters.
 *
 * A Telegram call reflector
 */
export type callServerTypeTelegramReflector$Input = {
  readonly _: "callServerTypeTelegramReflector";

  /**
   * A peer tag to be used with the reflector
   * @type {bytes} {@link bytes}
   */
  readonly peer_tag?: bytes$Input;

  /**
   * True, if the server uses TCP instead of UDP
   * @type {Bool} {@link Bool}
   */
  readonly is_tcp?: Bool$Input;
};

/**
 * A WebRTC server
 */
export type callServerTypeWebrtc = {
  _: "callServerTypeWebrtc";

  /**
   * Username to be used for authentication
   * @type {string} {@link string}
   */
  username: string;

  /**
   * Authentication password
   * @type {string} {@link string}
   */
  password: string;

  /**
   * True, if the server supports TURN
   * @type {Bool} {@link Bool}
   */
  supports_turn: Bool;

  /**
   * True, if the server supports STUN
   * @type {Bool} {@link Bool}
   */
  supports_stun: Bool;
};

/**
 * Version of {@link callServerTypeWebrtc} for method parameters.
 *
 * A WebRTC server
 */
export type callServerTypeWebrtc$Input = {
  readonly _: "callServerTypeWebrtc";

  /**
   * Username to be used for authentication
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Authentication password
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * True, if the server supports TURN
   * @type {Bool} {@link Bool}
   */
  readonly supports_turn?: Bool$Input;

  /**
   * True, if the server supports STUN
   * @type {Bool} {@link Bool}
   */
  readonly supports_stun?: Bool$Input;
};

/**
 * Describes a server for relaying call data
 */
export type callServer = {
  _: "callServer";

  /**
   * Server identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Server IPv4 address
   * @type {string} {@link string}
   */
  ip_address: string;

  /**
   * Server IPv6 address
   * @type {string} {@link string}
   */
  ipv6_address: string;

  /**
   * Server port number
   * @type {int32} {@link int32}
   */
  port: int32;

  /**
   * Server type
   * @type {CallServerType} {@link CallServerType}
   */
  type: CallServerType;
};

/**
 * Version of {@link callServer} for method parameters.
 *
 * Describes a server for relaying call data
 */
export type callServer$Input = {
  readonly _: "callServer";

  /**
   * Server identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Server IPv4 address
   * @type {string} {@link string}
   */
  readonly ip_address?: string;

  /**
   * Server IPv6 address
   * @type {string} {@link string}
   */
  readonly ipv6_address?: string;

  /**
   * Server port number
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Server type
   * @type {CallServerType} {@link CallServerType}
   */
  readonly type?: CallServerType$Input;
};

/**
 * Contains the call identifier
 */
export type callId = {
  _: "callId";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  id: int32;
};

/**
 * Version of {@link callId} for method parameters.
 *
 * Contains the call identifier
 */
export type callId$Input = {
  readonly _: "callId";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;
};

/**
 * Contains the group call identifier
 */
export type groupCallId = {
  _: "groupCallId";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  id: int32;
};

/**
 * Version of {@link groupCallId} for method parameters.
 *
 * Contains the group call identifier
 */
export type groupCallId$Input = {
  readonly _: "groupCallId";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;
};

/**
 * The call is pending, waiting to be accepted by a user
 */
export type callStatePending = {
  _: "callStatePending";

  /**
   * True, if the call has already been created by the server
   * @type {Bool} {@link Bool}
   */
  is_created: Bool;

  /**
   * True, if the call has already been received by the other party
   * @type {Bool} {@link Bool}
   */
  is_received: Bool;
};

/**
 * Version of {@link callStatePending} for method parameters.
 *
 * The call is pending, waiting to be accepted by a user
 */
export type callStatePending$Input = {
  readonly _: "callStatePending";

  /**
   * True, if the call has already been created by the server
   * @type {Bool} {@link Bool}
   */
  readonly is_created?: Bool$Input;

  /**
   * True, if the call has already been received by the other party
   * @type {Bool} {@link Bool}
   */
  readonly is_received?: Bool$Input;
};

/**
 * The call has been answered and encryption keys are being exchanged
 */
export type callStateExchangingKeys = {
  _: "callStateExchangingKeys";
};

/**
 * Version of {@link callStateExchangingKeys} for method parameters.
 *
 * The call has been answered and encryption keys are being exchanged
 */
export type callStateExchangingKeys$Input = {
  readonly _: "callStateExchangingKeys";
};

/**
 * The call is ready to use
 */
export type callStateReady = {
  _: "callStateReady";

  /**
   * Call protocols supported by the other call participant
   * @type {callProtocol} {@link callProtocol}
   */
  protocol: callProtocol;

  /**
   * List of available call servers
   * @type {vector<callServer>} {@link vector<callServer>}
   */
  servers: vector<callServer>;

  /**
   * A JSON-encoded call config
   * @type {string} {@link string}
   */
  config: string;

  /**
   * Call encryption key
   * @type {bytes} {@link bytes}
   */
  encryption_key: bytes;

  /**
   * Encryption key emojis fingerprint
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;

  /**
   * True, if peer-to-peer connection is allowed by users privacy settings
   * @type {Bool} {@link Bool}
   */
  allow_p2p: Bool;
};

/**
 * Version of {@link callStateReady} for method parameters.
 *
 * The call is ready to use
 */
export type callStateReady$Input = {
  readonly _: "callStateReady";

  /**
   * Call protocols supported by the other call participant
   * @type {callProtocol} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;

  /**
   * List of available call servers
   * @type {vector<callServer>} {@link vector<callServer>}
   */
  readonly servers?: vector$Input<callServer$Input>;

  /**
   * A JSON-encoded call config
   * @type {string} {@link string}
   */
  readonly config?: string;

  /**
   * Call encryption key
   * @type {bytes} {@link bytes}
   */
  readonly encryption_key?: bytes$Input;

  /**
   * Encryption key emojis fingerprint
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;

  /**
   * True, if peer-to-peer connection is allowed by users privacy settings
   * @type {Bool} {@link Bool}
   */
  readonly allow_p2p?: Bool$Input;
};

/**
 * The call is hanging up after discardCall has been called
 */
export type callStateHangingUp = {
  _: "callStateHangingUp";
};

/**
 * Version of {@link callStateHangingUp} for method parameters.
 *
 * The call is hanging up after discardCall has been called
 */
export type callStateHangingUp$Input = {
  readonly _: "callStateHangingUp";
};

/**
 * The call has ended successfully
 */
export type callStateDiscarded = {
  _: "callStateDiscarded";

  /**
   * The reason why the call has ended
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  reason: CallDiscardReason;

  /**
   * True, if the call rating must be sent to the server
   * @type {Bool} {@link Bool}
   */
  need_rating: Bool;

  /**
   * True, if the call debug information must be sent to the server
   * @type {Bool} {@link Bool}
   */
  need_debug_information: Bool;

  /**
   * True, if the call log must be sent to the server
   * @type {Bool} {@link Bool}
   */
  need_log: Bool;
};

/**
 * Version of {@link callStateDiscarded} for method parameters.
 *
 * The call has ended successfully
 */
export type callStateDiscarded$Input = {
  readonly _: "callStateDiscarded";

  /**
   * The reason why the call has ended
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  readonly reason?: CallDiscardReason$Input;

  /**
   * True, if the call rating must be sent to the server
   * @type {Bool} {@link Bool}
   */
  readonly need_rating?: Bool$Input;

  /**
   * True, if the call debug information must be sent to the server
   * @type {Bool} {@link Bool}
   */
  readonly need_debug_information?: Bool$Input;

  /**
   * True, if the call log must be sent to the server
   * @type {Bool} {@link Bool}
   */
  readonly need_log?: Bool$Input;
};

/**
 * The call has ended with an error
 */
export type callStateError = {
  _: "callStateError";

  /**
   * Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
   * @type {error} {@link error}
   */
  error: error;
};

/**
 * Version of {@link callStateError} for method parameters.
 *
 * The call has ended with an error
 */
export type callStateError$Input = {
  readonly _: "callStateError";

  /**
   * Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
   * @type {error} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * The worst available video quality
 */
export type groupCallVideoQualityThumbnail = {
  _: "groupCallVideoQualityThumbnail";
};

/**
 * Version of {@link groupCallVideoQualityThumbnail} for method parameters.
 *
 * The worst available video quality
 */
export type groupCallVideoQualityThumbnail$Input = {
  readonly _: "groupCallVideoQualityThumbnail";
};

/**
 * The medium video quality
 */
export type groupCallVideoQualityMedium = {
  _: "groupCallVideoQualityMedium";
};

/**
 * Version of {@link groupCallVideoQualityMedium} for method parameters.
 *
 * The medium video quality
 */
export type groupCallVideoQualityMedium$Input = {
  readonly _: "groupCallVideoQualityMedium";
};

/**
 * The best available video quality
 */
export type groupCallVideoQualityFull = {
  _: "groupCallVideoQualityFull";
};

/**
 * Version of {@link groupCallVideoQualityFull} for method parameters.
 *
 * The best available video quality
 */
export type groupCallVideoQualityFull$Input = {
  readonly _: "groupCallVideoQualityFull";
};

/**
 * Describes an available stream in a group call
 */
export type groupCallStream = {
  _: "groupCallStream";

  /**
   * Identifier of an audio/video channel
   * @type {int32} {@link int32}
   */
  channel_id: int32;

  /**
   * Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  scale: int32;

  /**
   * Point in time when the stream currently ends; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  time_offset: int53;
};

/**
 * Version of {@link groupCallStream} for method parameters.
 *
 * Describes an available stream in a group call
 */
export type groupCallStream$Input = {
  readonly _: "groupCallStream";

  /**
   * Identifier of an audio/video channel
   * @type {int32} {@link int32}
   */
  readonly channel_id?: int32;

  /**
   * Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Point in time when the stream currently ends; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  readonly time_offset?: int53;
};

/**
 * Represents a list of group call streams
 */
export type groupCallStreams = {
  _: "groupCallStreams";

  /**
   * A list of group call streams
   * @type {vector<groupCallStream>} {@link vector<groupCallStream>}
   */
  streams: vector<groupCallStream>;
};

/**
 * Version of {@link groupCallStreams} for method parameters.
 *
 * Represents a list of group call streams
 */
export type groupCallStreams$Input = {
  readonly _: "groupCallStreams";

  /**
   * A list of group call streams
   * @type {vector<groupCallStream>} {@link vector<groupCallStream>}
   */
  readonly streams?: vector$Input<groupCallStream$Input>;
};

/**
 * Represents an RTMP URL
 */
export type rtmpUrl = {
  _: "rtmpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Stream key
   * @type {string} {@link string}
   */
  stream_key: string;
};

/**
 * Version of {@link rtmpUrl} for method parameters.
 *
 * Represents an RTMP URL
 */
export type rtmpUrl$Input = {
  readonly _: "rtmpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Stream key
   * @type {string} {@link string}
   */
  readonly stream_key?: string;
};

/**
 * Describes a recently speaking participant in a group call
 */
export type groupCallRecentSpeaker = {
  _: "groupCallRecentSpeaker";

  /**
   * Group call participant identifier
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * True, is the user has spoken recently
   * @type {Bool} {@link Bool}
   */
  is_speaking: Bool;
};

/**
 * Version of {@link groupCallRecentSpeaker} for method parameters.
 *
 * Describes a recently speaking participant in a group call
 */
export type groupCallRecentSpeaker$Input = {
  readonly _: "groupCallRecentSpeaker";

  /**
   * Group call participant identifier
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * True, is the user has spoken recently
   * @type {Bool} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;
};

/**
 * Describes a group call
 */
export type groupCall = {
  _: "groupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Group call title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
   * @type {int32} {@link int32}
   */
  scheduled_start_date: int32;

  /**
   * True, if the group call is scheduled and the current user will receive a notification when the group call starts
   * @type {Bool} {@link Bool}
   */
  enabled_start_notification: Bool;

  /**
   * True, if the call is active
   * @type {Bool} {@link Bool}
   */
  is_active: Bool;

  /**
   * True, if the chat is an RTMP stream instead of an ordinary video chat
   * @type {Bool} {@link Bool}
   */
  is_rtmp_stream: Bool;

  /**
   * True, if the call is joined
   * @type {Bool} {@link Bool}
   */
  is_joined: Bool;

  /**
   * True, if user was kicked from the call because of network loss and the call needs to be rejoined
   * @type {Bool} {@link Bool}
   */
  need_rejoin: Bool;

  /**
   * True, if the current user can manage the group call
   * @type {Bool} {@link Bool}
   */
  can_be_managed: Bool;

  /**
   * Number of participants in the group call
   * @type {int32} {@link int32}
   */
  participant_count: int32;

  /**
   * True, if group call participants, which are muted, aren't returned in participant list
   * @type {Bool} {@link Bool}
   */
  has_hidden_listeners: Bool;

  /**
   * True, if all group call participants are loaded
   * @type {Bool} {@link Bool}
   */
  loaded_all_participants: Bool;

  /**
   * At most 3 recently speaking users in the group call
   * @type {vector<groupCallRecentSpeaker>} {@link vector<groupCallRecentSpeaker>}
   */
  recent_speakers: vector<groupCallRecentSpeaker>;

  /**
   * True, if the current user's video is enabled
   * @type {Bool} {@link Bool}
   */
  is_my_video_enabled: Bool;

  /**
   * True, if the current user's video is paused
   * @type {Bool} {@link Bool}
   */
  is_my_video_paused: Bool;

  /**
   * True, if the current user can broadcast video or share screen
   * @type {Bool} {@link Bool}
   */
  can_enable_video: Bool;

  /**
   * True, if only group call administrators can unmute new participants
   * @type {Bool} {@link Bool}
   */
  mute_new_participants: Bool;

  /**
   * True, if the current user can enable or disable mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  can_toggle_mute_new_participants: Bool;

  /**
   * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
   * @type {int32} {@link int32}
   */
  record_duration: int32;

  /**
   * True, if a video file is being recorded for the call
   * @type {Bool} {@link Bool}
   */
  is_video_recorded: Bool;

  /**
   * Call duration, in seconds; for ended calls only
   * @type {int32} {@link int32}
   */
  duration: int32;
};

/**
 * Version of {@link groupCall} for method parameters.
 *
 * Describes a group call
 */
export type groupCall$Input = {
  readonly _: "groupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Group call title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
   * @type {int32} {@link int32}
   */
  readonly scheduled_start_date?: int32;

  /**
   * True, if the group call is scheduled and the current user will receive a notification when the group call starts
   * @type {Bool} {@link Bool}
   */
  readonly enabled_start_notification?: Bool$Input;

  /**
   * True, if the call is active
   * @type {Bool} {@link Bool}
   */
  readonly is_active?: Bool$Input;

  /**
   * True, if the chat is an RTMP stream instead of an ordinary video chat
   * @type {Bool} {@link Bool}
   */
  readonly is_rtmp_stream?: Bool$Input;

  /**
   * True, if the call is joined
   * @type {Bool} {@link Bool}
   */
  readonly is_joined?: Bool$Input;

  /**
   * True, if user was kicked from the call because of network loss and the call needs to be rejoined
   * @type {Bool} {@link Bool}
   */
  readonly need_rejoin?: Bool$Input;

  /**
   * True, if the current user can manage the group call
   * @type {Bool} {@link Bool}
   */
  readonly can_be_managed?: Bool$Input;

  /**
   * Number of participants in the group call
   * @type {int32} {@link int32}
   */
  readonly participant_count?: int32;

  /**
   * True, if group call participants, which are muted, aren't returned in participant list
   * @type {Bool} {@link Bool}
   */
  readonly has_hidden_listeners?: Bool$Input;

  /**
   * True, if all group call participants are loaded
   * @type {Bool} {@link Bool}
   */
  readonly loaded_all_participants?: Bool$Input;

  /**
   * At most 3 recently speaking users in the group call
   * @type {vector<groupCallRecentSpeaker>} {@link vector<groupCallRecentSpeaker>}
   */
  readonly recent_speakers?: vector$Input<groupCallRecentSpeaker$Input>;

  /**
   * True, if the current user's video is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;

  /**
   * True, if the current user's video is paused
   * @type {Bool} {@link Bool}
   */
  readonly is_my_video_paused?: Bool$Input;

  /**
   * True, if the current user can broadcast video or share screen
   * @type {Bool} {@link Bool}
   */
  readonly can_enable_video?: Bool$Input;

  /**
   * True, if only group call administrators can unmute new participants
   * @type {Bool} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;

  /**
   * True, if the current user can enable or disable mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  readonly can_toggle_mute_new_participants?: Bool$Input;

  /**
   * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
   * @type {int32} {@link int32}
   */
  readonly record_duration?: int32;

  /**
   * True, if a video file is being recorded for the call
   * @type {Bool} {@link Bool}
   */
  readonly is_video_recorded?: Bool$Input;

  /**
   * Call duration, in seconds; for ended calls only
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/**
 * Describes a group of video synchronization source identifiers
 */
export type groupCallVideoSourceGroup = {
  _: "groupCallVideoSourceGroup";

  /**
   * The semantics of sources, one of "SIM" or "FID"
   * @type {string} {@link string}
   */
  semantics: string;

  /**
   * The list of synchronization source identifiers
   * @type {vector<int32>} {@link vector<int32>}
   */
  source_ids: vector<int32>;
};

/**
 * Version of {@link groupCallVideoSourceGroup} for method parameters.
 *
 * Describes a group of video synchronization source identifiers
 */
export type groupCallVideoSourceGroup$Input = {
  readonly _: "groupCallVideoSourceGroup";

  /**
   * The semantics of sources, one of "SIM" or "FID"
   * @type {string} {@link string}
   */
  readonly semantics?: string;

  /**
   * The list of synchronization source identifiers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly source_ids?: vector$Input<int32>;
};

/**
 * Contains information about a group call participant's video channel
 */
export type groupCallParticipantVideoInfo = {
  _: "groupCallParticipantVideoInfo";

  /**
   * List of synchronization source groups of the video
   * @type {vector<groupCallVideoSourceGroup>} {@link vector<groupCallVideoSourceGroup>}
   */
  source_groups: vector<groupCallVideoSourceGroup>;

  /**
   * Video channel endpoint identifier
   * @type {string} {@link string}
   */
  endpoint_id: string;

  /**
   * True, if the video is paused. This flag needs to be ignored, if new video frames are received
   * @type {Bool} {@link Bool}
   */
  is_paused: Bool;
};

/**
 * Version of {@link groupCallParticipantVideoInfo} for method parameters.
 *
 * Contains information about a group call participant's video channel
 */
export type groupCallParticipantVideoInfo$Input = {
  readonly _: "groupCallParticipantVideoInfo";

  /**
   * List of synchronization source groups of the video
   * @type {vector<groupCallVideoSourceGroup>} {@link vector<groupCallVideoSourceGroup>}
   */
  readonly source_groups?: vector$Input<groupCallVideoSourceGroup$Input>;

  /**
   * Video channel endpoint identifier
   * @type {string} {@link string}
   */
  readonly endpoint_id?: string;

  /**
   * True, if the video is paused. This flag needs to be ignored, if new video frames are received
   * @type {Bool} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Represents a group call participant
 */
export type groupCallParticipant = {
  _: "groupCallParticipant";

  /**
   * Identifier of the group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * User's audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  audio_source_id: int32;

  /**
   * User's screen sharing audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  screen_sharing_audio_source_id: int32;

  /**
   * Information about user's video channel; may be null if there is no active video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  video_info: groupCallParticipantVideoInfo | null;

  /**
   * Information about user's screen sharing video channel; may be null if there is no active screen sharing video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  screen_sharing_video_info: groupCallParticipantVideoInfo | null;

  /**
   * The participant user's bio or the participant chat's description
   * @type {string} {@link string}
   */
  bio: string;

  /**
   * True, if the participant is the current user
   * @type {Bool} {@link Bool}
   */
  is_current_user: Bool;

  /**
   * True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
   * @type {Bool} {@link Bool}
   */
  is_speaking: Bool;

  /**
   * True, if the participant hand is raised
   * @type {Bool} {@link Bool}
   */
  is_hand_raised: Bool;

  /**
   * True, if the current user can mute the participant for all other group call participants
   * @type {Bool} {@link Bool}
   */
  can_be_muted_for_all_users: Bool;

  /**
   * True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
   * @type {Bool} {@link Bool}
   */
  can_be_unmuted_for_all_users: Bool;

  /**
   * True, if the current user can mute the participant only for self
   * @type {Bool} {@link Bool}
   */
  can_be_muted_for_current_user: Bool;

  /**
   * True, if the current user can unmute the participant for self
   * @type {Bool} {@link Bool}
   */
  can_be_unmuted_for_current_user: Bool;

  /**
   * True, if the participant is muted for all users
   * @type {Bool} {@link Bool}
   */
  is_muted_for_all_users: Bool;

  /**
   * True, if the participant is muted for the current user
   * @type {Bool} {@link Bool}
   */
  is_muted_for_current_user: Bool;

  /**
   * True, if the participant is muted for all users, but can unmute themselves
   * @type {Bool} {@link Bool}
   */
  can_unmute_self: Bool;

  /**
   * Participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  volume_level: int32;

  /**
   * User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
   * @type {string} {@link string}
   */
  order: string;
};

/**
 * Version of {@link groupCallParticipant} for method parameters.
 *
 * Represents a group call participant
 */
export type groupCallParticipant$Input = {
  readonly _: "groupCallParticipant";

  /**
   * Identifier of the group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * User's audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * User's screen sharing audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  readonly screen_sharing_audio_source_id?: int32;

  /**
   * Information about user's video channel; may be null if there is no active video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  readonly video_info?: groupCallParticipantVideoInfo$Input | null;

  /**
   * Information about user's screen sharing video channel; may be null if there is no active screen sharing video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  readonly screen_sharing_video_info?: groupCallParticipantVideoInfo$Input | null;

  /**
   * The participant user's bio or the participant chat's description
   * @type {string} {@link string}
   */
  readonly bio?: string;

  /**
   * True, if the participant is the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_current_user?: Bool$Input;

  /**
   * True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
   * @type {Bool} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;

  /**
   * True, if the participant hand is raised
   * @type {Bool} {@link Bool}
   */
  readonly is_hand_raised?: Bool$Input;

  /**
   * True, if the current user can mute the participant for all other group call participants
   * @type {Bool} {@link Bool}
   */
  readonly can_be_muted_for_all_users?: Bool$Input;

  /**
   * True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
   * @type {Bool} {@link Bool}
   */
  readonly can_be_unmuted_for_all_users?: Bool$Input;

  /**
   * True, if the current user can mute the participant only for self
   * @type {Bool} {@link Bool}
   */
  readonly can_be_muted_for_current_user?: Bool$Input;

  /**
   * True, if the current user can unmute the participant for self
   * @type {Bool} {@link Bool}
   */
  readonly can_be_unmuted_for_current_user?: Bool$Input;

  /**
   * True, if the participant is muted for all users
   * @type {Bool} {@link Bool}
   */
  readonly is_muted_for_all_users?: Bool$Input;

  /**
   * True, if the participant is muted for the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_muted_for_current_user?: Bool$Input;

  /**
   * True, if the participant is muted for all users, but can unmute themselves
   * @type {Bool} {@link Bool}
   */
  readonly can_unmute_self?: Bool$Input;

  /**
   * Participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;

  /**
   * User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
   * @type {string} {@link string}
   */
  readonly order?: string;
};

/**
 * The user heard their own voice
 */
export type callProblemEcho = {
  _: "callProblemEcho";
};

/**
 * Version of {@link callProblemEcho} for method parameters.
 *
 * The user heard their own voice
 */
export type callProblemEcho$Input = {
  readonly _: "callProblemEcho";
};

/**
 * The user heard background noise
 */
export type callProblemNoise = {
  _: "callProblemNoise";
};

/**
 * Version of {@link callProblemNoise} for method parameters.
 *
 * The user heard background noise
 */
export type callProblemNoise$Input = {
  readonly _: "callProblemNoise";
};

/**
 * The other side kept disappearing
 */
export type callProblemInterruptions = {
  _: "callProblemInterruptions";
};

/**
 * Version of {@link callProblemInterruptions} for method parameters.
 *
 * The other side kept disappearing
 */
export type callProblemInterruptions$Input = {
  readonly _: "callProblemInterruptions";
};

/**
 * The speech was distorted
 */
export type callProblemDistortedSpeech = {
  _: "callProblemDistortedSpeech";
};

/**
 * Version of {@link callProblemDistortedSpeech} for method parameters.
 *
 * The speech was distorted
 */
export type callProblemDistortedSpeech$Input = {
  readonly _: "callProblemDistortedSpeech";
};

/**
 * The user couldn't hear the other side
 */
export type callProblemSilentLocal = {
  _: "callProblemSilentLocal";
};

/**
 * Version of {@link callProblemSilentLocal} for method parameters.
 *
 * The user couldn't hear the other side
 */
export type callProblemSilentLocal$Input = {
  readonly _: "callProblemSilentLocal";
};

/**
 * The other side couldn't hear the user
 */
export type callProblemSilentRemote = {
  _: "callProblemSilentRemote";
};

/**
 * Version of {@link callProblemSilentRemote} for method parameters.
 *
 * The other side couldn't hear the user
 */
export type callProblemSilentRemote$Input = {
  readonly _: "callProblemSilentRemote";
};

/**
 * The call ended unexpectedly
 */
export type callProblemDropped = {
  _: "callProblemDropped";
};

/**
 * Version of {@link callProblemDropped} for method parameters.
 *
 * The call ended unexpectedly
 */
export type callProblemDropped$Input = {
  readonly _: "callProblemDropped";
};

/**
 * The video was distorted
 */
export type callProblemDistortedVideo = {
  _: "callProblemDistortedVideo";
};

/**
 * Version of {@link callProblemDistortedVideo} for method parameters.
 *
 * The video was distorted
 */
export type callProblemDistortedVideo$Input = {
  readonly _: "callProblemDistortedVideo";
};

/**
 * The video was pixelated
 */
export type callProblemPixelatedVideo = {
  _: "callProblemPixelatedVideo";
};

/**
 * Version of {@link callProblemPixelatedVideo} for method parameters.
 *
 * The video was pixelated
 */
export type callProblemPixelatedVideo$Input = {
  readonly _: "callProblemPixelatedVideo";
};

/**
 * Describes a call
 */
export type call = {
  _: "call";

  /**
   * Call identifier, not persistent
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * User identifier of the other call participant
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * True, if the call is outgoing
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * True, if the call is a video call
   * @type {Bool} {@link Bool}
   */
  is_video: Bool;

  /**
   * Call state
   * @type {CallState} {@link CallState}
   */
  state: CallState;
};

/**
 * Version of {@link call} for method parameters.
 *
 * Describes a call
 */
export type call$Input = {
  readonly _: "call";

  /**
   * Call identifier, not persistent
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * User identifier of the other call participant
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * True, if the call is outgoing
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * True, if the call is a video call
   * @type {Bool} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Call state
   * @type {CallState} {@link CallState}
   */
  readonly state?: CallState$Input;
};

/**
 * Settings for Firebase Authentication in the official Android application
 */
export type firebaseAuthenticationSettingsAndroid = {
  _: "firebaseAuthenticationSettingsAndroid";
};

/**
 * Version of {@link firebaseAuthenticationSettingsAndroid} for method parameters.
 *
 * Settings for Firebase Authentication in the official Android application
 */
export type firebaseAuthenticationSettingsAndroid$Input = {
  readonly _: "firebaseAuthenticationSettingsAndroid";
};

/**
 * Settings for Firebase Authentication in the official iOS application
 */
export type firebaseAuthenticationSettingsIos = {
  _: "firebaseAuthenticationSettingsIos";

  /**
   * Device token from Apple Push Notification service
   * @type {string} {@link string}
   */
  device_token: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  is_app_sandbox: Bool;
};

/**
 * Version of {@link firebaseAuthenticationSettingsIos} for method parameters.
 *
 * Settings for Firebase Authentication in the official iOS application
 */
export type firebaseAuthenticationSettingsIos$Input = {
  readonly _: "firebaseAuthenticationSettingsIos";

  /**
   * Device token from Apple Push Notification service
   * @type {string} {@link string}
   */
  readonly device_token?: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_app_sandbox?: Bool$Input;
};

/**
 * Contains settings for the authentication of the user's phone number
 */
export type phoneNumberAuthenticationSettings = {
  _: "phoneNumberAuthenticationSettings";

  /**
   * Pass true if the authentication code may be sent via a flash call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  allow_flash_call: Bool;

  /**
   * Pass true if the authentication code may be sent via a missed call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  allow_missed_call: Bool;

  /**
   * Pass true if the authenticated phone number is used on the current device
   * @type {Bool} {@link Bool}
   */
  is_current_phone_number: Bool;

  /**
   * For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
   * @type {Bool} {@link Bool}
   */
  allow_sms_retriever_api: Bool;

  /**
   * For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication
   * @type {FirebaseAuthenticationSettings} {@link FirebaseAuthenticationSettings}
   */
  firebase_authentication_settings: FirebaseAuthenticationSettings | null;

  /**
   * List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
   * @type {vector<string>} {@link vector<string>}
   */
  authentication_tokens: vector<string>;
};

/**
 * Version of {@link phoneNumberAuthenticationSettings} for method parameters.
 *
 * Contains settings for the authentication of the user's phone number
 */
export type phoneNumberAuthenticationSettings$Input = {
  readonly _: "phoneNumberAuthenticationSettings";

  /**
   * Pass true if the authentication code may be sent via a flash call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  readonly allow_flash_call?: Bool$Input;

  /**
   * Pass true if the authentication code may be sent via a missed call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  readonly allow_missed_call?: Bool$Input;

  /**
   * Pass true if the authenticated phone number is used on the current device
   * @type {Bool} {@link Bool}
   */
  readonly is_current_phone_number?: Bool$Input;

  /**
   * For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
   * @type {Bool} {@link Bool}
   */
  readonly allow_sms_retriever_api?: Bool$Input;

  /**
   * For official Android and iOS applications only; pass null otherwise. Settings for Firebase Authentication
   * @type {FirebaseAuthenticationSettings} {@link FirebaseAuthenticationSettings}
   */
  readonly firebase_authentication_settings?: FirebaseAuthenticationSettings$Input | null;

  /**
   * List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
   * @type {vector<string>} {@link vector<string>}
   */
  readonly authentication_tokens?: vector$Input<string>;
};

/**
 * Represents a reaction applied to a message
 */
export type addedReaction = {
  _: "addedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * Identifier of the chat member, applied the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * True, if the reaction was added by the current user
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * Point in time (Unix timestamp) when the reaction was added
   * @type {int32} {@link int32}
   */
  date: int32;
};

/**
 * Version of {@link addedReaction} for method parameters.
 *
 * Represents a reaction applied to a message
 */
export type addedReaction$Input = {
  readonly _: "addedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * Identifier of the chat member, applied the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * True, if the reaction was added by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when the reaction was added
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * Represents a list of reactions added to a message
 */
export type addedReactions = {
  _: "addedReactions";

  /**
   * The total number of found reactions
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * The list of added reactions
   * @type {vector<addedReaction>} {@link vector<addedReaction>}
   */
  reactions: vector<addedReaction>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link addedReactions} for method parameters.
 *
 * Represents a list of reactions added to a message
 */
export type addedReactions$Input = {
  readonly _: "addedReactions";

  /**
   * The total number of found reactions
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * The list of added reactions
   * @type {vector<addedReaction>} {@link vector<addedReaction>}
   */
  readonly reactions?: vector$Input<addedReaction$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Represents an available reaction
 */
export type availableReaction = {
  _: "availableReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * True, if Telegram Premium is needed to send the reaction
   * @type {Bool} {@link Bool}
   */
  needs_premium: Bool;
};

/**
 * Version of {@link availableReaction} for method parameters.
 *
 * Represents an available reaction
 */
export type availableReaction$Input = {
  readonly _: "availableReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * True, if Telegram Premium is needed to send the reaction
   * @type {Bool} {@link Bool}
   */
  readonly needs_premium?: Bool$Input;
};

/**
 * Represents a list of reactions that can be added to a message
 */
export type availableReactions = {
  _: "availableReactions";

  /**
   * List of reactions to be shown at the top
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  top_reactions: vector<availableReaction>;

  /**
   * List of recently used reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  recent_reactions: vector<availableReaction>;

  /**
   * List of popular reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  popular_reactions: vector<availableReaction>;

  /**
   * True, if any custom emoji reaction can be added by Telegram Premium subscribers
   * @type {Bool} {@link Bool}
   */
  allow_custom_emoji: Bool;
};

/**
 * Version of {@link availableReactions} for method parameters.
 *
 * Represents a list of reactions that can be added to a message
 */
export type availableReactions$Input = {
  readonly _: "availableReactions";

  /**
   * List of reactions to be shown at the top
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  readonly top_reactions?: vector$Input<availableReaction$Input>;

  /**
   * List of recently used reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  readonly recent_reactions?: vector$Input<availableReaction$Input>;

  /**
   * List of popular reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  readonly popular_reactions?: vector$Input<availableReaction$Input>;

  /**
   * True, if any custom emoji reaction can be added by Telegram Premium subscribers
   * @type {Bool} {@link Bool}
   */
  readonly allow_custom_emoji?: Bool$Input;
};

/**
 * Contains information about a emoji reaction
 */
export type emojiReaction = {
  _: "emojiReaction";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * Reaction title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * True, if the reaction can be added to new messages and enabled in chats
   * @type {Bool} {@link Bool}
   */
  is_active: Bool;

  /**
   * Static icon for the reaction
   * @type {sticker} {@link sticker}
   */
  static_icon: sticker;

  /**
   * Appear animation for the reaction
   * @type {sticker} {@link sticker}
   */
  appear_animation: sticker;

  /**
   * Select animation for the reaction
   * @type {sticker} {@link sticker}
   */
  select_animation: sticker;

  /**
   * Activate animation for the reaction
   * @type {sticker} {@link sticker}
   */
  activate_animation: sticker;

  /**
   * Effect animation for the reaction
   * @type {sticker} {@link sticker}
   */
  effect_animation: sticker;

  /**
   * Around animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  around_animation: sticker | null;

  /**
   * Center animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  center_animation: sticker | null;
};

/**
 * Version of {@link emojiReaction} for method parameters.
 *
 * Contains information about a emoji reaction
 */
export type emojiReaction$Input = {
  readonly _: "emojiReaction";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * Reaction title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * True, if the reaction can be added to new messages and enabled in chats
   * @type {Bool} {@link Bool}
   */
  readonly is_active?: Bool$Input;

  /**
   * Static icon for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly static_icon?: sticker$Input;

  /**
   * Appear animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly appear_animation?: sticker$Input;

  /**
   * Select animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly select_animation?: sticker$Input;

  /**
   * Activate animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly activate_animation?: sticker$Input;

  /**
   * Effect animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly effect_animation?: sticker$Input;

  /**
   * Around animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  readonly around_animation?: sticker$Input | null;

  /**
   * Center animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  readonly center_animation?: sticker$Input | null;
};

/**
 * Represents a list of animations
 */
export type animations = {
  _: "animations";

  /**
   * List of animations
   * @type {vector<animation>} {@link vector<animation>}
   */
  animations: vector<animation>;
};

/**
 * Version of {@link animations} for method parameters.
 *
 * Represents a list of animations
 */
export type animations$Input = {
  readonly _: "animations";

  /**
   * List of animations
   * @type {vector<animation>} {@link vector<animation>}
   */
  readonly animations?: vector$Input<animation$Input>;
};

/**
 * A regular animated sticker
 */
export type diceStickersRegular = {
  _: "diceStickersRegular";

  /**
   * The animated sticker with the dice animation
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

/**
 * Version of {@link diceStickersRegular} for method parameters.
 *
 * A regular animated sticker
 */
export type diceStickersRegular$Input = {
  readonly _: "diceStickersRegular";

  /**
   * The animated sticker with the dice animation
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/**
 * Animated stickers to be combined into a slot machine
 */
export type diceStickersSlotMachine = {
  _: "diceStickersSlotMachine";

  /**
   * The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
   * @type {sticker} {@link sticker}
   */
  background: sticker;

  /**
   * The animated sticker with the lever animation. The lever animation must play once in the initial dice state
   * @type {sticker} {@link sticker}
   */
  lever: sticker;

  /**
   * The animated sticker with the left reel
   * @type {sticker} {@link sticker}
   */
  left_reel: sticker;

  /**
   * The animated sticker with the center reel
   * @type {sticker} {@link sticker}
   */
  center_reel: sticker;

  /**
   * The animated sticker with the right reel
   * @type {sticker} {@link sticker}
   */
  right_reel: sticker;
};

/**
 * Version of {@link diceStickersSlotMachine} for method parameters.
 *
 * Animated stickers to be combined into a slot machine
 */
export type diceStickersSlotMachine$Input = {
  readonly _: "diceStickersSlotMachine";

  /**
   * The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
   * @type {sticker} {@link sticker}
   */
  readonly background?: sticker$Input;

  /**
   * The animated sticker with the lever animation. The lever animation must play once in the initial dice state
   * @type {sticker} {@link sticker}
   */
  readonly lever?: sticker$Input;

  /**
   * The animated sticker with the left reel
   * @type {sticker} {@link sticker}
   */
  readonly left_reel?: sticker$Input;

  /**
   * The animated sticker with the center reel
   * @type {sticker} {@link sticker}
   */
  readonly center_reel?: sticker$Input;

  /**
   * The animated sticker with the right reel
   * @type {sticker} {@link sticker}
   */
  readonly right_reel?: sticker$Input;
};

/**
 * Represents the result of an importContacts request
 */
export type importedContacts = {
  _: "importedContacts";

  /**
   * User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;

  /**
   * The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
   * @type {vector<int32>} {@link vector<int32>}
   */
  importer_count: vector<int32>;
};

/**
 * Version of {@link importedContacts} for method parameters.
 *
 * Represents the result of an importContacts request
 */
export type importedContacts$Input = {
  readonly _: "importedContacts";

  /**
   * User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly importer_count?: vector$Input<int32>;
};

/**
 * The speech recognition is ongoing
 */
export type speechRecognitionResultPending = {
  _: "speechRecognitionResultPending";

  /**
   * Partially recognized text
   * @type {string} {@link string}
   */
  partial_text: string;
};

/**
 * Version of {@link speechRecognitionResultPending} for method parameters.
 *
 * The speech recognition is ongoing
 */
export type speechRecognitionResultPending$Input = {
  readonly _: "speechRecognitionResultPending";

  /**
   * Partially recognized text
   * @type {string} {@link string}
   */
  readonly partial_text?: string;
};

/**
 * The speech recognition successfully finished
 */
export type speechRecognitionResultText = {
  _: "speechRecognitionResultText";

  /**
   * Recognized text
   * @type {string} {@link string}
   */
  text: string;
};

/**
 * Version of {@link speechRecognitionResultText} for method parameters.
 *
 * The speech recognition successfully finished
 */
export type speechRecognitionResultText$Input = {
  readonly _: "speechRecognitionResultText";

  /**
   * Recognized text
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * The speech recognition failed
 */
export type speechRecognitionResultError = {
  _: "speechRecognitionResultError";

  /**
   * Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
   * @type {error} {@link error}
   */
  error: error;
};

/**
 * Version of {@link speechRecognitionResultError} for method parameters.
 *
 * The speech recognition failed
 */
export type speechRecognitionResultError$Input = {
  readonly _: "speechRecognitionResultError";

  /**
   * Recognition error. An error with a message "MSG_VOICE_TOO_LONG" is returned when media duration is too big to be recognized
   * @type {error} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * Describes a color to highlight a bot added to attachment menu
 */
export type attachmentMenuBotColor = {
  _: "attachmentMenuBotColor";

  /**
   * Color in the RGB24 format for light themes
   * @type {int32} {@link int32}
   */
  light_color: int32;

  /**
   * Color in the RGB24 format for dark themes
   * @type {int32} {@link int32}
   */
  dark_color: int32;
};

/**
 * Version of {@link attachmentMenuBotColor} for method parameters.
 *
 * Describes a color to highlight a bot added to attachment menu
 */
export type attachmentMenuBotColor$Input = {
  readonly _: "attachmentMenuBotColor";

  /**
   * Color in the RGB24 format for light themes
   * @type {int32} {@link int32}
   */
  readonly light_color?: int32;

  /**
   * Color in the RGB24 format for dark themes
   * @type {int32} {@link int32}
   */
  readonly dark_color?: int32;
};

/**
 * Represents a bot, which can be added to attachment or side menu
 */
export type attachmentMenuBot = {
  _: "attachmentMenuBot";

  /**
   * User identifier of the bot
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * True, if the bot supports opening from attachment menu in the chat with the bot
   * @type {Bool} {@link Bool}
   */
  supports_self_chat: Bool;

  /**
   * True, if the bot supports opening from attachment menu in private chats with ordinary users
   * @type {Bool} {@link Bool}
   */
  supports_user_chats: Bool;

  /**
   * True, if the bot supports opening from attachment menu in private chats with other bots
   * @type {Bool} {@link Bool}
   */
  supports_bot_chats: Bool;

  /**
   * True, if the bot supports opening from attachment menu in basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  supports_group_chats: Bool;

  /**
   * True, if the bot supports opening from attachment menu in channel chats
   * @type {Bool} {@link Bool}
   */
  supports_channel_chats: Bool;

  /**
   * True, if the user must be asked for the permission to send messages to the bot
   * @type {Bool} {@link Bool}
   */
  request_write_access: Bool;

  /**
   * True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
   * @type {Bool} {@link Bool}
   */
  is_added: Bool;

  /**
   * True, if the bot must be shown in the attachment menu
   * @type {Bool} {@link Bool}
   */
  show_in_attachment_menu: Bool;

  /**
   * True, if the bot must be shown in the side menu
   * @type {Bool} {@link Bool}
   */
  show_in_side_menu: Bool;

  /**
   * True, if a disclaimer, why the bot is shown in the side menu, is needed
   * @type {Bool} {@link Bool}
   */
  show_disclaimer_in_side_menu: Bool;

  /**
   * Name for the bot in attachment menu
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Color to highlight selected name of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  name_color: attachmentMenuBotColor | null;

  /**
   * Default icon for the bot in SVG format; may be null
   * @type {file} {@link file}
   */
  default_icon: file | null;

  /**
   * Icon for the bot in SVG format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  ios_static_icon: file | null;

  /**
   * Icon for the bot in TGS format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  ios_animated_icon: file | null;

  /**
   * Icon for the bot in PNG format for the official iOS app side menu; may be null
   * @type {file} {@link file}
   */
  ios_side_menu_icon: file | null;

  /**
   * Icon for the bot in TGS format for the official Android app; may be null
   * @type {file} {@link file}
   */
  android_icon: file | null;

  /**
   * Icon for the bot in SVG format for the official Android app side menu; may be null
   * @type {file} {@link file}
   */
  android_side_menu_icon: file | null;

  /**
   * Icon for the bot in TGS format for the official native macOS app; may be null
   * @type {file} {@link file}
   */
  macos_icon: file | null;

  /**
   * Icon for the bot in PNG format for the official macOS app side menu; may be null
   * @type {file} {@link file}
   */
  macos_side_menu_icon: file | null;

  /**
   * Color to highlight selected icon of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  icon_color: attachmentMenuBotColor | null;

  /**
   * Default placeholder for opened Web Apps in SVG format; may be null
   * @type {file} {@link file}
   */
  web_app_placeholder: file | null;
};

/**
 * Version of {@link attachmentMenuBot} for method parameters.
 *
 * Represents a bot, which can be added to attachment or side menu
 */
export type attachmentMenuBot$Input = {
  readonly _: "attachmentMenuBot";

  /**
   * User identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * True, if the bot supports opening from attachment menu in the chat with the bot
   * @type {Bool} {@link Bool}
   */
  readonly supports_self_chat?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in private chats with ordinary users
   * @type {Bool} {@link Bool}
   */
  readonly supports_user_chats?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in private chats with other bots
   * @type {Bool} {@link Bool}
   */
  readonly supports_bot_chats?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  readonly supports_group_chats?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in channel chats
   * @type {Bool} {@link Bool}
   */
  readonly supports_channel_chats?: Bool$Input;

  /**
   * True, if the user must be asked for the permission to send messages to the bot
   * @type {Bool} {@link Bool}
   */
  readonly request_write_access?: Bool$Input;

  /**
   * True, if the bot was explicitly added by the user. If the bot isn't added, then on the first bot launch toggleBotIsAddedToAttachmentMenu must be called and the bot must be added or removed
   * @type {Bool} {@link Bool}
   */
  readonly is_added?: Bool$Input;

  /**
   * True, if the bot must be shown in the attachment menu
   * @type {Bool} {@link Bool}
   */
  readonly show_in_attachment_menu?: Bool$Input;

  /**
   * True, if the bot must be shown in the side menu
   * @type {Bool} {@link Bool}
   */
  readonly show_in_side_menu?: Bool$Input;

  /**
   * True, if a disclaimer, why the bot is shown in the side menu, is needed
   * @type {Bool} {@link Bool}
   */
  readonly show_disclaimer_in_side_menu?: Bool$Input;

  /**
   * Name for the bot in attachment menu
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Color to highlight selected name of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  readonly name_color?: attachmentMenuBotColor$Input | null;

  /**
   * Default icon for the bot in SVG format; may be null
   * @type {file} {@link file}
   */
  readonly default_icon?: file$Input | null;

  /**
   * Icon for the bot in SVG format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  readonly ios_static_icon?: file$Input | null;

  /**
   * Icon for the bot in TGS format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  readonly ios_animated_icon?: file$Input | null;

  /**
   * Icon for the bot in PNG format for the official iOS app side menu; may be null
   * @type {file} {@link file}
   */
  readonly ios_side_menu_icon?: file$Input | null;

  /**
   * Icon for the bot in TGS format for the official Android app; may be null
   * @type {file} {@link file}
   */
  readonly android_icon?: file$Input | null;

  /**
   * Icon for the bot in SVG format for the official Android app side menu; may be null
   * @type {file} {@link file}
   */
  readonly android_side_menu_icon?: file$Input | null;

  /**
   * Icon for the bot in TGS format for the official native macOS app; may be null
   * @type {file} {@link file}
   */
  readonly macos_icon?: file$Input | null;

  /**
   * Icon for the bot in PNG format for the official macOS app side menu; may be null
   * @type {file} {@link file}
   */
  readonly macos_side_menu_icon?: file$Input | null;

  /**
   * Color to highlight selected icon of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  readonly icon_color?: attachmentMenuBotColor$Input | null;

  /**
   * Default placeholder for opened Web Apps in SVG format; may be null
   * @type {file} {@link file}
   */
  readonly web_app_placeholder?: file$Input | null;
};

/**
 * Information about the message sent by answerWebAppQuery
 */
export type sentWebAppMessage = {
  _: "sentWebAppMessage";

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  inline_message_id: string;
};

/**
 * Version of {@link sentWebAppMessage} for method parameters.
 *
 * Information about the message sent by answerWebAppQuery
 */
export type sentWebAppMessage$Input = {
  readonly _: "sentWebAppMessage";

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;
};

/**
 * The user connected a website by logging in using Telegram Login Widget on it
 */
export type botWriteAccessAllowReasonConnectedWebsite = {
  _: "botWriteAccessAllowReasonConnectedWebsite";

  /**
   * Domain name of the connected website
   * @type {string} {@link string}
   */
  domain_name: string;
};

/**
 * Version of {@link botWriteAccessAllowReasonConnectedWebsite} for method parameters.
 *
 * The user connected a website by logging in using Telegram Login Widget on it
 */
export type botWriteAccessAllowReasonConnectedWebsite$Input = {
  readonly _: "botWriteAccessAllowReasonConnectedWebsite";

  /**
   * Domain name of the connected website
   * @type {string} {@link string}
   */
  readonly domain_name?: string;
};

/**
 * The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu
 */
export type botWriteAccessAllowReasonAddedToAttachmentMenu = {
  _: "botWriteAccessAllowReasonAddedToAttachmentMenu";
};

/**
 * Version of {@link botWriteAccessAllowReasonAddedToAttachmentMenu} for method parameters.
 *
 * The user added the bot to attachment or side menu using toggleBotIsAddedToAttachmentMenu
 */
export type botWriteAccessAllowReasonAddedToAttachmentMenu$Input = {
  readonly _: "botWriteAccessAllowReasonAddedToAttachmentMenu";
};

/**
 * The user launched a Web App using getWebAppLinkUrl
 */
export type botWriteAccessAllowReasonLaunchedWebApp = {
  _: "botWriteAccessAllowReasonLaunchedWebApp";

  /**
   * Information about the Web App
   * @type {webApp} {@link webApp}
   */
  web_app: webApp;
};

/**
 * Version of {@link botWriteAccessAllowReasonLaunchedWebApp} for method parameters.
 *
 * The user launched a Web App using getWebAppLinkUrl
 */
export type botWriteAccessAllowReasonLaunchedWebApp$Input = {
  readonly _: "botWriteAccessAllowReasonLaunchedWebApp";

  /**
   * Information about the Web App
   * @type {webApp} {@link webApp}
   */
  readonly web_app?: webApp$Input;
};

/**
 * The user accepted bot's request to send messages with allowBotToSendMessages
 */
export type botWriteAccessAllowReasonAcceptedRequest = {
  _: "botWriteAccessAllowReasonAcceptedRequest";
};

/**
 * Version of {@link botWriteAccessAllowReasonAcceptedRequest} for method parameters.
 *
 * The user accepted bot's request to send messages with allowBotToSendMessages
 */
export type botWriteAccessAllowReasonAcceptedRequest$Input = {
  readonly _: "botWriteAccessAllowReasonAcceptedRequest";
};

/**
 * Contains an HTTP URL
 */
export type httpUrl = {
  _: "httpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link httpUrl} for method parameters.
 *
 * Contains an HTTP URL
 */
export type httpUrl$Input = {
  readonly _: "httpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Contains an HTTPS URL, which can be used to get information about a user
 */
export type userLink = {
  _: "userLink";

  /**
   * The URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Left time for which the link is valid, in seconds; 0 if the link is a public username link
   * @type {int32} {@link int32}
   */
  expires_in: int32;
};

/**
 * Version of {@link userLink} for method parameters.
 *
 * Contains an HTTPS URL, which can be used to get information about a user
 */
export type userLink$Input = {
  readonly _: "userLink";

  /**
   * The URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Left time for which the link is valid, in seconds; 0 if the link is a public username link
   * @type {int32} {@link int32}
   */
  readonly expires_in?: int32;
};

/**
 * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
 */
export type inputInlineQueryResultAnimation = {
  _: "inputInlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the query result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  thumbnail_mime_type: string;

  /**
   * The URL of the video file (file size must not exceed 1MB)
   * @type {string} {@link string}
   */
  video_url: string;

  /**
   * MIME type of the video file. Must be one of "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  video_mime_type: string;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  video_duration: int32;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  video_width: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  video_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultAnimation} for method parameters.
 *
 * Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
 */
export type inputInlineQueryResultAnimation$Input = {
  readonly _: "inputInlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the query result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  readonly thumbnail_mime_type?: string;

  /**
   * The URL of the video file (file size must not exceed 1MB)
   * @type {string} {@link string}
   */
  readonly video_url?: string;

  /**
   * MIME type of the video file. Must be one of "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  readonly video_mime_type?: string;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  readonly video_duration?: int32;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  readonly video_width?: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  readonly video_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to an article or web page
 */
export type inputInlineQueryResultArticle = {
  _: "inputInlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  hide_url: Bool;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  description: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultArticle} for method parameters.
 *
 * Represents a link to an article or web page
 */
export type inputInlineQueryResultArticle$Input = {
  readonly _: "inputInlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  readonly hide_url?: Bool$Input;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to an MP3 audio file
 */
export type inputInlineQueryResultAudio = {
  _: "inputInlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the audio file
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Performer of the audio file
   * @type {string} {@link string}
   */
  performer: string;

  /**
   * The URL of the audio file
   * @type {string} {@link string}
   */
  audio_url: string;

  /**
   * Audio file duration, in seconds
   * @type {int32} {@link int32}
   */
  audio_duration: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultAudio} for method parameters.
 *
 * Represents a link to an MP3 audio file
 */
export type inputInlineQueryResultAudio$Input = {
  readonly _: "inputInlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the audio file
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Performer of the audio file
   * @type {string} {@link string}
   */
  readonly performer?: string;

  /**
   * The URL of the audio file
   * @type {string} {@link string}
   */
  readonly audio_url?: string;

  /**
   * Audio file duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly audio_duration?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a user contact
 */
export type inputInlineQueryResultContact = {
  _: "inputInlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * User contact
   * @type {contact} {@link contact}
   */
  contact: contact;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultContact} for method parameters.
 *
 * Represents a user contact
 */
export type inputInlineQueryResultContact$Input = {
  readonly _: "inputInlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * User contact
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to a file
 */
export type inputInlineQueryResultDocument = {
  _: "inputInlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the resulting file
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to a file
   * @type {string} {@link string}
   */
  description: string;

  /**
   * URL of the file
   * @type {string} {@link string}
   */
  document_url: string;

  /**
   * MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * The URL of the file thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Width of the thumbnail
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Height of the thumbnail
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultDocument} for method parameters.
 *
 * Represents a link to a file
 */
export type inputInlineQueryResultDocument$Input = {
  readonly _: "inputInlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the resulting file
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to a file
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * URL of the file
   * @type {string} {@link string}
   */
  readonly document_url?: string;

  /**
   * MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * The URL of the file thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Width of the thumbnail
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Height of the thumbnail
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a game
 */
export type inputInlineQueryResultGame = {
  _: "inputInlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  game_short_name: string;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;
};

/**
 * Version of {@link inputInlineQueryResultGame} for method parameters.
 *
 * Represents a game
 */
export type inputInlineQueryResultGame$Input = {
  readonly _: "inputInlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Represents a point on the map
 */
export type inputInlineQueryResultLocation = {
  _: "inputInlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Amount of time relative to the message sent time until the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  live_period: int32;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultLocation} for method parameters.
 *
 * Represents a point on the map
 */
export type inputInlineQueryResultLocation$Input = {
  readonly _: "inputInlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Amount of time relative to the message sent time until the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  readonly live_period?: int32;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents link to a JPEG image
 */
export type inputInlineQueryResultPhoto = {
  _: "inputInlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents link to a JPEG image
   * @type {string} {@link string}
   */
  description: string;

  /**
   * URL of the photo thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * The URL of the JPEG photo (photo size must not exceed 5MB)
   * @type {string} {@link string}
   */
  photo_url: string;

  /**
   * Width of the photo
   * @type {int32} {@link int32}
   */
  photo_width: int32;

  /**
   * Height of the photo
   * @type {int32} {@link int32}
   */
  photo_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultPhoto} for method parameters.
 *
 * Represents link to a JPEG image
 */
export type inputInlineQueryResultPhoto$Input = {
  readonly _: "inputInlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents link to a JPEG image
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * URL of the photo thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * The URL of the JPEG photo (photo size must not exceed 5MB)
   * @type {string} {@link string}
   */
  readonly photo_url?: string;

  /**
   * Width of the photo
   * @type {int32} {@link int32}
   */
  readonly photo_width?: int32;

  /**
   * Height of the photo
   * @type {int32} {@link int32}
   */
  readonly photo_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to a WEBP, TGS, or WEBM sticker
 */
export type inputInlineQueryResultSticker = {
  _: "inputInlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * URL of the sticker thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
   * @type {string} {@link string}
   */
  sticker_url: string;

  /**
   * Width of the sticker
   * @type {int32} {@link int32}
   */
  sticker_width: int32;

  /**
   * Height of the sticker
   * @type {int32} {@link int32}
   */
  sticker_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultSticker} for method parameters.
 *
 * Represents a link to a WEBP, TGS, or WEBM sticker
 */
export type inputInlineQueryResultSticker$Input = {
  readonly _: "inputInlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * URL of the sticker thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
   * @type {string} {@link string}
   */
  readonly sticker_url?: string;

  /**
   * Width of the sticker
   * @type {int32} {@link int32}
   */
  readonly sticker_width?: int32;

  /**
   * Height of the sticker
   * @type {int32} {@link int32}
   */
  readonly sticker_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents information about a venue
 */
export type inputInlineQueryResultVenue = {
  _: "inputInlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  venue: venue;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultVenue} for method parameters.
 *
 * Represents information about a venue
 */
export type inputInlineQueryResultVenue$Input = {
  readonly _: "inputInlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to a page containing an embedded video player or a video file
 */
export type inputInlineQueryResultVideo = {
  _: "inputInlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to a page containing an embedded video player or a video file
   * @type {string} {@link string}
   */
  description: string;

  /**
   * The URL of the video thumbnail (JPEG), if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * URL of the embedded video player or video file
   * @type {string} {@link string}
   */
  video_url: string;

  /**
   * MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  video_width: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  video_height: int32;

  /**
   * Video duration, in seconds
   * @type {int32} {@link int32}
   */
  video_duration: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultVideo} for method parameters.
 *
 * Represents a link to a page containing an embedded video player or a video file
 */
export type inputInlineQueryResultVideo$Input = {
  readonly _: "inputInlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to a page containing an embedded video player or a video file
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * The URL of the video thumbnail (JPEG), if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * URL of the embedded video player or video file
   * @type {string} {@link string}
   */
  readonly video_url?: string;

  /**
   * MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  readonly video_width?: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  readonly video_height?: int32;

  /**
   * Video duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly video_duration?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to an opus-encoded audio file within an OGG container, single channel audio
 */
export type inputInlineQueryResultVoiceNote = {
  _: "inputInlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The URL of the voice note file
   * @type {string} {@link string}
   */
  voice_note_url: string;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  voice_note_duration: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

/**
 * Version of {@link inputInlineQueryResultVoiceNote} for method parameters.
 *
 * Represents a link to an opus-encoded audio file within an OGG container, single channel audio
 */
export type inputInlineQueryResultVoiceNote$Input = {
  readonly _: "inputInlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The URL of the voice note file
   * @type {string} {@link string}
   */
  readonly voice_note_url?: string;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  readonly voice_note_duration?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Represents a link to an article or web page
 */
export type inlineQueryResultArticle = {
  _: "inlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  hide_url: Bool;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;
};

/**
 * Version of {@link inlineQueryResultArticle} for method parameters.
 *
 * Represents a link to an article or web page
 */
export type inlineQueryResultArticle$Input = {
  readonly _: "inlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  readonly hide_url?: Bool$Input;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;
};

/**
 * Represents a user contact
 */
export type inlineQueryResultContact = {
  _: "inlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * A user contact
   * @type {contact} {@link contact}
   */
  contact: contact;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;
};

/**
 * Version of {@link inlineQueryResultContact} for method parameters.
 *
 * Represents a user contact
 */
export type inlineQueryResultContact$Input = {
  readonly _: "inlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * A user contact
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;
};

/**
 * Represents a point on the map
 */
export type inlineQueryResultLocation = {
  _: "inlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;
};

/**
 * Version of {@link inlineQueryResultLocation} for method parameters.
 *
 * Represents a point on the map
 */
export type inlineQueryResultLocation$Input = {
  readonly _: "inlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;
};

/**
 * Represents information about a venue
 */
export type inlineQueryResultVenue = {
  _: "inlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  venue: venue;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail | null;
};

/**
 * Version of {@link inlineQueryResultVenue} for method parameters.
 *
 * Represents information about a venue
 */
export type inlineQueryResultVenue$Input = {
  readonly _: "inlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input | null;
};

/**
 * Represents information about a game
 */
export type inlineQueryResultGame = {
  _: "inlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Game result
   * @type {game} {@link game}
   */
  game: game;
};

/**
 * Version of {@link inlineQueryResultGame} for method parameters.
 *
 * Represents information about a game
 */
export type inlineQueryResultGame$Input = {
  readonly _: "inlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Game result
   * @type {game} {@link game}
   */
  readonly game?: game$Input;
};

/**
 * Represents an animation file
 */
export type inlineQueryResultAnimation = {
  _: "inlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Animation file
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Animation title
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link inlineQueryResultAnimation} for method parameters.
 *
 * Represents an animation file
 */
export type inlineQueryResultAnimation$Input = {
  readonly _: "inlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Animation file
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Animation title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Represents an audio file
 */
export type inlineQueryResultAudio = {
  _: "inlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Audio file
   * @type {audio} {@link audio}
   */
  audio: audio;
};

/**
 * Version of {@link inlineQueryResultAudio} for method parameters.
 *
 * Represents an audio file
 */
export type inlineQueryResultAudio$Input = {
  readonly _: "inlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Audio file
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;
};

/**
 * Represents a document
 */
export type inlineQueryResultDocument = {
  _: "inlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Document
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Document title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a document
   * @type {string} {@link string}
   */
  description: string;
};

/**
 * Version of {@link inlineQueryResultDocument} for method parameters.
 *
 * Represents a document
 */
export type inlineQueryResultDocument$Input = {
  readonly _: "inlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Document
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Document title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a document
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Represents a photo
 */
export type inlineQueryResultPhoto = {
  _: "inlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a photo
   * @type {string} {@link string}
   */
  description: string;
};

/**
 * Version of {@link inlineQueryResultPhoto} for method parameters.
 *
 * Represents a photo
 */
export type inlineQueryResultPhoto$Input = {
  readonly _: "inlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a photo
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Represents a sticker
 */
export type inlineQueryResultSticker = {
  _: "inlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Sticker
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

/**
 * Version of {@link inlineQueryResultSticker} for method parameters.
 *
 * Represents a sticker
 */
export type inlineQueryResultSticker$Input = {
  readonly _: "inlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Sticker
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/**
 * Represents a video
 */
export type inlineQueryResultVideo = {
  _: "inlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Video
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Title of the video
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a video
   * @type {string} {@link string}
   */
  description: string;
};

/**
 * Version of {@link inlineQueryResultVideo} for method parameters.
 *
 * Represents a video
 */
export type inlineQueryResultVideo$Input = {
  readonly _: "inlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Video
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Title of the video
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a video
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Represents a voice note
 */
export type inlineQueryResultVoiceNote = {
  _: "inlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Voice note
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link inlineQueryResultVoiceNote} for method parameters.
 *
 * Represents a voice note
 */
export type inlineQueryResultVoiceNote$Input = {
  readonly _: "inlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Voice note
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter
 */
export type inlineQueryResultsButtonTypeStartBot = {
  _: "inlineQueryResultsButtonTypeStartBot";

  /**
   * The parameter for the bot start message
   * @type {string} {@link string}
   */
  parameter: string;
};

/**
 * Version of {@link inlineQueryResultsButtonTypeStartBot} for method parameters.
 *
 * Describes the button that opens a private chat with the bot and sends a start message to the bot with the given parameter
 */
export type inlineQueryResultsButtonTypeStartBot$Input = {
  readonly _: "inlineQueryResultsButtonTypeStartBot";

  /**
   * The parameter for the bot start message
   * @type {string} {@link string}
   */
  readonly parameter?: string;
};

/**
 * Describes the button that opens a Web App by calling getWebAppUrl
 */
export type inlineQueryResultsButtonTypeWebApp = {
  _: "inlineQueryResultsButtonTypeWebApp";

  /**
   * An HTTP URL to pass to getWebAppUrl
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link inlineQueryResultsButtonTypeWebApp} for method parameters.
 *
 * Describes the button that opens a Web App by calling getWebAppUrl
 */
export type inlineQueryResultsButtonTypeWebApp$Input = {
  readonly _: "inlineQueryResultsButtonTypeWebApp";

  /**
   * An HTTP URL to pass to getWebAppUrl
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Represents a button to be shown above inline query results
 */
export type inlineQueryResultsButton = {
  _: "inlineQueryResultsButton";

  /**
   * The text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Type of the button
   * @type {InlineQueryResultsButtonType} {@link InlineQueryResultsButtonType}
   */
  type: InlineQueryResultsButtonType;
};

/**
 * Version of {@link inlineQueryResultsButton} for method parameters.
 *
 * Represents a button to be shown above inline query results
 */
export type inlineQueryResultsButton$Input = {
  readonly _: "inlineQueryResultsButton";

  /**
   * The text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Type of the button
   * @type {InlineQueryResultsButtonType} {@link InlineQueryResultsButtonType}
   */
  readonly type?: InlineQueryResultsButtonType$Input;
};

/**
 * Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
 */
export type inlineQueryResults = {
  _: "inlineQueryResults";

  /**
   * Unique identifier of the inline query
   * @type {int64} {@link int64}
   */
  inline_query_id: int64;

  /**
   * Button to be shown above inline query results; may be null
   * @type {inlineQueryResultsButton} {@link inlineQueryResultsButton}
   */
  button: inlineQueryResultsButton | null;

  /**
   * Results of the query
   * @type {vector<InlineQueryResult>} {@link vector<InlineQueryResult>}
   */
  results: vector<InlineQueryResult>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

/**
 * Version of {@link inlineQueryResults} for method parameters.
 *
 * Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
 */
export type inlineQueryResults$Input = {
  readonly _: "inlineQueryResults";

  /**
   * Unique identifier of the inline query
   * @type {int64} {@link int64}
   */
  readonly inline_query_id?: int64$Input;

  /**
   * Button to be shown above inline query results; may be null
   * @type {inlineQueryResultsButton} {@link inlineQueryResultsButton}
   */
  readonly button?: inlineQueryResultsButton$Input | null;

  /**
   * Results of the query
   * @type {vector<InlineQueryResult>} {@link vector<InlineQueryResult>}
   */
  readonly results?: vector$Input<InlineQueryResult$Input>;

  /**
   * The offset for the next request. If empty, then there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * The payload for a general callback button
 */
export type callbackQueryPayloadData = {
  _: "callbackQueryPayloadData";

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link callbackQueryPayloadData} for method parameters.
 *
 * The payload for a general callback button
 */
export type callbackQueryPayloadData$Input = {
  readonly _: "callbackQueryPayloadData";

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * The payload for a callback button requiring password
 */
export type callbackQueryPayloadDataWithPassword = {
  _: "callbackQueryPayloadDataWithPassword";

  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  password: string;

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link callbackQueryPayloadDataWithPassword} for method parameters.
 *
 * The payload for a callback button requiring password
 */
export type callbackQueryPayloadDataWithPassword$Input = {
  readonly _: "callbackQueryPayloadDataWithPassword";

  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * The payload for a game callback button
 */
export type callbackQueryPayloadGame = {
  _: "callbackQueryPayloadGame";

  /**
   * A short name of the game that was attached to the callback button
   * @type {string} {@link string}
   */
  game_short_name: string;
};

/**
 * Version of {@link callbackQueryPayloadGame} for method parameters.
 *
 * The payload for a game callback button
 */
export type callbackQueryPayloadGame$Input = {
  readonly _: "callbackQueryPayloadGame";

  /**
   * A short name of the game that was attached to the callback button
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;
};

/**
 * Contains a bot's answer to a callback query
 */
export type callbackQueryAnswer = {
  _: "callbackQueryAnswer";

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  text: string;

  /**
   * True, if an alert must be shown to the user instead of a toast notification
   * @type {Bool} {@link Bool}
   */
  show_alert: Bool;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link callbackQueryAnswer} for method parameters.
 *
 * Contains a bot's answer to a callback query
 */
export type callbackQueryAnswer$Input = {
  readonly _: "callbackQueryAnswer";

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * True, if an alert must be shown to the user instead of a toast notification
   * @type {Bool} {@link Bool}
   */
  readonly show_alert?: Bool$Input;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Contains the result of a custom request
 */
export type customRequestResult = {
  _: "customRequestResult";

  /**
   * A JSON-serialized result
   * @type {string} {@link string}
   */
  result: string;
};

/**
 * Version of {@link customRequestResult} for method parameters.
 *
 * Contains the result of a custom request
 */
export type customRequestResult$Input = {
  readonly _: "customRequestResult";

  /**
   * A JSON-serialized result
   * @type {string} {@link string}
   */
  readonly result?: string;
};

/**
 * Contains one row of the game high score table
 */
export type gameHighScore = {
  _: "gameHighScore";

  /**
   * Position in the high score table
   * @type {int32} {@link int32}
   */
  position: int32;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * User score
   * @type {int32} {@link int32}
   */
  score: int32;
};

/**
 * Version of {@link gameHighScore} for method parameters.
 *
 * Contains one row of the game high score table
 */
export type gameHighScore$Input = {
  readonly _: "gameHighScore";

  /**
   * Position in the high score table
   * @type {int32} {@link int32}
   */
  readonly position?: int32;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * User score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;
};

/**
 * Contains a list of game high scores
 */
export type gameHighScores = {
  _: "gameHighScores";

  /**
   * A list of game high scores
   * @type {vector<gameHighScore>} {@link vector<gameHighScore>}
   */
  scores: vector<gameHighScore>;
};

/**
 * Version of {@link gameHighScores} for method parameters.
 *
 * Contains a list of game high scores
 */
export type gameHighScores$Input = {
  readonly _: "gameHighScores";

  /**
   * A list of game high scores
   * @type {vector<gameHighScore>} {@link vector<gameHighScore>}
   */
  readonly scores?: vector$Input<gameHighScore$Input>;
};

/**
 * A message was edited
 */
export type chatEventMessageEdited = {
  _: "chatEventMessageEdited";

  /**
   * The original message before the edit
   * @type {message} {@link message}
   */
  old_message: message;

  /**
   * The message after it was edited
   * @type {message} {@link message}
   */
  new_message: message;
};

/**
 * Version of {@link chatEventMessageEdited} for method parameters.
 *
 * A message was edited
 */
export type chatEventMessageEdited$Input = {
  readonly _: "chatEventMessageEdited";

  /**
   * The original message before the edit
   * @type {message} {@link message}
   */
  readonly old_message?: message$Input;

  /**
   * The message after it was edited
   * @type {message} {@link message}
   */
  readonly new_message?: message$Input;
};

/**
 * A message was deleted
 */
export type chatEventMessageDeleted = {
  _: "chatEventMessageDeleted";

  /**
   * Deleted message
   * @type {message} {@link message}
   */
  message: message;

  /**
   * True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
   * @type {Bool} {@link Bool}
   */
  can_report_anti_spam_false_positive: Bool;
};

/**
 * Version of {@link chatEventMessageDeleted} for method parameters.
 *
 * A message was deleted
 */
export type chatEventMessageDeleted$Input = {
  readonly _: "chatEventMessageDeleted";

  /**
   * Deleted message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * True, if the message deletion can be reported via reportSupergroupAntiSpamFalsePositive
   * @type {Bool} {@link Bool}
   */
  readonly can_report_anti_spam_false_positive?: Bool$Input;
};

/**
 * A message was pinned
 */
export type chatEventMessagePinned = {
  _: "chatEventMessagePinned";

  /**
   * Pinned message
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link chatEventMessagePinned} for method parameters.
 *
 * A message was pinned
 */
export type chatEventMessagePinned$Input = {
  readonly _: "chatEventMessagePinned";

  /**
   * Pinned message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * A message was unpinned
 */
export type chatEventMessageUnpinned = {
  _: "chatEventMessageUnpinned";

  /**
   * Unpinned message
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link chatEventMessageUnpinned} for method parameters.
 *
 * A message was unpinned
 */
export type chatEventMessageUnpinned$Input = {
  readonly _: "chatEventMessageUnpinned";

  /**
   * Unpinned message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * A poll in a message was stopped
 */
export type chatEventPollStopped = {
  _: "chatEventPollStopped";

  /**
   * The message with the poll
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link chatEventPollStopped} for method parameters.
 *
 * A poll in a message was stopped
 */
export type chatEventPollStopped$Input = {
  readonly _: "chatEventPollStopped";

  /**
   * The message with the poll
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * A new member joined the chat
 */
export type chatEventMemberJoined = {
  _: "chatEventMemberJoined";
};

/**
 * Version of {@link chatEventMemberJoined} for method parameters.
 *
 * A new member joined the chat
 */
export type chatEventMemberJoined$Input = {
  readonly _: "chatEventMemberJoined";
};

/**
 * A new member joined the chat via an invite link
 */
export type chatEventMemberJoinedByInviteLink = {
  _: "chatEventMemberJoinedByInviteLink";

  /**
   * Invite link used to join the chat
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;

  /**
   * True, if the user has joined the chat using an invite link for a chat folder
   * @type {Bool} {@link Bool}
   */
  via_chat_folder_invite_link: Bool;
};

/**
 * Version of {@link chatEventMemberJoinedByInviteLink} for method parameters.
 *
 * A new member joined the chat via an invite link
 */
export type chatEventMemberJoinedByInviteLink$Input = {
  readonly _: "chatEventMemberJoinedByInviteLink";

  /**
   * Invite link used to join the chat
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;

  /**
   * True, if the user has joined the chat using an invite link for a chat folder
   * @type {Bool} {@link Bool}
   */
  readonly via_chat_folder_invite_link?: Bool$Input;
};

/**
 * A new member was accepted to the chat by an administrator
 */
export type chatEventMemberJoinedByRequest = {
  _: "chatEventMemberJoinedByRequest";

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  approver_user_id: int53;

  /**
   * Invite link used to join the chat; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink | null;
};

/**
 * Version of {@link chatEventMemberJoinedByRequest} for method parameters.
 *
 * A new member was accepted to the chat by an administrator
 */
export type chatEventMemberJoinedByRequest$Input = {
  readonly _: "chatEventMemberJoinedByRequest";

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  readonly approver_user_id?: int53;

  /**
   * Invite link used to join the chat; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input | null;
};

/**
 * A new chat member was invited
 */
export type chatEventMemberInvited = {
  _: "chatEventMemberInvited";

  /**
   * New member user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * New member status
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;
};

/**
 * Version of {@link chatEventMemberInvited} for method parameters.
 *
 * A new chat member was invited
 */
export type chatEventMemberInvited$Input = {
  readonly _: "chatEventMemberInvited";

  /**
   * New member user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New member status
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/**
 * A member left the chat
 */
export type chatEventMemberLeft = {
  _: "chatEventMemberLeft";
};

/**
 * Version of {@link chatEventMemberLeft} for method parameters.
 *
 * A member left the chat
 */
export type chatEventMemberLeft$Input = {
  readonly _: "chatEventMemberLeft";
};

/**
 * A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
 */
export type chatEventMemberPromoted = {
  _: "chatEventMemberPromoted";

  /**
   * Affected chat member user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  old_status: ChatMemberStatus;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  new_status: ChatMemberStatus;
};

/**
 * Version of {@link chatEventMemberPromoted} for method parameters.
 *
 * A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
 */
export type chatEventMemberPromoted$Input = {
  readonly _: "chatEventMemberPromoted";

  /**
   * Affected chat member user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly old_status?: ChatMemberStatus$Input;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly new_status?: ChatMemberStatus$Input;
};

/**
 * A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
 */
export type chatEventMemberRestricted = {
  _: "chatEventMemberRestricted";

  /**
   * Affected chat member identifier
   * @type {MessageSender} {@link MessageSender}
   */
  member_id: MessageSender;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  old_status: ChatMemberStatus;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  new_status: ChatMemberStatus;
};

/**
 * Version of {@link chatEventMemberRestricted} for method parameters.
 *
 * A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
 */
export type chatEventMemberRestricted$Input = {
  readonly _: "chatEventMemberRestricted";

  /**
   * Affected chat member identifier
   * @type {MessageSender} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly old_status?: ChatMemberStatus$Input;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly new_status?: ChatMemberStatus$Input;
};

/**
 * The chat available reactions were changed
 */
export type chatEventAvailableReactionsChanged = {
  _: "chatEventAvailableReactionsChanged";

  /**
   * Previous chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  old_available_reactions: ChatAvailableReactions;

  /**
   * New chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  new_available_reactions: ChatAvailableReactions;
};

/**
 * Version of {@link chatEventAvailableReactionsChanged} for method parameters.
 *
 * The chat available reactions were changed
 */
export type chatEventAvailableReactionsChanged$Input = {
  readonly _: "chatEventAvailableReactionsChanged";

  /**
   * Previous chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly old_available_reactions?: ChatAvailableReactions$Input;

  /**
   * New chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly new_available_reactions?: ChatAvailableReactions$Input;
};

/**
 * The chat background was changed
 */
export type chatEventBackgroundChanged = {
  _: "chatEventBackgroundChanged";

  /**
   * Previous background; may be null if none
   * @type {chatBackground} {@link chatBackground}
   */
  old_background: chatBackground | null;

  /**
   * New background; may be null if none
   * @type {chatBackground} {@link chatBackground}
   */
  new_background: chatBackground | null;
};

/**
 * Version of {@link chatEventBackgroundChanged} for method parameters.
 *
 * The chat background was changed
 */
export type chatEventBackgroundChanged$Input = {
  readonly _: "chatEventBackgroundChanged";

  /**
   * Previous background; may be null if none
   * @type {chatBackground} {@link chatBackground}
   */
  readonly old_background?: chatBackground$Input | null;

  /**
   * New background; may be null if none
   * @type {chatBackground} {@link chatBackground}
   */
  readonly new_background?: chatBackground$Input | null;
};

/**
 * The chat description was changed
 */
export type chatEventDescriptionChanged = {
  _: "chatEventDescriptionChanged";

  /**
   * Previous chat description
   * @type {string} {@link string}
   */
  old_description: string;

  /**
   * New chat description
   * @type {string} {@link string}
   */
  new_description: string;
};

/**
 * Version of {@link chatEventDescriptionChanged} for method parameters.
 *
 * The chat description was changed
 */
export type chatEventDescriptionChanged$Input = {
  readonly _: "chatEventDescriptionChanged";

  /**
   * Previous chat description
   * @type {string} {@link string}
   */
  readonly old_description?: string;

  /**
   * New chat description
   * @type {string} {@link string}
   */
  readonly new_description?: string;
};

/**
 * The chat emoji status was changed
 */
export type chatEventEmojiStatusChanged = {
  _: "chatEventEmojiStatusChanged";

  /**
   * Previous emoji status; may be null if none
   * @type {emojiStatus} {@link emojiStatus}
   */
  old_emoji_status: emojiStatus | null;

  /**
   * New emoji status; may be null if none
   * @type {emojiStatus} {@link emojiStatus}
   */
  new_emoji_status: emojiStatus | null;
};

/**
 * Version of {@link chatEventEmojiStatusChanged} for method parameters.
 *
 * The chat emoji status was changed
 */
export type chatEventEmojiStatusChanged$Input = {
  readonly _: "chatEventEmojiStatusChanged";

  /**
   * Previous emoji status; may be null if none
   * @type {emojiStatus} {@link emojiStatus}
   */
  readonly old_emoji_status?: emojiStatus$Input | null;

  /**
   * New emoji status; may be null if none
   * @type {emojiStatus} {@link emojiStatus}
   */
  readonly new_emoji_status?: emojiStatus$Input | null;
};

/**
 * The linked chat of a supergroup was changed
 */
export type chatEventLinkedChatChanged = {
  _: "chatEventLinkedChatChanged";

  /**
   * Previous supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  old_linked_chat_id: int53;

  /**
   * New supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  new_linked_chat_id: int53;
};

/**
 * Version of {@link chatEventLinkedChatChanged} for method parameters.
 *
 * The linked chat of a supergroup was changed
 */
export type chatEventLinkedChatChanged$Input = {
  readonly _: "chatEventLinkedChatChanged";

  /**
   * Previous supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  readonly old_linked_chat_id?: int53;

  /**
   * New supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  readonly new_linked_chat_id?: int53;
};

/**
 * The supergroup location was changed
 */
export type chatEventLocationChanged = {
  _: "chatEventLocationChanged";

  /**
   * Previous location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  old_location: chatLocation | null;

  /**
   * New location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  new_location: chatLocation | null;
};

/**
 * Version of {@link chatEventLocationChanged} for method parameters.
 *
 * The supergroup location was changed
 */
export type chatEventLocationChanged$Input = {
  readonly _: "chatEventLocationChanged";

  /**
   * Previous location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  readonly old_location?: chatLocation$Input | null;

  /**
   * New location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  readonly new_location?: chatLocation$Input | null;
};

/**
 * The message auto-delete timer was changed
 */
export type chatEventMessageAutoDeleteTimeChanged = {
  _: "chatEventMessageAutoDeleteTimeChanged";

  /**
   * Previous value of message_auto_delete_time
   * @type {int32} {@link int32}
   */
  old_message_auto_delete_time: int32;

  /**
   * New value of message_auto_delete_time
   * @type {int32} {@link int32}
   */
  new_message_auto_delete_time: int32;
};

/**
 * Version of {@link chatEventMessageAutoDeleteTimeChanged} for method parameters.
 *
 * The message auto-delete timer was changed
 */
export type chatEventMessageAutoDeleteTimeChanged$Input = {
  readonly _: "chatEventMessageAutoDeleteTimeChanged";

  /**
   * Previous value of message_auto_delete_time
   * @type {int32} {@link int32}
   */
  readonly old_message_auto_delete_time?: int32;

  /**
   * New value of message_auto_delete_time
   * @type {int32} {@link int32}
   */
  readonly new_message_auto_delete_time?: int32;
};

/**
 * The chat permissions were changed
 */
export type chatEventPermissionsChanged = {
  _: "chatEventPermissionsChanged";

  /**
   * Previous chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  old_permissions: chatPermissions;

  /**
   * New chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  new_permissions: chatPermissions;
};

/**
 * Version of {@link chatEventPermissionsChanged} for method parameters.
 *
 * The chat permissions were changed
 */
export type chatEventPermissionsChanged$Input = {
  readonly _: "chatEventPermissionsChanged";

  /**
   * Previous chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly old_permissions?: chatPermissions$Input;

  /**
   * New chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly new_permissions?: chatPermissions$Input;
};

/**
 * The chat photo was changed
 */
export type chatEventPhotoChanged = {
  _: "chatEventPhotoChanged";

  /**
   * Previous chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  old_photo: chatPhoto | null;

  /**
   * New chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  new_photo: chatPhoto | null;
};

/**
 * Version of {@link chatEventPhotoChanged} for method parameters.
 *
 * The chat photo was changed
 */
export type chatEventPhotoChanged$Input = {
  readonly _: "chatEventPhotoChanged";

  /**
   * Previous chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly old_photo?: chatPhoto$Input | null;

  /**
   * New chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly new_photo?: chatPhoto$Input | null;
};

/**
 * The slow_mode_delay setting of a supergroup was changed
 */
export type chatEventSlowModeDelayChanged = {
  _: "chatEventSlowModeDelayChanged";

  /**
   * Previous value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  old_slow_mode_delay: int32;

  /**
   * New value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  new_slow_mode_delay: int32;
};

/**
 * Version of {@link chatEventSlowModeDelayChanged} for method parameters.
 *
 * The slow_mode_delay setting of a supergroup was changed
 */
export type chatEventSlowModeDelayChanged$Input = {
  readonly _: "chatEventSlowModeDelayChanged";

  /**
   * Previous value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  readonly old_slow_mode_delay?: int32;

  /**
   * New value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  readonly new_slow_mode_delay?: int32;
};

/**
 * The supergroup sticker set was changed
 */
export type chatEventStickerSetChanged = {
  _: "chatEventStickerSetChanged";

  /**
   * Previous identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  old_sticker_set_id: int64;

  /**
   * New identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  new_sticker_set_id: int64;
};

/**
 * Version of {@link chatEventStickerSetChanged} for method parameters.
 *
 * The supergroup sticker set was changed
 */
export type chatEventStickerSetChanged$Input = {
  readonly _: "chatEventStickerSetChanged";

  /**
   * Previous identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly old_sticker_set_id?: int64$Input;

  /**
   * New identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly new_sticker_set_id?: int64$Input;
};

/**
 * The chat title was changed
 */
export type chatEventTitleChanged = {
  _: "chatEventTitleChanged";

  /**
   * Previous chat title
   * @type {string} {@link string}
   */
  old_title: string;

  /**
   * New chat title
   * @type {string} {@link string}
   */
  new_title: string;
};

/**
 * Version of {@link chatEventTitleChanged} for method parameters.
 *
 * The chat title was changed
 */
export type chatEventTitleChanged$Input = {
  readonly _: "chatEventTitleChanged";

  /**
   * Previous chat title
   * @type {string} {@link string}
   */
  readonly old_title?: string;

  /**
   * New chat title
   * @type {string} {@link string}
   */
  readonly new_title?: string;
};

/**
 * The chat editable username was changed
 */
export type chatEventUsernameChanged = {
  _: "chatEventUsernameChanged";

  /**
   * Previous chat username
   * @type {string} {@link string}
   */
  old_username: string;

  /**
   * New chat username
   * @type {string} {@link string}
   */
  new_username: string;
};

/**
 * Version of {@link chatEventUsernameChanged} for method parameters.
 *
 * The chat editable username was changed
 */
export type chatEventUsernameChanged$Input = {
  readonly _: "chatEventUsernameChanged";

  /**
   * Previous chat username
   * @type {string} {@link string}
   */
  readonly old_username?: string;

  /**
   * New chat username
   * @type {string} {@link string}
   */
  readonly new_username?: string;
};

/**
 * The chat active usernames were changed
 */
export type chatEventActiveUsernamesChanged = {
  _: "chatEventActiveUsernamesChanged";

  /**
   * Previous list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  old_usernames: vector<string>;

  /**
   * New list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  new_usernames: vector<string>;
};

/**
 * Version of {@link chatEventActiveUsernamesChanged} for method parameters.
 *
 * The chat active usernames were changed
 */
export type chatEventActiveUsernamesChanged$Input = {
  readonly _: "chatEventActiveUsernamesChanged";

  /**
   * Previous list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  readonly old_usernames?: vector$Input<string>;

  /**
   * New list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  readonly new_usernames?: vector$Input<string>;
};

/**
 * The chat accent color or background custom emoji were changed
 */
export type chatEventAccentColorChanged = {
  _: "chatEventAccentColorChanged";

  /**
   * Previous identifier of chat accent color
   * @type {int32} {@link int32}
   */
  old_accent_color_id: int32;

  /**
   * Previous identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  old_background_custom_emoji_id: int64;

  /**
   * New identifier of chat accent color
   * @type {int32} {@link int32}
   */
  new_accent_color_id: int32;

  /**
   * New identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  new_background_custom_emoji_id: int64;
};

/**
 * Version of {@link chatEventAccentColorChanged} for method parameters.
 *
 * The chat accent color or background custom emoji were changed
 */
export type chatEventAccentColorChanged$Input = {
  readonly _: "chatEventAccentColorChanged";

  /**
   * Previous identifier of chat accent color
   * @type {int32} {@link int32}
   */
  readonly old_accent_color_id?: int32;

  /**
   * Previous identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  readonly old_background_custom_emoji_id?: int64$Input;

  /**
   * New identifier of chat accent color
   * @type {int32} {@link int32}
   */
  readonly new_accent_color_id?: int32;

  /**
   * New identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  readonly new_background_custom_emoji_id?: int64$Input;
};

/**
 * The chat's profile accent color or profile background custom emoji were changed
 */
export type chatEventProfileAccentColorChanged = {
  _: "chatEventProfileAccentColorChanged";

  /**
   * Previous identifier of chat's profile accent color; -1 if none
   * @type {int32} {@link int32}
   */
  old_profile_accent_color_id: int32;

  /**
   * Previous identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  old_profile_background_custom_emoji_id: int64;

  /**
   * New identifier of chat's profile accent color; -1 if none
   * @type {int32} {@link int32}
   */
  new_profile_accent_color_id: int32;

  /**
   * New identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  new_profile_background_custom_emoji_id: int64;
};

/**
 * Version of {@link chatEventProfileAccentColorChanged} for method parameters.
 *
 * The chat's profile accent color or profile background custom emoji were changed
 */
export type chatEventProfileAccentColorChanged$Input = {
  readonly _: "chatEventProfileAccentColorChanged";

  /**
   * Previous identifier of chat's profile accent color; -1 if none
   * @type {int32} {@link int32}
   */
  readonly old_profile_accent_color_id?: int32;

  /**
   * Previous identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  readonly old_profile_background_custom_emoji_id?: int64$Input;

  /**
   * New identifier of chat's profile accent color; -1 if none
   * @type {int32} {@link int32}
   */
  readonly new_profile_accent_color_id?: int32;

  /**
   * New identifier of the custom emoji; 0 if none
   * @type {int64} {@link int64}
   */
  readonly new_profile_background_custom_emoji_id?: int64$Input;
};

/**
 * The has_protected_content setting of a channel was toggled
 */
export type chatEventHasProtectedContentToggled = {
  _: "chatEventHasProtectedContentToggled";

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  has_protected_content: Bool;
};

/**
 * Version of {@link chatEventHasProtectedContentToggled} for method parameters.
 *
 * The has_protected_content setting of a channel was toggled
 */
export type chatEventHasProtectedContentToggled$Input = {
  readonly _: "chatEventHasProtectedContentToggled";

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/**
 * The can_invite_users permission of a supergroup chat was toggled
 */
export type chatEventInvitesToggled = {
  _: "chatEventInvitesToggled";

  /**
   * New value of can_invite_users permission
   * @type {Bool} {@link Bool}
   */
  can_invite_users: Bool;
};

/**
 * Version of {@link chatEventInvitesToggled} for method parameters.
 *
 * The can_invite_users permission of a supergroup chat was toggled
 */
export type chatEventInvitesToggled$Input = {
  readonly _: "chatEventInvitesToggled";

  /**
   * New value of can_invite_users permission
   * @type {Bool} {@link Bool}
   */
  readonly can_invite_users?: Bool$Input;
};

/**
 * The is_all_history_available setting of a supergroup was toggled
 */
export type chatEventIsAllHistoryAvailableToggled = {
  _: "chatEventIsAllHistoryAvailableToggled";

  /**
   * New value of is_all_history_available
   * @type {Bool} {@link Bool}
   */
  is_all_history_available: Bool;
};

/**
 * Version of {@link chatEventIsAllHistoryAvailableToggled} for method parameters.
 *
 * The is_all_history_available setting of a supergroup was toggled
 */
export type chatEventIsAllHistoryAvailableToggled$Input = {
  readonly _: "chatEventIsAllHistoryAvailableToggled";

  /**
   * New value of is_all_history_available
   * @type {Bool} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;
};

/**
 * The has_aggressive_anti_spam_enabled setting of a supergroup was toggled
 */
export type chatEventHasAggressiveAntiSpamEnabledToggled = {
  _: "chatEventHasAggressiveAntiSpamEnabledToggled";

  /**
   * New value of has_aggressive_anti_spam_enabled
   * @type {Bool} {@link Bool}
   */
  has_aggressive_anti_spam_enabled: Bool;
};

/**
 * Version of {@link chatEventHasAggressiveAntiSpamEnabledToggled} for method parameters.
 *
 * The has_aggressive_anti_spam_enabled setting of a supergroup was toggled
 */
export type chatEventHasAggressiveAntiSpamEnabledToggled$Input = {
  readonly _: "chatEventHasAggressiveAntiSpamEnabledToggled";

  /**
   * New value of has_aggressive_anti_spam_enabled
   * @type {Bool} {@link Bool}
   */
  readonly has_aggressive_anti_spam_enabled?: Bool$Input;
};

/**
 * The sign_messages setting of a channel was toggled
 */
export type chatEventSignMessagesToggled = {
  _: "chatEventSignMessagesToggled";

  /**
   * New value of sign_messages
   * @type {Bool} {@link Bool}
   */
  sign_messages: Bool;
};

/**
 * Version of {@link chatEventSignMessagesToggled} for method parameters.
 *
 * The sign_messages setting of a channel was toggled
 */
export type chatEventSignMessagesToggled$Input = {
  readonly _: "chatEventSignMessagesToggled";

  /**
   * New value of sign_messages
   * @type {Bool} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;
};

/**
 * A chat invite link was edited
 */
export type chatEventInviteLinkEdited = {
  _: "chatEventInviteLinkEdited";

  /**
   * Previous information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  old_invite_link: chatInviteLink;

  /**
   * New information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  new_invite_link: chatInviteLink;
};

/**
 * Version of {@link chatEventInviteLinkEdited} for method parameters.
 *
 * A chat invite link was edited
 */
export type chatEventInviteLinkEdited$Input = {
  readonly _: "chatEventInviteLinkEdited";

  /**
   * Previous information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly old_invite_link?: chatInviteLink$Input;

  /**
   * New information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly new_invite_link?: chatInviteLink$Input;
};

/**
 * A chat invite link was revoked
 */
export type chatEventInviteLinkRevoked = {
  _: "chatEventInviteLinkRevoked";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

/**
 * Version of {@link chatEventInviteLinkRevoked} for method parameters.
 *
 * A chat invite link was revoked
 */
export type chatEventInviteLinkRevoked$Input = {
  readonly _: "chatEventInviteLinkRevoked";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/**
 * A revoked chat invite link was deleted
 */
export type chatEventInviteLinkDeleted = {
  _: "chatEventInviteLinkDeleted";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

/**
 * Version of {@link chatEventInviteLinkDeleted} for method parameters.
 *
 * A revoked chat invite link was deleted
 */
export type chatEventInviteLinkDeleted$Input = {
  readonly _: "chatEventInviteLinkDeleted";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/**
 * A video chat was created
 */
export type chatEventVideoChatCreated = {
  _: "chatEventVideoChatCreated";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;
};

/**
 * Version of {@link chatEventVideoChatCreated} for method parameters.
 *
 * A video chat was created
 */
export type chatEventVideoChatCreated$Input = {
  readonly _: "chatEventVideoChatCreated";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * A video chat was ended
 */
export type chatEventVideoChatEnded = {
  _: "chatEventVideoChatEnded";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;
};

/**
 * Version of {@link chatEventVideoChatEnded} for method parameters.
 *
 * A video chat was ended
 */
export type chatEventVideoChatEnded$Input = {
  readonly _: "chatEventVideoChatEnded";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * The mute_new_participants setting of a video chat was toggled
 */
export type chatEventVideoChatMuteNewParticipantsToggled = {
  _: "chatEventVideoChatMuteNewParticipantsToggled";

  /**
   * New value of the mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  mute_new_participants: Bool;
};

/**
 * Version of {@link chatEventVideoChatMuteNewParticipantsToggled} for method parameters.
 *
 * The mute_new_participants setting of a video chat was toggled
 */
export type chatEventVideoChatMuteNewParticipantsToggled$Input = {
  readonly _: "chatEventVideoChatMuteNewParticipantsToggled";

  /**
   * New value of the mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;
};

/**
 * A video chat participant was muted or unmuted
 */
export type chatEventVideoChatParticipantIsMutedToggled = {
  _: "chatEventVideoChatParticipantIsMutedToggled";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * New value of is_muted
   * @type {Bool} {@link Bool}
   */
  is_muted: Bool;
};

/**
 * Version of {@link chatEventVideoChatParticipantIsMutedToggled} for method parameters.
 *
 * A video chat participant was muted or unmuted
 */
export type chatEventVideoChatParticipantIsMutedToggled$Input = {
  readonly _: "chatEventVideoChatParticipantIsMutedToggled";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New value of is_muted
   * @type {Bool} {@link Bool}
   */
  readonly is_muted?: Bool$Input;
};

/**
 * A video chat participant volume level was changed
 */
export type chatEventVideoChatParticipantVolumeLevelChanged = {
  _: "chatEventVideoChatParticipantVolumeLevelChanged";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * New value of volume_level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  volume_level: int32;
};

/**
 * Version of {@link chatEventVideoChatParticipantVolumeLevelChanged} for method parameters.
 *
 * A video chat participant volume level was changed
 */
export type chatEventVideoChatParticipantVolumeLevelChanged$Input = {
  readonly _: "chatEventVideoChatParticipantVolumeLevelChanged";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New value of volume_level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;
};

/**
 * The is_forum setting of a channel was toggled
 */
export type chatEventIsForumToggled = {
  _: "chatEventIsForumToggled";

  /**
   * New value of is_forum
   * @type {Bool} {@link Bool}
   */
  is_forum: Bool;
};

/**
 * Version of {@link chatEventIsForumToggled} for method parameters.
 *
 * The is_forum setting of a channel was toggled
 */
export type chatEventIsForumToggled$Input = {
  readonly _: "chatEventIsForumToggled";

  /**
   * New value of is_forum
   * @type {Bool} {@link Bool}
   */
  readonly is_forum?: Bool$Input;
};

/**
 * A new forum topic was created
 */
export type chatEventForumTopicCreated = {
  _: "chatEventForumTopicCreated";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

/**
 * Version of {@link chatEventForumTopicCreated} for method parameters.
 *
 * A new forum topic was created
 */
export type chatEventForumTopicCreated$Input = {
  readonly _: "chatEventForumTopicCreated";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/**
 * A forum topic was edited
 */
export type chatEventForumTopicEdited = {
  _: "chatEventForumTopicEdited";

  /**
   * Old information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  old_topic_info: forumTopicInfo;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  new_topic_info: forumTopicInfo;
};

/**
 * Version of {@link chatEventForumTopicEdited} for method parameters.
 *
 * A forum topic was edited
 */
export type chatEventForumTopicEdited$Input = {
  readonly _: "chatEventForumTopicEdited";

  /**
   * Old information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly old_topic_info?: forumTopicInfo$Input;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly new_topic_info?: forumTopicInfo$Input;
};

/**
 * A forum topic was closed or reopened
 */
export type chatEventForumTopicToggleIsClosed = {
  _: "chatEventForumTopicToggleIsClosed";

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

/**
 * Version of {@link chatEventForumTopicToggleIsClosed} for method parameters.
 *
 * A forum topic was closed or reopened
 */
export type chatEventForumTopicToggleIsClosed$Input = {
  readonly _: "chatEventForumTopicToggleIsClosed";

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/**
 * The General forum topic was hidden or unhidden
 */
export type chatEventForumTopicToggleIsHidden = {
  _: "chatEventForumTopicToggleIsHidden";

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

/**
 * Version of {@link chatEventForumTopicToggleIsHidden} for method parameters.
 *
 * The General forum topic was hidden or unhidden
 */
export type chatEventForumTopicToggleIsHidden$Input = {
  readonly _: "chatEventForumTopicToggleIsHidden";

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/**
 * A forum topic was deleted
 */
export type chatEventForumTopicDeleted = {
  _: "chatEventForumTopicDeleted";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

/**
 * Version of {@link chatEventForumTopicDeleted} for method parameters.
 *
 * A forum topic was deleted
 */
export type chatEventForumTopicDeleted$Input = {
  readonly _: "chatEventForumTopicDeleted";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/**
 * A pinned forum topic was changed
 */
export type chatEventForumTopicPinned = {
  _: "chatEventForumTopicPinned";

  /**
   * Information about the old pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  old_topic_info: forumTopicInfo | null;

  /**
   * Information about the new pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  new_topic_info: forumTopicInfo | null;
};

/**
 * Version of {@link chatEventForumTopicPinned} for method parameters.
 *
 * A pinned forum topic was changed
 */
export type chatEventForumTopicPinned$Input = {
  readonly _: "chatEventForumTopicPinned";

  /**
   * Information about the old pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly old_topic_info?: forumTopicInfo$Input | null;

  /**
   * Information about the new pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly new_topic_info?: forumTopicInfo$Input | null;
};

/**
 * Represents a chat event
 */
export type chatEvent = {
  _: "chatEvent";

  /**
   * Chat event identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Point in time (Unix timestamp) when the event happened
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Identifier of the user or chat who performed the action
   * @type {MessageSender} {@link MessageSender}
   */
  member_id: MessageSender;

  /**
   * The action
   * @type {ChatEventAction} {@link ChatEventAction}
   */
  action: ChatEventAction;
};

/**
 * Version of {@link chatEvent} for method parameters.
 *
 * Represents a chat event
 */
export type chatEvent$Input = {
  readonly _: "chatEvent";

  /**
   * Chat event identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Point in time (Unix timestamp) when the event happened
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Identifier of the user or chat who performed the action
   * @type {MessageSender} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * The action
   * @type {ChatEventAction} {@link ChatEventAction}
   */
  readonly action?: ChatEventAction$Input;
};

/**
 * Contains a list of chat events
 */
export type chatEvents = {
  _: "chatEvents";

  /**
   * List of events
   * @type {vector<chatEvent>} {@link vector<chatEvent>}
   */
  events: vector<chatEvent>;
};

/**
 * Version of {@link chatEvents} for method parameters.
 *
 * Contains a list of chat events
 */
export type chatEvents$Input = {
  readonly _: "chatEvents";

  /**
   * List of events
   * @type {vector<chatEvent>} {@link vector<chatEvent>}
   */
  readonly events?: vector$Input<chatEvent$Input>;
};

/**
 * Represents a set of filters used to obtain a chat event log
 */
export type chatEventLogFilters = {
  _: "chatEventLogFilters";

  /**
   * True, if message edits need to be returned
   * @type {Bool} {@link Bool}
   */
  message_edits: Bool;

  /**
   * True, if message deletions need to be returned
   * @type {Bool} {@link Bool}
   */
  message_deletions: Bool;

  /**
   * True, if pin/unpin events need to be returned
   * @type {Bool} {@link Bool}
   */
  message_pins: Bool;

  /**
   * True, if members joining events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_joins: Bool;

  /**
   * True, if members leaving events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_leaves: Bool;

  /**
   * True, if invited member events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_invites: Bool;

  /**
   * True, if member promotion/demotion events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_promotions: Bool;

  /**
   * True, if member restricted/unrestricted/banned/unbanned events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_restrictions: Bool;

  /**
   * True, if changes in chat information need to be returned
   * @type {Bool} {@link Bool}
   */
  info_changes: Bool;

  /**
   * True, if changes in chat settings need to be returned
   * @type {Bool} {@link Bool}
   */
  setting_changes: Bool;

  /**
   * True, if changes to invite links need to be returned
   * @type {Bool} {@link Bool}
   */
  invite_link_changes: Bool;

  /**
   * True, if video chat actions need to be returned
   * @type {Bool} {@link Bool}
   */
  video_chat_changes: Bool;

  /**
   * True, if forum-related actions need to be returned
   * @type {Bool} {@link Bool}
   */
  forum_changes: Bool;
};

/**
 * Version of {@link chatEventLogFilters} for method parameters.
 *
 * Represents a set of filters used to obtain a chat event log
 */
export type chatEventLogFilters$Input = {
  readonly _: "chatEventLogFilters";

  /**
   * True, if message edits need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly message_edits?: Bool$Input;

  /**
   * True, if message deletions need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly message_deletions?: Bool$Input;

  /**
   * True, if pin/unpin events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly message_pins?: Bool$Input;

  /**
   * True, if members joining events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_joins?: Bool$Input;

  /**
   * True, if members leaving events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_leaves?: Bool$Input;

  /**
   * True, if invited member events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_invites?: Bool$Input;

  /**
   * True, if member promotion/demotion events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_promotions?: Bool$Input;

  /**
   * True, if member restricted/unrestricted/banned/unbanned events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_restrictions?: Bool$Input;

  /**
   * True, if changes in chat information need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly info_changes?: Bool$Input;

  /**
   * True, if changes in chat settings need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly setting_changes?: Bool$Input;

  /**
   * True, if changes to invite links need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly invite_link_changes?: Bool$Input;

  /**
   * True, if video chat actions need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly video_chat_changes?: Bool$Input;

  /**
   * True, if forum-related actions need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly forum_changes?: Bool$Input;
};

/**
 * An ordinary language pack string
 */
export type languagePackStringValueOrdinary = {
  _: "languagePackStringValueOrdinary";

  /**
   * String value
   * @type {string} {@link string}
   */
  value: string;
};

/**
 * Version of {@link languagePackStringValueOrdinary} for method parameters.
 *
 * An ordinary language pack string
 */
export type languagePackStringValueOrdinary$Input = {
  readonly _: "languagePackStringValueOrdinary";

  /**
   * String value
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/**
 * A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
 */
export type languagePackStringValuePluralized = {
  _: "languagePackStringValuePluralized";

  /**
   * Value for zero objects
   * @type {string} {@link string}
   */
  zero_value: string;

  /**
   * Value for one object
   * @type {string} {@link string}
   */
  one_value: string;

  /**
   * Value for two objects
   * @type {string} {@link string}
   */
  two_value: string;

  /**
   * Value for few objects
   * @type {string} {@link string}
   */
  few_value: string;

  /**
   * Value for many objects
   * @type {string} {@link string}
   */
  many_value: string;

  /**
   * Default value
   * @type {string} {@link string}
   */
  other_value: string;
};

/**
 * Version of {@link languagePackStringValuePluralized} for method parameters.
 *
 * A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
 */
export type languagePackStringValuePluralized$Input = {
  readonly _: "languagePackStringValuePluralized";

  /**
   * Value for zero objects
   * @type {string} {@link string}
   */
  readonly zero_value?: string;

  /**
   * Value for one object
   * @type {string} {@link string}
   */
  readonly one_value?: string;

  /**
   * Value for two objects
   * @type {string} {@link string}
   */
  readonly two_value?: string;

  /**
   * Value for few objects
   * @type {string} {@link string}
   */
  readonly few_value?: string;

  /**
   * Value for many objects
   * @type {string} {@link string}
   */
  readonly many_value?: string;

  /**
   * Default value
   * @type {string} {@link string}
   */
  readonly other_value?: string;
};

/**
 * A deleted language pack string, the value must be taken from the built-in English language pack
 */
export type languagePackStringValueDeleted = {
  _: "languagePackStringValueDeleted";
};

/**
 * Version of {@link languagePackStringValueDeleted} for method parameters.
 *
 * A deleted language pack string, the value must be taken from the built-in English language pack
 */
export type languagePackStringValueDeleted$Input = {
  readonly _: "languagePackStringValueDeleted";
};

/**
 * Represents one language pack string
 */
export type languagePackString = {
  _: "languagePackString";

  /**
   * String key
   * @type {string} {@link string}
   */
  key: string;

  /**
   * String value; pass null if the string needs to be taken from the built-in English language pack
   * @type {LanguagePackStringValue} {@link LanguagePackStringValue}
   */
  value: LanguagePackStringValue | null;
};

/**
 * Version of {@link languagePackString} for method parameters.
 *
 * Represents one language pack string
 */
export type languagePackString$Input = {
  readonly _: "languagePackString";

  /**
   * String key
   * @type {string} {@link string}
   */
  readonly key?: string;

  /**
   * String value; pass null if the string needs to be taken from the built-in English language pack
   * @type {LanguagePackStringValue} {@link LanguagePackStringValue}
   */
  readonly value?: LanguagePackStringValue$Input | null;
};

/**
 * Contains a list of language pack strings
 */
export type languagePackStrings = {
  _: "languagePackStrings";

  /**
   * A list of language pack strings
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  strings: vector<languagePackString>;
};

/**
 * Version of {@link languagePackStrings} for method parameters.
 *
 * Contains a list of language pack strings
 */
export type languagePackStrings$Input = {
  readonly _: "languagePackStrings";

  /**
   * A list of language pack strings
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/**
 * Contains information about a language pack
 */
export type languagePackInfo = {
  _: "languagePackInfo";

  /**
   * Unique language pack identifier
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
   * @type {string} {@link string}
   */
  base_language_pack_id: string;

  /**
   * Language name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Name of the language in that language
   * @type {string} {@link string}
   */
  native_name: string;

  /**
   * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
   * @type {string} {@link string}
   */
  plural_code: string;

  /**
   * True, if the language pack is official
   * @type {Bool} {@link Bool}
   */
  is_official: Bool;

  /**
   * True, if the language pack strings are RTL
   * @type {Bool} {@link Bool}
   */
  is_rtl: Bool;

  /**
   * True, if the language pack is a beta language pack
   * @type {Bool} {@link Bool}
   */
  is_beta: Bool;

  /**
   * True, if the language pack is installed by the current user
   * @type {Bool} {@link Bool}
   */
  is_installed: Bool;

  /**
   * Total number of non-deleted strings from the language pack
   * @type {int32} {@link int32}
   */
  total_string_count: int32;

  /**
   * Total number of translated strings from the language pack
   * @type {int32} {@link int32}
   */
  translated_string_count: int32;

  /**
   * Total number of non-deleted strings from the language pack available locally
   * @type {int32} {@link int32}
   */
  local_string_count: int32;

  /**
   * Link to language translation interface; empty for custom local language packs
   * @type {string} {@link string}
   */
  translation_url: string;
};

/**
 * Version of {@link languagePackInfo} for method parameters.
 *
 * Contains information about a language pack
 */
export type languagePackInfo$Input = {
  readonly _: "languagePackInfo";

  /**
   * Unique language pack identifier
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
   * @type {string} {@link string}
   */
  readonly base_language_pack_id?: string;

  /**
   * Language name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Name of the language in that language
   * @type {string} {@link string}
   */
  readonly native_name?: string;

  /**
   * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
   * @type {string} {@link string}
   */
  readonly plural_code?: string;

  /**
   * True, if the language pack is official
   * @type {Bool} {@link Bool}
   */
  readonly is_official?: Bool$Input;

  /**
   * True, if the language pack strings are RTL
   * @type {Bool} {@link Bool}
   */
  readonly is_rtl?: Bool$Input;

  /**
   * True, if the language pack is a beta language pack
   * @type {Bool} {@link Bool}
   */
  readonly is_beta?: Bool$Input;

  /**
   * True, if the language pack is installed by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * Total number of non-deleted strings from the language pack
   * @type {int32} {@link int32}
   */
  readonly total_string_count?: int32;

  /**
   * Total number of translated strings from the language pack
   * @type {int32} {@link int32}
   */
  readonly translated_string_count?: int32;

  /**
   * Total number of non-deleted strings from the language pack available locally
   * @type {int32} {@link int32}
   */
  readonly local_string_count?: int32;

  /**
   * Link to language translation interface; empty for custom local language packs
   * @type {string} {@link string}
   */
  readonly translation_url?: string;
};

/**
 * Contains information about the current localization target
 */
export type localizationTargetInfo = {
  _: "localizationTargetInfo";

  /**
   * List of available language packs for this application
   * @type {vector<languagePackInfo>} {@link vector<languagePackInfo>}
   */
  language_packs: vector<languagePackInfo>;
};

/**
 * Version of {@link localizationTargetInfo} for method parameters.
 *
 * Contains information about the current localization target
 */
export type localizationTargetInfo$Input = {
  readonly _: "localizationTargetInfo";

  /**
   * List of available language packs for this application
   * @type {vector<languagePackInfo>} {@link vector<languagePackInfo>}
   */
  readonly language_packs?: vector$Input<languagePackInfo$Input>;
};

/**
 * The maximum number of joined supergroups and channels
 */
export type premiumLimitTypeSupergroupCount = {
  _: "premiumLimitTypeSupergroupCount";
};

/**
 * Version of {@link premiumLimitTypeSupergroupCount} for method parameters.
 *
 * The maximum number of joined supergroups and channels
 */
export type premiumLimitTypeSupergroupCount$Input = {
  readonly _: "premiumLimitTypeSupergroupCount";
};

/**
 * The maximum number of pinned chats in the main chat list
 */
export type premiumLimitTypePinnedChatCount = {
  _: "premiumLimitTypePinnedChatCount";
};

/**
 * Version of {@link premiumLimitTypePinnedChatCount} for method parameters.
 *
 * The maximum number of pinned chats in the main chat list
 */
export type premiumLimitTypePinnedChatCount$Input = {
  readonly _: "premiumLimitTypePinnedChatCount";
};

/**
 * The maximum number of created public chats
 */
export type premiumLimitTypeCreatedPublicChatCount = {
  _: "premiumLimitTypeCreatedPublicChatCount";
};

/**
 * Version of {@link premiumLimitTypeCreatedPublicChatCount} for method parameters.
 *
 * The maximum number of created public chats
 */
export type premiumLimitTypeCreatedPublicChatCount$Input = {
  readonly _: "premiumLimitTypeCreatedPublicChatCount";
};

/**
 * The maximum number of saved animations
 */
export type premiumLimitTypeSavedAnimationCount = {
  _: "premiumLimitTypeSavedAnimationCount";
};

/**
 * Version of {@link premiumLimitTypeSavedAnimationCount} for method parameters.
 *
 * The maximum number of saved animations
 */
export type premiumLimitTypeSavedAnimationCount$Input = {
  readonly _: "premiumLimitTypeSavedAnimationCount";
};

/**
 * The maximum number of favorite stickers
 */
export type premiumLimitTypeFavoriteStickerCount = {
  _: "premiumLimitTypeFavoriteStickerCount";
};

/**
 * Version of {@link premiumLimitTypeFavoriteStickerCount} for method parameters.
 *
 * The maximum number of favorite stickers
 */
export type premiumLimitTypeFavoriteStickerCount$Input = {
  readonly _: "premiumLimitTypeFavoriteStickerCount";
};

/**
 * The maximum number of chat folders
 */
export type premiumLimitTypeChatFolderCount = {
  _: "premiumLimitTypeChatFolderCount";
};

/**
 * Version of {@link premiumLimitTypeChatFolderCount} for method parameters.
 *
 * The maximum number of chat folders
 */
export type premiumLimitTypeChatFolderCount$Input = {
  readonly _: "premiumLimitTypeChatFolderCount";
};

/**
 * The maximum number of pinned and always included, or always excluded chats in a chat folder
 */
export type premiumLimitTypeChatFolderChosenChatCount = {
  _: "premiumLimitTypeChatFolderChosenChatCount";
};

/**
 * Version of {@link premiumLimitTypeChatFolderChosenChatCount} for method parameters.
 *
 * The maximum number of pinned and always included, or always excluded chats in a chat folder
 */
export type premiumLimitTypeChatFolderChosenChatCount$Input = {
  readonly _: "premiumLimitTypeChatFolderChosenChatCount";
};

/**
 * The maximum number of pinned chats in the archive chat list
 */
export type premiumLimitTypePinnedArchivedChatCount = {
  _: "premiumLimitTypePinnedArchivedChatCount";
};

/**
 * Version of {@link premiumLimitTypePinnedArchivedChatCount} for method parameters.
 *
 * The maximum number of pinned chats in the archive chat list
 */
export type premiumLimitTypePinnedArchivedChatCount$Input = {
  readonly _: "premiumLimitTypePinnedArchivedChatCount";
};

/**
 * The maximum length of sent media caption
 */
export type premiumLimitTypeCaptionLength = {
  _: "premiumLimitTypeCaptionLength";
};

/**
 * Version of {@link premiumLimitTypeCaptionLength} for method parameters.
 *
 * The maximum length of sent media caption
 */
export type premiumLimitTypeCaptionLength$Input = {
  readonly _: "premiumLimitTypeCaptionLength";
};

/**
 * The maximum length of the user's bio
 */
export type premiumLimitTypeBioLength = {
  _: "premiumLimitTypeBioLength";
};

/**
 * Version of {@link premiumLimitTypeBioLength} for method parameters.
 *
 * The maximum length of the user's bio
 */
export type premiumLimitTypeBioLength$Input = {
  readonly _: "premiumLimitTypeBioLength";
};

/**
 * The maximum number of invite links for a chat folder
 */
export type premiumLimitTypeChatFolderInviteLinkCount = {
  _: "premiumLimitTypeChatFolderInviteLinkCount";
};

/**
 * Version of {@link premiumLimitTypeChatFolderInviteLinkCount} for method parameters.
 *
 * The maximum number of invite links for a chat folder
 */
export type premiumLimitTypeChatFolderInviteLinkCount$Input = {
  readonly _: "premiumLimitTypeChatFolderInviteLinkCount";
};

/**
 * The maximum number of added shareable chat folders
 */
export type premiumLimitTypeShareableChatFolderCount = {
  _: "premiumLimitTypeShareableChatFolderCount";
};

/**
 * Version of {@link premiumLimitTypeShareableChatFolderCount} for method parameters.
 *
 * The maximum number of added shareable chat folders
 */
export type premiumLimitTypeShareableChatFolderCount$Input = {
  readonly _: "premiumLimitTypeShareableChatFolderCount";
};

/**
 * The maximum number of active stories
 */
export type premiumLimitTypeActiveStoryCount = {
  _: "premiumLimitTypeActiveStoryCount";
};

/**
 * Version of {@link premiumLimitTypeActiveStoryCount} for method parameters.
 *
 * The maximum number of active stories
 */
export type premiumLimitTypeActiveStoryCount$Input = {
  readonly _: "premiumLimitTypeActiveStoryCount";
};

/**
 * The maximum number of stories sent per week
 */
export type premiumLimitTypeWeeklySentStoryCount = {
  _: "premiumLimitTypeWeeklySentStoryCount";
};

/**
 * Version of {@link premiumLimitTypeWeeklySentStoryCount} for method parameters.
 *
 * The maximum number of stories sent per week
 */
export type premiumLimitTypeWeeklySentStoryCount$Input = {
  readonly _: "premiumLimitTypeWeeklySentStoryCount";
};

/**
 * The maximum number of stories sent per month
 */
export type premiumLimitTypeMonthlySentStoryCount = {
  _: "premiumLimitTypeMonthlySentStoryCount";
};

/**
 * Version of {@link premiumLimitTypeMonthlySentStoryCount} for method parameters.
 *
 * The maximum number of stories sent per month
 */
export type premiumLimitTypeMonthlySentStoryCount$Input = {
  readonly _: "premiumLimitTypeMonthlySentStoryCount";
};

/**
 * The maximum length of captions of sent stories
 */
export type premiumLimitTypeStoryCaptionLength = {
  _: "premiumLimitTypeStoryCaptionLength";
};

/**
 * Version of {@link premiumLimitTypeStoryCaptionLength} for method parameters.
 *
 * The maximum length of captions of sent stories
 */
export type premiumLimitTypeStoryCaptionLength$Input = {
  readonly _: "premiumLimitTypeStoryCaptionLength";
};

/**
 * The maximum number of suggested reaction areas on a story
 */
export type premiumLimitTypeStorySuggestedReactionAreaCount = {
  _: "premiumLimitTypeStorySuggestedReactionAreaCount";
};

/**
 * Version of {@link premiumLimitTypeStorySuggestedReactionAreaCount} for method parameters.
 *
 * The maximum number of suggested reaction areas on a story
 */
export type premiumLimitTypeStorySuggestedReactionAreaCount$Input = {
  readonly _: "premiumLimitTypeStorySuggestedReactionAreaCount";
};

/**
 * The maximum number of received similar chats
 */
export type premiumLimitTypeSimilarChatCount = {
  _: "premiumLimitTypeSimilarChatCount";
};

/**
 * Version of {@link premiumLimitTypeSimilarChatCount} for method parameters.
 *
 * The maximum number of received similar chats
 */
export type premiumLimitTypeSimilarChatCount$Input = {
  readonly _: "premiumLimitTypeSimilarChatCount";
};

/**
 * Increased limits
 */
export type premiumFeatureIncreasedLimits = {
  _: "premiumFeatureIncreasedLimits";
};

/**
 * Version of {@link premiumFeatureIncreasedLimits} for method parameters.
 *
 * Increased limits
 */
export type premiumFeatureIncreasedLimits$Input = {
  readonly _: "premiumFeatureIncreasedLimits";
};

/**
 * Increased maximum upload file size
 */
export type premiumFeatureIncreasedUploadFileSize = {
  _: "premiumFeatureIncreasedUploadFileSize";
};

/**
 * Version of {@link premiumFeatureIncreasedUploadFileSize} for method parameters.
 *
 * Increased maximum upload file size
 */
export type premiumFeatureIncreasedUploadFileSize$Input = {
  readonly _: "premiumFeatureIncreasedUploadFileSize";
};

/**
 * Improved download speed
 */
export type premiumFeatureImprovedDownloadSpeed = {
  _: "premiumFeatureImprovedDownloadSpeed";
};

/**
 * Version of {@link premiumFeatureImprovedDownloadSpeed} for method parameters.
 *
 * Improved download speed
 */
export type premiumFeatureImprovedDownloadSpeed$Input = {
  readonly _: "premiumFeatureImprovedDownloadSpeed";
};

/**
 * The ability to convert voice notes to text
 */
export type premiumFeatureVoiceRecognition = {
  _: "premiumFeatureVoiceRecognition";
};

/**
 * Version of {@link premiumFeatureVoiceRecognition} for method parameters.
 *
 * The ability to convert voice notes to text
 */
export type premiumFeatureVoiceRecognition$Input = {
  readonly _: "premiumFeatureVoiceRecognition";
};

/**
 * Disabled ads
 */
export type premiumFeatureDisabledAds = {
  _: "premiumFeatureDisabledAds";
};

/**
 * Version of {@link premiumFeatureDisabledAds} for method parameters.
 *
 * Disabled ads
 */
export type premiumFeatureDisabledAds$Input = {
  readonly _: "premiumFeatureDisabledAds";
};

/**
 * Allowed to use more reactions
 */
export type premiumFeatureUniqueReactions = {
  _: "premiumFeatureUniqueReactions";
};

/**
 * Version of {@link premiumFeatureUniqueReactions} for method parameters.
 *
 * Allowed to use more reactions
 */
export type premiumFeatureUniqueReactions$Input = {
  readonly _: "premiumFeatureUniqueReactions";
};

/**
 * Allowed to use premium stickers with unique effects
 */
export type premiumFeatureUniqueStickers = {
  _: "premiumFeatureUniqueStickers";
};

/**
 * Version of {@link premiumFeatureUniqueStickers} for method parameters.
 *
 * Allowed to use premium stickers with unique effects
 */
export type premiumFeatureUniqueStickers$Input = {
  readonly _: "premiumFeatureUniqueStickers";
};

/**
 * Allowed to use custom emoji stickers in message texts and captions
 */
export type premiumFeatureCustomEmoji = {
  _: "premiumFeatureCustomEmoji";
};

/**
 * Version of {@link premiumFeatureCustomEmoji} for method parameters.
 *
 * Allowed to use custom emoji stickers in message texts and captions
 */
export type premiumFeatureCustomEmoji$Input = {
  readonly _: "premiumFeatureCustomEmoji";
};

/**
 * Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
 */
export type premiumFeatureAdvancedChatManagement = {
  _: "premiumFeatureAdvancedChatManagement";
};

/**
 * Version of {@link premiumFeatureAdvancedChatManagement} for method parameters.
 *
 * Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram
 */
export type premiumFeatureAdvancedChatManagement$Input = {
  readonly _: "premiumFeatureAdvancedChatManagement";
};

/**
 * A badge in the user's profile
 */
export type premiumFeatureProfileBadge = {
  _: "premiumFeatureProfileBadge";
};

/**
 * Version of {@link premiumFeatureProfileBadge} for method parameters.
 *
 * A badge in the user's profile
 */
export type premiumFeatureProfileBadge$Input = {
  readonly _: "premiumFeatureProfileBadge";
};

/**
 * An emoji status shown along with the user's name
 */
export type premiumFeatureEmojiStatus = {
  _: "premiumFeatureEmojiStatus";
};

/**
 * Version of {@link premiumFeatureEmojiStatus} for method parameters.
 *
 * An emoji status shown along with the user's name
 */
export type premiumFeatureEmojiStatus$Input = {
  readonly _: "premiumFeatureEmojiStatus";
};

/**
 * Profile photo animation on message and chat screens
 */
export type premiumFeatureAnimatedProfilePhoto = {
  _: "premiumFeatureAnimatedProfilePhoto";
};

/**
 * Version of {@link premiumFeatureAnimatedProfilePhoto} for method parameters.
 *
 * Profile photo animation on message and chat screens
 */
export type premiumFeatureAnimatedProfilePhoto$Input = {
  readonly _: "premiumFeatureAnimatedProfilePhoto";
};

/**
 * The ability to set a custom emoji as a forum topic icon
 */
export type premiumFeatureForumTopicIcon = {
  _: "premiumFeatureForumTopicIcon";
};

/**
 * Version of {@link premiumFeatureForumTopicIcon} for method parameters.
 *
 * The ability to set a custom emoji as a forum topic icon
 */
export type premiumFeatureForumTopicIcon$Input = {
  readonly _: "premiumFeatureForumTopicIcon";
};

/**
 * Allowed to set a premium application icons
 */
export type premiumFeatureAppIcons = {
  _: "premiumFeatureAppIcons";
};

/**
 * Version of {@link premiumFeatureAppIcons} for method parameters.
 *
 * Allowed to set a premium application icons
 */
export type premiumFeatureAppIcons$Input = {
  readonly _: "premiumFeatureAppIcons";
};

/**
 * Allowed to translate chat messages real-time
 */
export type premiumFeatureRealTimeChatTranslation = {
  _: "premiumFeatureRealTimeChatTranslation";
};

/**
 * Version of {@link premiumFeatureRealTimeChatTranslation} for method parameters.
 *
 * Allowed to translate chat messages real-time
 */
export type premiumFeatureRealTimeChatTranslation$Input = {
  readonly _: "premiumFeatureRealTimeChatTranslation";
};

/**
 * Allowed to use many additional features for stories
 */
export type premiumFeatureUpgradedStories = {
  _: "premiumFeatureUpgradedStories";
};

/**
 * Version of {@link premiumFeatureUpgradedStories} for method parameters.
 *
 * Allowed to use many additional features for stories
 */
export type premiumFeatureUpgradedStories$Input = {
  readonly _: "premiumFeatureUpgradedStories";
};

/**
 * The ability to boost chats
 */
export type premiumFeatureChatBoost = {
  _: "premiumFeatureChatBoost";
};

/**
 * Version of {@link premiumFeatureChatBoost} for method parameters.
 *
 * The ability to boost chats
 */
export type premiumFeatureChatBoost$Input = {
  readonly _: "premiumFeatureChatBoost";
};

/**
 * The ability to choose accent color for replies and user profile
 */
export type premiumFeatureAccentColor = {
  _: "premiumFeatureAccentColor";
};

/**
 * Version of {@link premiumFeatureAccentColor} for method parameters.
 *
 * The ability to choose accent color for replies and user profile
 */
export type premiumFeatureAccentColor$Input = {
  readonly _: "premiumFeatureAccentColor";
};

/**
 * The ability to set private chat background for both users
 */
export type premiumFeatureBackgroundForBoth = {
  _: "premiumFeatureBackgroundForBoth";
};

/**
 * Version of {@link premiumFeatureBackgroundForBoth} for method parameters.
 *
 * The ability to set private chat background for both users
 */
export type premiumFeatureBackgroundForBoth$Input = {
  readonly _: "premiumFeatureBackgroundForBoth";
};

/**
 * User stories are displayed before stories of non-premium contacts and channels
 */
export type premiumStoryFeaturePriorityOrder = {
  _: "premiumStoryFeaturePriorityOrder";
};

/**
 * Version of {@link premiumStoryFeaturePriorityOrder} for method parameters.
 *
 * User stories are displayed before stories of non-premium contacts and channels
 */
export type premiumStoryFeaturePriorityOrder$Input = {
  readonly _: "premiumStoryFeaturePriorityOrder";
};

/**
 * The ability to hide the fact that the user viewed other's stories
 */
export type premiumStoryFeatureStealthMode = {
  _: "premiumStoryFeatureStealthMode";
};

/**
 * Version of {@link premiumStoryFeatureStealthMode} for method parameters.
 *
 * The ability to hide the fact that the user viewed other's stories
 */
export type premiumStoryFeatureStealthMode$Input = {
  readonly _: "premiumStoryFeatureStealthMode";
};

/**
 * The ability to check who opened the current user's stories after they expire
 */
export type premiumStoryFeaturePermanentViewsHistory = {
  _: "premiumStoryFeaturePermanentViewsHistory";
};

/**
 * Version of {@link premiumStoryFeaturePermanentViewsHistory} for method parameters.
 *
 * The ability to check who opened the current user's stories after they expire
 */
export type premiumStoryFeaturePermanentViewsHistory$Input = {
  readonly _: "premiumStoryFeaturePermanentViewsHistory";
};

/**
 * The ability to set custom expiration duration for stories
 */
export type premiumStoryFeatureCustomExpirationDuration = {
  _: "premiumStoryFeatureCustomExpirationDuration";
};

/**
 * Version of {@link premiumStoryFeatureCustomExpirationDuration} for method parameters.
 *
 * The ability to set custom expiration duration for stories
 */
export type premiumStoryFeatureCustomExpirationDuration$Input = {
  readonly _: "premiumStoryFeatureCustomExpirationDuration";
};

/**
 * The ability to save other's unprotected stories
 */
export type premiumStoryFeatureSaveStories = {
  _: "premiumStoryFeatureSaveStories";
};

/**
 * Version of {@link premiumStoryFeatureSaveStories} for method parameters.
 *
 * The ability to save other's unprotected stories
 */
export type premiumStoryFeatureSaveStories$Input = {
  readonly _: "premiumStoryFeatureSaveStories";
};

/**
 * The ability to use links and formatting in story caption
 */
export type premiumStoryFeatureLinksAndFormatting = {
  _: "premiumStoryFeatureLinksAndFormatting";
};

/**
 * Version of {@link premiumStoryFeatureLinksAndFormatting} for method parameters.
 *
 * The ability to use links and formatting in story caption
 */
export type premiumStoryFeatureLinksAndFormatting$Input = {
  readonly _: "premiumStoryFeatureLinksAndFormatting";
};

/**
 * Contains information about a limit, increased for Premium users
 */
export type premiumLimit = {
  _: "premiumLimit";

  /**
   * The type of the limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  type: PremiumLimitType;

  /**
   * Default value of the limit
   * @type {int32} {@link int32}
   */
  default_value: int32;

  /**
   * Value of the limit for Premium users
   * @type {int32} {@link int32}
   */
  premium_value: int32;
};

/**
 * Version of {@link premiumLimit} for method parameters.
 *
 * Contains information about a limit, increased for Premium users
 */
export type premiumLimit$Input = {
  readonly _: "premiumLimit";

  /**
   * The type of the limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  readonly type?: PremiumLimitType$Input;

  /**
   * Default value of the limit
   * @type {int32} {@link int32}
   */
  readonly default_value?: int32;

  /**
   * Value of the limit for Premium users
   * @type {int32} {@link int32}
   */
  readonly premium_value?: int32;
};

/**
 * Contains information about features, available to Premium users
 */
export type premiumFeatures = {
  _: "premiumFeatures";

  /**
   * The list of available features
   * @type {vector<PremiumFeature>} {@link vector<PremiumFeature>}
   */
  features: vector<PremiumFeature>;

  /**
   * The list of limits, increased for Premium users
   * @type {vector<premiumLimit>} {@link vector<premiumLimit>}
   */
  limits: vector<premiumLimit>;

  /**
   * An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  payment_link: InternalLinkType | null;
};

/**
 * Version of {@link premiumFeatures} for method parameters.
 *
 * Contains information about features, available to Premium users
 */
export type premiumFeatures$Input = {
  readonly _: "premiumFeatures";

  /**
   * The list of available features
   * @type {vector<PremiumFeature>} {@link vector<PremiumFeature>}
   */
  readonly features?: vector$Input<PremiumFeature$Input>;

  /**
   * The list of limits, increased for Premium users
   * @type {vector<premiumLimit>} {@link vector<premiumLimit>}
   */
  readonly limits?: vector$Input<premiumLimit$Input>;

  /**
   * An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly payment_link?: InternalLinkType$Input | null;
};

/**
 * A limit was exceeded
 */
export type premiumSourceLimitExceeded = {
  _: "premiumSourceLimitExceeded";

  /**
   * Type of the exceeded limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  limit_type: PremiumLimitType;
};

/**
 * Version of {@link premiumSourceLimitExceeded} for method parameters.
 *
 * A limit was exceeded
 */
export type premiumSourceLimitExceeded$Input = {
  readonly _: "premiumSourceLimitExceeded";

  /**
   * Type of the exceeded limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  readonly limit_type?: PremiumLimitType$Input;
};

/**
 * A user tried to use a Premium feature
 */
export type premiumSourceFeature = {
  _: "premiumSourceFeature";

  /**
   * The used feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  feature: PremiumFeature;
};

/**
 * Version of {@link premiumSourceFeature} for method parameters.
 *
 * A user tried to use a Premium feature
 */
export type premiumSourceFeature$Input = {
  readonly _: "premiumSourceFeature";

  /**
   * The used feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;
};

/**
 * A user tried to use a Premium story feature
 */
export type premiumSourceStoryFeature = {
  _: "premiumSourceStoryFeature";

  /**
   * The used feature
   * @type {PremiumStoryFeature} {@link PremiumStoryFeature}
   */
  feature: PremiumStoryFeature;
};

/**
 * Version of {@link premiumSourceStoryFeature} for method parameters.
 *
 * A user tried to use a Premium story feature
 */
export type premiumSourceStoryFeature$Input = {
  readonly _: "premiumSourceStoryFeature";

  /**
   * The used feature
   * @type {PremiumStoryFeature} {@link PremiumStoryFeature}
   */
  readonly feature?: PremiumStoryFeature$Input;
};

/**
 * A user opened an internal link of the type internalLinkTypePremiumFeatures
 */
export type premiumSourceLink = {
  _: "premiumSourceLink";

  /**
   * The referrer from the link
   * @type {string} {@link string}
   */
  referrer: string;
};

/**
 * Version of {@link premiumSourceLink} for method parameters.
 *
 * A user opened an internal link of the type internalLinkTypePremiumFeatures
 */
export type premiumSourceLink$Input = {
  readonly _: "premiumSourceLink";

  /**
   * The referrer from the link
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/**
 * A user opened the Premium features screen from settings
 */
export type premiumSourceSettings = {
  _: "premiumSourceSettings";
};

/**
 * Version of {@link premiumSourceSettings} for method parameters.
 *
 * A user opened the Premium features screen from settings
 */
export type premiumSourceSettings$Input = {
  readonly _: "premiumSourceSettings";
};

/**
 * Describes a promotion animation for a Premium feature
 */
export type premiumFeaturePromotionAnimation = {
  _: "premiumFeaturePromotionAnimation";

  /**
   * Premium feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  feature: PremiumFeature;

  /**
   * Promotion animation for the feature
   * @type {animation} {@link animation}
   */
  animation: animation;
};

/**
 * Version of {@link premiumFeaturePromotionAnimation} for method parameters.
 *
 * Describes a promotion animation for a Premium feature
 */
export type premiumFeaturePromotionAnimation$Input = {
  readonly _: "premiumFeaturePromotionAnimation";

  /**
   * Premium feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;

  /**
   * Promotion animation for the feature
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;
};

/**
 * Contains state of Telegram Premium subscription and promotion videos for Premium features
 */
export type premiumState = {
  _: "premiumState";

  /**
   * Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
   * @type {formattedText} {@link formattedText}
   */
  state: formattedText;

  /**
   * The list of available options for buying Telegram Premium
   * @type {vector<premiumStatePaymentOption>} {@link vector<premiumStatePaymentOption>}
   */
  payment_options: vector<premiumStatePaymentOption>;

  /**
   * The list of available promotion animations for Premium features
   * @type {vector<premiumFeaturePromotionAnimation>} {@link vector<premiumFeaturePromotionAnimation>}
   */
  animations: vector<premiumFeaturePromotionAnimation>;
};

/**
 * Version of {@link premiumState} for method parameters.
 *
 * Contains state of Telegram Premium subscription and promotion videos for Premium features
 */
export type premiumState$Input = {
  readonly _: "premiumState";

  /**
   * Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
   * @type {formattedText} {@link formattedText}
   */
  readonly state?: formattedText$Input;

  /**
   * The list of available options for buying Telegram Premium
   * @type {vector<premiumStatePaymentOption>} {@link vector<premiumStatePaymentOption>}
   */
  readonly payment_options?: vector$Input<premiumStatePaymentOption$Input>;

  /**
   * The list of available promotion animations for Premium features
   * @type {vector<premiumFeaturePromotionAnimation>} {@link vector<premiumFeaturePromotionAnimation>}
   */
  readonly animations?: vector$Input<premiumFeaturePromotionAnimation$Input>;
};

/**
 * The user subscribing to Telegram Premium
 */
export type storePaymentPurposePremiumSubscription = {
  _: "storePaymentPurposePremiumSubscription";

  /**
   * Pass true if this is a restore of a Telegram Premium purchase; only for App Store
   * @type {Bool} {@link Bool}
   */
  is_restore: Bool;

  /**
   * Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
   * @type {Bool} {@link Bool}
   */
  is_upgrade: Bool;
};

/**
 * Version of {@link storePaymentPurposePremiumSubscription} for method parameters.
 *
 * The user subscribing to Telegram Premium
 */
export type storePaymentPurposePremiumSubscription$Input = {
  readonly _: "storePaymentPurposePremiumSubscription";

  /**
   * Pass true if this is a restore of a Telegram Premium purchase; only for App Store
   * @type {Bool} {@link Bool}
   */
  readonly is_restore?: Bool$Input;

  /**
   * Pass true if this is an upgrade from a monthly subscription to early subscription; only for App Store
   * @type {Bool} {@link Bool}
   */
  readonly is_upgrade?: Bool$Input;
};

/**
 * The user gifting Telegram Premium to another user
 */
export type storePaymentPurposeGiftedPremium = {
  _: "storePaymentPurposeGiftedPremium";

  /**
   * Identifier of the user to which Premium was gifted
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;
};

/**
 * Version of {@link storePaymentPurposeGiftedPremium} for method parameters.
 *
 * The user gifting Telegram Premium to another user
 */
export type storePaymentPurposeGiftedPremium$Input = {
  readonly _: "storePaymentPurposeGiftedPremium";

  /**
   * Identifier of the user to which Premium was gifted
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;
};

/**
 * The user creating Telegram Premium gift codes for other users
 */
export type storePaymentPurposePremiumGiftCodes = {
  _: "storePaymentPurposePremiumGiftCodes";

  /**
   * Identifier of the channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
   * @type {int53} {@link int53}
   */
  boosted_chat_id: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Identifiers of the users which can activate the gift codes
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link storePaymentPurposePremiumGiftCodes} for method parameters.
 *
 * The user creating Telegram Premium gift codes for other users
 */
export type storePaymentPurposePremiumGiftCodes$Input = {
  readonly _: "storePaymentPurposePremiumGiftCodes";

  /**
   * Identifier of the channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
   * @type {int53} {@link int53}
   */
  readonly boosted_chat_id?: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Identifiers of the users which can activate the gift codes
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * The user creating a Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 */
export type storePaymentPurposePremiumGiveaway = {
  _: "storePaymentPurposePremiumGiveaway";

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters} {@link premiumGiveawayParameters}
   */
  parameters: premiumGiveawayParameters;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;
};

/**
 * Version of {@link storePaymentPurposePremiumGiveaway} for method parameters.
 *
 * The user creating a Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 */
export type storePaymentPurposePremiumGiveaway$Input = {
  readonly _: "storePaymentPurposePremiumGiveaway";

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters} {@link premiumGiveawayParameters}
   */
  readonly parameters?: premiumGiveawayParameters$Input;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;
};

/**
 * The user creating Telegram Premium gift codes for other users
 */
export type telegramPaymentPurposePremiumGiftCodes = {
  _: "telegramPaymentPurposePremiumGiftCodes";

  /**
   * Identifier of the channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
   * @type {int53} {@link int53}
   */
  boosted_chat_id: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Identifiers of the users which can activate the gift codes
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;

  /**
   * Number of months the Telegram Premium subscription will be active for the users
   * @type {int32} {@link int32}
   */
  month_count: int32;
};

/**
 * Version of {@link telegramPaymentPurposePremiumGiftCodes} for method parameters.
 *
 * The user creating Telegram Premium gift codes for other users
 */
export type telegramPaymentPurposePremiumGiftCodes$Input = {
  readonly _: "telegramPaymentPurposePremiumGiftCodes";

  /**
   * Identifier of the channel chat, which will be automatically boosted by the users for duration of the Premium subscription and which is administered by the user; 0 if none
   * @type {int53} {@link int53}
   */
  readonly boosted_chat_id?: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Identifiers of the users which can activate the gift codes
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * Number of months the Telegram Premium subscription will be active for the users
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;
};

/**
 * The user creating a Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 */
export type telegramPaymentPurposePremiumGiveaway = {
  _: "telegramPaymentPurposePremiumGiveaway";

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters} {@link premiumGiveawayParameters}
   */
  parameters: premiumGiveawayParameters;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Number of users which will be able to activate the gift codes
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Number of months the Telegram Premium subscription will be active for the users
   * @type {int32} {@link int32}
   */
  month_count: int32;
};

/**
 * Version of {@link telegramPaymentPurposePremiumGiveaway} for method parameters.
 *
 * The user creating a Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 */
export type telegramPaymentPurposePremiumGiveaway$Input = {
  readonly _: "telegramPaymentPurposePremiumGiveaway";

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters} {@link premiumGiveawayParameters}
   */
  readonly parameters?: premiumGiveawayParameters$Input;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Number of users which will be able to activate the gift codes
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Number of months the Telegram Premium subscription will be active for the users
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;
};

/**
 * A token for Firebase Cloud Messaging
 */
export type deviceTokenFirebaseCloudMessaging = {
  _: "deviceTokenFirebaseCloudMessaging";

  /**
   * Device registration token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  encrypt: Bool;
};

/**
 * Version of {@link deviceTokenFirebaseCloudMessaging} for method parameters.
 *
 * A token for Firebase Cloud Messaging
 */
export type deviceTokenFirebaseCloudMessaging$Input = {
  readonly _: "deviceTokenFirebaseCloudMessaging";

  /**
   * Device registration token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  readonly encrypt?: Bool$Input;
};

/**
 * A token for Apple Push Notification service
 */
export type deviceTokenApplePush = {
  _: "deviceTokenApplePush";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  device_token: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  is_app_sandbox: Bool;
};

/**
 * Version of {@link deviceTokenApplePush} for method parameters.
 *
 * A token for Apple Push Notification service
 */
export type deviceTokenApplePush$Input = {
  readonly _: "deviceTokenApplePush";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly device_token?: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_app_sandbox?: Bool$Input;
};

/**
 * A token for Apple Push Notification service VoIP notifications
 */
export type deviceTokenApplePushVoIP = {
  _: "deviceTokenApplePushVoIP";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  device_token: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  is_app_sandbox: Bool;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  encrypt: Bool;
};

/**
 * Version of {@link deviceTokenApplePushVoIP} for method parameters.
 *
 * A token for Apple Push Notification service VoIP notifications
 */
export type deviceTokenApplePushVoIP$Input = {
  readonly _: "deviceTokenApplePushVoIP";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly device_token?: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_app_sandbox?: Bool$Input;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  readonly encrypt?: Bool$Input;
};

/**
 * A token for Windows Push Notification Services
 */
export type deviceTokenWindowsPush = {
  _: "deviceTokenWindowsPush";

  /**
   * The access token that will be used to send notifications; may be empty to deregister a device
   * @type {string} {@link string}
   */
  access_token: string;
};

/**
 * Version of {@link deviceTokenWindowsPush} for method parameters.
 *
 * A token for Windows Push Notification Services
 */
export type deviceTokenWindowsPush$Input = {
  readonly _: "deviceTokenWindowsPush";

  /**
   * The access token that will be used to send notifications; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly access_token?: string;
};

/**
 * A token for Microsoft Push Notification Service
 */
export type deviceTokenMicrosoftPush = {
  _: "deviceTokenMicrosoftPush";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  channel_uri: string;
};

/**
 * Version of {@link deviceTokenMicrosoftPush} for method parameters.
 *
 * A token for Microsoft Push Notification Service
 */
export type deviceTokenMicrosoftPush$Input = {
  readonly _: "deviceTokenMicrosoftPush";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly channel_uri?: string;
};

/**
 * A token for Microsoft Push Notification Service VoIP channel
 */
export type deviceTokenMicrosoftPushVoIP = {
  _: "deviceTokenMicrosoftPushVoIP";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  channel_uri: string;
};

/**
 * Version of {@link deviceTokenMicrosoftPushVoIP} for method parameters.
 *
 * A token for Microsoft Push Notification Service VoIP channel
 */
export type deviceTokenMicrosoftPushVoIP$Input = {
  readonly _: "deviceTokenMicrosoftPushVoIP";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly channel_uri?: string;
};

/**
 * A token for web Push API
 */
export type deviceTokenWebPush = {
  _: "deviceTokenWebPush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  endpoint: string;

  /**
   * Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
   * @type {string} {@link string}
   */
  p256dh_base64url: string;

  /**
   * Base64url-encoded authentication secret
   * @type {string} {@link string}
   */
  auth_base64url: string;
};

/**
 * Version of {@link deviceTokenWebPush} for method parameters.
 *
 * A token for web Push API
 */
export type deviceTokenWebPush$Input = {
  readonly _: "deviceTokenWebPush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly endpoint?: string;

  /**
   * Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
   * @type {string} {@link string}
   */
  readonly p256dh_base64url?: string;

  /**
   * Base64url-encoded authentication secret
   * @type {string} {@link string}
   */
  readonly auth_base64url?: string;
};

/**
 * A token for Simple Push API for Firefox OS
 */
export type deviceTokenSimplePush = {
  _: "deviceTokenSimplePush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  endpoint: string;
};

/**
 * Version of {@link deviceTokenSimplePush} for method parameters.
 *
 * A token for Simple Push API for Firefox OS
 */
export type deviceTokenSimplePush$Input = {
  readonly _: "deviceTokenSimplePush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly endpoint?: string;
};

/**
 * A token for Ubuntu Push Client service
 */
export type deviceTokenUbuntuPush = {
  _: "deviceTokenUbuntuPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;
};

/**
 * Version of {@link deviceTokenUbuntuPush} for method parameters.
 *
 * A token for Ubuntu Push Client service
 */
export type deviceTokenUbuntuPush$Input = {
  readonly _: "deviceTokenUbuntuPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * A token for BlackBerry Push Service
 */
export type deviceTokenBlackBerryPush = {
  _: "deviceTokenBlackBerryPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;
};

/**
 * Version of {@link deviceTokenBlackBerryPush} for method parameters.
 *
 * A token for BlackBerry Push Service
 */
export type deviceTokenBlackBerryPush$Input = {
  readonly _: "deviceTokenBlackBerryPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * A token for Tizen Push Service
 */
export type deviceTokenTizenPush = {
  _: "deviceTokenTizenPush";

  /**
   * Push service registration identifier; may be empty to deregister a device
   * @type {string} {@link string}
   */
  reg_id: string;
};

/**
 * Version of {@link deviceTokenTizenPush} for method parameters.
 *
 * A token for Tizen Push Service
 */
export type deviceTokenTizenPush$Input = {
  readonly _: "deviceTokenTizenPush";

  /**
   * Push service registration identifier; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly reg_id?: string;
};

/**
 * A token for HUAWEI Push Service
 */
export type deviceTokenHuaweiPush = {
  _: "deviceTokenHuaweiPush";

  /**
   * Device registration token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  encrypt: Bool;
};

/**
 * Version of {@link deviceTokenHuaweiPush} for method parameters.
 *
 * A token for HUAWEI Push Service
 */
export type deviceTokenHuaweiPush$Input = {
  readonly _: "deviceTokenHuaweiPush";

  /**
   * Device registration token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  readonly encrypt?: Bool$Input;
};

/**
 * Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
 */
export type pushReceiverId = {
  _: "pushReceiverId";

  /**
   * The globally unique identifier of push notification subscription
   * @type {int64} {@link int64}
   */
  id: int64;
};

/**
 * Version of {@link pushReceiverId} for method parameters.
 *
 * Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
 */
export type pushReceiverId$Input = {
  readonly _: "pushReceiverId";

  /**
   * The globally unique identifier of push notification subscription
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;
};

/**
 * Describes a solid fill of a background
 */
export type backgroundFillSolid = {
  _: "backgroundFillSolid";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  color: int32;
};

/**
 * Version of {@link backgroundFillSolid} for method parameters.
 *
 * Describes a solid fill of a background
 */
export type backgroundFillSolid$Input = {
  readonly _: "backgroundFillSolid";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly color?: int32;
};

/**
 * Describes a gradient fill of a background
 */
export type backgroundFillGradient = {
  _: "backgroundFillGradient";

  /**
   * A top color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  top_color: int32;

  /**
   * A bottom color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  bottom_color: int32;

  /**
   * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
   * @type {int32} {@link int32}
   */
  rotation_angle: int32;
};

/**
 * Version of {@link backgroundFillGradient} for method parameters.
 *
 * Describes a gradient fill of a background
 */
export type backgroundFillGradient$Input = {
  readonly _: "backgroundFillGradient";

  /**
   * A top color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly top_color?: int32;

  /**
   * A bottom color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly bottom_color?: int32;

  /**
   * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
   * @type {int32} {@link int32}
   */
  readonly rotation_angle?: int32;
};

/**
 * Describes a freeform gradient fill of a background
 */
export type backgroundFillFreeformGradient = {
  _: "backgroundFillFreeformGradient";

  /**
   * A list of 3 or 4 colors of the freeform gradients in the RGB24 format
   * @type {vector<int32>} {@link vector<int32>}
   */
  colors: vector<int32>;
};

/**
 * Version of {@link backgroundFillFreeformGradient} for method parameters.
 *
 * Describes a freeform gradient fill of a background
 */
export type backgroundFillFreeformGradient$Input = {
  readonly _: "backgroundFillFreeformGradient";

  /**
   * A list of 3 or 4 colors of the freeform gradients in the RGB24 format
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly colors?: vector$Input<int32>;
};

/**
 * A wallpaper in JPEG format
 */
export type backgroundTypeWallpaper = {
  _: "backgroundTypeWallpaper";

  /**
   * True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
   * @type {Bool} {@link Bool}
   */
  is_blurred: Bool;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  is_moving: Bool;
};

/**
 * Version of {@link backgroundTypeWallpaper} for method parameters.
 *
 * A wallpaper in JPEG format
 */
export type backgroundTypeWallpaper$Input = {
  readonly _: "backgroundTypeWallpaper";

  /**
   * True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
   * @type {Bool} {@link Bool}
   */
  readonly is_blurred?: Bool$Input;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  readonly is_moving?: Bool$Input;
};

/**
 * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
 */
export type backgroundTypePattern = {
  _: "backgroundTypePattern";

  /**
   * Fill of the background
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  fill: BackgroundFill;

  /**
   * Intensity of the pattern when it is shown above the filled background; 0-100.
   * @type {int32} {@link int32}
   */
  intensity: int32;

  /**
   * True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
   * @type {Bool} {@link Bool}
   */
  is_inverted: Bool;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  is_moving: Bool;
};

/**
 * Version of {@link backgroundTypePattern} for method parameters.
 *
 * A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
 */
export type backgroundTypePattern$Input = {
  readonly _: "backgroundTypePattern";

  /**
   * Fill of the background
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly fill?: BackgroundFill$Input;

  /**
   * Intensity of the pattern when it is shown above the filled background; 0-100.
   * @type {int32} {@link int32}
   */
  readonly intensity?: int32;

  /**
   * True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
   * @type {Bool} {@link Bool}
   */
  readonly is_inverted?: Bool$Input;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  readonly is_moving?: Bool$Input;
};

/**
 * A filled background
 */
export type backgroundTypeFill = {
  _: "backgroundTypeFill";

  /**
   * The background fill
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  fill: BackgroundFill;
};

/**
 * Version of {@link backgroundTypeFill} for method parameters.
 *
 * A filled background
 */
export type backgroundTypeFill$Input = {
  readonly _: "backgroundTypeFill";

  /**
   * The background fill
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly fill?: BackgroundFill$Input;
};

/**
 * A background from a chat theme; can be used only as a chat background in channels
 */
export type backgroundTypeChatTheme = {
  _: "backgroundTypeChatTheme";

  /**
   * Name of the chat theme
   * @type {string} {@link string}
   */
  theme_name: string;
};

/**
 * Version of {@link backgroundTypeChatTheme} for method parameters.
 *
 * A background from a chat theme; can be used only as a chat background in channels
 */
export type backgroundTypeChatTheme$Input = {
  readonly _: "backgroundTypeChatTheme";

  /**
   * Name of the chat theme
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * A background from a local file
 */
export type inputBackgroundLocal = {
  _: "inputBackgroundLocal";

  /**
   * Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
   * @type {InputFile} {@link InputFile}
   */
  background: InputFile;
};

/**
 * Version of {@link inputBackgroundLocal} for method parameters.
 *
 * A background from a local file
 */
export type inputBackgroundLocal$Input = {
  readonly _: "inputBackgroundLocal";

  /**
   * Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
   * @type {InputFile} {@link InputFile}
   */
  readonly background?: InputFile$Input;
};

/**
 * A background from the server
 */
export type inputBackgroundRemote = {
  _: "inputBackgroundRemote";

  /**
   * The background identifier
   * @type {int64} {@link int64}
   */
  background_id: int64;
};

/**
 * Version of {@link inputBackgroundRemote} for method parameters.
 *
 * A background from the server
 */
export type inputBackgroundRemote$Input = {
  readonly _: "inputBackgroundRemote";

  /**
   * The background identifier
   * @type {int64} {@link int64}
   */
  readonly background_id?: int64$Input;
};

/**
 * A background previously set in the chat; for chat backgrounds only
 */
export type inputBackgroundPrevious = {
  _: "inputBackgroundPrevious";

  /**
   * Identifier of the message with the background
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link inputBackgroundPrevious} for method parameters.
 *
 * A background previously set in the chat; for chat backgrounds only
 */
export type inputBackgroundPrevious$Input = {
  readonly _: "inputBackgroundPrevious";

  /**
   * Identifier of the message with the background
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Describes theme settings
 */
export type themeSettings = {
  _: "themeSettings";

  /**
   * Theme accent color in ARGB format
   * @type {int32} {@link int32}
   */
  accent_color: int32;

  /**
   * The background to be used in chats; may be null
   * @type {background} {@link background}
   */
  background: background | null;

  /**
   * The fill to be used as a background for outgoing messages
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  outgoing_message_fill: BackgroundFill;

  /**
   * If true, the freeform gradient fill needs to be animated on every sent message
   * @type {Bool} {@link Bool}
   */
  animate_outgoing_message_fill: Bool;

  /**
   * Accent color of outgoing messages in ARGB format
   * @type {int32} {@link int32}
   */
  outgoing_message_accent_color: int32;
};

/**
 * Version of {@link themeSettings} for method parameters.
 *
 * Describes theme settings
 */
export type themeSettings$Input = {
  readonly _: "themeSettings";

  /**
   * Theme accent color in ARGB format
   * @type {int32} {@link int32}
   */
  readonly accent_color?: int32;

  /**
   * The background to be used in chats; may be null
   * @type {background} {@link background}
   */
  readonly background?: background$Input | null;

  /**
   * The fill to be used as a background for outgoing messages
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly outgoing_message_fill?: BackgroundFill$Input;

  /**
   * If true, the freeform gradient fill needs to be animated on every sent message
   * @type {Bool} {@link Bool}
   */
  readonly animate_outgoing_message_fill?: Bool$Input;

  /**
   * Accent color of outgoing messages in ARGB format
   * @type {int32} {@link int32}
   */
  readonly outgoing_message_accent_color?: int32;
};

/**
 * Describes a chat theme
 */
export type chatTheme = {
  _: "chatTheme";

  /**
   * Theme name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Theme settings for a light chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  light_settings: themeSettings;

  /**
   * Theme settings for a dark chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  dark_settings: themeSettings;
};

/**
 * Version of {@link chatTheme} for method parameters.
 *
 * Describes a chat theme
 */
export type chatTheme$Input = {
  readonly _: "chatTheme";

  /**
   * Theme name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Theme settings for a light chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  readonly light_settings?: themeSettings$Input;

  /**
   * Theme settings for a dark chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  readonly dark_settings?: themeSettings$Input;
};

/**
 * Contains a list of hashtags
 */
export type hashtags = {
  _: "hashtags";

  /**
   * A list of hashtags
   * @type {vector<string>} {@link vector<string>}
   */
  hashtags: vector<string>;
};

/**
 * Version of {@link hashtags} for method parameters.
 *
 * Contains a list of hashtags
 */
export type hashtags$Input = {
  readonly _: "hashtags";

  /**
   * A list of hashtags
   * @type {vector<string>} {@link vector<string>}
   */
  readonly hashtags?: vector$Input<string>;
};

/**
 * A story can be sent
 */
export type canSendStoryResultOk = {
  _: "canSendStoryResultOk";
};

/**
 * Version of {@link canSendStoryResultOk} for method parameters.
 *
 * A story can be sent
 */
export type canSendStoryResultOk$Input = {
  readonly _: "canSendStoryResultOk";
};

/**
 * The user must subscribe to Telegram Premium to be able to post stories
 */
export type canSendStoryResultPremiumNeeded = {
  _: "canSendStoryResultPremiumNeeded";
};

/**
 * Version of {@link canSendStoryResultPremiumNeeded} for method parameters.
 *
 * The user must subscribe to Telegram Premium to be able to post stories
 */
export type canSendStoryResultPremiumNeeded$Input = {
  readonly _: "canSendStoryResultPremiumNeeded";
};

/**
 * The channel chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat
 */
export type canSendStoryResultBoostNeeded = {
  _: "canSendStoryResultBoostNeeded";
};

/**
 * Version of {@link canSendStoryResultBoostNeeded} for method parameters.
 *
 * The channel chat must be boosted first by Telegram Premium subscribers to post more stories. Call getChatBoostStatus to get current boost status of the chat
 */
export type canSendStoryResultBoostNeeded$Input = {
  readonly _: "canSendStoryResultBoostNeeded";
};

/**
 * The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire
 */
export type canSendStoryResultActiveStoryLimitExceeded = {
  _: "canSendStoryResultActiveStoryLimitExceeded";
};

/**
 * Version of {@link canSendStoryResultActiveStoryLimitExceeded} for method parameters.
 *
 * The limit for the number of active stories exceeded. The user can buy Telegram Premium, delete an active story, or wait for the oldest story to expire
 */
export type canSendStoryResultActiveStoryLimitExceeded$Input = {
  readonly _: "canSendStoryResultActiveStoryLimitExceeded";
};

/**
 * The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
 */
export type canSendStoryResultWeeklyLimitExceeded = {
  _: "canSendStoryResultWeeklyLimitExceeded";

  /**
   * Time left before the user can send the next story
   * @type {int32} {@link int32}
   */
  retry_after: int32;
};

/**
 * Version of {@link canSendStoryResultWeeklyLimitExceeded} for method parameters.
 *
 * The weekly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
 */
export type canSendStoryResultWeeklyLimitExceeded$Input = {
  readonly _: "canSendStoryResultWeeklyLimitExceeded";

  /**
   * Time left before the user can send the next story
   * @type {int32} {@link int32}
   */
  readonly retry_after?: int32;
};

/**
 * The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
 */
export type canSendStoryResultMonthlyLimitExceeded = {
  _: "canSendStoryResultMonthlyLimitExceeded";

  /**
   * Time left before the user can send the next story
   * @type {int32} {@link int32}
   */
  retry_after: int32;
};

/**
 * Version of {@link canSendStoryResultMonthlyLimitExceeded} for method parameters.
 *
 * The monthly limit for the number of posted stories exceeded. The user needs to buy Telegram Premium or wait specified time
 */
export type canSendStoryResultMonthlyLimitExceeded$Input = {
  readonly _: "canSendStoryResultMonthlyLimitExceeded";

  /**
   * Time left before the user can send the next story
   * @type {int32} {@link int32}
   */
  readonly retry_after?: int32;
};

/**
 * The session can be used
 */
export type canTransferOwnershipResultOk = {
  _: "canTransferOwnershipResultOk";
};

/**
 * Version of {@link canTransferOwnershipResultOk} for method parameters.
 *
 * The session can be used
 */
export type canTransferOwnershipResultOk$Input = {
  readonly _: "canTransferOwnershipResultOk";
};

/**
 * The 2-step verification needs to be enabled first
 */
export type canTransferOwnershipResultPasswordNeeded = {
  _: "canTransferOwnershipResultPasswordNeeded";
};

/**
 * Version of {@link canTransferOwnershipResultPasswordNeeded} for method parameters.
 *
 * The 2-step verification needs to be enabled first
 */
export type canTransferOwnershipResultPasswordNeeded$Input = {
  readonly _: "canTransferOwnershipResultPasswordNeeded";
};

/**
 * The 2-step verification was enabled recently, user needs to wait
 */
export type canTransferOwnershipResultPasswordTooFresh = {
  _: "canTransferOwnershipResultPasswordTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  retry_after: int32;
};

/**
 * Version of {@link canTransferOwnershipResultPasswordTooFresh} for method parameters.
 *
 * The 2-step verification was enabled recently, user needs to wait
 */
export type canTransferOwnershipResultPasswordTooFresh$Input = {
  readonly _: "canTransferOwnershipResultPasswordTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  readonly retry_after?: int32;
};

/**
 * The session was created recently, user needs to wait
 */
export type canTransferOwnershipResultSessionTooFresh = {
  _: "canTransferOwnershipResultSessionTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  retry_after: int32;
};

/**
 * Version of {@link canTransferOwnershipResultSessionTooFresh} for method parameters.
 *
 * The session was created recently, user needs to wait
 */
export type canTransferOwnershipResultSessionTooFresh$Input = {
  readonly _: "canTransferOwnershipResultSessionTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  readonly retry_after?: int32;
};

/**
 * The username can be set
 */
export type checkChatUsernameResultOk = {
  _: "checkChatUsernameResultOk";
};

/**
 * Version of {@link checkChatUsernameResultOk} for method parameters.
 *
 * The username can be set
 */
export type checkChatUsernameResultOk$Input = {
  readonly _: "checkChatUsernameResultOk";
};

/**
 * The username is invalid
 */
export type checkChatUsernameResultUsernameInvalid = {
  _: "checkChatUsernameResultUsernameInvalid";
};

/**
 * Version of {@link checkChatUsernameResultUsernameInvalid} for method parameters.
 *
 * The username is invalid
 */
export type checkChatUsernameResultUsernameInvalid$Input = {
  readonly _: "checkChatUsernameResultUsernameInvalid";
};

/**
 * The username is occupied
 */
export type checkChatUsernameResultUsernameOccupied = {
  _: "checkChatUsernameResultUsernameOccupied";
};

/**
 * Version of {@link checkChatUsernameResultUsernameOccupied} for method parameters.
 *
 * The username is occupied
 */
export type checkChatUsernameResultUsernameOccupied$Input = {
  readonly _: "checkChatUsernameResultUsernameOccupied";
};

/**
 * The username can be purchased at fragment.com
 */
export type checkChatUsernameResultUsernamePurchasable = {
  _: "checkChatUsernameResultUsernamePurchasable";
};

/**
 * Version of {@link checkChatUsernameResultUsernamePurchasable} for method parameters.
 *
 * The username can be purchased at fragment.com
 */
export type checkChatUsernameResultUsernamePurchasable$Input = {
  readonly _: "checkChatUsernameResultUsernamePurchasable";
};

/**
 * The user has too many chats with username, one of them must be made private first
 */
export type checkChatUsernameResultPublicChatsTooMany = {
  _: "checkChatUsernameResultPublicChatsTooMany";
};

/**
 * Version of {@link checkChatUsernameResultPublicChatsTooMany} for method parameters.
 *
 * The user has too many chats with username, one of them must be made private first
 */
export type checkChatUsernameResultPublicChatsTooMany$Input = {
  readonly _: "checkChatUsernameResultPublicChatsTooMany";
};

/**
 * The user can't be a member of a public supergroup
 */
export type checkChatUsernameResultPublicGroupsUnavailable = {
  _: "checkChatUsernameResultPublicGroupsUnavailable";
};

/**
 * Version of {@link checkChatUsernameResultPublicGroupsUnavailable} for method parameters.
 *
 * The user can't be a member of a public supergroup
 */
export type checkChatUsernameResultPublicGroupsUnavailable$Input = {
  readonly _: "checkChatUsernameResultPublicGroupsUnavailable";
};

/**
 * The name can be set
 */
export type checkStickerSetNameResultOk = {
  _: "checkStickerSetNameResultOk";
};

/**
 * Version of {@link checkStickerSetNameResultOk} for method parameters.
 *
 * The name can be set
 */
export type checkStickerSetNameResultOk$Input = {
  readonly _: "checkStickerSetNameResultOk";
};

/**
 * The name is invalid
 */
export type checkStickerSetNameResultNameInvalid = {
  _: "checkStickerSetNameResultNameInvalid";
};

/**
 * Version of {@link checkStickerSetNameResultNameInvalid} for method parameters.
 *
 * The name is invalid
 */
export type checkStickerSetNameResultNameInvalid$Input = {
  readonly _: "checkStickerSetNameResultNameInvalid";
};

/**
 * The name is occupied
 */
export type checkStickerSetNameResultNameOccupied = {
  _: "checkStickerSetNameResultNameOccupied";
};

/**
 * Version of {@link checkStickerSetNameResultNameOccupied} for method parameters.
 *
 * The name is occupied
 */
export type checkStickerSetNameResultNameOccupied$Input = {
  readonly _: "checkStickerSetNameResultNameOccupied";
};

/**
 * The password was reset
 */
export type resetPasswordResultOk = {
  _: "resetPasswordResultOk";
};

/**
 * Version of {@link resetPasswordResultOk} for method parameters.
 *
 * The password was reset
 */
export type resetPasswordResultOk$Input = {
  readonly _: "resetPasswordResultOk";
};

/**
 * The password reset request is pending
 */
export type resetPasswordResultPending = {
  _: "resetPasswordResultPending";

  /**
   * Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  pending_reset_date: int32;
};

/**
 * Version of {@link resetPasswordResultPending} for method parameters.
 *
 * The password reset request is pending
 */
export type resetPasswordResultPending$Input = {
  readonly _: "resetPasswordResultPending";

  /**
   * Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  readonly pending_reset_date?: int32;
};

/**
 * The password reset request was declined
 */
export type resetPasswordResultDeclined = {
  _: "resetPasswordResultDeclined";

  /**
   * Point in time (Unix timestamp) when the password reset can be retried
   * @type {int32} {@link int32}
   */
  retry_date: int32;
};

/**
 * Version of {@link resetPasswordResultDeclined} for method parameters.
 *
 * The password reset request was declined
 */
export type resetPasswordResultDeclined$Input = {
  readonly _: "resetPasswordResultDeclined";

  /**
   * Point in time (Unix timestamp) when the password reset can be retried
   * @type {int32} {@link int32}
   */
  readonly retry_date?: int32;
};

/**
 * The messages were exported from a private chat
 */
export type messageFileTypePrivate = {
  _: "messageFileTypePrivate";

  /**
   * Name of the other party; may be empty if unrecognized
   * @type {string} {@link string}
   */
  name: string;
};

/**
 * Version of {@link messageFileTypePrivate} for method parameters.
 *
 * The messages were exported from a private chat
 */
export type messageFileTypePrivate$Input = {
  readonly _: "messageFileTypePrivate";

  /**
   * Name of the other party; may be empty if unrecognized
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * The messages were exported from a group chat
 */
export type messageFileTypeGroup = {
  _: "messageFileTypeGroup";

  /**
   * Title of the group chat; may be empty if unrecognized
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link messageFileTypeGroup} for method parameters.
 *
 * The messages were exported from a group chat
 */
export type messageFileTypeGroup$Input = {
  readonly _: "messageFileTypeGroup";

  /**
   * Title of the group chat; may be empty if unrecognized
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * The messages were exported from a chat of unknown type
 */
export type messageFileTypeUnknown = {
  _: "messageFileTypeUnknown";
};

/**
 * Version of {@link messageFileTypeUnknown} for method parameters.
 *
 * The messages were exported from a chat of unknown type
 */
export type messageFileTypeUnknown$Input = {
  readonly _: "messageFileTypeUnknown";
};

/**
 * A general message with hidden content
 */
export type pushMessageContentHidden = {
  _: "pushMessageContentHidden";

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentHidden} for method parameters.
 *
 * A general message with hidden content
 */
export type pushMessageContentHidden$Input = {
  readonly _: "pushMessageContentHidden";

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * An animation message (GIF-style).
 */
export type pushMessageContentAnimation = {
  _: "pushMessageContentAnimation";

  /**
   * Message content; may be null
   * @type {animation} {@link animation}
   */
  animation: animation | null;

  /**
   * Animation caption
   * @type {string} {@link string}
   */
  caption: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentAnimation} for method parameters.
 *
 * An animation message (GIF-style).
 */
export type pushMessageContentAnimation$Input = {
  readonly _: "pushMessageContentAnimation";

  /**
   * Message content; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input | null;

  /**
   * Animation caption
   * @type {string} {@link string}
   */
  readonly caption?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * An audio message
 */
export type pushMessageContentAudio = {
  _: "pushMessageContentAudio";

  /**
   * Message content; may be null
   * @type {audio} {@link audio}
   */
  audio: audio | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentAudio} for method parameters.
 *
 * An audio message
 */
export type pushMessageContentAudio$Input = {
  readonly _: "pushMessageContentAudio";

  /**
   * Message content; may be null
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with a user contact
 */
export type pushMessageContentContact = {
  _: "pushMessageContentContact";

  /**
   * Contact's name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentContact} for method parameters.
 *
 * A message with a user contact
 */
export type pushMessageContentContact$Input = {
  readonly _: "pushMessageContentContact";

  /**
   * Contact's name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A contact has registered with Telegram
 */
export type pushMessageContentContactRegistered = {
  _: "pushMessageContentContactRegistered";
};

/**
 * Version of {@link pushMessageContentContactRegistered} for method parameters.
 *
 * A contact has registered with Telegram
 */
export type pushMessageContentContactRegistered$Input = {
  readonly _: "pushMessageContentContactRegistered";
};

/**
 * A document message (a general file)
 */
export type pushMessageContentDocument = {
  _: "pushMessageContentDocument";

  /**
   * Message content; may be null
   * @type {document} {@link document}
   */
  document: document | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentDocument} for method parameters.
 *
 * A document message (a general file)
 */
export type pushMessageContentDocument$Input = {
  readonly _: "pushMessageContentDocument";

  /**
   * Message content; may be null
   * @type {document} {@link document}
   */
  readonly document?: document$Input | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with a game
 */
export type pushMessageContentGame = {
  _: "pushMessageContentGame";

  /**
   * Game title, empty for pinned game message
   * @type {string} {@link string}
   */
  title: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentGame} for method parameters.
 *
 * A message with a game
 */
export type pushMessageContentGame$Input = {
  readonly _: "pushMessageContentGame";

  /**
   * Game title, empty for pinned game message
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A new high score was achieved in a game
 */
export type pushMessageContentGameScore = {
  _: "pushMessageContentGameScore";

  /**
   * Game title, empty for pinned message
   * @type {string} {@link string}
   */
  title: string;

  /**
   * New score, 0 for pinned message
   * @type {int32} {@link int32}
   */
  score: int32;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentGameScore} for method parameters.
 *
 * A new high score was achieved in a game
 */
export type pushMessageContentGameScore$Input = {
  readonly _: "pushMessageContentGameScore";

  /**
   * Game title, empty for pinned message
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * New score, 0 for pinned message
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with an invoice from a bot
 */
export type pushMessageContentInvoice = {
  _: "pushMessageContentInvoice";

  /**
   * Product price
   * @type {string} {@link string}
   */
  price: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentInvoice} for method parameters.
 *
 * A message with an invoice from a bot
 */
export type pushMessageContentInvoice$Input = {
  readonly _: "pushMessageContentInvoice";

  /**
   * Product price
   * @type {string} {@link string}
   */
  readonly price?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with a location
 */
export type pushMessageContentLocation = {
  _: "pushMessageContentLocation";

  /**
   * True, if the location is live
   * @type {Bool} {@link Bool}
   */
  is_live: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentLocation} for method parameters.
 *
 * A message with a location
 */
export type pushMessageContentLocation$Input = {
  readonly _: "pushMessageContentLocation";

  /**
   * True, if the location is live
   * @type {Bool} {@link Bool}
   */
  readonly is_live?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A photo message
 */
export type pushMessageContentPhoto = {
  _: "pushMessageContentPhoto";

  /**
   * Message content; may be null
   * @type {photo} {@link photo}
   */
  photo: photo | null;

  /**
   * Photo caption
   * @type {string} {@link string}
   */
  caption: string;

  /**
   * True, if the photo is secret
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentPhoto} for method parameters.
 *
 * A photo message
 */
export type pushMessageContentPhoto$Input = {
  readonly _: "pushMessageContentPhoto";

  /**
   * Message content; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input | null;

  /**
   * Photo caption
   * @type {string} {@link string}
   */
  readonly caption?: string;

  /**
   * True, if the photo is secret
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with a poll
 */
export type pushMessageContentPoll = {
  _: "pushMessageContentPoll";

  /**
   * Poll question
   * @type {string} {@link string}
   */
  question: string;

  /**
   * True, if the poll is regular and not in quiz mode
   * @type {Bool} {@link Bool}
   */
  is_regular: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentPoll} for method parameters.
 *
 * A message with a poll
 */
export type pushMessageContentPoll$Input = {
  readonly _: "pushMessageContentPoll";

  /**
   * Poll question
   * @type {string} {@link string}
   */
  readonly question?: string;

  /**
   * True, if the poll is regular and not in quiz mode
   * @type {Bool} {@link Bool}
   */
  readonly is_regular?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with a Telegram Premium gift code created for the user
 */
export type pushMessageContentPremiumGiftCode = {
  _: "pushMessageContentPremiumGiftCode";

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  month_count: int32;
};

/**
 * Version of {@link pushMessageContentPremiumGiftCode} for method parameters.
 *
 * A message with a Telegram Premium gift code created for the user
 */
export type pushMessageContentPremiumGiftCode$Input = {
  readonly _: "pushMessageContentPremiumGiftCode";

  /**
   * Number of months the Telegram Premium subscription will be active after code activation
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;
};

/**
 * A message with a Telegram Premium giveaway
 */
export type pushMessageContentPremiumGiveaway = {
  _: "pushMessageContentPremiumGiveaway";

  /**
   * Number of users which will receive Telegram Premium subscription gift codes; 0 for pinned message
   * @type {int32} {@link int32}
   */
  winner_count: int32;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation; 0 for pinned message
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentPremiumGiveaway} for method parameters.
 *
 * A message with a Telegram Premium giveaway
 */
export type pushMessageContentPremiumGiveaway$Input = {
  readonly _: "pushMessageContentPremiumGiveaway";

  /**
   * Number of users which will receive Telegram Premium subscription gift codes; 0 for pinned message
   * @type {int32} {@link int32}
   */
  readonly winner_count?: int32;

  /**
   * Number of months the Telegram Premium subscription will be active after code activation; 0 for pinned message
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A screenshot of a message in the chat has been taken
 */
export type pushMessageContentScreenshotTaken = {
  _: "pushMessageContentScreenshotTaken";
};

/**
 * Version of {@link pushMessageContentScreenshotTaken} for method parameters.
 *
 * A screenshot of a message in the chat has been taken
 */
export type pushMessageContentScreenshotTaken$Input = {
  readonly _: "pushMessageContentScreenshotTaken";
};

/**
 * A message with a sticker
 */
export type pushMessageContentSticker = {
  _: "pushMessageContentSticker";

  /**
   * Message content; may be null
   * @type {sticker} {@link sticker}
   */
  sticker: sticker | null;

  /**
   * Emoji corresponding to the sticker; may be empty
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentSticker} for method parameters.
 *
 * A message with a sticker
 */
export type pushMessageContentSticker$Input = {
  readonly _: "pushMessageContentSticker";

  /**
   * Message content; may be null
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input | null;

  /**
   * Emoji corresponding to the sticker; may be empty
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A message with a story
 */
export type pushMessageContentStory = {
  _: "pushMessageContentStory";

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentStory} for method parameters.
 *
 * A message with a story
 */
export type pushMessageContentStory$Input = {
  readonly _: "pushMessageContentStory";

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A text message
 */
export type pushMessageContentText = {
  _: "pushMessageContentText";

  /**
   * Message text
   * @type {string} {@link string}
   */
  text: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentText} for method parameters.
 *
 * A text message
 */
export type pushMessageContentText$Input = {
  readonly _: "pushMessageContentText";

  /**
   * Message text
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A video message
 */
export type pushMessageContentVideo = {
  _: "pushMessageContentVideo";

  /**
   * Message content; may be null
   * @type {video} {@link video}
   */
  video: video | null;

  /**
   * Video caption
   * @type {string} {@link string}
   */
  caption: string;

  /**
   * True, if the video is secret
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentVideo} for method parameters.
 *
 * A video message
 */
export type pushMessageContentVideo$Input = {
  readonly _: "pushMessageContentVideo";

  /**
   * Message content; may be null
   * @type {video} {@link video}
   */
  readonly video?: video$Input | null;

  /**
   * Video caption
   * @type {string} {@link string}
   */
  readonly caption?: string;

  /**
   * True, if the video is secret
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A video note message
 */
export type pushMessageContentVideoNote = {
  _: "pushMessageContentVideoNote";

  /**
   * Message content; may be null
   * @type {videoNote} {@link videoNote}
   */
  video_note: videoNote | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentVideoNote} for method parameters.
 *
 * A video note message
 */
export type pushMessageContentVideoNote$Input = {
  readonly _: "pushMessageContentVideoNote";

  /**
   * Message content; may be null
   * @type {videoNote} {@link videoNote}
   */
  readonly video_note?: videoNote$Input | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A voice note message
 */
export type pushMessageContentVoiceNote = {
  _: "pushMessageContentVoiceNote";

  /**
   * Message content; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link pushMessageContentVoiceNote} for method parameters.
 *
 * A voice note message
 */
export type pushMessageContentVoiceNote$Input = {
  readonly _: "pushMessageContentVoiceNote";

  /**
   * Message content; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input | null;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * A newly created basic group
 */
export type pushMessageContentBasicGroupChatCreate = {
  _: "pushMessageContentBasicGroupChatCreate";
};

/**
 * Version of {@link pushMessageContentBasicGroupChatCreate} for method parameters.
 *
 * A newly created basic group
 */
export type pushMessageContentBasicGroupChatCreate$Input = {
  readonly _: "pushMessageContentBasicGroupChatCreate";
};

/**
 * New chat members were invited to a group
 */
export type pushMessageContentChatAddMembers = {
  _: "pushMessageContentChatAddMembers";

  /**
   * Name of the added member
   * @type {string} {@link string}
   */
  member_name: string;

  /**
   * True, if the current user was added to the group
   * @type {Bool} {@link Bool}
   */
  is_current_user: Bool;

  /**
   * True, if the user has returned to the group themselves
   * @type {Bool} {@link Bool}
   */
  is_returned: Bool;
};

/**
 * Version of {@link pushMessageContentChatAddMembers} for method parameters.
 *
 * New chat members were invited to a group
 */
export type pushMessageContentChatAddMembers$Input = {
  readonly _: "pushMessageContentChatAddMembers";

  /**
   * Name of the added member
   * @type {string} {@link string}
   */
  readonly member_name?: string;

  /**
   * True, if the current user was added to the group
   * @type {Bool} {@link Bool}
   */
  readonly is_current_user?: Bool$Input;

  /**
   * True, if the user has returned to the group themselves
   * @type {Bool} {@link Bool}
   */
  readonly is_returned?: Bool$Input;
};

/**
 * A chat photo was edited
 */
export type pushMessageContentChatChangePhoto = {
  _: "pushMessageContentChatChangePhoto";
};

/**
 * Version of {@link pushMessageContentChatChangePhoto} for method parameters.
 *
 * A chat photo was edited
 */
export type pushMessageContentChatChangePhoto$Input = {
  readonly _: "pushMessageContentChatChangePhoto";
};

/**
 * A chat title was edited
 */
export type pushMessageContentChatChangeTitle = {
  _: "pushMessageContentChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link pushMessageContentChatChangeTitle} for method parameters.
 *
 * A chat title was edited
 */
export type pushMessageContentChatChangeTitle$Input = {
  readonly _: "pushMessageContentChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * A chat background was edited
 */
export type pushMessageContentChatSetBackground = {
  _: "pushMessageContentChatSetBackground";

  /**
   * True, if the set background is the same as the background of the current user
   * @type {Bool} {@link Bool}
   */
  is_same: Bool;
};

/**
 * Version of {@link pushMessageContentChatSetBackground} for method parameters.
 *
 * A chat background was edited
 */
export type pushMessageContentChatSetBackground$Input = {
  readonly _: "pushMessageContentChatSetBackground";

  /**
   * True, if the set background is the same as the background of the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_same?: Bool$Input;
};

/**
 * A chat theme was edited
 */
export type pushMessageContentChatSetTheme = {
  _: "pushMessageContentChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
   * @type {string} {@link string}
   */
  theme_name: string;
};

/**
 * Version of {@link pushMessageContentChatSetTheme} for method parameters.
 *
 * A chat theme was edited
 */
export type pushMessageContentChatSetTheme$Input = {
  readonly _: "pushMessageContentChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise, the chat theme was reset to the default one
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * A chat member was deleted
 */
export type pushMessageContentChatDeleteMember = {
  _: "pushMessageContentChatDeleteMember";

  /**
   * Name of the deleted member
   * @type {string} {@link string}
   */
  member_name: string;

  /**
   * True, if the current user was deleted from the group
   * @type {Bool} {@link Bool}
   */
  is_current_user: Bool;

  /**
   * True, if the user has left the group themselves
   * @type {Bool} {@link Bool}
   */
  is_left: Bool;
};

/**
 * Version of {@link pushMessageContentChatDeleteMember} for method parameters.
 *
 * A chat member was deleted
 */
export type pushMessageContentChatDeleteMember$Input = {
  readonly _: "pushMessageContentChatDeleteMember";

  /**
   * Name of the deleted member
   * @type {string} {@link string}
   */
  readonly member_name?: string;

  /**
   * True, if the current user was deleted from the group
   * @type {Bool} {@link Bool}
   */
  readonly is_current_user?: Bool$Input;

  /**
   * True, if the user has left the group themselves
   * @type {Bool} {@link Bool}
   */
  readonly is_left?: Bool$Input;
};

/**
 * A new member joined the chat via an invite link
 */
export type pushMessageContentChatJoinByLink = {
  _: "pushMessageContentChatJoinByLink";
};

/**
 * Version of {@link pushMessageContentChatJoinByLink} for method parameters.
 *
 * A new member joined the chat via an invite link
 */
export type pushMessageContentChatJoinByLink$Input = {
  readonly _: "pushMessageContentChatJoinByLink";
};

/**
 * A new member was accepted to the chat by an administrator
 */
export type pushMessageContentChatJoinByRequest = {
  _: "pushMessageContentChatJoinByRequest";
};

/**
 * Version of {@link pushMessageContentChatJoinByRequest} for method parameters.
 *
 * A new member was accepted to the chat by an administrator
 */
export type pushMessageContentChatJoinByRequest$Input = {
  readonly _: "pushMessageContentChatJoinByRequest";
};

/**
 * A new recurring payment was made by the current user
 */
export type pushMessageContentRecurringPayment = {
  _: "pushMessageContentRecurringPayment";

  /**
   * The paid amount
   * @type {string} {@link string}
   */
  amount: string;
};

/**
 * Version of {@link pushMessageContentRecurringPayment} for method parameters.
 *
 * A new recurring payment was made by the current user
 */
export type pushMessageContentRecurringPayment$Input = {
  readonly _: "pushMessageContentRecurringPayment";

  /**
   * The paid amount
   * @type {string} {@link string}
   */
  readonly amount?: string;
};

/**
 * A profile photo was suggested to the user
 */
export type pushMessageContentSuggestProfilePhoto = {
  _: "pushMessageContentSuggestProfilePhoto";
};

/**
 * Version of {@link pushMessageContentSuggestProfilePhoto} for method parameters.
 *
 * A profile photo was suggested to the user
 */
export type pushMessageContentSuggestProfilePhoto$Input = {
  readonly _: "pushMessageContentSuggestProfilePhoto";
};

/**
 * A forwarded messages
 */
export type pushMessageContentMessageForwards = {
  _: "pushMessageContentMessageForwards";

  /**
   * Number of forwarded messages
   * @type {int32} {@link int32}
   */
  total_count: int32;
};

/**
 * Version of {@link pushMessageContentMessageForwards} for method parameters.
 *
 * A forwarded messages
 */
export type pushMessageContentMessageForwards$Input = {
  readonly _: "pushMessageContentMessageForwards";

  /**
   * Number of forwarded messages
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;
};

/**
 * A media album
 */
export type pushMessageContentMediaAlbum = {
  _: "pushMessageContentMediaAlbum";

  /**
   * Number of messages in the album
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * True, if the album has at least one photo
   * @type {Bool} {@link Bool}
   */
  has_photos: Bool;

  /**
   * True, if the album has at least one video file
   * @type {Bool} {@link Bool}
   */
  has_videos: Bool;

  /**
   * True, if the album has at least one audio file
   * @type {Bool} {@link Bool}
   */
  has_audios: Bool;

  /**
   * True, if the album has at least one document
   * @type {Bool} {@link Bool}
   */
  has_documents: Bool;
};

/**
 * Version of {@link pushMessageContentMediaAlbum} for method parameters.
 *
 * A media album
 */
export type pushMessageContentMediaAlbum$Input = {
  readonly _: "pushMessageContentMediaAlbum";

  /**
   * Number of messages in the album
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * True, if the album has at least one photo
   * @type {Bool} {@link Bool}
   */
  readonly has_photos?: Bool$Input;

  /**
   * True, if the album has at least one video file
   * @type {Bool} {@link Bool}
   */
  readonly has_videos?: Bool$Input;

  /**
   * True, if the album has at least one audio file
   * @type {Bool} {@link Bool}
   */
  readonly has_audios?: Bool$Input;

  /**
   * True, if the album has at least one document
   * @type {Bool} {@link Bool}
   */
  readonly has_documents?: Bool$Input;
};

/**
 * New message was received
 */
export type notificationTypeNewMessage = {
  _: "notificationTypeNewMessage";

  /**
   * The message
   * @type {message} {@link message}
   */
  message: message;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_preview: Bool;
};

/**
 * Version of {@link notificationTypeNewMessage} for method parameters.
 *
 * New message was received
 */
export type notificationTypeNewMessage$Input = {
  readonly _: "notificationTypeNewMessage";

  /**
   * The message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_preview?: Bool$Input;
};

/**
 * New secret chat was created
 */
export type notificationTypeNewSecretChat = {
  _: "notificationTypeNewSecretChat";
};

/**
 * Version of {@link notificationTypeNewSecretChat} for method parameters.
 *
 * New secret chat was created
 */
export type notificationTypeNewSecretChat$Input = {
  readonly _: "notificationTypeNewSecretChat";
};

/**
 * New call was received
 */
export type notificationTypeNewCall = {
  _: "notificationTypeNewCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  call_id: int32;
};

/**
 * Version of {@link notificationTypeNewCall} for method parameters.
 *
 * New call was received
 */
export type notificationTypeNewCall$Input = {
  readonly _: "notificationTypeNewCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;
};

/**
 * New message was received through a push notification
 */
export type notificationTypeNewPushMessage = {
  _: "notificationTypeNewPushMessage";

  /**
   * The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Identifier of the sender of the message. Corresponding user or chat may be inaccessible
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  sender_name: string;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * Push message content
   * @type {PushMessageContent} {@link PushMessageContent}
   */
  content: PushMessageContent;
};

/**
 * Version of {@link notificationTypeNewPushMessage} for method parameters.
 *
 * New message was received through a push notification
 */
export type notificationTypeNewPushMessage$Input = {
  readonly _: "notificationTypeNewPushMessage";

  /**
   * The message identifier. The message will not be available in the chat history, but the identifier can be used in viewMessages, or as a message to be replied in the same chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the sender of the message. Corresponding user or chat may be inaccessible
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * Push message content
   * @type {PushMessageContent} {@link PushMessageContent}
   */
  readonly content?: PushMessageContent$Input;
};

/**
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
 */
export type notificationGroupTypeMessages = {
  _: "notificationGroupTypeMessages";
};

/**
 * Version of {@link notificationGroupTypeMessages} for method parameters.
 *
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
 */
export type notificationGroupTypeMessages$Input = {
  readonly _: "notificationGroupTypeMessages";
};

/**
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
 */
export type notificationGroupTypeMentions = {
  _: "notificationGroupTypeMentions";
};

/**
 * Version of {@link notificationGroupTypeMentions} for method parameters.
 *
 * A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
 */
export type notificationGroupTypeMentions$Input = {
  readonly _: "notificationGroupTypeMentions";
};

/**
 * A group containing a notification of type notificationTypeNewSecretChat
 */
export type notificationGroupTypeSecretChat = {
  _: "notificationGroupTypeSecretChat";
};

/**
 * Version of {@link notificationGroupTypeSecretChat} for method parameters.
 *
 * A group containing a notification of type notificationTypeNewSecretChat
 */
export type notificationGroupTypeSecretChat$Input = {
  readonly _: "notificationGroupTypeSecretChat";
};

/**
 * A group containing notifications of type notificationTypeNewCall
 */
export type notificationGroupTypeCalls = {
  _: "notificationGroupTypeCalls";
};

/**
 * Version of {@link notificationGroupTypeCalls} for method parameters.
 *
 * A group containing notifications of type notificationTypeNewCall
 */
export type notificationGroupTypeCalls$Input = {
  readonly _: "notificationGroupTypeCalls";
};

/**
 * Describes a notification sound in MP3 format
 */
export type notificationSound = {
  _: "notificationSound";

  /**
   * Unique identifier of the notification sound
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Duration of the sound, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Point in time (Unix timestamp) when the sound was created
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Title of the notification sound
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Arbitrary data, defined while the sound was uploaded
   * @type {string} {@link string}
   */
  data: string;

  /**
   * File containing the sound
   * @type {file} {@link file}
   */
  sound: file;
};

/**
 * Version of {@link notificationSound} for method parameters.
 *
 * Describes a notification sound in MP3 format
 */
export type notificationSound$Input = {
  readonly _: "notificationSound";

  /**
   * Unique identifier of the notification sound
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Duration of the sound, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Point in time (Unix timestamp) when the sound was created
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Title of the notification sound
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Arbitrary data, defined while the sound was uploaded
   * @type {string} {@link string}
   */
  readonly data?: string;

  /**
   * File containing the sound
   * @type {file} {@link file}
   */
  readonly sound?: file$Input;
};

/**
 * Contains a list of notification sounds
 */
export type notificationSounds = {
  _: "notificationSounds";

  /**
   * A list of notification sounds
   * @type {vector<notificationSound>} {@link vector<notificationSound>}
   */
  notification_sounds: vector<notificationSound>;
};

/**
 * Version of {@link notificationSounds} for method parameters.
 *
 * Contains a list of notification sounds
 */
export type notificationSounds$Input = {
  readonly _: "notificationSounds";

  /**
   * A list of notification sounds
   * @type {vector<notificationSound>} {@link vector<notificationSound>}
   */
  readonly notification_sounds?: vector$Input<notificationSound$Input>;
};

/**
 * Contains information about a notification
 */
export type notification = {
  _: "notification";

  /**
   * Unique persistent identifier of this notification
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Notification date
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * True, if the notification was explicitly sent without sound
   * @type {Bool} {@link Bool}
   */
  is_silent: Bool;

  /**
   * Notification type
   * @type {NotificationType} {@link NotificationType}
   */
  type: NotificationType;
};

/**
 * Version of {@link notification} for method parameters.
 *
 * Contains information about a notification
 */
export type notification$Input = {
  readonly _: "notification";

  /**
   * Unique persistent identifier of this notification
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Notification date
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * True, if the notification was explicitly sent without sound
   * @type {Bool} {@link Bool}
   */
  readonly is_silent?: Bool$Input;

  /**
   * Notification type
   * @type {NotificationType} {@link NotificationType}
   */
  readonly type?: NotificationType$Input;
};

/**
 * Describes a group of notifications
 */
export type notificationGroup = {
  _: "notificationGroup";

  /**
   * Unique persistent auto-incremented from 1 identifier of the notification group
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Type of the group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  type: NotificationGroupType;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Total number of active notifications in the group
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * The list of active notifications
   * @type {vector<notification>} {@link vector<notification>}
   */
  notifications: vector<notification>;
};

/**
 * Version of {@link notificationGroup} for method parameters.
 *
 * Describes a group of notifications
 */
export type notificationGroup$Input = {
  readonly _: "notificationGroup";

  /**
   * Unique persistent auto-incremented from 1 identifier of the notification group
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Type of the group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  readonly type?: NotificationGroupType$Input;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Total number of active notifications in the group
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * The list of active notifications
   * @type {vector<notification>} {@link vector<notification>}
   */
  readonly notifications?: vector$Input<notification$Input>;
};

/**
 * Represents a boolean option
 */
export type optionValueBoolean = {
  _: "optionValueBoolean";

  /**
   * The value of the option
   * @type {Bool} {@link Bool}
   */
  value: Bool;
};

/**
 * Version of {@link optionValueBoolean} for method parameters.
 *
 * Represents a boolean option
 */
export type optionValueBoolean$Input = {
  readonly _: "optionValueBoolean";

  /**
   * The value of the option
   * @type {Bool} {@link Bool}
   */
  readonly value?: Bool$Input;
};

/**
 * Represents an unknown option or an option which has a default value
 */
export type optionValueEmpty = {
  _: "optionValueEmpty";
};

/**
 * Version of {@link optionValueEmpty} for method parameters.
 *
 * Represents an unknown option or an option which has a default value
 */
export type optionValueEmpty$Input = {
  readonly _: "optionValueEmpty";
};

/**
 * Represents an integer option
 */
export type optionValueInteger = {
  _: "optionValueInteger";

  /**
   * The value of the option
   * @type {int64} {@link int64}
   */
  value: int64;
};

/**
 * Version of {@link optionValueInteger} for method parameters.
 *
 * Represents an integer option
 */
export type optionValueInteger$Input = {
  readonly _: "optionValueInteger";

  /**
   * The value of the option
   * @type {int64} {@link int64}
   */
  readonly value?: int64$Input;
};

/**
 * Represents a string option
 */
export type optionValueString = {
  _: "optionValueString";

  /**
   * The value of the option
   * @type {string} {@link string}
   */
  value: string;
};

/**
 * Version of {@link optionValueString} for method parameters.
 *
 * Represents a string option
 */
export type optionValueString$Input = {
  readonly _: "optionValueString";

  /**
   * The value of the option
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/**
 * Represents one member of a JSON object
 */
export type jsonObjectMember = {
  _: "jsonObjectMember";

  /**
   * Member's key
   * @type {string} {@link string}
   */
  key: string;

  /**
   * Member's value
   * @type {JsonValue} {@link JsonValue}
   */
  value: JsonValue;
};

/**
 * Version of {@link jsonObjectMember} for method parameters.
 *
 * Represents one member of a JSON object
 */
export type jsonObjectMember$Input = {
  readonly _: "jsonObjectMember";

  /**
   * Member's key
   * @type {string} {@link string}
   */
  readonly key?: string;

  /**
   * Member's value
   * @type {JsonValue} {@link JsonValue}
   */
  readonly value?: JsonValue$Input;
};

/**
 * Represents a null JSON value
 */
export type jsonValueNull = {
  _: "jsonValueNull";
};

/**
 * Version of {@link jsonValueNull} for method parameters.
 *
 * Represents a null JSON value
 */
export type jsonValueNull$Input = {
  readonly _: "jsonValueNull";
};

/**
 * Represents a boolean JSON value
 */
export type jsonValueBoolean = {
  _: "jsonValueBoolean";

  /**
   * The value
   * @type {Bool} {@link Bool}
   */
  value: Bool;
};

/**
 * Version of {@link jsonValueBoolean} for method parameters.
 *
 * Represents a boolean JSON value
 */
export type jsonValueBoolean$Input = {
  readonly _: "jsonValueBoolean";

  /**
   * The value
   * @type {Bool} {@link Bool}
   */
  readonly value?: Bool$Input;
};

/**
 * Represents a numeric JSON value
 */
export type jsonValueNumber = {
  _: "jsonValueNumber";

  /**
   * The value
   * @type {double} {@link double}
   */
  value: double;
};

/**
 * Version of {@link jsonValueNumber} for method parameters.
 *
 * Represents a numeric JSON value
 */
export type jsonValueNumber$Input = {
  readonly _: "jsonValueNumber";

  /**
   * The value
   * @type {double} {@link double}
   */
  readonly value?: double;
};

/**
 * Represents a string JSON value
 */
export type jsonValueString = {
  _: "jsonValueString";

  /**
   * The value
   * @type {string} {@link string}
   */
  value: string;
};

/**
 * Version of {@link jsonValueString} for method parameters.
 *
 * Represents a string JSON value
 */
export type jsonValueString$Input = {
  readonly _: "jsonValueString";

  /**
   * The value
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/**
 * Represents a JSON array
 */
export type jsonValueArray = {
  _: "jsonValueArray";

  /**
   * The list of array elements
   * @type {vector<JsonValue>} {@link vector<JsonValue>}
   */
  values: vector<JsonValue>;
};

/**
 * Version of {@link jsonValueArray} for method parameters.
 *
 * Represents a JSON array
 */
export type jsonValueArray$Input = {
  readonly _: "jsonValueArray";

  /**
   * The list of array elements
   * @type {vector<JsonValue>} {@link vector<JsonValue>}
   */
  readonly values?: vector$Input<JsonValue$Input>;
};

/**
 * Represents a JSON object
 */
export type jsonValueObject = {
  _: "jsonValueObject";

  /**
   * The list of object members
   * @type {vector<jsonObjectMember>} {@link vector<jsonObjectMember>}
   */
  members: vector<jsonObjectMember>;
};

/**
 * Version of {@link jsonValueObject} for method parameters.
 *
 * Represents a JSON object
 */
export type jsonValueObject$Input = {
  readonly _: "jsonValueObject";

  /**
   * The list of object members
   * @type {vector<jsonObjectMember>} {@link vector<jsonObjectMember>}
   */
  readonly members?: vector$Input<jsonObjectMember$Input>;
};

/**
 * The story can be viewed by everyone
 */
export type storyPrivacySettingsEveryone = {
  _: "storyPrivacySettingsEveryone";

  /**
   * Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
   * @type {vector<int53>} {@link vector<int53>}
   */
  except_user_ids: vector<int53>;
};

/**
 * Version of {@link storyPrivacySettingsEveryone} for method parameters.
 *
 * The story can be viewed by everyone
 */
export type storyPrivacySettingsEveryone$Input = {
  readonly _: "storyPrivacySettingsEveryone";

  /**
   * Identifiers of the users that can't see the story; always unknown and empty for non-owned stories
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly except_user_ids?: vector$Input<int53>;
};

/**
 * The story can be viewed by all contacts except chosen users
 */
export type storyPrivacySettingsContacts = {
  _: "storyPrivacySettingsContacts";

  /**
   * User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
   * @type {vector<int53>} {@link vector<int53>}
   */
  except_user_ids: vector<int53>;
};

/**
 * Version of {@link storyPrivacySettingsContacts} for method parameters.
 *
 * The story can be viewed by all contacts except chosen users
 */
export type storyPrivacySettingsContacts$Input = {
  readonly _: "storyPrivacySettingsContacts";

  /**
   * User identifiers of the contacts that can't see the story; always unknown and empty for non-owned stories
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly except_user_ids?: vector$Input<int53>;
};

/**
 * The story can be viewed by all close friends
 */
export type storyPrivacySettingsCloseFriends = {
  _: "storyPrivacySettingsCloseFriends";
};

/**
 * Version of {@link storyPrivacySettingsCloseFriends} for method parameters.
 *
 * The story can be viewed by all close friends
 */
export type storyPrivacySettingsCloseFriends$Input = {
  readonly _: "storyPrivacySettingsCloseFriends";
};

/**
 * The story can be viewed by certain specified users
 */
export type storyPrivacySettingsSelectedUsers = {
  _: "storyPrivacySettingsSelectedUsers";

  /**
   * Identifiers of the users; always unknown and empty for non-owned stories
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link storyPrivacySettingsSelectedUsers} for method parameters.
 *
 * The story can be viewed by certain specified users
 */
export type storyPrivacySettingsSelectedUsers$Input = {
  readonly _: "storyPrivacySettingsSelectedUsers";

  /**
   * Identifiers of the users; always unknown and empty for non-owned stories
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * A rule to allow all users to do something
 */
export type userPrivacySettingRuleAllowAll = {
  _: "userPrivacySettingRuleAllowAll";
};

/**
 * Version of {@link userPrivacySettingRuleAllowAll} for method parameters.
 *
 * A rule to allow all users to do something
 */
export type userPrivacySettingRuleAllowAll$Input = {
  readonly _: "userPrivacySettingRuleAllowAll";
};

/**
 * A rule to allow all contacts of the user to do something
 */
export type userPrivacySettingRuleAllowContacts = {
  _: "userPrivacySettingRuleAllowContacts";
};

/**
 * Version of {@link userPrivacySettingRuleAllowContacts} for method parameters.
 *
 * A rule to allow all contacts of the user to do something
 */
export type userPrivacySettingRuleAllowContacts$Input = {
  readonly _: "userPrivacySettingRuleAllowContacts";
};

/**
 * A rule to allow certain specified users to do something
 */
export type userPrivacySettingRuleAllowUsers = {
  _: "userPrivacySettingRuleAllowUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link userPrivacySettingRuleAllowUsers} for method parameters.
 *
 * A rule to allow certain specified users to do something
 */
export type userPrivacySettingRuleAllowUsers$Input = {
  readonly _: "userPrivacySettingRuleAllowUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * A rule to allow all members of certain specified basic groups and supergroups to doing something
 */
export type userPrivacySettingRuleAllowChatMembers = {
  _: "userPrivacySettingRuleAllowChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

/**
 * Version of {@link userPrivacySettingRuleAllowChatMembers} for method parameters.
 *
 * A rule to allow all members of certain specified basic groups and supergroups to doing something
 */
export type userPrivacySettingRuleAllowChatMembers$Input = {
  readonly _: "userPrivacySettingRuleAllowChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * A rule to restrict all users from doing something
 */
export type userPrivacySettingRuleRestrictAll = {
  _: "userPrivacySettingRuleRestrictAll";
};

/**
 * Version of {@link userPrivacySettingRuleRestrictAll} for method parameters.
 *
 * A rule to restrict all users from doing something
 */
export type userPrivacySettingRuleRestrictAll$Input = {
  readonly _: "userPrivacySettingRuleRestrictAll";
};

/**
 * A rule to restrict all contacts of the user from doing something
 */
export type userPrivacySettingRuleRestrictContacts = {
  _: "userPrivacySettingRuleRestrictContacts";
};

/**
 * Version of {@link userPrivacySettingRuleRestrictContacts} for method parameters.
 *
 * A rule to restrict all contacts of the user from doing something
 */
export type userPrivacySettingRuleRestrictContacts$Input = {
  readonly _: "userPrivacySettingRuleRestrictContacts";
};

/**
 * A rule to restrict all specified users from doing something
 */
export type userPrivacySettingRuleRestrictUsers = {
  _: "userPrivacySettingRuleRestrictUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link userPrivacySettingRuleRestrictUsers} for method parameters.
 *
 * A rule to restrict all specified users from doing something
 */
export type userPrivacySettingRuleRestrictUsers$Input = {
  readonly _: "userPrivacySettingRuleRestrictUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * A rule to restrict all members of specified basic groups and supergroups from doing something
 */
export type userPrivacySettingRuleRestrictChatMembers = {
  _: "userPrivacySettingRuleRestrictChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

/**
 * Version of {@link userPrivacySettingRuleRestrictChatMembers} for method parameters.
 *
 * A rule to restrict all members of specified basic groups and supergroups from doing something
 */
export type userPrivacySettingRuleRestrictChatMembers$Input = {
  readonly _: "userPrivacySettingRuleRestrictChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
 */
export type userPrivacySettingRules = {
  _: "userPrivacySettingRules";

  /**
   * A list of rules
   * @type {vector<UserPrivacySettingRule>} {@link vector<UserPrivacySettingRule>}
   */
  rules: vector<UserPrivacySettingRule>;
};

/**
 * Version of {@link userPrivacySettingRules} for method parameters.
 *
 * A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
 */
export type userPrivacySettingRules$Input = {
  readonly _: "userPrivacySettingRules";

  /**
   * A list of rules
   * @type {vector<UserPrivacySettingRule>} {@link vector<UserPrivacySettingRule>}
   */
  readonly rules?: vector$Input<UserPrivacySettingRule$Input>;
};

/**
 * A privacy setting for managing whether the user's online status is visible
 */
export type userPrivacySettingShowStatus = {
  _: "userPrivacySettingShowStatus";
};

/**
 * Version of {@link userPrivacySettingShowStatus} for method parameters.
 *
 * A privacy setting for managing whether the user's online status is visible
 */
export type userPrivacySettingShowStatus$Input = {
  readonly _: "userPrivacySettingShowStatus";
};

/**
 * A privacy setting for managing whether the user's profile photo is visible
 */
export type userPrivacySettingShowProfilePhoto = {
  _: "userPrivacySettingShowProfilePhoto";
};

/**
 * Version of {@link userPrivacySettingShowProfilePhoto} for method parameters.
 *
 * A privacy setting for managing whether the user's profile photo is visible
 */
export type userPrivacySettingShowProfilePhoto$Input = {
  readonly _: "userPrivacySettingShowProfilePhoto";
};

/**
 * A privacy setting for managing whether a link to the user's account is included in forwarded messages
 */
export type userPrivacySettingShowLinkInForwardedMessages = {
  _: "userPrivacySettingShowLinkInForwardedMessages";
};

/**
 * Version of {@link userPrivacySettingShowLinkInForwardedMessages} for method parameters.
 *
 * A privacy setting for managing whether a link to the user's account is included in forwarded messages
 */
export type userPrivacySettingShowLinkInForwardedMessages$Input = {
  readonly _: "userPrivacySettingShowLinkInForwardedMessages";
};

/**
 * A privacy setting for managing whether the user's phone number is visible
 */
export type userPrivacySettingShowPhoneNumber = {
  _: "userPrivacySettingShowPhoneNumber";
};

/**
 * Version of {@link userPrivacySettingShowPhoneNumber} for method parameters.
 *
 * A privacy setting for managing whether the user's phone number is visible
 */
export type userPrivacySettingShowPhoneNumber$Input = {
  readonly _: "userPrivacySettingShowPhoneNumber";
};

/**
 * A privacy setting for managing whether the user's bio is visible
 */
export type userPrivacySettingShowBio = {
  _: "userPrivacySettingShowBio";
};

/**
 * Version of {@link userPrivacySettingShowBio} for method parameters.
 *
 * A privacy setting for managing whether the user's bio is visible
 */
export type userPrivacySettingShowBio$Input = {
  readonly _: "userPrivacySettingShowBio";
};

/**
 * A privacy setting for managing whether the user can be invited to chats
 */
export type userPrivacySettingAllowChatInvites = {
  _: "userPrivacySettingAllowChatInvites";
};

/**
 * Version of {@link userPrivacySettingAllowChatInvites} for method parameters.
 *
 * A privacy setting for managing whether the user can be invited to chats
 */
export type userPrivacySettingAllowChatInvites$Input = {
  readonly _: "userPrivacySettingAllowChatInvites";
};

/**
 * A privacy setting for managing whether the user can be called
 */
export type userPrivacySettingAllowCalls = {
  _: "userPrivacySettingAllowCalls";
};

/**
 * Version of {@link userPrivacySettingAllowCalls} for method parameters.
 *
 * A privacy setting for managing whether the user can be called
 */
export type userPrivacySettingAllowCalls$Input = {
  readonly _: "userPrivacySettingAllowCalls";
};

/**
 * A privacy setting for managing whether peer-to-peer connections can be used for calls
 */
export type userPrivacySettingAllowPeerToPeerCalls = {
  _: "userPrivacySettingAllowPeerToPeerCalls";
};

/**
 * Version of {@link userPrivacySettingAllowPeerToPeerCalls} for method parameters.
 *
 * A privacy setting for managing whether peer-to-peer connections can be used for calls
 */
export type userPrivacySettingAllowPeerToPeerCalls$Input = {
  readonly _: "userPrivacySettingAllowPeerToPeerCalls";
};

/**
 * A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
 */
export type userPrivacySettingAllowFindingByPhoneNumber = {
  _: "userPrivacySettingAllowFindingByPhoneNumber";
};

/**
 * Version of {@link userPrivacySettingAllowFindingByPhoneNumber} for method parameters.
 *
 * A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
 */
export type userPrivacySettingAllowFindingByPhoneNumber$Input = {
  readonly _: "userPrivacySettingAllowFindingByPhoneNumber";
};

/**
 * A privacy setting for managing whether the user can receive voice and video messages in private chats
 */
export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = {
  _: "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages";
};

/**
 * Version of {@link userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages} for method parameters.
 *
 * A privacy setting for managing whether the user can receive voice and video messages in private chats
 */
export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input = {
  readonly _: "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages";
};

/**
 * Contains information about the period of inactivity after which the current user's account will automatically be deleted
 */
export type accountTtl = {
  _: "accountTtl";

  /**
   * Number of days of inactivity before the account will be flagged for deletion; 30-366 days
   * @type {int32} {@link int32}
   */
  days: int32;
};

/**
 * Version of {@link accountTtl} for method parameters.
 *
 * Contains information about the period of inactivity after which the current user's account will automatically be deleted
 */
export type accountTtl$Input = {
  readonly _: "accountTtl";

  /**
   * Number of days of inactivity before the account will be flagged for deletion; 30-366 days
   * @type {int32} {@link int32}
   */
  readonly days?: int32;
};

/**
 * Contains default auto-delete timer setting for new chats
 */
export type messageAutoDeleteTime = {
  _: "messageAutoDeleteTime";

  /**
   * Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  time: int32;
};

/**
 * Version of {@link messageAutoDeleteTime} for method parameters.
 *
 * Contains default auto-delete timer setting for new chats
 */
export type messageAutoDeleteTime$Input = {
  readonly _: "messageAutoDeleteTime";

  /**
   * Message auto-delete time, in seconds. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly time?: int32;
};

/**
 * The session is running on an Android device
 */
export type sessionTypeAndroid = {
  _: "sessionTypeAndroid";
};

/**
 * Version of {@link sessionTypeAndroid} for method parameters.
 *
 * The session is running on an Android device
 */
export type sessionTypeAndroid$Input = {
  readonly _: "sessionTypeAndroid";
};

/**
 * The session is running on a generic Apple device
 */
export type sessionTypeApple = {
  _: "sessionTypeApple";
};

/**
 * Version of {@link sessionTypeApple} for method parameters.
 *
 * The session is running on a generic Apple device
 */
export type sessionTypeApple$Input = {
  readonly _: "sessionTypeApple";
};

/**
 * The session is running on the Brave browser
 */
export type sessionTypeBrave = {
  _: "sessionTypeBrave";
};

/**
 * Version of {@link sessionTypeBrave} for method parameters.
 *
 * The session is running on the Brave browser
 */
export type sessionTypeBrave$Input = {
  readonly _: "sessionTypeBrave";
};

/**
 * The session is running on the Chrome browser
 */
export type sessionTypeChrome = {
  _: "sessionTypeChrome";
};

/**
 * Version of {@link sessionTypeChrome} for method parameters.
 *
 * The session is running on the Chrome browser
 */
export type sessionTypeChrome$Input = {
  readonly _: "sessionTypeChrome";
};

/**
 * The session is running on the Edge browser
 */
export type sessionTypeEdge = {
  _: "sessionTypeEdge";
};

/**
 * Version of {@link sessionTypeEdge} for method parameters.
 *
 * The session is running on the Edge browser
 */
export type sessionTypeEdge$Input = {
  readonly _: "sessionTypeEdge";
};

/**
 * The session is running on the Firefox browser
 */
export type sessionTypeFirefox = {
  _: "sessionTypeFirefox";
};

/**
 * Version of {@link sessionTypeFirefox} for method parameters.
 *
 * The session is running on the Firefox browser
 */
export type sessionTypeFirefox$Input = {
  readonly _: "sessionTypeFirefox";
};

/**
 * The session is running on an iPad device
 */
export type sessionTypeIpad = {
  _: "sessionTypeIpad";
};

/**
 * Version of {@link sessionTypeIpad} for method parameters.
 *
 * The session is running on an iPad device
 */
export type sessionTypeIpad$Input = {
  readonly _: "sessionTypeIpad";
};

/**
 * The session is running on an iPhone device
 */
export type sessionTypeIphone = {
  _: "sessionTypeIphone";
};

/**
 * Version of {@link sessionTypeIphone} for method parameters.
 *
 * The session is running on an iPhone device
 */
export type sessionTypeIphone$Input = {
  readonly _: "sessionTypeIphone";
};

/**
 * The session is running on a Linux device
 */
export type sessionTypeLinux = {
  _: "sessionTypeLinux";
};

/**
 * Version of {@link sessionTypeLinux} for method parameters.
 *
 * The session is running on a Linux device
 */
export type sessionTypeLinux$Input = {
  readonly _: "sessionTypeLinux";
};

/**
 * The session is running on a Mac device
 */
export type sessionTypeMac = {
  _: "sessionTypeMac";
};

/**
 * Version of {@link sessionTypeMac} for method parameters.
 *
 * The session is running on a Mac device
 */
export type sessionTypeMac$Input = {
  readonly _: "sessionTypeMac";
};

/**
 * The session is running on the Opera browser
 */
export type sessionTypeOpera = {
  _: "sessionTypeOpera";
};

/**
 * Version of {@link sessionTypeOpera} for method parameters.
 *
 * The session is running on the Opera browser
 */
export type sessionTypeOpera$Input = {
  readonly _: "sessionTypeOpera";
};

/**
 * The session is running on the Safari browser
 */
export type sessionTypeSafari = {
  _: "sessionTypeSafari";
};

/**
 * Version of {@link sessionTypeSafari} for method parameters.
 *
 * The session is running on the Safari browser
 */
export type sessionTypeSafari$Input = {
  readonly _: "sessionTypeSafari";
};

/**
 * The session is running on an Ubuntu device
 */
export type sessionTypeUbuntu = {
  _: "sessionTypeUbuntu";
};

/**
 * Version of {@link sessionTypeUbuntu} for method parameters.
 *
 * The session is running on an Ubuntu device
 */
export type sessionTypeUbuntu$Input = {
  readonly _: "sessionTypeUbuntu";
};

/**
 * The session is running on an unknown type of device
 */
export type sessionTypeUnknown = {
  _: "sessionTypeUnknown";
};

/**
 * Version of {@link sessionTypeUnknown} for method parameters.
 *
 * The session is running on an unknown type of device
 */
export type sessionTypeUnknown$Input = {
  readonly _: "sessionTypeUnknown";
};

/**
 * The session is running on the Vivaldi browser
 */
export type sessionTypeVivaldi = {
  _: "sessionTypeVivaldi";
};

/**
 * Version of {@link sessionTypeVivaldi} for method parameters.
 *
 * The session is running on the Vivaldi browser
 */
export type sessionTypeVivaldi$Input = {
  readonly _: "sessionTypeVivaldi";
};

/**
 * The session is running on a Windows device
 */
export type sessionTypeWindows = {
  _: "sessionTypeWindows";
};

/**
 * Version of {@link sessionTypeWindows} for method parameters.
 *
 * The session is running on a Windows device
 */
export type sessionTypeWindows$Input = {
  readonly _: "sessionTypeWindows";
};

/**
 * The session is running on an Xbox console
 */
export type sessionTypeXbox = {
  _: "sessionTypeXbox";
};

/**
 * Version of {@link sessionTypeXbox} for method parameters.
 *
 * The session is running on an Xbox console
 */
export type sessionTypeXbox$Input = {
  readonly _: "sessionTypeXbox";
};

/**
 * Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
 */
export type session = {
  _: "session";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * True, if this session is the current session
   * @type {Bool} {@link Bool}
   */
  is_current: Bool;

  /**
   * True, if a 2-step verification password is needed to complete authorization of the session
   * @type {Bool} {@link Bool}
   */
  is_password_pending: Bool;

  /**
   * True, if the session wasn't confirmed from another session
   * @type {Bool} {@link Bool}
   */
  is_unconfirmed: Bool;

  /**
   * True, if incoming secret chats can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  can_accept_secret_chats: Bool;

  /**
   * True, if incoming calls can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  can_accept_calls: Bool;

  /**
   * Session type based on the system and application version, which can be used to display a corresponding icon
   * @type {SessionType} {@link SessionType}
   */
  type: SessionType;

  /**
   * Telegram API identifier, as provided by the application
   * @type {int32} {@link int32}
   */
  api_id: int32;

  /**
   * Name of the application, as provided by the application
   * @type {string} {@link string}
   */
  application_name: string;

  /**
   * The version of the application, as provided by the application
   * @type {string} {@link string}
   */
  application_version: string;

  /**
   * True, if the application is an official application or uses the api_id of an official application
   * @type {Bool} {@link Bool}
   */
  is_official_application: Bool;

  /**
   * Model of the device the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  device_model: string;

  /**
   * Operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  platform: string;

  /**
   * Version of the operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  system_version: string;

  /**
   * Point in time (Unix timestamp) when the user has logged in
   * @type {int32} {@link int32}
   */
  log_in_date: int32;

  /**
   * Point in time (Unix timestamp) when the session was last used
   * @type {int32} {@link int32}
   */
  last_active_date: int32;

  /**
   * IP address from which the session was created, in human-readable format
   * @type {string} {@link string}
   */
  ip_address: string;

  /**
   * A human-readable description of the location from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  location: string;
};

/**
 * Version of {@link session} for method parameters.
 *
 * Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
 */
export type session$Input = {
  readonly _: "session";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * True, if this session is the current session
   * @type {Bool} {@link Bool}
   */
  readonly is_current?: Bool$Input;

  /**
   * True, if a 2-step verification password is needed to complete authorization of the session
   * @type {Bool} {@link Bool}
   */
  readonly is_password_pending?: Bool$Input;

  /**
   * True, if the session wasn't confirmed from another session
   * @type {Bool} {@link Bool}
   */
  readonly is_unconfirmed?: Bool$Input;

  /**
   * True, if incoming secret chats can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  readonly can_accept_secret_chats?: Bool$Input;

  /**
   * True, if incoming calls can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  readonly can_accept_calls?: Bool$Input;

  /**
   * Session type based on the system and application version, which can be used to display a corresponding icon
   * @type {SessionType} {@link SessionType}
   */
  readonly type?: SessionType$Input;

  /**
   * Telegram API identifier, as provided by the application
   * @type {int32} {@link int32}
   */
  readonly api_id?: int32;

  /**
   * Name of the application, as provided by the application
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * The version of the application, as provided by the application
   * @type {string} {@link string}
   */
  readonly application_version?: string;

  /**
   * True, if the application is an official application or uses the api_id of an official application
   * @type {Bool} {@link Bool}
   */
  readonly is_official_application?: Bool$Input;

  /**
   * Model of the device the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  readonly device_model?: string;

  /**
   * Operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  readonly platform?: string;

  /**
   * Version of the operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  readonly system_version?: string;

  /**
   * Point in time (Unix timestamp) when the user has logged in
   * @type {int32} {@link int32}
   */
  readonly log_in_date?: int32;

  /**
   * Point in time (Unix timestamp) when the session was last used
   * @type {int32} {@link int32}
   */
  readonly last_active_date?: int32;

  /**
   * IP address from which the session was created, in human-readable format
   * @type {string} {@link string}
   */
  readonly ip_address?: string;

  /**
   * A human-readable description of the location from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  readonly location?: string;
};

/**
 * Contains a list of sessions
 */
export type sessions = {
  _: "sessions";

  /**
   * List of sessions
   * @type {vector<session>} {@link vector<session>}
   */
  sessions: vector<session>;

  /**
   * Number of days of inactivity before sessions will automatically be terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  inactive_session_ttl_days: int32;
};

/**
 * Version of {@link sessions} for method parameters.
 *
 * Contains a list of sessions
 */
export type sessions$Input = {
  readonly _: "sessions";

  /**
   * List of sessions
   * @type {vector<session>} {@link vector<session>}
   */
  readonly sessions?: vector$Input<session$Input>;

  /**
   * Number of days of inactivity before sessions will automatically be terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  readonly inactive_session_ttl_days?: int32;
};

/**
 * Contains information about an unconfirmed session
 */
export type unconfirmedSession = {
  _: "unconfirmedSession";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Point in time (Unix timestamp) when the user has logged in
   * @type {int32} {@link int32}
   */
  log_in_date: int32;

  /**
   * Model of the device that was used for the session creation, as provided by the application
   * @type {string} {@link string}
   */
  device_model: string;

  /**
   * A human-readable description of the location from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  location: string;
};

/**
 * Version of {@link unconfirmedSession} for method parameters.
 *
 * Contains information about an unconfirmed session
 */
export type unconfirmedSession$Input = {
  readonly _: "unconfirmedSession";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Point in time (Unix timestamp) when the user has logged in
   * @type {int32} {@link int32}
   */
  readonly log_in_date?: int32;

  /**
   * Model of the device that was used for the session creation, as provided by the application
   * @type {string} {@link string}
   */
  readonly device_model?: string;

  /**
   * A human-readable description of the location from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  readonly location?: string;
};

/**
 * Contains information about one website the current user is logged in with Telegram
 */
export type connectedWebsite = {
  _: "connectedWebsite";

  /**
   * Website identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * The domain name of the website
   * @type {string} {@link string}
   */
  domain_name: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * The version of a browser used to log in
   * @type {string} {@link string}
   */
  browser: string;

  /**
   * Operating system the browser is running on
   * @type {string} {@link string}
   */
  platform: string;

  /**
   * Point in time (Unix timestamp) when the user was logged in
   * @type {int32} {@link int32}
   */
  log_in_date: int32;

  /**
   * Point in time (Unix timestamp) when obtained authorization was last used
   * @type {int32} {@link int32}
   */
  last_active_date: int32;

  /**
   * IP address from which the user was logged in, in human-readable format
   * @type {string} {@link string}
   */
  ip_address: string;

  /**
   * Human-readable description of a country and a region from which the user was logged in, based on the IP address
   * @type {string} {@link string}
   */
  location: string;
};

/**
 * Version of {@link connectedWebsite} for method parameters.
 *
 * Contains information about one website the current user is logged in with Telegram
 */
export type connectedWebsite$Input = {
  readonly _: "connectedWebsite";

  /**
   * Website identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * The domain name of the website
   * @type {string} {@link string}
   */
  readonly domain_name?: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The version of a browser used to log in
   * @type {string} {@link string}
   */
  readonly browser?: string;

  /**
   * Operating system the browser is running on
   * @type {string} {@link string}
   */
  readonly platform?: string;

  /**
   * Point in time (Unix timestamp) when the user was logged in
   * @type {int32} {@link int32}
   */
  readonly log_in_date?: int32;

  /**
   * Point in time (Unix timestamp) when obtained authorization was last used
   * @type {int32} {@link int32}
   */
  readonly last_active_date?: int32;

  /**
   * IP address from which the user was logged in, in human-readable format
   * @type {string} {@link string}
   */
  readonly ip_address?: string;

  /**
   * Human-readable description of a country and a region from which the user was logged in, based on the IP address
   * @type {string} {@link string}
   */
  readonly location?: string;
};

/**
 * Contains a list of websites the current user is logged in with Telegram
 */
export type connectedWebsites = {
  _: "connectedWebsites";

  /**
   * List of connected websites
   * @type {vector<connectedWebsite>} {@link vector<connectedWebsite>}
   */
  websites: vector<connectedWebsite>;
};

/**
 * Version of {@link connectedWebsites} for method parameters.
 *
 * Contains a list of websites the current user is logged in with Telegram
 */
export type connectedWebsites$Input = {
  readonly _: "connectedWebsites";

  /**
   * List of connected websites
   * @type {vector<connectedWebsite>} {@link vector<connectedWebsite>}
   */
  readonly websites?: vector$Input<connectedWebsite$Input>;
};

/**
 * The chat contains spam messages
 */
export type reportReasonSpam = {
  _: "reportReasonSpam";
};

/**
 * Version of {@link reportReasonSpam} for method parameters.
 *
 * The chat contains spam messages
 */
export type reportReasonSpam$Input = {
  readonly _: "reportReasonSpam";
};

/**
 * The chat promotes violence
 */
export type reportReasonViolence = {
  _: "reportReasonViolence";
};

/**
 * Version of {@link reportReasonViolence} for method parameters.
 *
 * The chat promotes violence
 */
export type reportReasonViolence$Input = {
  readonly _: "reportReasonViolence";
};

/**
 * The chat contains pornographic messages
 */
export type reportReasonPornography = {
  _: "reportReasonPornography";
};

/**
 * Version of {@link reportReasonPornography} for method parameters.
 *
 * The chat contains pornographic messages
 */
export type reportReasonPornography$Input = {
  readonly _: "reportReasonPornography";
};

/**
 * The chat has child abuse related content
 */
export type reportReasonChildAbuse = {
  _: "reportReasonChildAbuse";
};

/**
 * Version of {@link reportReasonChildAbuse} for method parameters.
 *
 * The chat has child abuse related content
 */
export type reportReasonChildAbuse$Input = {
  readonly _: "reportReasonChildAbuse";
};

/**
 * The chat contains copyrighted content
 */
export type reportReasonCopyright = {
  _: "reportReasonCopyright";
};

/**
 * Version of {@link reportReasonCopyright} for method parameters.
 *
 * The chat contains copyrighted content
 */
export type reportReasonCopyright$Input = {
  readonly _: "reportReasonCopyright";
};

/**
 * The location-based chat is unrelated to its stated location
 */
export type reportReasonUnrelatedLocation = {
  _: "reportReasonUnrelatedLocation";
};

/**
 * Version of {@link reportReasonUnrelatedLocation} for method parameters.
 *
 * The location-based chat is unrelated to its stated location
 */
export type reportReasonUnrelatedLocation$Input = {
  readonly _: "reportReasonUnrelatedLocation";
};

/**
 * The chat represents a fake account
 */
export type reportReasonFake = {
  _: "reportReasonFake";
};

/**
 * Version of {@link reportReasonFake} for method parameters.
 *
 * The chat represents a fake account
 */
export type reportReasonFake$Input = {
  readonly _: "reportReasonFake";
};

/**
 * The chat has illegal drugs related content
 */
export type reportReasonIllegalDrugs = {
  _: "reportReasonIllegalDrugs";
};

/**
 * Version of {@link reportReasonIllegalDrugs} for method parameters.
 *
 * The chat has illegal drugs related content
 */
export type reportReasonIllegalDrugs$Input = {
  readonly _: "reportReasonIllegalDrugs";
};

/**
 * The chat contains messages with personal details
 */
export type reportReasonPersonalDetails = {
  _: "reportReasonPersonalDetails";
};

/**
 * Version of {@link reportReasonPersonalDetails} for method parameters.
 *
 * The chat contains messages with personal details
 */
export type reportReasonPersonalDetails$Input = {
  readonly _: "reportReasonPersonalDetails";
};

/**
 * A custom reason provided by the user
 */
export type reportReasonCustom = {
  _: "reportReasonCustom";
};

/**
 * Version of {@link reportReasonCustom} for method parameters.
 *
 * A custom reason provided by the user
 */
export type reportReasonCustom$Input = {
  readonly _: "reportReasonCustom";
};

/**
 * The currently opened chat needs to be kept
 */
export type targetChatCurrent = {
  _: "targetChatCurrent";
};

/**
 * Version of {@link targetChatCurrent} for method parameters.
 *
 * The currently opened chat needs to be kept
 */
export type targetChatCurrent$Input = {
  readonly _: "targetChatCurrent";
};

/**
 * The chat needs to be chosen by the user among chats of the specified types
 */
export type targetChatChosen = {
  _: "targetChatChosen";

  /**
   * True, if private chats with ordinary users are allowed
   * @type {Bool} {@link Bool}
   */
  allow_user_chats: Bool;

  /**
   * True, if private chats with other bots are allowed
   * @type {Bool} {@link Bool}
   */
  allow_bot_chats: Bool;

  /**
   * True, if basic group and supergroup chats are allowed
   * @type {Bool} {@link Bool}
   */
  allow_group_chats: Bool;

  /**
   * True, if channel chats are allowed
   * @type {Bool} {@link Bool}
   */
  allow_channel_chats: Bool;
};

/**
 * Version of {@link targetChatChosen} for method parameters.
 *
 * The chat needs to be chosen by the user among chats of the specified types
 */
export type targetChatChosen$Input = {
  readonly _: "targetChatChosen";

  /**
   * True, if private chats with ordinary users are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_user_chats?: Bool$Input;

  /**
   * True, if private chats with other bots are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_bot_chats?: Bool$Input;

  /**
   * True, if basic group and supergroup chats are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_group_chats?: Bool$Input;

  /**
   * True, if channel chats are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_channel_chats?: Bool$Input;
};

/**
 * The chat needs to be open with the provided internal link
 */
export type targetChatInternalLink = {
  _: "targetChatInternalLink";

  /**
   * An internal link pointing to the chat
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  link: InternalLinkType;
};

/**
 * Version of {@link targetChatInternalLink} for method parameters.
 *
 * The chat needs to be open with the provided internal link
 */
export type targetChatInternalLink$Input = {
  readonly _: "targetChatInternalLink";

  /**
   * An internal link pointing to the chat
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly link?: InternalLinkType$Input;
};

/**
 * The link is a link to the active sessions section of the application. Use getActiveSessions to handle the link
 */
export type internalLinkTypeActiveSessions = {
  _: "internalLinkTypeActiveSessions";
};

/**
 * Version of {@link internalLinkTypeActiveSessions} for method parameters.
 *
 * The link is a link to the active sessions section of the application. Use getActiveSessions to handle the link
 */
export type internalLinkTypeActiveSessions$Input = {
  readonly _: "internalLinkTypeActiveSessions";
};

/**
 * The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat.
 *
 * - Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then, use getAttachmentMenuBot to receive information about the bot.
 *
 * - If the bot isn't added to attachment menu, then show a disclaimer about Mini Apps being a third-party apps, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu.
 *
 * - If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot.
 *
 * - If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL
 */
export type internalLinkTypeAttachmentMenuBot = {
  _: "internalLinkTypeAttachmentMenuBot";

  /**
   * Target chat to be opened
   * @type {TargetChat} {@link TargetChat}
   */
  target_chat: TargetChat;

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link internalLinkTypeAttachmentMenuBot} for method parameters.
 *
 * The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat.
 *
 * - Then, call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then, use getAttachmentMenuBot to receive information about the bot.
 *
 * - If the bot isn't added to attachment menu, then show a disclaimer about Mini Apps being a third-party apps, ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu.
 *
 * - If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot.
 *
 * - If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL
 */
export type internalLinkTypeAttachmentMenuBot$Input = {
  readonly _: "internalLinkTypeAttachmentMenuBot";

  /**
   * Target chat to be opened
   * @type {TargetChat} {@link TargetChat}
   */
  readonly target_chat?: TargetChat$Input;

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
 */
export type internalLinkTypeAuthenticationCode = {
  _: "internalLinkTypeAuthenticationCode";

  /**
   * The authentication code
   * @type {string} {@link string}
   */
  code: string;
};

/**
 * Version of {@link internalLinkTypeAuthenticationCode} for method parameters.
 *
 * The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
 */
export type internalLinkTypeAuthenticationCode$Input = {
  readonly _: "internalLinkTypeAuthenticationCode";

  /**
   * The authentication code
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * The link is a link to a background. Call searchBackground with the given background name to process the link
 */
export type internalLinkTypeBackground = {
  _: "internalLinkTypeBackground";

  /**
   * Name of the background
   * @type {string} {@link string}
   */
  background_name: string;
};

/**
 * Version of {@link internalLinkTypeBackground} for method parameters.
 *
 * The link is a link to a background. Call searchBackground with the given background name to process the link
 */
export type internalLinkTypeBackground$Input = {
  readonly _: "internalLinkTypeBackground";

  /**
   * Name of the background
   * @type {string} {@link string}
   */
  readonly background_name?: string;
};

/**
 * The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot,
 *
 * - ask the current user to select a channel chat to add the bot to as an administrator. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator,
 *
 * - check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights
 */
export type internalLinkTypeBotAddToChannel = {
  _: "internalLinkTypeBotAddToChannel";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * Expected administrator rights for the bot
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  administrator_rights: chatAdministratorRights;
};

/**
 * Version of {@link internalLinkTypeBotAddToChannel} for method parameters.
 *
 * The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot,
 *
 * - ask the current user to select a channel chat to add the bot to as an administrator. Then, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator,
 *
 * - check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then, show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights
 */
export type internalLinkTypeBotAddToChannel$Input = {
  readonly _: "internalLinkTypeBotAddToChannel";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * Expected administrator rights for the bot
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly administrator_rights?: chatAdministratorRights$Input;
};

/**
 * The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot,
 *
 * - and then call sendBotStartMessage with the given start parameter after the button is pressed
 */
export type internalLinkTypeBotStart = {
  _: "internalLinkTypeBotStart";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * True, if sendBotStartMessage must be called automatically without showing the START button
   * @type {Bool} {@link Bool}
   */
  autostart: Bool;
};

/**
 * Version of {@link internalLinkTypeBotStart} for method parameters.
 *
 * The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot,
 *
 * - and then call sendBotStartMessage with the given start parameter after the button is pressed
 */
export type internalLinkTypeBotStart$Input = {
  readonly _: "internalLinkTypeBotStart";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * True, if sendBotStartMessage must be called automatically without showing the START button
   * @type {Bool} {@link Bool}
   */
  readonly autostart?: Bool$Input;
};

/**
 * The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups,
 *
 * - ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup.
 *
 * - If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator,
 *
 * - check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user,
 *
 * - and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat.
 *
 * - Then, if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat.
 */
export type internalLinkTypeBotStartInGroup = {
  _: "internalLinkTypeBotStartInGroup";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * Expected administrator rights for the bot; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  administrator_rights: chatAdministratorRights | null;
};

/**
 * Version of {@link internalLinkTypeBotStartInGroup} for method parameters.
 *
 * The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups,
 *
 * - ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup.
 *
 * - If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator,
 *
 * - check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user,
 *
 * - and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat.
 *
 * - Then, if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat; otherwise, just send /start message with bot's username added to the chat.
 */
export type internalLinkTypeBotStartInGroup$Input = {
  readonly _: "internalLinkTypeBotStartInGroup";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * Expected administrator rights for the bot; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly administrator_rights?: chatAdministratorRights$Input | null;
};

/**
 * The link is a link to the change phone number section of the app
 */
export type internalLinkTypeChangePhoneNumber = {
  _: "internalLinkTypeChangePhoneNumber";
};

/**
 * Version of {@link internalLinkTypeChangePhoneNumber} for method parameters.
 *
 * The link is a link to the change phone number section of the app
 */
export type internalLinkTypeChangePhoneNumber$Input = {
  readonly _: "internalLinkTypeChangePhoneNumber";
};

/**
 * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link.
 *
 * - If the chat is found, then call getChatBoostStatus and getAvailableChatBoostSlots to get the current boost status and check whether the chat can be boosted.
 *
 * - If the user wants to boost the chat and the chat can be boosted, then call boostChat
 */
export type internalLinkTypeChatBoost = {
  _: "internalLinkTypeChatBoost";

  /**
   * URL to be passed to getChatBoostLinkInfo
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link internalLinkTypeChatBoost} for method parameters.
 *
 * The link is a link to boost a Telegram chat. Call getChatBoostLinkInfo with the given URL to process the link.
 *
 * - If the chat is found, then call getChatBoostStatus and getAvailableChatBoostSlots to get the current boost status and check whether the chat can be boosted.
 *
 * - If the user wants to boost the chat and the chat can be boosted, then call boostChat
 */
export type internalLinkTypeChatBoost$Input = {
  readonly _: "internalLinkTypeChatBoost";

  /**
   * URL to be passed to getChatBoostLinkInfo
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link
 */
export type internalLinkTypeChatFolderInvite = {
  _: "internalLinkTypeChatFolderInvite";

  /**
   * Internal representation of the invite link
   * @type {string} {@link string}
   */
  invite_link: string;
};

/**
 * Version of {@link internalLinkTypeChatFolderInvite} for method parameters.
 *
 * The link is an invite link to a chat folder. Call checkChatFolderInviteLink with the given invite link to process the link
 */
export type internalLinkTypeChatFolderInvite$Input = {
  readonly _: "internalLinkTypeChatFolderInvite";

  /**
   * Internal representation of the invite link
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * The link is a link to the folder section of the app settings
 */
export type internalLinkTypeChatFolderSettings = {
  _: "internalLinkTypeChatFolderSettings";
};

/**
 * Version of {@link internalLinkTypeChatFolderSettings} for method parameters.
 *
 * The link is a link to the folder section of the app settings
 */
export type internalLinkTypeChatFolderSettings$Input = {
  readonly _: "internalLinkTypeChatFolderSettings";
};

/**
 * The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link
 */
export type internalLinkTypeChatInvite = {
  _: "internalLinkTypeChatInvite";

  /**
   * Internal representation of the invite link
   * @type {string} {@link string}
   */
  invite_link: string;
};

/**
 * Version of {@link internalLinkTypeChatInvite} for method parameters.
 *
 * The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link
 */
export type internalLinkTypeChatInvite$Input = {
  readonly _: "internalLinkTypeChatInvite";

  /**
   * Internal representation of the invite link
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * The link is a link to the default message auto-delete timer settings section of the app settings
 */
export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings = {
  _: "internalLinkTypeDefaultMessageAutoDeleteTimerSettings";
};

/**
 * Version of {@link internalLinkTypeDefaultMessageAutoDeleteTimerSettings} for method parameters.
 *
 * The link is a link to the default message auto-delete timer settings section of the app settings
 */
export type internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input = {
  readonly _: "internalLinkTypeDefaultMessageAutoDeleteTimerSettings";
};

/**
 * The link is a link to the edit profile section of the app settings
 */
export type internalLinkTypeEditProfileSettings = {
  _: "internalLinkTypeEditProfileSettings";
};

/**
 * Version of {@link internalLinkTypeEditProfileSettings} for method parameters.
 *
 * The link is a link to the edit profile section of the app settings
 */
export type internalLinkTypeEditProfileSettings$Input = {
  readonly _: "internalLinkTypeEditProfileSettings";
};

/**
 * The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
 */
export type internalLinkTypeGame = {
  _: "internalLinkTypeGame";

  /**
   * Username of the bot that owns the game
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  game_short_name: string;
};

/**
 * Version of {@link internalLinkTypeGame} for method parameters.
 *
 * The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
 */
export type internalLinkTypeGame$Input = {
  readonly _: "internalLinkTypeGame";

  /**
   * Username of the bot that owns the game
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;
};

/**
 * The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link
 */
export type internalLinkTypeInstantView = {
  _: "internalLinkTypeInstantView";

  /**
   * URL to be passed to getWebPageInstantView
   * @type {string} {@link string}
   */
  url: string;

  /**
   * An URL to open if getWebPageInstantView fails
   * @type {string} {@link string}
   */
  fallback_url: string;
};

/**
 * Version of {@link internalLinkTypeInstantView} for method parameters.
 *
 * The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link
 */
export type internalLinkTypeInstantView$Input = {
  readonly _: "internalLinkTypeInstantView";

  /**
   * URL to be passed to getWebPageInstantView
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * An URL to open if getWebPageInstantView fails
   * @type {string} {@link string}
   */
  readonly fallback_url?: string;
};

/**
 * The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link
 */
export type internalLinkTypeInvoice = {
  _: "internalLinkTypeInvoice";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  invoice_name: string;
};

/**
 * Version of {@link internalLinkTypeInvoice} for method parameters.
 *
 * The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link
 */
export type internalLinkTypeInvoice$Input = {
  readonly _: "internalLinkTypeInvoice";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  readonly invoice_name?: string;
};

/**
 * The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link
 */
export type internalLinkTypeLanguagePack = {
  _: "internalLinkTypeLanguagePack";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  language_pack_id: string;
};

/**
 * Version of {@link internalLinkTypeLanguagePack} for method parameters.
 *
 * The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link
 */
export type internalLinkTypeLanguagePack$Input = {
  readonly _: "internalLinkTypeLanguagePack";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * The link is a link to the language section of the app settings
 */
export type internalLinkTypeLanguageSettings = {
  _: "internalLinkTypeLanguageSettings";
};

/**
 * Version of {@link internalLinkTypeLanguageSettings} for method parameters.
 *
 * The link is a link to the language section of the app settings
 */
export type internalLinkTypeLanguageSettings$Input = {
  readonly _: "internalLinkTypeLanguageSettings";
};

/**
 * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link
 */
export type internalLinkTypeMessage = {
  _: "internalLinkTypeMessage";

  /**
   * URL to be passed to getMessageLinkInfo
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link internalLinkTypeMessage} for method parameters.
 *
 * The link is a link to a Telegram message or a forum topic. Call getMessageLinkInfo with the given URL to process the link
 */
export type internalLinkTypeMessage$Input = {
  readonly _: "internalLinkTypeMessage";

  /**
   * URL to be passed to getMessageLinkInfo
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
 */
export type internalLinkTypeMessageDraft = {
  _: "internalLinkTypeMessageDraft";

  /**
   * Message draft text
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
   * @type {Bool} {@link Bool}
   */
  contains_link: Bool;
};

/**
 * Version of {@link internalLinkTypeMessageDraft} for method parameters.
 *
 * The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
 */
export type internalLinkTypeMessageDraft$Input = {
  readonly _: "internalLinkTypeMessageDraft";

  /**
   * Message draft text
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
   * @type {Bool} {@link Bool}
   */
  readonly contains_link?: Bool$Input;
};

/**
 * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it
 */
export type internalLinkTypePassportDataRequest = {
  _: "internalLinkTypePassportDataRequest";

  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  scope: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  public_key: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  nonce: string;

  /**
   * An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively.
   *
   * - If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
   * @type {string} {@link string}
   */
  callback_url: string;
};

/**
 * Version of {@link internalLinkTypePassportDataRequest} for method parameters.
 *
 * The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application; otherwise, ignore it
 */
export type internalLinkTypePassportDataRequest$Input = {
  readonly _: "internalLinkTypePassportDataRequest";

  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  readonly scope?: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  readonly public_key?: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  readonly nonce?: string;

  /**
   * An HTTP URL to open once the request is finished, canceled, or failed with the parameters tg_passport=success, tg_passport=cancel, or tg_passport=error&error=... respectively.
   *
   * - If empty, then onActivityResult method must be used to return response on Android, or the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel must be opened otherwise
   * @type {string} {@link string}
   */
  readonly callback_url?: string;
};

/**
 * The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link
 */
export type internalLinkTypePhoneNumberConfirmation = {
  _: "internalLinkTypePhoneNumberConfirmation";

  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  hash: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  phone_number: string;
};

/**
 * Version of {@link internalLinkTypePhoneNumberConfirmation} for method parameters.
 *
 * The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link
 */
export type internalLinkTypePhoneNumberConfirmation$Input = {
  readonly _: "internalLinkTypePhoneNumberConfirmation";

  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  readonly hash?: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link
 */
export type internalLinkTypePremiumFeatures = {
  _: "internalLinkTypePremiumFeatures";

  /**
   * Referrer specified in the link
   * @type {string} {@link string}
   */
  referrer: string;
};

/**
 * Version of {@link internalLinkTypePremiumFeatures} for method parameters.
 *
 * The link is a link to the Premium features screen of the application from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link
 */
export type internalLinkTypePremiumFeatures$Input = {
  readonly _: "internalLinkTypePremiumFeatures";

  /**
   * Referrer specified in the link
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/**
 * The link is a link to the screen for gifting Telegram Premium subscriptions to friends
 */
export type internalLinkTypePremiumGift = {
  _: "internalLinkTypePremiumGift";

  /**
   * Referrer specified in the link
   * @type {string} {@link string}
   */
  referrer: string;
};

/**
 * Version of {@link internalLinkTypePremiumGift} for method parameters.
 *
 * The link is a link to the screen for gifting Telegram Premium subscriptions to friends
 */
export type internalLinkTypePremiumGift$Input = {
  readonly _: "internalLinkTypePremiumGift";

  /**
   * Referrer specified in the link
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/**
 * The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode with the given code to process the link. If the code is valid and the user wants to apply it, then call applyPremiumGiftCode
 */
export type internalLinkTypePremiumGiftCode = {
  _: "internalLinkTypePremiumGiftCode";

  /**
   * The Telegram Premium gift code
   * @type {string} {@link string}
   */
  code: string;
};

/**
 * Version of {@link internalLinkTypePremiumGiftCode} for method parameters.
 *
 * The link is a link with a Telegram Premium gift code. Call checkPremiumGiftCode with the given code to process the link. If the code is valid and the user wants to apply it, then call applyPremiumGiftCode
 */
export type internalLinkTypePremiumGiftCode$Input = {
  readonly _: "internalLinkTypePremiumGiftCode";

  /**
   * The Telegram Premium gift code
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * The link is a link to the privacy and security section of the app settings
 */
export type internalLinkTypePrivacyAndSecuritySettings = {
  _: "internalLinkTypePrivacyAndSecuritySettings";
};

/**
 * Version of {@link internalLinkTypePrivacyAndSecuritySettings} for method parameters.
 *
 * The link is a link to the privacy and security section of the app settings
 */
export type internalLinkTypePrivacyAndSecuritySettings$Input = {
  readonly _: "internalLinkTypePrivacyAndSecuritySettings";
};

/**
 * The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
 */
export type internalLinkTypeProxy = {
  _: "internalLinkTypeProxy";

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  server: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  port: int32;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  type: ProxyType;
};

/**
 * Version of {@link internalLinkTypeProxy} for method parameters.
 *
 * The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
 */
export type internalLinkTypeProxy$Input = {
  readonly _: "internalLinkTypeProxy";

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link
 */
export type internalLinkTypePublicChat = {
  _: "internalLinkTypePublicChat";

  /**
   * Username of the chat
   * @type {string} {@link string}
   */
  chat_username: string;
};

/**
 * Version of {@link internalLinkTypePublicChat} for method parameters.
 *
 * The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link
 */
export type internalLinkTypePublicChat$Input = {
  readonly _: "internalLinkTypePublicChat";

  /**
   * Username of the chat
   * @type {string} {@link string}
   */
  readonly chat_username?: string;
};

/**
 * The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to
 *
 * - "This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown
 */
export type internalLinkTypeQrCodeAuthentication = {
  _: "internalLinkTypeQrCodeAuthentication";
};

/**
 * Version of {@link internalLinkTypeQrCodeAuthentication} for method parameters.
 *
 * The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to
 *
 * - "This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown
 */
export type internalLinkTypeQrCodeAuthentication$Input = {
  readonly _: "internalLinkTypeQrCodeAuthentication";
};

/**
 * The link forces restore of App Store purchases when opened. For official iOS application only
 */
export type internalLinkTypeRestorePurchases = {
  _: "internalLinkTypeRestorePurchases";
};

/**
 * Version of {@link internalLinkTypeRestorePurchases} for method parameters.
 *
 * The link forces restore of App Store purchases when opened. For official iOS application only
 */
export type internalLinkTypeRestorePurchases$Input = {
  readonly _: "internalLinkTypeRestorePurchases";
};

/**
 * The link is a link to application settings
 */
export type internalLinkTypeSettings = {
  _: "internalLinkTypeSettings";
};

/**
 * Version of {@link internalLinkTypeSettings} for method parameters.
 *
 * The link is a link to application settings
 */
export type internalLinkTypeSettings$Input = {
  readonly _: "internalLinkTypeSettings";
};

/**
 * The link is a link to a bot, which can be installed to the side menu. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu.
 *
 * - Then, use getAttachmentMenuBot to receive information about the bot. If the bot isn't added to side menu, then show a disclaimer about Mini Apps being a third-party apps,
 *
 * - ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot.
 *
 * - If the bot is added to side menu, then use getWebAppUrl with the given URL
 */
export type internalLinkTypeSideMenuBot = {
  _: "internalLinkTypeSideMenuBot";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * URL to be passed to getWebAppUrl
   * @type {string} {@link string}
   */
  url: string;
};

/**
 * Version of {@link internalLinkTypeSideMenuBot} for method parameters.
 *
 * The link is a link to a bot, which can be installed to the side menu. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu.
 *
 * - Then, use getAttachmentMenuBot to receive information about the bot. If the bot isn't added to side menu, then show a disclaimer about Mini Apps being a third-party apps,
 *
 * - ask the user to accept their Terms of service and confirm adding the bot to side and attachment menu. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot.
 *
 * - If the bot is added to side menu, then use getWebAppUrl with the given URL
 */
export type internalLinkTypeSideMenuBot$Input = {
  readonly _: "internalLinkTypeSideMenuBot";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * URL to be passed to getWebAppUrl
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set
 */
export type internalLinkTypeStickerSet = {
  _: "internalLinkTypeStickerSet";

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  sticker_set_name: string;

  /**
   * True, if the sticker set is expected to contain custom emoji
   * @type {Bool} {@link Bool}
   */
  expect_custom_emoji: Bool;
};

/**
 * Version of {@link internalLinkTypeStickerSet} for method parameters.
 *
 * The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set
 */
export type internalLinkTypeStickerSet$Input = {
  readonly _: "internalLinkTypeStickerSet";

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly sticker_set_name?: string;

  /**
   * True, if the sticker set is expected to contain custom emoji
   * @type {Bool} {@link Bool}
   */
  readonly expect_custom_emoji?: Bool$Input;
};

/**
 * The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier
 */
export type internalLinkTypeStory = {
  _: "internalLinkTypeStory";

  /**
   * Username of the sender of the story
   * @type {string} {@link string}
   */
  story_sender_username: string;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link internalLinkTypeStory} for method parameters.
 *
 * The link is a link to a story. Call searchPublicChat with the given sender username, then call getStory with the received chat identifier and the given story identifier
 */
export type internalLinkTypeStory$Input = {
  readonly _: "internalLinkTypeStory";

  /**
   * Username of the sender of the story
   * @type {string} {@link string}
   */
  readonly story_sender_username?: string;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * The link is a link to a theme. TDLib has no theme support yet
 */
export type internalLinkTypeTheme = {
  _: "internalLinkTypeTheme";

  /**
   * Name of the theme
   * @type {string} {@link string}
   */
  theme_name: string;
};

/**
 * Version of {@link internalLinkTypeTheme} for method parameters.
 *
 * The link is a link to a theme. TDLib has no theme support yet
 */
export type internalLinkTypeTheme$Input = {
  readonly _: "internalLinkTypeTheme";

  /**
   * Name of the theme
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * The link is a link to the theme section of the app settings
 */
export type internalLinkTypeThemeSettings = {
  _: "internalLinkTypeThemeSettings";
};

/**
 * Version of {@link internalLinkTypeThemeSettings} for method parameters.
 *
 * The link is a link to the theme section of the app settings
 */
export type internalLinkTypeThemeSettings$Input = {
  readonly _: "internalLinkTypeThemeSettings";
};

/**
 * The link is an unknown tg: link. Call getDeepLinkInfo to process the link
 */
export type internalLinkTypeUnknownDeepLink = {
  _: "internalLinkTypeUnknownDeepLink";

  /**
   * Link to be passed to getDeepLinkInfo
   * @type {string} {@link string}
   */
  link: string;
};

/**
 * Version of {@link internalLinkTypeUnknownDeepLink} for method parameters.
 *
 * The link is an unknown tg: link. Call getDeepLinkInfo to process the link
 */
export type internalLinkTypeUnknownDeepLink$Input = {
  readonly _: "internalLinkTypeUnknownDeepLink";

  /**
   * Link to be passed to getDeepLinkInfo
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * The link is a link to an unsupported proxy. An alert can be shown to the user
 */
export type internalLinkTypeUnsupportedProxy = {
  _: "internalLinkTypeUnsupportedProxy";
};

/**
 * Version of {@link internalLinkTypeUnsupportedProxy} for method parameters.
 *
 * The link is a link to an unsupported proxy. An alert can be shown to the user
 */
export type internalLinkTypeUnsupportedProxy$Input = {
  readonly _: "internalLinkTypeUnsupportedProxy";
};

/**
 * The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link
 */
export type internalLinkTypeUserPhoneNumber = {
  _: "internalLinkTypeUserPhoneNumber";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;
};

/**
 * Version of {@link internalLinkTypeUserPhoneNumber} for method parameters.
 *
 * The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link
 */
export type internalLinkTypeUserPhoneNumber$Input = {
  readonly _: "internalLinkTypeUserPhoneNumber";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link
 */
export type internalLinkTypeUserToken = {
  _: "internalLinkTypeUserToken";

  /**
   * The token
   * @type {string} {@link string}
   */
  token: string;
};

/**
 * Version of {@link internalLinkTypeUserToken} for method parameters.
 *
 * The link is a link to a user by a temporary token. Call searchUserByToken with the given token to process the link
 */
export type internalLinkTypeUserToken$Input = {
  readonly _: "internalLinkTypeUserToken";

  /**
   * The token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link
 */
export type internalLinkTypeVideoChat = {
  _: "internalLinkTypeVideoChat";

  /**
   * Username of the chat with the video chat
   * @type {string} {@link string}
   */
  chat_username: string;

  /**
   * If non-empty, invite hash to be used to join the video chat without being muted by administrators
   * @type {string} {@link string}
   */
  invite_hash: string;

  /**
   * True, if the video chat is expected to be a live stream in a channel or a broadcast group
   * @type {Bool} {@link Bool}
   */
  is_live_stream: Bool;
};

/**
 * Version of {@link internalLinkTypeVideoChat} for method parameters.
 *
 * The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link
 */
export type internalLinkTypeVideoChat$Input = {
  readonly _: "internalLinkTypeVideoChat";

  /**
   * Username of the chat with the video chat
   * @type {string} {@link string}
   */
  readonly chat_username?: string;

  /**
   * If non-empty, invite hash to be used to join the video chat without being muted by administrators
   * @type {string} {@link string}
   */
  readonly invite_hash?: string;

  /**
   * True, if the video chat is expected to be a live stream in a channel or a broadcast group
   * @type {Bool} {@link Bool}
   */
  readonly is_live_stream?: Bool$Input;
};

/**
 * The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name.
 *
 * - Process received foundWebApp by showing a confirmation dialog if needed. If the bot can be added to attachment or side menu, but isn't added yet, then show a disclaimer about Mini Apps being a third-party apps
 *
 * - instead of the dialog and ask the user to accept their Terms of service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot.
 *
 * - Then, call getWebAppLinkUrl and open the returned URL as a Web App
 */
export type internalLinkTypeWebApp = {
  _: "internalLinkTypeWebApp";

  /**
   * Username of the bot that owns the Web App
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * Short name of the Web App
   * @type {string} {@link string}
   */
  web_app_short_name: string;

  /**
   * Start parameter to be passed to getWebAppLinkUrl
   * @type {string} {@link string}
   */
  start_parameter: string;
};

/**
 * Version of {@link internalLinkTypeWebApp} for method parameters.
 *
 * The link is a link to a Web App. Call searchPublicChat with the given bot username, check that the user is a bot, then call searchWebApp with the received bot and the given web_app_short_name.
 *
 * - Process received foundWebApp by showing a confirmation dialog if needed. If the bot can be added to attachment or side menu, but isn't added yet, then show a disclaimer about Mini Apps being a third-party apps
 *
 * - instead of the dialog and ask the user to accept their Terms of service. If the user accept the terms and confirms adding, then use toggleBotIsAddedToAttachmentMenu to add the bot.
 *
 * - Then, call getWebAppLinkUrl and open the returned URL as a Web App
 */
export type internalLinkTypeWebApp$Input = {
  readonly _: "internalLinkTypeWebApp";

  /**
   * Username of the bot that owns the Web App
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * Short name of the Web App
   * @type {string} {@link string}
   */
  readonly web_app_short_name?: string;

  /**
   * Start parameter to be passed to getWebAppLinkUrl
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;
};

/**
 * Contains an HTTPS link to a message in a supergroup or channel, or a forum topic
 */
export type messageLink = {
  _: "messageLink";

  /**
   * The link
   * @type {string} {@link string}
   */
  link: string;

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;
};

/**
 * Version of {@link messageLink} for method parameters.
 *
 * Contains an HTTPS link to a message in a supergroup or channel, or a forum topic
 */
export type messageLink$Input = {
  readonly _: "messageLink";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;
};

/**
 * Contains information about a link to a message or a forum topic in a chat
 */
export type messageLinkInfo = {
  _: "messageLinkInfo";

  /**
   * True, if the link is a public link for a message or a forum topic in a chat
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;

  /**
   * If found, identifier of the chat to which the link points, 0 otherwise
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * If found, the linked message; may be null
   * @type {message} {@link message}
   */
  message: message | null;

  /**
   * Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  media_timestamp: int32;

  /**
   * True, if the whole media album to which the message belongs is linked
   * @type {Bool} {@link Bool}
   */
  for_album: Bool;
};

/**
 * Version of {@link messageLinkInfo} for method parameters.
 *
 * Contains information about a link to a message or a forum topic in a chat
 */
export type messageLinkInfo$Input = {
  readonly _: "messageLinkInfo";

  /**
   * True, if the link is a public link for a message or a forum topic in a chat
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;

  /**
   * If found, identifier of the chat to which the link points, 0 otherwise
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If found, identifier of the message thread in which to open the message, or a forum topic to open if the message is missing
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * If found, the linked message; may be null
   * @type {message} {@link message}
   */
  readonly message?: message$Input | null;

  /**
   * Timestamp from which the video/audio/video note/voice note/story playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;

  /**
   * True, if the whole media album to which the message belongs is linked
   * @type {Bool} {@link Bool}
   */
  readonly for_album?: Bool$Input;
};

/**
 * Contains an HTTPS link to boost a chat
 */
export type chatBoostLink = {
  _: "chatBoostLink";

  /**
   * The link
   * @type {string} {@link string}
   */
  link: string;

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;
};

/**
 * Version of {@link chatBoostLink} for method parameters.
 *
 * Contains an HTTPS link to boost a chat
 */
export type chatBoostLink$Input = {
  readonly _: "chatBoostLink";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;
};

/**
 * Contains information about a link to boost a chat
 */
export type chatBoostLinkInfo = {
  _: "chatBoostLinkInfo";

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;

  /**
   * Identifier of the chat to which the link points; 0 if the chat isn't found
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

/**
 * Version of {@link chatBoostLinkInfo} for method parameters.
 *
 * Contains information about a link to boost a chat
 */
export type chatBoostLinkInfo$Input = {
  readonly _: "chatBoostLinkInfo";

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;

  /**
   * Identifier of the chat to which the link points; 0 if the chat isn't found
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions
 */
export type blockListMain = {
  _: "blockListMain";
};

/**
 * Version of {@link blockListMain} for method parameters.
 *
 * The main block list that disallows writing messages to the current user, receiving their status and photo, viewing of stories, and some other actions
 */
export type blockListMain$Input = {
  readonly _: "blockListMain";
};

/**
 * The block list that disallows viewing of stories of the current user
 */
export type blockListStories = {
  _: "blockListStories";
};

/**
 * Version of {@link blockListStories} for method parameters.
 *
 * The block list that disallows viewing of stories of the current user
 */
export type blockListStories$Input = {
  readonly _: "blockListStories";
};

/**
 * Contains a part of a file
 */
export type filePart = {
  _: "filePart";

  /**
   * File bytes
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link filePart} for method parameters.
 *
 * Contains a part of a file
 */
export type filePart$Input = {
  readonly _: "filePart";

  /**
   * File bytes
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * The data is not a file
 */
export type fileTypeNone = {
  _: "fileTypeNone";
};

/**
 * Version of {@link fileTypeNone} for method parameters.
 *
 * The data is not a file
 */
export type fileTypeNone$Input = {
  readonly _: "fileTypeNone";
};

/**
 * The file is an animation
 */
export type fileTypeAnimation = {
  _: "fileTypeAnimation";
};

/**
 * Version of {@link fileTypeAnimation} for method parameters.
 *
 * The file is an animation
 */
export type fileTypeAnimation$Input = {
  readonly _: "fileTypeAnimation";
};

/**
 * The file is an audio file
 */
export type fileTypeAudio = {
  _: "fileTypeAudio";
};

/**
 * Version of {@link fileTypeAudio} for method parameters.
 *
 * The file is an audio file
 */
export type fileTypeAudio$Input = {
  readonly _: "fileTypeAudio";
};

/**
 * The file is a document
 */
export type fileTypeDocument = {
  _: "fileTypeDocument";
};

/**
 * Version of {@link fileTypeDocument} for method parameters.
 *
 * The file is a document
 */
export type fileTypeDocument$Input = {
  readonly _: "fileTypeDocument";
};

/**
 * The file is a notification sound
 */
export type fileTypeNotificationSound = {
  _: "fileTypeNotificationSound";
};

/**
 * Version of {@link fileTypeNotificationSound} for method parameters.
 *
 * The file is a notification sound
 */
export type fileTypeNotificationSound$Input = {
  readonly _: "fileTypeNotificationSound";
};

/**
 * The file is a photo
 */
export type fileTypePhoto = {
  _: "fileTypePhoto";
};

/**
 * Version of {@link fileTypePhoto} for method parameters.
 *
 * The file is a photo
 */
export type fileTypePhoto$Input = {
  readonly _: "fileTypePhoto";
};

/**
 * The file is a photo published as a story
 */
export type fileTypePhotoStory = {
  _: "fileTypePhotoStory";
};

/**
 * Version of {@link fileTypePhotoStory} for method parameters.
 *
 * The file is a photo published as a story
 */
export type fileTypePhotoStory$Input = {
  readonly _: "fileTypePhotoStory";
};

/**
 * The file is a profile photo
 */
export type fileTypeProfilePhoto = {
  _: "fileTypeProfilePhoto";
};

/**
 * Version of {@link fileTypeProfilePhoto} for method parameters.
 *
 * The file is a profile photo
 */
export type fileTypeProfilePhoto$Input = {
  readonly _: "fileTypeProfilePhoto";
};

/**
 * The file was sent to a secret chat (the file type is not known to the server)
 */
export type fileTypeSecret = {
  _: "fileTypeSecret";
};

/**
 * Version of {@link fileTypeSecret} for method parameters.
 *
 * The file was sent to a secret chat (the file type is not known to the server)
 */
export type fileTypeSecret$Input = {
  readonly _: "fileTypeSecret";
};

/**
 * The file is a thumbnail of a file from a secret chat
 */
export type fileTypeSecretThumbnail = {
  _: "fileTypeSecretThumbnail";
};

/**
 * Version of {@link fileTypeSecretThumbnail} for method parameters.
 *
 * The file is a thumbnail of a file from a secret chat
 */
export type fileTypeSecretThumbnail$Input = {
  readonly _: "fileTypeSecretThumbnail";
};

/**
 * The file is a file from Secure storage used for storing Telegram Passport files
 */
export type fileTypeSecure = {
  _: "fileTypeSecure";
};

/**
 * Version of {@link fileTypeSecure} for method parameters.
 *
 * The file is a file from Secure storage used for storing Telegram Passport files
 */
export type fileTypeSecure$Input = {
  readonly _: "fileTypeSecure";
};

/**
 * The file is a sticker
 */
export type fileTypeSticker = {
  _: "fileTypeSticker";
};

/**
 * Version of {@link fileTypeSticker} for method parameters.
 *
 * The file is a sticker
 */
export type fileTypeSticker$Input = {
  readonly _: "fileTypeSticker";
};

/**
 * The file is a thumbnail of another file
 */
export type fileTypeThumbnail = {
  _: "fileTypeThumbnail";
};

/**
 * Version of {@link fileTypeThumbnail} for method parameters.
 *
 * The file is a thumbnail of another file
 */
export type fileTypeThumbnail$Input = {
  readonly _: "fileTypeThumbnail";
};

/**
 * The file type is not yet known
 */
export type fileTypeUnknown = {
  _: "fileTypeUnknown";
};

/**
 * Version of {@link fileTypeUnknown} for method parameters.
 *
 * The file type is not yet known
 */
export type fileTypeUnknown$Input = {
  readonly _: "fileTypeUnknown";
};

/**
 * The file is a video
 */
export type fileTypeVideo = {
  _: "fileTypeVideo";
};

/**
 * Version of {@link fileTypeVideo} for method parameters.
 *
 * The file is a video
 */
export type fileTypeVideo$Input = {
  readonly _: "fileTypeVideo";
};

/**
 * The file is a video note
 */
export type fileTypeVideoNote = {
  _: "fileTypeVideoNote";
};

/**
 * Version of {@link fileTypeVideoNote} for method parameters.
 *
 * The file is a video note
 */
export type fileTypeVideoNote$Input = {
  readonly _: "fileTypeVideoNote";
};

/**
 * The file is a video published as a story
 */
export type fileTypeVideoStory = {
  _: "fileTypeVideoStory";
};

/**
 * Version of {@link fileTypeVideoStory} for method parameters.
 *
 * The file is a video published as a story
 */
export type fileTypeVideoStory$Input = {
  readonly _: "fileTypeVideoStory";
};

/**
 * The file is a voice note
 */
export type fileTypeVoiceNote = {
  _: "fileTypeVoiceNote";
};

/**
 * Version of {@link fileTypeVoiceNote} for method parameters.
 *
 * The file is a voice note
 */
export type fileTypeVoiceNote$Input = {
  readonly _: "fileTypeVoiceNote";
};

/**
 * The file is a wallpaper or a background pattern
 */
export type fileTypeWallpaper = {
  _: "fileTypeWallpaper";
};

/**
 * Version of {@link fileTypeWallpaper} for method parameters.
 *
 * The file is a wallpaper or a background pattern
 */
export type fileTypeWallpaper$Input = {
  readonly _: "fileTypeWallpaper";
};

/**
 * Contains the storage usage statistics for a specific file type
 */
export type storageStatisticsByFileType = {
  _: "storageStatisticsByFileType";

  /**
   * File type
   * @type {FileType} {@link FileType}
   */
  file_type: FileType;

  /**
   * Total size of the files, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  count: int32;
};

/**
 * Version of {@link storageStatisticsByFileType} for method parameters.
 *
 * Contains the storage usage statistics for a specific file type
 */
export type storageStatisticsByFileType$Input = {
  readonly _: "storageStatisticsByFileType";

  /**
   * File type
   * @type {FileType} {@link FileType}
   */
  readonly file_type?: FileType$Input;

  /**
   * Total size of the files, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  readonly count?: int32;
};

/**
 * Contains the storage usage statistics for a specific chat
 */
export type storageStatisticsByChat = {
  _: "storageStatisticsByChat";

  /**
   * Chat identifier; 0 if none
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Total size of the files in the chat, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Total number of files in the chat
   * @type {int32} {@link int32}
   */
  count: int32;

  /**
   * Statistics split by file types
   * @type {vector<storageStatisticsByFileType>} {@link vector<storageStatisticsByFileType>}
   */
  by_file_type: vector<storageStatisticsByFileType>;
};

/**
 * Version of {@link storageStatisticsByChat} for method parameters.
 *
 * Contains the storage usage statistics for a specific chat
 */
export type storageStatisticsByChat$Input = {
  readonly _: "storageStatisticsByChat";

  /**
   * Chat identifier; 0 if none
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Total size of the files in the chat, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Total number of files in the chat
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * Statistics split by file types
   * @type {vector<storageStatisticsByFileType>} {@link vector<storageStatisticsByFileType>}
   */
  readonly by_file_type?: vector$Input<storageStatisticsByFileType$Input>;
};

/**
 * Contains the exact storage usage statistics split by chats and file type
 */
export type storageStatistics = {
  _: "storageStatistics";

  /**
   * Total size of files, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  count: int32;

  /**
   * Statistics split by chats
   * @type {vector<storageStatisticsByChat>} {@link vector<storageStatisticsByChat>}
   */
  by_chat: vector<storageStatisticsByChat>;
};

/**
 * Version of {@link storageStatistics} for method parameters.
 *
 * Contains the exact storage usage statistics split by chats and file type
 */
export type storageStatistics$Input = {
  readonly _: "storageStatistics";

  /**
   * Total size of files, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * Statistics split by chats
   * @type {vector<storageStatisticsByChat>} {@link vector<storageStatisticsByChat>}
   */
  readonly by_chat?: vector$Input<storageStatisticsByChat$Input>;
};

/**
 * Contains approximate storage usage statistics, excluding files of unknown file type
 */
export type storageStatisticsFast = {
  _: "storageStatisticsFast";

  /**
   * Approximate total size of files, in bytes
   * @type {int53} {@link int53}
   */
  files_size: int53;

  /**
   * Approximate number of files
   * @type {int32} {@link int32}
   */
  file_count: int32;

  /**
   * Size of the database
   * @type {int53} {@link int53}
   */
  database_size: int53;

  /**
   * Size of the language pack database
   * @type {int53} {@link int53}
   */
  language_pack_database_size: int53;

  /**
   * Size of the TDLib internal log
   * @type {int53} {@link int53}
   */
  log_size: int53;
};

/**
 * Version of {@link storageStatisticsFast} for method parameters.
 *
 * Contains approximate storage usage statistics, excluding files of unknown file type
 */
export type storageStatisticsFast$Input = {
  readonly _: "storageStatisticsFast";

  /**
   * Approximate total size of files, in bytes
   * @type {int53} {@link int53}
   */
  readonly files_size?: int53;

  /**
   * Approximate number of files
   * @type {int32} {@link int32}
   */
  readonly file_count?: int32;

  /**
   * Size of the database
   * @type {int53} {@link int53}
   */
  readonly database_size?: int53;

  /**
   * Size of the language pack database
   * @type {int53} {@link int53}
   */
  readonly language_pack_database_size?: int53;

  /**
   * Size of the TDLib internal log
   * @type {int53} {@link int53}
   */
  readonly log_size?: int53;
};

/**
 * Contains database statistics
 */
export type databaseStatistics = {
  _: "databaseStatistics";

  /**
   * Database statistics in an unspecified human-readable format
   * @type {string} {@link string}
   */
  statistics: string;
};

/**
 * Version of {@link databaseStatistics} for method parameters.
 *
 * Contains database statistics
 */
export type databaseStatistics$Input = {
  readonly _: "databaseStatistics";

  /**
   * Database statistics in an unspecified human-readable format
   * @type {string} {@link string}
   */
  readonly statistics?: string;
};

/**
 * The network is not available
 */
export type networkTypeNone = {
  _: "networkTypeNone";
};

/**
 * Version of {@link networkTypeNone} for method parameters.
 *
 * The network is not available
 */
export type networkTypeNone$Input = {
  readonly _: "networkTypeNone";
};

/**
 * A mobile network
 */
export type networkTypeMobile = {
  _: "networkTypeMobile";
};

/**
 * Version of {@link networkTypeMobile} for method parameters.
 *
 * A mobile network
 */
export type networkTypeMobile$Input = {
  readonly _: "networkTypeMobile";
};

/**
 * A mobile roaming network
 */
export type networkTypeMobileRoaming = {
  _: "networkTypeMobileRoaming";
};

/**
 * Version of {@link networkTypeMobileRoaming} for method parameters.
 *
 * A mobile roaming network
 */
export type networkTypeMobileRoaming$Input = {
  readonly _: "networkTypeMobileRoaming";
};

/**
 * A Wi-Fi network
 */
export type networkTypeWiFi = {
  _: "networkTypeWiFi";
};

/**
 * Version of {@link networkTypeWiFi} for method parameters.
 *
 * A Wi-Fi network
 */
export type networkTypeWiFi$Input = {
  readonly _: "networkTypeWiFi";
};

/**
 * A different network type (e.g., Ethernet network)
 */
export type networkTypeOther = {
  _: "networkTypeOther";
};

/**
 * Version of {@link networkTypeOther} for method parameters.
 *
 * A different network type (e.g., Ethernet network)
 */
export type networkTypeOther$Input = {
  readonly _: "networkTypeOther";
};

/**
 * Contains information about the total amount of data that was used to send and receive files
 */
export type networkStatisticsEntryFile = {
  _: "networkStatisticsEntryFile";

  /**
   * Type of the file the data is part of; pass null if the data isn't related to files
   * @type {FileType} {@link FileType}
   */
  file_type: FileType | null;

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  network_type: NetworkType;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  sent_bytes: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  received_bytes: int53;
};

/**
 * Version of {@link networkStatisticsEntryFile} for method parameters.
 *
 * Contains information about the total amount of data that was used to send and receive files
 */
export type networkStatisticsEntryFile$Input = {
  readonly _: "networkStatisticsEntryFile";

  /**
   * Type of the file the data is part of; pass null if the data isn't related to files
   * @type {FileType} {@link FileType}
   */
  readonly file_type?: FileType$Input | null;

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  readonly network_type?: NetworkType$Input;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  readonly sent_bytes?: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  readonly received_bytes?: int53;
};

/**
 * Contains information about the total amount of data that was used for calls
 */
export type networkStatisticsEntryCall = {
  _: "networkStatisticsEntryCall";

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  network_type: NetworkType;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  sent_bytes: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  received_bytes: int53;

  /**
   * Total call duration, in seconds
   * @type {double} {@link double}
   */
  duration: double;
};

/**
 * Version of {@link networkStatisticsEntryCall} for method parameters.
 *
 * Contains information about the total amount of data that was used for calls
 */
export type networkStatisticsEntryCall$Input = {
  readonly _: "networkStatisticsEntryCall";

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  readonly network_type?: NetworkType$Input;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  readonly sent_bytes?: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  readonly received_bytes?: int53;

  /**
   * Total call duration, in seconds
   * @type {double} {@link double}
   */
  readonly duration?: double;
};

/**
 * A full list of available network statistic entries
 */
export type networkStatistics = {
  _: "networkStatistics";

  /**
   * Point in time (Unix timestamp) from which the statistics are collected
   * @type {int32} {@link int32}
   */
  since_date: int32;

  /**
   * Network statistics entries
   * @type {vector<NetworkStatisticsEntry>} {@link vector<NetworkStatisticsEntry>}
   */
  entries: vector<NetworkStatisticsEntry>;
};

/**
 * Version of {@link networkStatistics} for method parameters.
 *
 * A full list of available network statistic entries
 */
export type networkStatistics$Input = {
  readonly _: "networkStatistics";

  /**
   * Point in time (Unix timestamp) from which the statistics are collected
   * @type {int32} {@link int32}
   */
  readonly since_date?: int32;

  /**
   * Network statistics entries
   * @type {vector<NetworkStatisticsEntry>} {@link vector<NetworkStatisticsEntry>}
   */
  readonly entries?: vector$Input<NetworkStatisticsEntry$Input>;
};

/**
 * Contains auto-download settings
 */
export type autoDownloadSettings = {
  _: "autoDownloadSettings";

  /**
   * True, if the auto-download is enabled
   * @type {Bool} {@link Bool}
   */
  is_auto_download_enabled: Bool;

  /**
   * The maximum size of a photo file to be auto-downloaded, in bytes
   * @type {int32} {@link int32}
   */
  max_photo_file_size: int32;

  /**
   * The maximum size of a video file to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  max_video_file_size: int53;

  /**
   * The maximum size of other file types to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  max_other_file_size: int53;

  /**
   * The maximum suggested bitrate for uploaded videos, in kbit/s
   * @type {int32} {@link int32}
   */
  video_upload_bitrate: int32;

  /**
   * True, if the beginning of video files needs to be preloaded for instant playback
   * @type {Bool} {@link Bool}
   */
  preload_large_videos: Bool;

  /**
   * True, if the next audio track needs to be preloaded while the user is listening to an audio file
   * @type {Bool} {@link Bool}
   */
  preload_next_audio: Bool;

  /**
   * True, if stories needs to be preloaded
   * @type {Bool} {@link Bool}
   */
  preload_stories: Bool;

  /**
   * True, if "use less data for calls" option needs to be enabled
   * @type {Bool} {@link Bool}
   */
  use_less_data_for_calls: Bool;
};

/**
 * Version of {@link autoDownloadSettings} for method parameters.
 *
 * Contains auto-download settings
 */
export type autoDownloadSettings$Input = {
  readonly _: "autoDownloadSettings";

  /**
   * True, if the auto-download is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_auto_download_enabled?: Bool$Input;

  /**
   * The maximum size of a photo file to be auto-downloaded, in bytes
   * @type {int32} {@link int32}
   */
  readonly max_photo_file_size?: int32;

  /**
   * The maximum size of a video file to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  readonly max_video_file_size?: int53;

  /**
   * The maximum size of other file types to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  readonly max_other_file_size?: int53;

  /**
   * The maximum suggested bitrate for uploaded videos, in kbit/s
   * @type {int32} {@link int32}
   */
  readonly video_upload_bitrate?: int32;

  /**
   * True, if the beginning of video files needs to be preloaded for instant playback
   * @type {Bool} {@link Bool}
   */
  readonly preload_large_videos?: Bool$Input;

  /**
   * True, if the next audio track needs to be preloaded while the user is listening to an audio file
   * @type {Bool} {@link Bool}
   */
  readonly preload_next_audio?: Bool$Input;

  /**
   * True, if stories needs to be preloaded
   * @type {Bool} {@link Bool}
   */
  readonly preload_stories?: Bool$Input;

  /**
   * True, if "use less data for calls" option needs to be enabled
   * @type {Bool} {@link Bool}
   */
  readonly use_less_data_for_calls?: Bool$Input;
};

/**
 * Contains auto-download settings presets for the current user
 */
export type autoDownloadSettingsPresets = {
  _: "autoDownloadSettingsPresets";

  /**
   * Preset with lowest settings; supposed to be used by default when roaming
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  low: autoDownloadSettings;

  /**
   * Preset with medium settings; supposed to be used by default when using mobile data
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  medium: autoDownloadSettings;

  /**
   * Preset with highest settings; supposed to be used by default when connected on Wi-Fi
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  high: autoDownloadSettings;
};

/**
 * Version of {@link autoDownloadSettingsPresets} for method parameters.
 *
 * Contains auto-download settings presets for the current user
 */
export type autoDownloadSettingsPresets$Input = {
  readonly _: "autoDownloadSettingsPresets";

  /**
   * Preset with lowest settings; supposed to be used by default when roaming
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  readonly low?: autoDownloadSettings$Input;

  /**
   * Preset with medium settings; supposed to be used by default when using mobile data
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  readonly medium?: autoDownloadSettings$Input;

  /**
   * Preset with highest settings; supposed to be used by default when connected on Wi-Fi
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  readonly high?: autoDownloadSettings$Input;
};

/**
 * Autosave settings applied to all private chats without chat-specific settings
 */
export type autosaveSettingsScopePrivateChats = {
  _: "autosaveSettingsScopePrivateChats";
};

/**
 * Version of {@link autosaveSettingsScopePrivateChats} for method parameters.
 *
 * Autosave settings applied to all private chats without chat-specific settings
 */
export type autosaveSettingsScopePrivateChats$Input = {
  readonly _: "autosaveSettingsScopePrivateChats";
};

/**
 * Autosave settings applied to all basic group and supergroup chats without chat-specific settings
 */
export type autosaveSettingsScopeGroupChats = {
  _: "autosaveSettingsScopeGroupChats";
};

/**
 * Version of {@link autosaveSettingsScopeGroupChats} for method parameters.
 *
 * Autosave settings applied to all basic group and supergroup chats without chat-specific settings
 */
export type autosaveSettingsScopeGroupChats$Input = {
  readonly _: "autosaveSettingsScopeGroupChats";
};

/**
 * Autosave settings applied to all channel chats without chat-specific settings
 */
export type autosaveSettingsScopeChannelChats = {
  _: "autosaveSettingsScopeChannelChats";
};

/**
 * Version of {@link autosaveSettingsScopeChannelChats} for method parameters.
 *
 * Autosave settings applied to all channel chats without chat-specific settings
 */
export type autosaveSettingsScopeChannelChats$Input = {
  readonly _: "autosaveSettingsScopeChannelChats";
};

/**
 * Autosave settings applied to a chat
 */
export type autosaveSettingsScopeChat = {
  _: "autosaveSettingsScopeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

/**
 * Version of {@link autosaveSettingsScopeChat} for method parameters.
 *
 * Autosave settings applied to a chat
 */
export type autosaveSettingsScopeChat$Input = {
  readonly _: "autosaveSettingsScopeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Contains autosave settings for an autosave settings scope
 */
export type scopeAutosaveSettings = {
  _: "scopeAutosaveSettings";

  /**
   * True, if photo autosave is enabled
   * @type {Bool} {@link Bool}
   */
  autosave_photos: Bool;

  /**
   * True, if video autosave is enabled
   * @type {Bool} {@link Bool}
   */
  autosave_videos: Bool;

  /**
   * The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
   * @type {int53} {@link int53}
   */
  max_video_file_size: int53;
};

/**
 * Version of {@link scopeAutosaveSettings} for method parameters.
 *
 * Contains autosave settings for an autosave settings scope
 */
export type scopeAutosaveSettings$Input = {
  readonly _: "scopeAutosaveSettings";

  /**
   * True, if photo autosave is enabled
   * @type {Bool} {@link Bool}
   */
  readonly autosave_photos?: Bool$Input;

  /**
   * True, if video autosave is enabled
   * @type {Bool} {@link Bool}
   */
  readonly autosave_videos?: Bool$Input;

  /**
   * The maximum size of a video file to be autosaved, in bytes; 512 KB - 4000 MB
   * @type {int53} {@link int53}
   */
  readonly max_video_file_size?: int53;
};

/**
 * Contains autosave settings for a chat, which overrides default settings for the corresponding scope
 */
export type autosaveSettingsException = {
  _: "autosaveSettingsException";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Autosave settings for the chat
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  settings: scopeAutosaveSettings;
};

/**
 * Version of {@link autosaveSettingsException} for method parameters.
 *
 * Contains autosave settings for a chat, which overrides default settings for the corresponding scope
 */
export type autosaveSettingsException$Input = {
  readonly _: "autosaveSettingsException";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Autosave settings for the chat
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  readonly settings?: scopeAutosaveSettings$Input;
};

/**
 * Describes autosave settings
 */
export type autosaveSettings = {
  _: "autosaveSettings";

  /**
   * Default autosave settings for private chats
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  private_chat_settings: scopeAutosaveSettings;

  /**
   * Default autosave settings for basic group and supergroup chats
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  group_settings: scopeAutosaveSettings;

  /**
   * Default autosave settings for channel chats
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  channel_settings: scopeAutosaveSettings;

  /**
   * Autosave settings for specific chats
   * @type {vector<autosaveSettingsException>} {@link vector<autosaveSettingsException>}
   */
  exceptions: vector<autosaveSettingsException>;
};

/**
 * Version of {@link autosaveSettings} for method parameters.
 *
 * Describes autosave settings
 */
export type autosaveSettings$Input = {
  readonly _: "autosaveSettings";

  /**
   * Default autosave settings for private chats
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  readonly private_chat_settings?: scopeAutosaveSettings$Input;

  /**
   * Default autosave settings for basic group and supergroup chats
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  readonly group_settings?: scopeAutosaveSettings$Input;

  /**
   * Default autosave settings for channel chats
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  readonly channel_settings?: scopeAutosaveSettings$Input;

  /**
   * Autosave settings for specific chats
   * @type {vector<autosaveSettingsException>} {@link vector<autosaveSettingsException>}
   */
  readonly exceptions?: vector$Input<autosaveSettingsException$Input>;
};

/**
 * Waiting for the network to become available. Use setNetworkType to change the available network type
 */
export type connectionStateWaitingForNetwork = {
  _: "connectionStateWaitingForNetwork";
};

/**
 * Version of {@link connectionStateWaitingForNetwork} for method parameters.
 *
 * Waiting for the network to become available. Use setNetworkType to change the available network type
 */
export type connectionStateWaitingForNetwork$Input = {
  readonly _: "connectionStateWaitingForNetwork";
};

/**
 * Establishing a connection with a proxy server
 */
export type connectionStateConnectingToProxy = {
  _: "connectionStateConnectingToProxy";
};

/**
 * Version of {@link connectionStateConnectingToProxy} for method parameters.
 *
 * Establishing a connection with a proxy server
 */
export type connectionStateConnectingToProxy$Input = {
  readonly _: "connectionStateConnectingToProxy";
};

/**
 * Establishing a connection to the Telegram servers
 */
export type connectionStateConnecting = {
  _: "connectionStateConnecting";
};

/**
 * Version of {@link connectionStateConnecting} for method parameters.
 *
 * Establishing a connection to the Telegram servers
 */
export type connectionStateConnecting$Input = {
  readonly _: "connectionStateConnecting";
};

/**
 * Downloading data supposed to be received while the application was offline
 */
export type connectionStateUpdating = {
  _: "connectionStateUpdating";
};

/**
 * Version of {@link connectionStateUpdating} for method parameters.
 *
 * Downloading data supposed to be received while the application was offline
 */
export type connectionStateUpdating$Input = {
  readonly _: "connectionStateUpdating";
};

/**
 * There is a working connection to the Telegram servers
 */
export type connectionStateReady = {
  _: "connectionStateReady";
};

/**
 * Version of {@link connectionStateReady} for method parameters.
 *
 * There is a working connection to the Telegram servers
 */
export type connectionStateReady$Input = {
  readonly _: "connectionStateReady";
};

/**
 * A category containing frequently used private chats with non-bot users
 */
export type topChatCategoryUsers = {
  _: "topChatCategoryUsers";
};

/**
 * Version of {@link topChatCategoryUsers} for method parameters.
 *
 * A category containing frequently used private chats with non-bot users
 */
export type topChatCategoryUsers$Input = {
  readonly _: "topChatCategoryUsers";
};

/**
 * A category containing frequently used private chats with bot users
 */
export type topChatCategoryBots = {
  _: "topChatCategoryBots";
};

/**
 * Version of {@link topChatCategoryBots} for method parameters.
 *
 * A category containing frequently used private chats with bot users
 */
export type topChatCategoryBots$Input = {
  readonly _: "topChatCategoryBots";
};

/**
 * A category containing frequently used basic groups and supergroups
 */
export type topChatCategoryGroups = {
  _: "topChatCategoryGroups";
};

/**
 * Version of {@link topChatCategoryGroups} for method parameters.
 *
 * A category containing frequently used basic groups and supergroups
 */
export type topChatCategoryGroups$Input = {
  readonly _: "topChatCategoryGroups";
};

/**
 * A category containing frequently used channels
 */
export type topChatCategoryChannels = {
  _: "topChatCategoryChannels";
};

/**
 * Version of {@link topChatCategoryChannels} for method parameters.
 *
 * A category containing frequently used channels
 */
export type topChatCategoryChannels$Input = {
  readonly _: "topChatCategoryChannels";
};

/**
 * A category containing frequently used chats with inline bots sorted by their usage in inline mode
 */
export type topChatCategoryInlineBots = {
  _: "topChatCategoryInlineBots";
};

/**
 * Version of {@link topChatCategoryInlineBots} for method parameters.
 *
 * A category containing frequently used chats with inline bots sorted by their usage in inline mode
 */
export type topChatCategoryInlineBots$Input = {
  readonly _: "topChatCategoryInlineBots";
};

/**
 * A category containing frequently used chats used for calls
 */
export type topChatCategoryCalls = {
  _: "topChatCategoryCalls";
};

/**
 * Version of {@link topChatCategoryCalls} for method parameters.
 *
 * A category containing frequently used chats used for calls
 */
export type topChatCategoryCalls$Input = {
  readonly _: "topChatCategoryCalls";
};

/**
 * A category containing frequently used chats used to forward messages
 */
export type topChatCategoryForwardChats = {
  _: "topChatCategoryForwardChats";
};

/**
 * Version of {@link topChatCategoryForwardChats} for method parameters.
 *
 * A category containing frequently used chats used to forward messages
 */
export type topChatCategoryForwardChats$Input = {
  readonly _: "topChatCategoryForwardChats";
};

/**
 * Contains 0-based match position
 */
export type foundPosition = {
  _: "foundPosition";

  /**
   * The position of the match
   * @type {int32} {@link int32}
   */
  position: int32;
};

/**
 * Version of {@link foundPosition} for method parameters.
 *
 * Contains 0-based match position
 */
export type foundPosition$Input = {
  readonly _: "foundPosition";

  /**
   * The position of the match
   * @type {int32} {@link int32}
   */
  readonly position?: int32;
};

/**
 * Contains 0-based positions of matched objects
 */
export type foundPositions = {
  _: "foundPositions";

  /**
   * Total number of matched objects
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * The positions of the matched objects
   * @type {vector<int32>} {@link vector<int32>}
   */
  positions: vector<int32>;
};

/**
 * Version of {@link foundPositions} for method parameters.
 *
 * Contains 0-based positions of matched objects
 */
export type foundPositions$Input = {
  readonly _: "foundPositions";

  /**
   * Total number of matched objects
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * The positions of the matched objects
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly positions?: vector$Input<int32>;
};

/**
 * A URL linking to a user
 */
export type tMeUrlTypeUser = {
  _: "tMeUrlTypeUser";

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link tMeUrlTypeUser} for method parameters.
 *
 * A URL linking to a user
 */
export type tMeUrlTypeUser$Input = {
  readonly _: "tMeUrlTypeUser";

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * A URL linking to a public supergroup or channel
 */
export type tMeUrlTypeSupergroup = {
  _: "tMeUrlTypeSupergroup";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;
};

/**
 * Version of {@link tMeUrlTypeSupergroup} for method parameters.
 *
 * A URL linking to a public supergroup or channel
 */
export type tMeUrlTypeSupergroup$Input = {
  readonly _: "tMeUrlTypeSupergroup";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * A chat invite link
 */
export type tMeUrlTypeChatInvite = {
  _: "tMeUrlTypeChatInvite";

  /**
   * Information about the chat invite link
   * @type {chatInviteLinkInfo} {@link chatInviteLinkInfo}
   */
  info: chatInviteLinkInfo;
};

/**
 * Version of {@link tMeUrlTypeChatInvite} for method parameters.
 *
 * A chat invite link
 */
export type tMeUrlTypeChatInvite$Input = {
  readonly _: "tMeUrlTypeChatInvite";

  /**
   * Information about the chat invite link
   * @type {chatInviteLinkInfo} {@link chatInviteLinkInfo}
   */
  readonly info?: chatInviteLinkInfo$Input;
};

/**
 * A URL linking to a sticker set
 */
export type tMeUrlTypeStickerSet = {
  _: "tMeUrlTypeStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  sticker_set_id: int64;
};

/**
 * Version of {@link tMeUrlTypeStickerSet} for method parameters.
 *
 * A URL linking to a sticker set
 */
export type tMeUrlTypeStickerSet$Input = {
  readonly _: "tMeUrlTypeStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly sticker_set_id?: int64$Input;
};

/**
 * Represents a URL linking to an internal Telegram entity
 */
export type tMeUrl = {
  _: "tMeUrl";

  /**
   * URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Type of the URL
   * @type {TMeUrlType} {@link TMeUrlType}
   */
  type: TMeUrlType;
};

/**
 * Version of {@link tMeUrl} for method parameters.
 *
 * Represents a URL linking to an internal Telegram entity
 */
export type tMeUrl$Input = {
  readonly _: "tMeUrl";

  /**
   * URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Type of the URL
   * @type {TMeUrlType} {@link TMeUrlType}
   */
  readonly type?: TMeUrlType$Input;
};

/**
 * Contains a list of t.me URLs
 */
export type tMeUrls = {
  _: "tMeUrls";

  /**
   * List of URLs
   * @type {vector<tMeUrl>} {@link vector<tMeUrl>}
   */
  urls: vector<tMeUrl>;
};

/**
 * Version of {@link tMeUrls} for method parameters.
 *
 * Contains a list of t.me URLs
 */
export type tMeUrls$Input = {
  readonly _: "tMeUrls";

  /**
   * List of URLs
   * @type {vector<tMeUrl>} {@link vector<tMeUrl>}
   */
  readonly urls?: vector$Input<tMeUrl$Input>;
};

/**
 * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings
 */
export type suggestedActionEnableArchiveAndMuteNewChats = {
  _: "suggestedActionEnableArchiveAndMuteNewChats";
};

/**
 * Version of {@link suggestedActionEnableArchiveAndMuteNewChats} for method parameters.
 *
 * Suggests the user to enable archive_and_mute_new_chats_from_unknown_users setting in archiveChatListSettings
 */
export type suggestedActionEnableArchiveAndMuteNewChats$Input = {
  readonly _: "suggestedActionEnableArchiveAndMuteNewChats";
};

/**
 * Suggests the user to check whether they still remember their 2-step verification password
 */
export type suggestedActionCheckPassword = {
  _: "suggestedActionCheckPassword";
};

/**
 * Version of {@link suggestedActionCheckPassword} for method parameters.
 *
 * Suggests the user to check whether they still remember their 2-step verification password
 */
export type suggestedActionCheckPassword$Input = {
  readonly _: "suggestedActionCheckPassword";
};

/**
 * Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
 */
export type suggestedActionCheckPhoneNumber = {
  _: "suggestedActionCheckPhoneNumber";
};

/**
 * Version of {@link suggestedActionCheckPhoneNumber} for method parameters.
 *
 * Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
 */
export type suggestedActionCheckPhoneNumber$Input = {
  readonly _: "suggestedActionCheckPhoneNumber";
};

/**
 * Suggests the user to view a hint about the meaning of one and two check marks on sent messages
 */
export type suggestedActionViewChecksHint = {
  _: "suggestedActionViewChecksHint";
};

/**
 * Version of {@link suggestedActionViewChecksHint} for method parameters.
 *
 * Suggests the user to view a hint about the meaning of one and two check marks on sent messages
 */
export type suggestedActionViewChecksHint$Input = {
  readonly _: "suggestedActionViewChecksHint";
};

/**
 * Suggests the user to convert specified supergroup to a broadcast group
 */
export type suggestedActionConvertToBroadcastGroup = {
  _: "suggestedActionConvertToBroadcastGroup";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;
};

/**
 * Version of {@link suggestedActionConvertToBroadcastGroup} for method parameters.
 *
 * Suggests the user to convert specified supergroup to a broadcast group
 */
export type suggestedActionConvertToBroadcastGroup$Input = {
  readonly _: "suggestedActionConvertToBroadcastGroup";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Suggests the user to set a 2-step verification password to be able to log in again
 */
export type suggestedActionSetPassword = {
  _: "suggestedActionSetPassword";

  /**
   * The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
   * @type {int32} {@link int32}
   */
  authorization_delay: int32;
};

/**
 * Version of {@link suggestedActionSetPassword} for method parameters.
 *
 * Suggests the user to set a 2-step verification password to be able to log in again
 */
export type suggestedActionSetPassword$Input = {
  readonly _: "suggestedActionSetPassword";

  /**
   * The number of days to pass between consecutive authorizations if the user declines to set password; if 0, then the user is advised to set the password for security reasons
   * @type {int32} {@link int32}
   */
  readonly authorization_delay?: int32;
};

/**
 * Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
 */
export type suggestedActionUpgradePremium = {
  _: "suggestedActionUpgradePremium";
};

/**
 * Version of {@link suggestedActionUpgradePremium} for method parameters.
 *
 * Suggests the user to upgrade the Premium subscription from monthly payments to annual payments
 */
export type suggestedActionUpgradePremium$Input = {
  readonly _: "suggestedActionUpgradePremium";
};

/**
 * Suggests the user to restore a recently expired Premium subscription
 */
export type suggestedActionRestorePremium = {
  _: "suggestedActionRestorePremium";
};

/**
 * Version of {@link suggestedActionRestorePremium} for method parameters.
 *
 * Suggests the user to restore a recently expired Premium subscription
 */
export type suggestedActionRestorePremium$Input = {
  readonly _: "suggestedActionRestorePremium";
};

/**
 * Suggests the user to subscribe to the Premium subscription with annual payments
 */
export type suggestedActionSubscribeToAnnualPremium = {
  _: "suggestedActionSubscribeToAnnualPremium";
};

/**
 * Version of {@link suggestedActionSubscribeToAnnualPremium} for method parameters.
 *
 * Suggests the user to subscribe to the Premium subscription with annual payments
 */
export type suggestedActionSubscribeToAnnualPremium$Input = {
  readonly _: "suggestedActionSubscribeToAnnualPremium";
};

/**
 * Suggests the user to gift Telegram Premium to friends for Christmas
 */
export type suggestedActionGiftPremiumForChristmas = {
  _: "suggestedActionGiftPremiumForChristmas";
};

/**
 * Version of {@link suggestedActionGiftPremiumForChristmas} for method parameters.
 *
 * Suggests the user to gift Telegram Premium to friends for Christmas
 */
export type suggestedActionGiftPremiumForChristmas$Input = {
  readonly _: "suggestedActionGiftPremiumForChristmas";
};

/**
 * Contains a counter
 */
export type count = {
  _: "count";

  /**
   * Count
   * @type {int32} {@link int32}
   */
  count: int32;
};

/**
 * Version of {@link count} for method parameters.
 *
 * Contains a counter
 */
export type count$Input = {
  readonly _: "count";

  /**
   * Count
   * @type {int32} {@link int32}
   */
  readonly count?: int32;
};

/**
 * Contains some text
 */
export type text = {
  _: "text";

  /**
   * Text
   * @type {string} {@link string}
   */
  text: string;
};

/**
 * Version of {@link text} for method parameters.
 *
 * Contains some text
 */
export type text$Input = {
  readonly _: "text";

  /**
   * Text
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Contains a value representing a number of seconds
 */
export type seconds = {
  _: "seconds";

  /**
   * Number of seconds
   * @type {double} {@link double}
   */
  seconds: double;
};

/**
 * Version of {@link seconds} for method parameters.
 *
 * Contains a value representing a number of seconds
 */
export type seconds$Input = {
  readonly _: "seconds";

  /**
   * Number of seconds
   * @type {double} {@link double}
   */
  readonly seconds?: double;
};

/**
 * Contains size of downloaded prefix of a file
 */
export type fileDownloadedPrefixSize = {
  _: "fileDownloadedPrefixSize";

  /**
   * The prefix size, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;
};

/**
 * Version of {@link fileDownloadedPrefixSize} for method parameters.
 *
 * Contains size of downloaded prefix of a file
 */
export type fileDownloadedPrefixSize$Input = {
  readonly _: "fileDownloadedPrefixSize";

  /**
   * The prefix size, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;
};

/**
 * Contains information about a tg: deep link
 */
export type deepLinkInfo = {
  _: "deepLinkInfo";

  /**
   * Text to be shown to the user
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * True, if the user must be asked to update the application
   * @type {Bool} {@link Bool}
   */
  need_update_application: Bool;
};

/**
 * Version of {@link deepLinkInfo} for method parameters.
 *
 * Contains information about a tg: deep link
 */
export type deepLinkInfo$Input = {
  readonly _: "deepLinkInfo";

  /**
   * Text to be shown to the user
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * True, if the user must be asked to update the application
   * @type {Bool} {@link Bool}
   */
  readonly need_update_application?: Bool$Input;
};

/**
 * The text uses Markdown-style formatting
 */
export type textParseModeMarkdown = {
  _: "textParseModeMarkdown";

  /**
   * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
   * @type {int32} {@link int32}
   */
  version: int32;
};

/**
 * Version of {@link textParseModeMarkdown} for method parameters.
 *
 * The text uses Markdown-style formatting
 */
export type textParseModeMarkdown$Input = {
  readonly _: "textParseModeMarkdown";

  /**
   * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
   * @type {int32} {@link int32}
   */
  readonly version?: int32;
};

/**
 * The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
 */
export type textParseModeHTML = {
  _: "textParseModeHTML";
};

/**
 * Version of {@link textParseModeHTML} for method parameters.
 *
 * The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
 */
export type textParseModeHTML$Input = {
  readonly _: "textParseModeHTML";
};

/**
 * A SOCKS5 proxy server
 */
export type proxyTypeSocks5 = {
  _: "proxyTypeSocks5";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  username: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  password: string;
};

/**
 * Version of {@link proxyTypeSocks5} for method parameters.
 *
 * A SOCKS5 proxy server
 */
export type proxyTypeSocks5$Input = {
  readonly _: "proxyTypeSocks5";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * A HTTP transparent proxy server
 */
export type proxyTypeHttp = {
  _: "proxyTypeHttp";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  username: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  password: string;

  /**
   * Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
   * @type {Bool} {@link Bool}
   */
  http_only: Bool;
};

/**
 * Version of {@link proxyTypeHttp} for method parameters.
 *
 * A HTTP transparent proxy server
 */
export type proxyTypeHttp$Input = {
  readonly _: "proxyTypeHttp";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
   * @type {Bool} {@link Bool}
   */
  readonly http_only?: Bool$Input;
};

/**
 * An MTProto proxy server
 */
export type proxyTypeMtproto = {
  _: "proxyTypeMtproto";

  /**
   * The proxy's secret in hexadecimal encoding
   * @type {string} {@link string}
   */
  secret: string;
};

/**
 * Version of {@link proxyTypeMtproto} for method parameters.
 *
 * An MTProto proxy server
 */
export type proxyTypeMtproto$Input = {
  readonly _: "proxyTypeMtproto";

  /**
   * The proxy's secret in hexadecimal encoding
   * @type {string} {@link string}
   */
  readonly secret?: string;
};

/**
 * Contains information about a proxy server
 */
export type proxy = {
  _: "proxy";

  /**
   * Unique identifier of the proxy
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  server: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  port: int32;

  /**
   * Point in time (Unix timestamp) when the proxy was last used; 0 if never
   * @type {int32} {@link int32}
   */
  last_used_date: int32;

  /**
   * True, if the proxy is enabled now
   * @type {Bool} {@link Bool}
   */
  is_enabled: Bool;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  type: ProxyType;
};

/**
 * Version of {@link proxy} for method parameters.
 *
 * Contains information about a proxy server
 */
export type proxy$Input = {
  readonly _: "proxy";

  /**
   * Unique identifier of the proxy
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Point in time (Unix timestamp) when the proxy was last used; 0 if never
   * @type {int32} {@link int32}
   */
  readonly last_used_date?: int32;

  /**
   * True, if the proxy is enabled now
   * @type {Bool} {@link Bool}
   */
  readonly is_enabled?: Bool$Input;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Represents a list of proxy servers
 */
export type proxies = {
  _: "proxies";

  /**
   * List of proxy servers
   * @type {vector<proxy>} {@link vector<proxy>}
   */
  proxies: vector<proxy>;
};

/**
 * Version of {@link proxies} for method parameters.
 *
 * Represents a list of proxy servers
 */
export type proxies$Input = {
  readonly _: "proxies";

  /**
   * List of proxy servers
   * @type {vector<proxy>} {@link vector<proxy>}
   */
  readonly proxies?: vector$Input<proxy$Input>;
};

/**
 * A sticker to be added to a sticker set
 */
export type inputSticker = {
  _: "inputSticker";

  /**
   * File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side.
   *
   * - See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
   * @type {InputFile} {@link InputFile}
   */
  sticker: InputFile;

  /**
   * String with 1-20 emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  emojis: string;

  /**
   * Position where the mask is placed; pass null if not specified
   * @type {maskPosition} {@link maskPosition}
   */
  mask_position: maskPosition | null;

  /**
   * List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
   * @type {vector<string>} {@link vector<string>}
   */
  keywords: vector<string>;
};

/**
 * Version of {@link inputSticker} for method parameters.
 *
 * A sticker to be added to a sticker set
 */
export type inputSticker$Input = {
  readonly _: "inputSticker";

  /**
   * File with the sticker; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side.
   *
   * - See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
   * @type {InputFile} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * String with 1-20 emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  readonly emojis?: string;

  /**
   * Position where the mask is placed; pass null if not specified
   * @type {maskPosition} {@link maskPosition}
   */
  readonly mask_position?: maskPosition$Input | null;

  /**
   * List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
   * @type {vector<string>} {@link vector<string>}
   */
  readonly keywords?: vector$Input<string>;
};

/**
 * Represents a date range
 */
export type dateRange = {
  _: "dateRange";

  /**
   * Point in time (Unix timestamp) at which the date range begins
   * @type {int32} {@link int32}
   */
  start_date: int32;

  /**
   * Point in time (Unix timestamp) at which the date range ends
   * @type {int32} {@link int32}
   */
  end_date: int32;
};

/**
 * Version of {@link dateRange} for method parameters.
 *
 * Represents a date range
 */
export type dateRange$Input = {
  readonly _: "dateRange";

  /**
   * Point in time (Unix timestamp) at which the date range begins
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Point in time (Unix timestamp) at which the date range ends
   * @type {int32} {@link int32}
   */
  readonly end_date?: int32;
};

/**
 * A value with information about its recent changes
 */
export type statisticalValue = {
  _: "statisticalValue";

  /**
   * The current value
   * @type {double} {@link double}
   */
  value: double;

  /**
   * The value for the previous day
   * @type {double} {@link double}
   */
  previous_value: double;

  /**
   * The growth rate of the value, as a percentage
   * @type {double} {@link double}
   */
  growth_rate_percentage: double;
};

/**
 * Version of {@link statisticalValue} for method parameters.
 *
 * A value with information about its recent changes
 */
export type statisticalValue$Input = {
  readonly _: "statisticalValue";

  /**
   * The current value
   * @type {double} {@link double}
   */
  readonly value?: double;

  /**
   * The value for the previous day
   * @type {double} {@link double}
   */
  readonly previous_value?: double;

  /**
   * The growth rate of the value, as a percentage
   * @type {double} {@link double}
   */
  readonly growth_rate_percentage?: double;
};

/**
 * A graph data
 */
export type statisticalGraphData = {
  _: "statisticalGraphData";

  /**
   * Graph data in JSON format
   * @type {string} {@link string}
   */
  json_data: string;

  /**
   * If non-empty, a token which can be used to receive a zoomed in graph
   * @type {string} {@link string}
   */
  zoom_token: string;
};

/**
 * Version of {@link statisticalGraphData} for method parameters.
 *
 * A graph data
 */
export type statisticalGraphData$Input = {
  readonly _: "statisticalGraphData";

  /**
   * Graph data in JSON format
   * @type {string} {@link string}
   */
  readonly json_data?: string;

  /**
   * If non-empty, a token which can be used to receive a zoomed in graph
   * @type {string} {@link string}
   */
  readonly zoom_token?: string;
};

/**
 * The graph data to be asynchronously loaded through getStatisticalGraph
 */
export type statisticalGraphAsync = {
  _: "statisticalGraphAsync";

  /**
   * The token to use for data loading
   * @type {string} {@link string}
   */
  token: string;
};

/**
 * Version of {@link statisticalGraphAsync} for method parameters.
 *
 * The graph data to be asynchronously loaded through getStatisticalGraph
 */
export type statisticalGraphAsync$Input = {
  readonly _: "statisticalGraphAsync";

  /**
   * The token to use for data loading
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * An error message to be shown to the user instead of the graph
 */
export type statisticalGraphError = {
  _: "statisticalGraphError";

  /**
   * The error message
   * @type {string} {@link string}
   */
  error_message: string;
};

/**
 * Version of {@link statisticalGraphError} for method parameters.
 *
 * An error message to be shown to the user instead of the graph
 */
export type statisticalGraphError$Input = {
  readonly _: "statisticalGraphError";

  /**
   * The error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Describes a message sent in the chat
 */
export type chatStatisticsObjectTypeMessage = {
  _: "chatStatisticsObjectTypeMessage";

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link chatStatisticsObjectTypeMessage} for method parameters.
 *
 * Describes a message sent in the chat
 */
export type chatStatisticsObjectTypeMessage$Input = {
  readonly _: "chatStatisticsObjectTypeMessage";

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Describes a story sent by the chat
 */
export type chatStatisticsObjectTypeStory = {
  _: "chatStatisticsObjectTypeStory";

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link chatStatisticsObjectTypeStory} for method parameters.
 *
 * Describes a story sent by the chat
 */
export type chatStatisticsObjectTypeStory$Input = {
  readonly _: "chatStatisticsObjectTypeStory";

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Contains statistics about interactions with a message sent in the chat or a story sent by the chat
 */
export type chatStatisticsInteractionInfo = {
  _: "chatStatisticsInteractionInfo";

  /**
   * Type of the object
   * @type {ChatStatisticsObjectType} {@link ChatStatisticsObjectType}
   */
  object_type: ChatStatisticsObjectType;

  /**
   * Number of times the object was viewed
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Number of times the object was forwarded
   * @type {int32} {@link int32}
   */
  forward_count: int32;

  /**
   * Number of times reactions were added to the object
   * @type {int32} {@link int32}
   */
  reaction_count: int32;
};

/**
 * Version of {@link chatStatisticsInteractionInfo} for method parameters.
 *
 * Contains statistics about interactions with a message sent in the chat or a story sent by the chat
 */
export type chatStatisticsInteractionInfo$Input = {
  readonly _: "chatStatisticsInteractionInfo";

  /**
   * Type of the object
   * @type {ChatStatisticsObjectType} {@link ChatStatisticsObjectType}
   */
  readonly object_type?: ChatStatisticsObjectType$Input;

  /**
   * Number of times the object was viewed
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Number of times the object was forwarded
   * @type {int32} {@link int32}
   */
  readonly forward_count?: int32;

  /**
   * Number of times reactions were added to the object
   * @type {int32} {@link int32}
   */
  readonly reaction_count?: int32;
};

/**
 * Contains statistics about messages sent by a user
 */
export type chatStatisticsMessageSenderInfo = {
  _: "chatStatisticsMessageSenderInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of sent messages
   * @type {int32} {@link int32}
   */
  sent_message_count: int32;

  /**
   * Average number of characters in sent messages; 0 if unknown
   * @type {int32} {@link int32}
   */
  average_character_count: int32;
};

/**
 * Version of {@link chatStatisticsMessageSenderInfo} for method parameters.
 *
 * Contains statistics about messages sent by a user
 */
export type chatStatisticsMessageSenderInfo$Input = {
  readonly _: "chatStatisticsMessageSenderInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of sent messages
   * @type {int32} {@link int32}
   */
  readonly sent_message_count?: int32;

  /**
   * Average number of characters in sent messages; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly average_character_count?: int32;
};

/**
 * Contains statistics about administrator actions done by a user
 */
export type chatStatisticsAdministratorActionsInfo = {
  _: "chatStatisticsAdministratorActionsInfo";

  /**
   * Administrator user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of messages deleted by the administrator
   * @type {int32} {@link int32}
   */
  deleted_message_count: int32;

  /**
   * Number of users banned by the administrator
   * @type {int32} {@link int32}
   */
  banned_user_count: int32;

  /**
   * Number of users restricted by the administrator
   * @type {int32} {@link int32}
   */
  restricted_user_count: int32;
};

/**
 * Version of {@link chatStatisticsAdministratorActionsInfo} for method parameters.
 *
 * Contains statistics about administrator actions done by a user
 */
export type chatStatisticsAdministratorActionsInfo$Input = {
  readonly _: "chatStatisticsAdministratorActionsInfo";

  /**
   * Administrator user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of messages deleted by the administrator
   * @type {int32} {@link int32}
   */
  readonly deleted_message_count?: int32;

  /**
   * Number of users banned by the administrator
   * @type {int32} {@link int32}
   */
  readonly banned_user_count?: int32;

  /**
   * Number of users restricted by the administrator
   * @type {int32} {@link int32}
   */
  readonly restricted_user_count?: int32;
};

/**
 * Contains statistics about number of new members invited by a user
 */
export type chatStatisticsInviterInfo = {
  _: "chatStatisticsInviterInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of new members invited by the user
   * @type {int32} {@link int32}
   */
  added_member_count: int32;
};

/**
 * Version of {@link chatStatisticsInviterInfo} for method parameters.
 *
 * Contains statistics about number of new members invited by a user
 */
export type chatStatisticsInviterInfo$Input = {
  readonly _: "chatStatisticsInviterInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of new members invited by the user
   * @type {int32} {@link int32}
   */
  readonly added_member_count?: int32;
};

/**
 * A detailed statistics about a supergroup chat
 */
export type chatStatisticsSupergroup = {
  _: "chatStatisticsSupergroup";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  period: dateRange;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  member_count: statisticalValue;

  /**
   * Number of messages sent to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  message_count: statisticalValue;

  /**
   * Number of users who viewed messages in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  viewer_count: statisticalValue;

  /**
   * Number of users who sent messages to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  sender_count: statisticalValue;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  member_count_graph: StatisticalGraph;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_graph: StatisticalGraph;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_by_source_graph: StatisticalGraph;

  /**
   * A graph containing distribution of active users per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  language_graph: StatisticalGraph;

  /**
   * A graph containing distribution of sent messages by content type
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_content_graph: StatisticalGraph;

  /**
   * A graph containing number of different actions in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  action_graph: StatisticalGraph;

  /**
   * A graph containing distribution of message views per hour
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  day_graph: StatisticalGraph;

  /**
   * A graph containing distribution of message views per day of week
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  week_graph: StatisticalGraph;

  /**
   * List of users sent most messages in the last week
   * @type {vector<chatStatisticsMessageSenderInfo>} {@link vector<chatStatisticsMessageSenderInfo>}
   */
  top_senders: vector<chatStatisticsMessageSenderInfo>;

  /**
   * List of most active administrators in the last week
   * @type {vector<chatStatisticsAdministratorActionsInfo>} {@link vector<chatStatisticsAdministratorActionsInfo>}
   */
  top_administrators: vector<chatStatisticsAdministratorActionsInfo>;

  /**
   * List of most active inviters of new members in the last week
   * @type {vector<chatStatisticsInviterInfo>} {@link vector<chatStatisticsInviterInfo>}
   */
  top_inviters: vector<chatStatisticsInviterInfo>;
};

/**
 * Version of {@link chatStatisticsSupergroup} for method parameters.
 *
 * A detailed statistics about a supergroup chat
 */
export type chatStatisticsSupergroup$Input = {
  readonly _: "chatStatisticsSupergroup";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  readonly period?: dateRange$Input;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly member_count?: statisticalValue$Input;

  /**
   * Number of messages sent to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly message_count?: statisticalValue$Input;

  /**
   * Number of users who viewed messages in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly viewer_count?: statisticalValue$Input;

  /**
   * Number of users who sent messages to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly sender_count?: statisticalValue$Input;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly member_count_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_by_source_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of active users per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly language_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of sent messages by content type
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_content_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of different actions in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly action_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of message views per hour
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly day_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of message views per day of week
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly week_graph?: StatisticalGraph$Input;

  /**
   * List of users sent most messages in the last week
   * @type {vector<chatStatisticsMessageSenderInfo>} {@link vector<chatStatisticsMessageSenderInfo>}
   */
  readonly top_senders?: vector$Input<chatStatisticsMessageSenderInfo$Input>;

  /**
   * List of most active administrators in the last week
   * @type {vector<chatStatisticsAdministratorActionsInfo>} {@link vector<chatStatisticsAdministratorActionsInfo>}
   */
  readonly top_administrators?: vector$Input<chatStatisticsAdministratorActionsInfo$Input>;

  /**
   * List of most active inviters of new members in the last week
   * @type {vector<chatStatisticsInviterInfo>} {@link vector<chatStatisticsInviterInfo>}
   */
  readonly top_inviters?: vector$Input<chatStatisticsInviterInfo$Input>;
};

/**
 * A detailed statistics about a channel chat
 */
export type chatStatisticsChannel = {
  _: "chatStatisticsChannel";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  period: dateRange;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  member_count: statisticalValue;

  /**
   * Mean number of times the recently sent messages were viewed
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_message_view_count: statisticalValue;

  /**
   * Mean number of times the recently sent messages were shared
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_message_share_count: statisticalValue;

  /**
   * Mean number of times reactions were added to the recently sent messages
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_message_reaction_count: statisticalValue;

  /**
   * Mean number of times the recently sent stories were viewed
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_story_view_count: statisticalValue;

  /**
   * Mean number of times the recently sent stories were shared
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_story_share_count: statisticalValue;

  /**
   * Mean number of times reactions were added to the recently sent stories
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_story_reaction_count: statisticalValue;

  /**
   * A percentage of users with enabled notifications for the chat; 0-100
   * @type {double} {@link double}
   */
  enabled_notifications_percentage: double;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  member_count_graph: StatisticalGraph;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_graph: StatisticalGraph;

  /**
   * A graph containing number of members muted and unmuted the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  mute_graph: StatisticalGraph;

  /**
   * A graph containing number of message views in a given hour in the last two weeks
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  view_count_by_hour_graph: StatisticalGraph;

  /**
   * A graph containing number of message views per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  view_count_by_source_graph: StatisticalGraph;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_by_source_graph: StatisticalGraph;

  /**
   * A graph containing number of users viewed chat messages per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  language_graph: StatisticalGraph;

  /**
   * A graph containing number of chat message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_interaction_graph: StatisticalGraph;

  /**
   * A graph containing number of reactions on messages
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_reaction_graph: StatisticalGraph;

  /**
   * A graph containing number of story views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  story_interaction_graph: StatisticalGraph;

  /**
   * A graph containing number of reactions on stories
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  story_reaction_graph: StatisticalGraph;

  /**
   * A graph containing number of views of associated with the chat instant views
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  instant_view_interaction_graph: StatisticalGraph;

  /**
   * Detailed statistics about number of views and shares of recently sent messages and stories
   * @type {vector<chatStatisticsInteractionInfo>} {@link vector<chatStatisticsInteractionInfo>}
   */
  recent_interactions: vector<chatStatisticsInteractionInfo>;
};

/**
 * Version of {@link chatStatisticsChannel} for method parameters.
 *
 * A detailed statistics about a channel chat
 */
export type chatStatisticsChannel$Input = {
  readonly _: "chatStatisticsChannel";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  readonly period?: dateRange$Input;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly member_count?: statisticalValue$Input;

  /**
   * Mean number of times the recently sent messages were viewed
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_message_view_count?: statisticalValue$Input;

  /**
   * Mean number of times the recently sent messages were shared
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_message_share_count?: statisticalValue$Input;

  /**
   * Mean number of times reactions were added to the recently sent messages
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_message_reaction_count?: statisticalValue$Input;

  /**
   * Mean number of times the recently sent stories were viewed
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_story_view_count?: statisticalValue$Input;

  /**
   * Mean number of times the recently sent stories were shared
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_story_share_count?: statisticalValue$Input;

  /**
   * Mean number of times reactions were added to the recently sent stories
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_story_reaction_count?: statisticalValue$Input;

  /**
   * A percentage of users with enabled notifications for the chat; 0-100
   * @type {double} {@link double}
   */
  readonly enabled_notifications_percentage?: double;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly member_count_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of members muted and unmuted the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly mute_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of message views in a given hour in the last two weeks
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly view_count_by_hour_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of message views per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly view_count_by_source_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_by_source_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of users viewed chat messages per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly language_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of chat message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_interaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of reactions on messages
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_reaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of story views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly story_interaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of reactions on stories
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly story_reaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of views of associated with the chat instant views
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly instant_view_interaction_graph?: StatisticalGraph$Input;

  /**
   * Detailed statistics about number of views and shares of recently sent messages and stories
   * @type {vector<chatStatisticsInteractionInfo>} {@link vector<chatStatisticsInteractionInfo>}
   */
  readonly recent_interactions?: vector$Input<chatStatisticsInteractionInfo$Input>;
};

/**
 * A detailed statistics about a message
 */
export type messageStatistics = {
  _: "messageStatistics";

  /**
   * A graph containing number of message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_interaction_graph: StatisticalGraph;

  /**
   * A graph containing number of message reactions
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_reaction_graph: StatisticalGraph;
};

/**
 * Version of {@link messageStatistics} for method parameters.
 *
 * A detailed statistics about a message
 */
export type messageStatistics$Input = {
  readonly _: "messageStatistics";

  /**
   * A graph containing number of message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_interaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of message reactions
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_reaction_graph?: StatisticalGraph$Input;
};

/**
 * A detailed statistics about a story
 */
export type storyStatistics = {
  _: "storyStatistics";

  /**
   * A graph containing number of story views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  story_interaction_graph: StatisticalGraph;

  /**
   * A graph containing number of story reactions
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  story_reaction_graph: StatisticalGraph;
};

/**
 * Version of {@link storyStatistics} for method parameters.
 *
 * A detailed statistics about a story
 */
export type storyStatistics$Input = {
  readonly _: "storyStatistics";

  /**
   * A graph containing number of story views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly story_interaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of story reactions
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly story_reaction_graph?: StatisticalGraph$Input;
};

/**
 * A point on a Cartesian plane
 */
export type point = {
  _: "point";

  /**
   * The point's first coordinate
   * @type {double} {@link double}
   */
  x: double;

  /**
   * The point's second coordinate
   * @type {double} {@link double}
   */
  y: double;
};

/**
 * Version of {@link point} for method parameters.
 *
 * A point on a Cartesian plane
 */
export type point$Input = {
  readonly _: "point";

  /**
   * The point's first coordinate
   * @type {double} {@link double}
   */
  readonly x?: double;

  /**
   * The point's second coordinate
   * @type {double} {@link double}
   */
  readonly y?: double;
};

/**
 * A straight line to a given point
 */
export type vectorPathCommandLine = {
  _: "vectorPathCommandLine";

  /**
   * The end point of the straight line
   * @type {point} {@link point}
   */
  end_point: point;
};

/**
 * Version of {@link vectorPathCommandLine} for method parameters.
 *
 * A straight line to a given point
 */
export type vectorPathCommandLine$Input = {
  readonly _: "vectorPathCommandLine";

  /**
   * The end point of the straight line
   * @type {point} {@link point}
   */
  readonly end_point?: point$Input;
};

/**
 * A cubic Bézier curve to a given point
 */
export type vectorPathCommandCubicBezierCurve = {
  _: "vectorPathCommandCubicBezierCurve";

  /**
   * The start control point of the curve
   * @type {point} {@link point}
   */
  start_control_point: point;

  /**
   * The end control point of the curve
   * @type {point} {@link point}
   */
  end_control_point: point;

  /**
   * The end point of the curve
   * @type {point} {@link point}
   */
  end_point: point;
};

/**
 * Version of {@link vectorPathCommandCubicBezierCurve} for method parameters.
 *
 * A cubic Bézier curve to a given point
 */
export type vectorPathCommandCubicBezierCurve$Input = {
  readonly _: "vectorPathCommandCubicBezierCurve";

  /**
   * The start control point of the curve
   * @type {point} {@link point}
   */
  readonly start_control_point?: point$Input;

  /**
   * The end control point of the curve
   * @type {point} {@link point}
   */
  readonly end_control_point?: point$Input;

  /**
   * The end point of the curve
   * @type {point} {@link point}
   */
  readonly end_point?: point$Input;
};

/**
 * A scope covering all users
 */
export type botCommandScopeDefault = {
  _: "botCommandScopeDefault";
};

/**
 * Version of {@link botCommandScopeDefault} for method parameters.
 *
 * A scope covering all users
 */
export type botCommandScopeDefault$Input = {
  readonly _: "botCommandScopeDefault";
};

/**
 * A scope covering all private chats
 */
export type botCommandScopeAllPrivateChats = {
  _: "botCommandScopeAllPrivateChats";
};

/**
 * Version of {@link botCommandScopeAllPrivateChats} for method parameters.
 *
 * A scope covering all private chats
 */
export type botCommandScopeAllPrivateChats$Input = {
  readonly _: "botCommandScopeAllPrivateChats";
};

/**
 * A scope covering all group and supergroup chats
 */
export type botCommandScopeAllGroupChats = {
  _: "botCommandScopeAllGroupChats";
};

/**
 * Version of {@link botCommandScopeAllGroupChats} for method parameters.
 *
 * A scope covering all group and supergroup chats
 */
export type botCommandScopeAllGroupChats$Input = {
  readonly _: "botCommandScopeAllGroupChats";
};

/**
 * A scope covering all group and supergroup chat administrators
 */
export type botCommandScopeAllChatAdministrators = {
  _: "botCommandScopeAllChatAdministrators";
};

/**
 * Version of {@link botCommandScopeAllChatAdministrators} for method parameters.
 *
 * A scope covering all group and supergroup chat administrators
 */
export type botCommandScopeAllChatAdministrators$Input = {
  readonly _: "botCommandScopeAllChatAdministrators";
};

/**
 * A scope covering all members of a chat
 */
export type botCommandScopeChat = {
  _: "botCommandScopeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

/**
 * Version of {@link botCommandScopeChat} for method parameters.
 *
 * A scope covering all members of a chat
 */
export type botCommandScopeChat$Input = {
  readonly _: "botCommandScopeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * A scope covering all administrators of a chat
 */
export type botCommandScopeChatAdministrators = {
  _: "botCommandScopeChatAdministrators";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

/**
 * Version of {@link botCommandScopeChatAdministrators} for method parameters.
 *
 * A scope covering all administrators of a chat
 */
export type botCommandScopeChatAdministrators$Input = {
  readonly _: "botCommandScopeChatAdministrators";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * A scope covering a member of a chat
 */
export type botCommandScopeChatMember = {
  _: "botCommandScopeChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

/**
 * Version of {@link botCommandScopeChatMember} for method parameters.
 *
 * A scope covering a member of a chat
 */
export type botCommandScopeChatMember$Input = {
  readonly _: "botCommandScopeChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * The user authorization state has changed
 */
export type updateAuthorizationState = {
  _: "updateAuthorizationState";

  /**
   * New authorization state
   * @type {AuthorizationState} {@link AuthorizationState}
   */
  authorization_state: AuthorizationState;
};

/**
 * Version of {@link updateAuthorizationState} for method parameters.
 *
 * The user authorization state has changed
 */
export type updateAuthorizationState$Input = {
  readonly _: "updateAuthorizationState";

  /**
   * New authorization state
   * @type {AuthorizationState} {@link AuthorizationState}
   */
  readonly authorization_state?: AuthorizationState$Input;
};

/**
 * A new message was received; can also be an outgoing message
 */
export type updateNewMessage = {
  _: "updateNewMessage";

  /**
   * The new message
   * @type {message} {@link message}
   */
  message: message;
};

/**
 * Version of {@link updateNewMessage} for method parameters.
 *
 * A new message was received; can also be an outgoing message
 */
export type updateNewMessage$Input = {
  readonly _: "updateNewMessage";

  /**
   * The new message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/**
 * A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully.
 *
 * - This update is sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
 */
export type updateMessageSendAcknowledged = {
  _: "updateMessageSendAcknowledged";

  /**
   * The chat identifier of the sent message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * A temporary message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link updateMessageSendAcknowledged} for method parameters.
 *
 * A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully.
 *
 * - This update is sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
 */
export type updateMessageSendAcknowledged$Input = {
  readonly _: "updateMessageSendAcknowledged";

  /**
   * The chat identifier of the sent message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * A temporary message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * A message has been successfully sent
 */
export type updateMessageSendSucceeded = {
  _: "updateMessageSendSucceeded";

  /**
   * The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
   * @type {message} {@link message}
   */
  message: message;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  old_message_id: int53;
};

/**
 * Version of {@link updateMessageSendSucceeded} for method parameters.
 *
 * A message has been successfully sent
 */
export type updateMessageSendSucceeded$Input = {
  readonly _: "updateMessageSendSucceeded";

  /**
   * The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  readonly old_message_id?: int53;
};

/**
 * A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
 */
export type updateMessageSendFailed = {
  _: "updateMessageSendFailed";

  /**
   * The failed to send message
   * @type {message} {@link message}
   */
  message: message;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  old_message_id: int53;

  /**
   * The cause of the message sending failure
   * @type {error} {@link error}
   */
  error: error;
};

/**
 * Version of {@link updateMessageSendFailed} for method parameters.
 *
 * A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
 */
export type updateMessageSendFailed$Input = {
  readonly _: "updateMessageSendFailed";

  /**
   * The failed to send message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  readonly old_message_id?: int53;

  /**
   * The cause of the message sending failure
   * @type {error} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * The message content has changed
 */
export type updateMessageContent = {
  _: "updateMessageContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * New message content
   * @type {MessageContent} {@link MessageContent}
   */
  new_content: MessageContent;
};

/**
 * Version of {@link updateMessageContent} for method parameters.
 *
 * The message content has changed
 */
export type updateMessageContent$Input = {
  readonly _: "updateMessageContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * New message content
   * @type {MessageContent} {@link MessageContent}
   */
  readonly new_content?: MessageContent$Input;
};

/**
 * A message was edited. Changes in the message content will come in a separate updateMessageContent
 */
export type updateMessageEdited = {
  _: "updateMessageEdited";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Point in time (Unix timestamp) when the message was edited
   * @type {int32} {@link int32}
   */
  edit_date: int32;

  /**
   * New message reply markup; may be null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup | null;
};

/**
 * Version of {@link updateMessageEdited} for method parameters.
 *
 * A message was edited. Changes in the message content will come in a separate updateMessageContent
 */
export type updateMessageEdited$Input = {
  readonly _: "updateMessageEdited";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Point in time (Unix timestamp) when the message was edited
   * @type {int32} {@link int32}
   */
  readonly edit_date?: int32;

  /**
   * New message reply markup; may be null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * The message pinned state was changed
 */
export type updateMessageIsPinned = {
  _: "updateMessageIsPinned";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

/**
 * Version of {@link updateMessageIsPinned} for method parameters.
 *
 * The message pinned state was changed
 */
export type updateMessageIsPinned$Input = {
  readonly _: "updateMessageIsPinned";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * The information about interactions with a message has changed
 */
export type updateMessageInteractionInfo = {
  _: "updateMessageInteractionInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * New information about interactions with the message; may be null
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  interaction_info: messageInteractionInfo | null;
};

/**
 * Version of {@link updateMessageInteractionInfo} for method parameters.
 *
 * The information about interactions with a message has changed
 */
export type updateMessageInteractionInfo$Input = {
  readonly _: "updateMessageInteractionInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * New information about interactions with the message; may be null
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  readonly interaction_info?: messageInteractionInfo$Input | null;
};

/**
 * The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer
 */
export type updateMessageContentOpened = {
  _: "updateMessageContentOpened";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link updateMessageContentOpened} for method parameters.
 *
 * The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the self-destruct timer
 */
export type updateMessageContentOpened$Input = {
  readonly _: "updateMessageContentOpened";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * A message with an unread mention was read
 */
export type updateMessageMentionRead = {
  _: "updateMessageMentionRead";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * The new number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;
};

/**
 * Version of {@link updateMessageMentionRead} for method parameters.
 *
 * A message with an unread mention was read
 */
export type updateMessageMentionRead$Input = {
  readonly _: "updateMessageMentionRead";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;
};

/**
 * The list of unread reactions added to a message was changed
 */
export type updateMessageUnreadReactions = {
  _: "updateMessageUnreadReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * The new list of unread reactions
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  unread_reactions: vector<unreadReaction>;

  /**
   * The new number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;
};

/**
 * Version of {@link updateMessageUnreadReactions} for method parameters.
 *
 * The list of unread reactions added to a message was changed
 */
export type updateMessageUnreadReactions$Input = {
  readonly _: "updateMessageUnreadReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new list of unread reactions
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  readonly unread_reactions?: vector$Input<unreadReaction$Input>;

  /**
   * The new number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;
};

/**
 * A message with a live location was viewed. When the update is received, the application is supposed to update the live location
 */
export type updateMessageLiveLocationViewed = {
  _: "updateMessageLiveLocationViewed";

  /**
   * Identifier of the chat with the live location message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message with live location
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

/**
 * Version of {@link updateMessageLiveLocationViewed} for method parameters.
 *
 * A message with a live location was viewed. When the update is received, the application is supposed to update the live location
 */
export type updateMessageLiveLocationViewed$Input = {
  readonly _: "updateMessageLiveLocationViewed";

  /**
   * Identifier of the chat with the live location message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with live location
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
 */
export type updateNewChat = {
  _: "updateNewChat";

  /**
   * The chat
   * @type {chat} {@link chat}
   */
  chat: chat;
};

/**
 * Version of {@link updateNewChat} for method parameters.
 *
 * A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
 */
export type updateNewChat$Input = {
  readonly _: "updateNewChat";

  /**
   * The chat
   * @type {chat} {@link chat}
   */
  readonly chat?: chat$Input;
};

/**
 * The title of a chat was changed
 */
export type updateChatTitle = {
  _: "updateChatTitle";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat title
   * @type {string} {@link string}
   */
  title: string;
};

/**
 * Version of {@link updateChatTitle} for method parameters.
 *
 * The title of a chat was changed
 */
export type updateChatTitle$Input = {
  readonly _: "updateChatTitle";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * A chat photo was changed
 */
export type updateChatPhoto = {
  _: "updateChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo | null;
};

/**
 * Version of {@link updateChatPhoto} for method parameters.
 *
 * A chat photo was changed
 */
export type updateChatPhoto$Input = {
  readonly _: "updateChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input | null;
};

/**
 * Chat accent colors have changed
 */
export type updateChatAccentColors = {
  _: "updateChatAccentColors";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat accent color identifier
   * @type {int32} {@link int32}
   */
  accent_color_id: int32;

  /**
   * The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
   * @type {int64} {@link int64}
   */
  background_custom_emoji_id: int64;

  /**
   * The new chat profile accent color identifier; -1 if none
   * @type {int32} {@link int32}
   */
  profile_accent_color_id: int32;

  /**
   * The new identifier of a custom emoji to be shown on the profile background; 0 if none
   * @type {int64} {@link int64}
   */
  profile_background_custom_emoji_id: int64;
};

/**
 * Version of {@link updateChatAccentColors} for method parameters.
 *
 * Chat accent colors have changed
 */
export type updateChatAccentColors$Input = {
  readonly _: "updateChatAccentColors";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat accent color identifier
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * The new identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
   * @type {int64} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;

  /**
   * The new chat profile accent color identifier; -1 if none
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * The new identifier of a custom emoji to be shown on the profile background; 0 if none
   * @type {int64} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;
};

/**
 * Chat permissions were changed
 */
export type updateChatPermissions = {
  _: "updateChatPermissions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  permissions: chatPermissions;
};

/**
 * Version of {@link updateChatPermissions} for method parameters.
 *
 * Chat permissions were changed
 */
export type updateChatPermissions$Input = {
  readonly _: "updateChatPermissions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/**
 * The last message of a chat was changed
 */
export type updateChatLastMessage = {
  _: "updateChatLastMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new last message in the chat; may be null if the last message became unknown. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update
   * @type {message} {@link message}
   */
  last_message: message | null;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  positions: vector<chatPosition>;
};

/**
 * Version of {@link updateChatLastMessage} for method parameters.
 *
 * The last message of a chat was changed
 */
export type updateChatLastMessage$Input = {
  readonly _: "updateChatLastMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new last message in the chat; may be null if the last message became unknown. While the last message is unknown, new messages can be added to the chat without corresponding updateNewMessage update
   * @type {message} {@link message}
   */
  readonly last_message?: message$Input | null;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  readonly positions?: vector$Input<chatPosition$Input>;
};

/**
 * The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update
 */
export type updateChatPosition = {
  _: "updateChatPosition";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New chat position. If new order is 0, then the chat needs to be removed from the list
   * @type {chatPosition} {@link chatPosition}
   */
  position: chatPosition;
};

/**
 * Version of {@link updateChatPosition} for method parameters.
 *
 * The position of a chat in a chat list has changed. An updateChatLastMessage or updateChatDraftMessage update might be sent instead of the update
 */
export type updateChatPosition$Input = {
  readonly _: "updateChatPosition";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New chat position. If new order is 0, then the chat needs to be removed from the list
   * @type {chatPosition} {@link chatPosition}
   */
  readonly position?: chatPosition$Input;
};

/**
 * Incoming messages were read or the number of unread messages has been changed
 */
export type updateChatReadInbox = {
  _: "updateChatReadInbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * The number of unread messages left in the chat
   * @type {int32} {@link int32}
   */
  unread_count: int32;
};

/**
 * Version of {@link updateChatReadInbox} for method parameters.
 *
 * Incoming messages were read or the number of unread messages has been changed
 */
export type updateChatReadInbox$Input = {
  readonly _: "updateChatReadInbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * The number of unread messages left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;
};

/**
 * Outgoing messages were read
 */
export type updateChatReadOutbox = {
  _: "updateChatReadOutbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of last read outgoing message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;
};

/**
 * Version of {@link updateChatReadOutbox} for method parameters.
 *
 * Outgoing messages were read
 */
export type updateChatReadOutbox$Input = {
  readonly _: "updateChatReadOutbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of last read outgoing message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;
};

/**
 * The chat action bar was changed
 */
export type updateChatActionBar = {
  _: "updateChatActionBar";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new value of the action bar; may be null
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  action_bar: ChatActionBar | null;
};

/**
 * Version of {@link updateChatActionBar} for method parameters.
 *
 * The chat action bar was changed
 */
export type updateChatActionBar$Input = {
  readonly _: "updateChatActionBar";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new value of the action bar; may be null
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  readonly action_bar?: ChatActionBar$Input | null;
};

/**
 * The chat available reactions were changed
 */
export type updateChatAvailableReactions = {
  _: "updateChatAvailableReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new reactions, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  available_reactions: ChatAvailableReactions;
};

/**
 * Version of {@link updateChatAvailableReactions} for method parameters.
 *
 * The chat available reactions were changed
 */
export type updateChatAvailableReactions$Input = {
  readonly _: "updateChatAvailableReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new reactions, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;
};

/**
 * A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
 */
export type updateChatDraftMessage = {
  _: "updateChatDraftMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new draft message; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage | null;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  positions: vector<chatPosition>;
};

/**
 * Version of {@link updateChatDraftMessage} for method parameters.
 *
 * A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
 */
export type updateChatDraftMessage$Input = {
  readonly _: "updateChatDraftMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new draft message; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input | null;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  readonly positions?: vector$Input<chatPosition$Input>;
};

/**
 * Chat emoji status has changed
 */
export type updateChatEmojiStatus = {
  _: "updateChatEmojiStatus";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat emoji status; may be null
   * @type {emojiStatus} {@link emojiStatus}
   */
  emoji_status: emojiStatus | null;
};

/**
 * Version of {@link updateChatEmojiStatus} for method parameters.
 *
 * Chat emoji status has changed
 */
export type updateChatEmojiStatus$Input = {
  readonly _: "updateChatEmojiStatus";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat emoji status; may be null
   * @type {emojiStatus} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;
};

/**
 * The message sender that is selected to send messages in a chat has changed
 */
export type updateChatMessageSender = {
  _: "updateChatMessageSender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of message_sender_id; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  message_sender_id: MessageSender | null;
};

/**
 * Version of {@link updateChatMessageSender} for method parameters.
 *
 * The message sender that is selected to send messages in a chat has changed
 */
export type updateChatMessageSender$Input = {
  readonly _: "updateChatMessageSender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of message_sender_id; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input | null;
};

/**
 * The message auto-delete or self-destruct timer setting for a chat was changed
 */
export type updateChatMessageAutoDeleteTime = {
  _: "updateChatMessageAutoDeleteTime";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of message_auto_delete_time
   * @type {int32} {@link int32}
   */
  message_auto_delete_time: int32;
};

/**
 * Version of {@link updateChatMessageAutoDeleteTime} for method parameters.
 *
 * The message auto-delete or self-destruct timer setting for a chat was changed
 */
export type updateChatMessageAutoDeleteTime$Input = {
  readonly _: "updateChatMessageAutoDeleteTime";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of message_auto_delete_time
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;
};

/**
 * Notification settings for a chat were changed
 */
export type updateChatNotificationSettings = {
  _: "updateChatNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new notification settings
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  notification_settings: chatNotificationSettings;
};

/**
 * Version of {@link updateChatNotificationSettings} for method parameters.
 *
 * Notification settings for a chat were changed
 */
export type updateChatNotificationSettings$Input = {
  readonly _: "updateChatNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new notification settings
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/**
 * The chat pending join requests were changed
 */
export type updateChatPendingJoinRequests = {
  _: "updateChatPendingJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new data about pending join requests; may be null
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  pending_join_requests: chatJoinRequestsInfo | null;
};

/**
 * Version of {@link updateChatPendingJoinRequests} for method parameters.
 *
 * The chat pending join requests were changed
 */
export type updateChatPendingJoinRequests$Input = {
  readonly _: "updateChatPendingJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new data about pending join requests; may be null
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  readonly pending_join_requests?: chatJoinRequestsInfo$Input | null;
};

/**
 * The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
 */
export type updateChatReplyMarkup = {
  _: "updateChatReplyMarkup";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  reply_markup_message_id: int53;
};

/**
 * Version of {@link updateChatReplyMarkup} for method parameters.
 *
 * The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
 */
export type updateChatReplyMarkup$Input = {
  readonly _: "updateChatReplyMarkup";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  readonly reply_markup_message_id?: int53;
};

/**
 * The chat background was changed
 */
export type updateChatBackground = {
  _: "updateChatBackground";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat background; may be null if background was reset to default
   * @type {chatBackground} {@link chatBackground}
   */
  background: chatBackground | null;
};

/**
 * Version of {@link updateChatBackground} for method parameters.
 *
 * The chat background was changed
 */
export type updateChatBackground$Input = {
  readonly _: "updateChatBackground";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat background; may be null if background was reset to default
   * @type {chatBackground} {@link chatBackground}
   */
  readonly background?: chatBackground$Input | null;
};

/**
 * The chat theme was changed
 */
export type updateChatTheme = {
  _: "updateChatTheme";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new name of the chat theme; may be empty if theme was reset to default
   * @type {string} {@link string}
   */
  theme_name: string;
};

/**
 * Version of {@link updateChatTheme} for method parameters.
 *
 * The chat theme was changed
 */
export type updateChatTheme$Input = {
  readonly _: "updateChatTheme";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new name of the chat theme; may be empty if theme was reset to default
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * The chat unread_mention_count has changed
 */
export type updateChatUnreadMentionCount = {
  _: "updateChatUnreadMentionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;
};

/**
 * Version of {@link updateChatUnreadMentionCount} for method parameters.
 *
 * The chat unread_mention_count has changed
 */
export type updateChatUnreadMentionCount$Input = {
  readonly _: "updateChatUnreadMentionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;
};

/**
 * The chat unread_reaction_count has changed
 */
export type updateChatUnreadReactionCount = {
  _: "updateChatUnreadReactionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;
};

/**
 * Version of {@link updateChatUnreadReactionCount} for method parameters.
 *
 * The chat unread_reaction_count has changed
 */
export type updateChatUnreadReactionCount$Input = {
  readonly _: "updateChatUnreadReactionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;
};

/**
 * A chat video chat state has changed
 */
export type updateChatVideoChat = {
  _: "updateChatVideoChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of video_chat
   * @type {videoChat} {@link videoChat}
   */
  video_chat: videoChat;
};

/**
 * Version of {@link updateChatVideoChat} for method parameters.
 *
 * A chat video chat state has changed
 */
export type updateChatVideoChat$Input = {
  readonly _: "updateChatVideoChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of video_chat
   * @type {videoChat} {@link videoChat}
   */
  readonly video_chat?: videoChat$Input;
};

/**
 * The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
 */
export type updateChatDefaultDisableNotification = {
  _: "updateChatDefaultDisableNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new default_disable_notification value
   * @type {Bool} {@link Bool}
   */
  default_disable_notification: Bool;
};

/**
 * Version of {@link updateChatDefaultDisableNotification} for method parameters.
 *
 * The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
 */
export type updateChatDefaultDisableNotification$Input = {
  readonly _: "updateChatDefaultDisableNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new default_disable_notification value
   * @type {Bool} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;
};

/**
 * A chat content was allowed or restricted for saving
 */
export type updateChatHasProtectedContent = {
  _: "updateChatHasProtectedContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  has_protected_content: Bool;
};

/**
 * Version of {@link updateChatHasProtectedContent} for method parameters.
 *
 * A chat content was allowed or restricted for saving
 */
export type updateChatHasProtectedContent$Input = {
  readonly _: "updateChatHasProtectedContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/**
 * Translation of chat messages was enabled or disabled
 */
export type updateChatIsTranslatable = {
  _: "updateChatIsTranslatable";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of is_translatable
   * @type {Bool} {@link Bool}
   */
  is_translatable: Bool;
};

/**
 * Version of {@link updateChatIsTranslatable} for method parameters.
 *
 * Translation of chat messages was enabled or disabled
 */
export type updateChatIsTranslatable$Input = {
  readonly _: "updateChatIsTranslatable";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_translatable
   * @type {Bool} {@link Bool}
   */
  readonly is_translatable?: Bool$Input;
};

/**
 * A chat was marked as unread or was read
 */
export type updateChatIsMarkedAsUnread = {
  _: "updateChatIsMarkedAsUnread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool} {@link Bool}
   */
  is_marked_as_unread: Bool;
};

/**
 * Version of {@link updateChatIsMarkedAsUnread} for method parameters.
 *
 * A chat was marked as unread or was read
 */
export type updateChatIsMarkedAsUnread$Input = {
  readonly _: "updateChatIsMarkedAsUnread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;
};

/**
 * A chat default appearance has changed
 */
export type updateChatViewAsTopics = {
  _: "updateChatViewAsTopics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of view_as_topics
   * @type {Bool} {@link Bool}
   */
  view_as_topics: Bool;
};

/**
 * Version of {@link updateChatViewAsTopics} for method parameters.
 *
 * A chat default appearance has changed
 */
export type updateChatViewAsTopics$Input = {
  readonly _: "updateChatViewAsTopics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of view_as_topics
   * @type {Bool} {@link Bool}
   */
  readonly view_as_topics?: Bool$Input;
};

/**
 * A chat was blocked or unblocked
 */
export type updateChatBlockList = {
  _: "updateChatBlockList";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Block list to which the chat is added; may be null if none
   * @type {BlockList} {@link BlockList}
   */
  block_list: BlockList | null;
};

/**
 * Version of {@link updateChatBlockList} for method parameters.
 *
 * A chat was blocked or unblocked
 */
export type updateChatBlockList$Input = {
  readonly _: "updateChatBlockList";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Block list to which the chat is added; may be null if none
   * @type {BlockList} {@link BlockList}
   */
  readonly block_list?: BlockList$Input | null;
};

/**
 * A chat's has_scheduled_messages field has changed
 */
export type updateChatHasScheduledMessages = {
  _: "updateChatHasScheduledMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of has_scheduled_messages
   * @type {Bool} {@link Bool}
   */
  has_scheduled_messages: Bool;
};

/**
 * Version of {@link updateChatHasScheduledMessages} for method parameters.
 *
 * A chat's has_scheduled_messages field has changed
 */
export type updateChatHasScheduledMessages$Input = {
  readonly _: "updateChatHasScheduledMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_scheduled_messages
   * @type {Bool} {@link Bool}
   */
  readonly has_scheduled_messages?: Bool$Input;
};

/**
 * The list of chat folders or a chat folder has changed
 */
export type updateChatFolders = {
  _: "updateChatFolders";

  /**
   * The new list of chat folders
   * @type {vector<chatFolderInfo>} {@link vector<chatFolderInfo>}
   */
  chat_folders: vector<chatFolderInfo>;

  /**
   * Position of the main chat list among chat folders, 0-based
   * @type {int32} {@link int32}
   */
  main_chat_list_position: int32;
};

/**
 * Version of {@link updateChatFolders} for method parameters.
 *
 * The list of chat folders or a chat folder has changed
 */
export type updateChatFolders$Input = {
  readonly _: "updateChatFolders";

  /**
   * The new list of chat folders
   * @type {vector<chatFolderInfo>} {@link vector<chatFolderInfo>}
   */
  readonly chat_folders?: vector$Input<chatFolderInfo$Input>;

  /**
   * Position of the main chat list among chat folders, 0-based
   * @type {int32} {@link int32}
   */
  readonly main_chat_list_position?: int32;
};

/**
 * The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats.
 *
 * - There is no guarantee that it is sent just after the number of online users has changed
 */
export type updateChatOnlineMemberCount = {
  _: "updateChatOnlineMemberCount";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New number of online members in the chat, or 0 if unknown
   * @type {int32} {@link int32}
   */
  online_member_count: int32;
};

/**
 * Version of {@link updateChatOnlineMemberCount} for method parameters.
 *
 * The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats.
 *
 * - There is no guarantee that it is sent just after the number of online users has changed
 */
export type updateChatOnlineMemberCount$Input = {
  readonly _: "updateChatOnlineMemberCount";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New number of online members in the chat, or 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly online_member_count?: int32;
};

/**
 * Basic information about a topic in a forum chat was changed
 */
export type updateForumTopicInfo = {
  _: "updateForumTopicInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  info: forumTopicInfo;
};

/**
 * Version of {@link updateForumTopicInfo} for method parameters.
 *
 * Basic information about a topic in a forum chat was changed
 */
export type updateForumTopicInfo$Input = {
  readonly _: "updateForumTopicInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly info?: forumTopicInfo$Input;
};

/**
 * Notification settings for some type of chats were updated
 */
export type updateScopeNotificationSettings = {
  _: "updateScopeNotificationSettings";

  /**
   * Types of chats for which notification settings were updated
   * @type {NotificationSettingsScope} {@link NotificationSettingsScope}
   */
  scope: NotificationSettingsScope;

  /**
   * The new notification settings
   * @type {scopeNotificationSettings} {@link scopeNotificationSettings}
   */
  notification_settings: scopeNotificationSettings;
};

/**
 * Version of {@link updateScopeNotificationSettings} for method parameters.
 *
 * Notification settings for some type of chats were updated
 */
export type updateScopeNotificationSettings$Input = {
  readonly _: "updateScopeNotificationSettings";

  /**
   * Types of chats for which notification settings were updated
   * @type {NotificationSettingsScope} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;

  /**
   * The new notification settings
   * @type {scopeNotificationSettings} {@link scopeNotificationSettings}
   */
  readonly notification_settings?: scopeNotificationSettings$Input;
};

/**
 * A notification was changed
 */
export type updateNotification = {
  _: "updateNotification";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  notification_group_id: int32;

  /**
   * Changed notification
   * @type {notification} {@link notification}
   */
  notification: notification;
};

/**
 * Version of {@link updateNotification} for method parameters.
 *
 * A notification was changed
 */
export type updateNotification$Input = {
  readonly _: "updateNotification";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * Changed notification
   * @type {notification} {@link notification}
   */
  readonly notification?: notification$Input;
};

/**
 * A list of active notifications in a notification group has changed
 */
export type updateNotificationGroup = {
  _: "updateNotificationGroup";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  notification_group_id: int32;

  /**
   * New type of the notification group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  type: NotificationGroupType;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Chat identifier, which notification settings must be applied to the added notifications
   * @type {int53} {@link int53}
   */
  notification_settings_chat_id: int53;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  notification_sound_id: int64;

  /**
   * Total number of unread notifications in the group, can be bigger than number of active notifications
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of added group notifications, sorted by notification identifier
   * @type {vector<notification>} {@link vector<notification>}
   */
  added_notifications: vector<notification>;

  /**
   * Identifiers of removed group notifications, sorted by notification identifier
   * @type {vector<int32>} {@link vector<int32>}
   */
  removed_notification_ids: vector<int32>;
};

/**
 * Version of {@link updateNotificationGroup} for method parameters.
 *
 * A list of active notifications in a notification group has changed
 */
export type updateNotificationGroup$Input = {
  readonly _: "updateNotificationGroup";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * New type of the notification group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  readonly type?: NotificationGroupType$Input;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Chat identifier, which notification settings must be applied to the added notifications
   * @type {int53} {@link int53}
   */
  readonly notification_settings_chat_id?: int53;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly notification_sound_id?: int64$Input;

  /**
   * Total number of unread notifications in the group, can be bigger than number of active notifications
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of added group notifications, sorted by notification identifier
   * @type {vector<notification>} {@link vector<notification>}
   */
  readonly added_notifications?: vector$Input<notification$Input>;

  /**
   * Identifiers of removed group notifications, sorted by notification identifier
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly removed_notification_ids?: vector$Input<int32>;
};

/**
 * Contains active notifications that were shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
 */
export type updateActiveNotifications = {
  _: "updateActiveNotifications";

  /**
   * Lists of active notification groups
   * @type {vector<notificationGroup>} {@link vector<notificationGroup>}
   */
  groups: vector<notificationGroup>;
};

/**
 * Version of {@link updateActiveNotifications} for method parameters.
 *
 * Contains active notifications that were shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
 */
export type updateActiveNotifications$Input = {
  readonly _: "updateActiveNotifications";

  /**
   * Lists of active notification groups
   * @type {vector<notificationGroup>} {@link vector<notificationGroup>}
   */
  readonly groups?: vector$Input<notificationGroup$Input>;
};

/**
 * Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
 */
export type updateHavePendingNotifications = {
  _: "updateHavePendingNotifications";

  /**
   * True, if there are some delayed notification updates, which will be sent soon
   * @type {Bool} {@link Bool}
   */
  have_delayed_notifications: Bool;

  /**
   * True, if there can be some yet unreceived notifications, which are being fetched from the server
   * @type {Bool} {@link Bool}
   */
  have_unreceived_notifications: Bool;
};

/**
 * Version of {@link updateHavePendingNotifications} for method parameters.
 *
 * Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
 */
export type updateHavePendingNotifications$Input = {
  readonly _: "updateHavePendingNotifications";

  /**
   * True, if there are some delayed notification updates, which will be sent soon
   * @type {Bool} {@link Bool}
   */
  readonly have_delayed_notifications?: Bool$Input;

  /**
   * True, if there can be some yet unreceived notifications, which are being fetched from the server
   * @type {Bool} {@link Bool}
   */
  readonly have_unreceived_notifications?: Bool$Input;
};

/**
 * Some messages were deleted
 */
export type updateDeleteMessages = {
  _: "updateDeleteMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifiers of the deleted messages
   * @type {vector<int53>} {@link vector<int53>}
   */
  message_ids: vector<int53>;

  /**
   * True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
   * @type {Bool} {@link Bool}
   */
  is_permanent: Bool;

  /**
   * True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
   * @type {Bool} {@link Bool}
   */
  from_cache: Bool;
};

/**
 * Version of {@link updateDeleteMessages} for method parameters.
 *
 * Some messages were deleted
 */
export type updateDeleteMessages$Input = {
  readonly _: "updateDeleteMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the deleted messages
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
   * @type {Bool} {@link Bool}
   */
  readonly is_permanent?: Bool$Input;

  /**
   * True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
   * @type {Bool} {@link Bool}
   */
  readonly from_cache?: Bool$Input;
};

/**
 * A message sender activity in the chat has changed
 */
export type updateChatAction = {
  _: "updateChatAction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * Identifier of a message sender performing the action
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * The action
   * @type {ChatAction} {@link ChatAction}
   */
  action: ChatAction;
};

/**
 * Version of {@link updateChatAction} for method parameters.
 *
 * A message sender activity in the chat has changed
 */
export type updateChatAction$Input = {
  readonly _: "updateChatAction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of a message sender performing the action
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * The action
   * @type {ChatAction} {@link ChatAction}
   */
  readonly action?: ChatAction$Input;
};

/**
 * The user went online or offline
 */
export type updateUserStatus = {
  _: "updateUserStatus";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * New status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  status: UserStatus;
};

/**
 * Version of {@link updateUserStatus} for method parameters.
 *
 * The user went online or offline
 */
export type updateUserStatus$Input = {
  readonly _: "updateUserStatus";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  readonly status?: UserStatus$Input;
};

/**
 * Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
 */
export type updateUser = {
  _: "updateUser";

  /**
   * New data about the user
   * @type {user} {@link user}
   */
  user: user;
};

/**
 * Version of {@link updateUser} for method parameters.
 *
 * Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
 */
export type updateUser$Input = {
  readonly _: "updateUser";

  /**
   * New data about the user
   * @type {user} {@link user}
   */
  readonly user?: user$Input;
};

/**
 * Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
 */
export type updateBasicGroup = {
  _: "updateBasicGroup";

  /**
   * New data about the group
   * @type {basicGroup} {@link basicGroup}
   */
  basic_group: basicGroup;
};

/**
 * Version of {@link updateBasicGroup} for method parameters.
 *
 * Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
 */
export type updateBasicGroup$Input = {
  readonly _: "updateBasicGroup";

  /**
   * New data about the group
   * @type {basicGroup} {@link basicGroup}
   */
  readonly basic_group?: basicGroup$Input;
};

/**
 * Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
 */
export type updateSupergroup = {
  _: "updateSupergroup";

  /**
   * New data about the supergroup
   * @type {supergroup} {@link supergroup}
   */
  supergroup: supergroup;
};

/**
 * Version of {@link updateSupergroup} for method parameters.
 *
 * Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
 */
export type updateSupergroup$Input = {
  readonly _: "updateSupergroup";

  /**
   * New data about the supergroup
   * @type {supergroup} {@link supergroup}
   */
  readonly supergroup?: supergroup$Input;
};

/**
 * Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
 */
export type updateSecretChat = {
  _: "updateSecretChat";

  /**
   * New data about the secret chat
   * @type {secretChat} {@link secretChat}
   */
  secret_chat: secretChat;
};

/**
 * Version of {@link updateSecretChat} for method parameters.
 *
 * Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
 */
export type updateSecretChat$Input = {
  readonly _: "updateSecretChat";

  /**
   * New data about the secret chat
   * @type {secretChat} {@link secretChat}
   */
  readonly secret_chat?: secretChat$Input;
};

/**
 * Some data in userFullInfo has been changed
 */
export type updateUserFullInfo = {
  _: "updateUserFullInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * New full information about the user
   * @type {userFullInfo} {@link userFullInfo}
   */
  user_full_info: userFullInfo;
};

/**
 * Version of {@link updateUserFullInfo} for method parameters.
 *
 * Some data in userFullInfo has been changed
 */
export type updateUserFullInfo$Input = {
  readonly _: "updateUserFullInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New full information about the user
   * @type {userFullInfo} {@link userFullInfo}
   */
  readonly user_full_info?: userFullInfo$Input;
};

/**
 * Some data in basicGroupFullInfo has been changed
 */
export type updateBasicGroupFullInfo = {
  _: "updateBasicGroupFullInfo";

  /**
   * Identifier of a basic group
   * @type {int53} {@link int53}
   */
  basic_group_id: int53;

  /**
   * New full information about the group
   * @type {basicGroupFullInfo} {@link basicGroupFullInfo}
   */
  basic_group_full_info: basicGroupFullInfo;
};

/**
 * Version of {@link updateBasicGroupFullInfo} for method parameters.
 *
 * Some data in basicGroupFullInfo has been changed
 */
export type updateBasicGroupFullInfo$Input = {
  readonly _: "updateBasicGroupFullInfo";

  /**
   * Identifier of a basic group
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;

  /**
   * New full information about the group
   * @type {basicGroupFullInfo} {@link basicGroupFullInfo}
   */
  readonly basic_group_full_info?: basicGroupFullInfo$Input;
};

/**
 * Some data in supergroupFullInfo has been changed
 */
export type updateSupergroupFullInfo = {
  _: "updateSupergroupFullInfo";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;

  /**
   * New full information about the supergroup
   * @type {supergroupFullInfo} {@link supergroupFullInfo}
   */
  supergroup_full_info: supergroupFullInfo;
};

/**
 * Version of {@link updateSupergroupFullInfo} for method parameters.
 *
 * Some data in supergroupFullInfo has been changed
 */
export type updateSupergroupFullInfo$Input = {
  readonly _: "updateSupergroupFullInfo";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New full information about the supergroup
   * @type {supergroupFullInfo} {@link supergroupFullInfo}
   */
  readonly supergroup_full_info?: supergroupFullInfo$Input;
};

/**
 * A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification
 */
export type updateServiceNotification = {
  _: "updateServiceNotification";

  /**
   * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
   * @type {string} {@link string}
   */
  type: string;

  /**
   * Notification content
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent;
};

/**
 * Version of {@link updateServiceNotification} for method parameters.
 *
 * A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification
 */
export type updateServiceNotification$Input = {
  readonly _: "updateServiceNotification";

  /**
   * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Notification content
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input;
};

/**
 * Information about a file was updated
 */
export type updateFile = {
  _: "updateFile";

  /**
   * New data about the file
   * @type {file} {@link file}
   */
  file: file;
};

/**
 * Version of {@link updateFile} for method parameters.
 *
 * Information about a file was updated
 */
export type updateFile$Input = {
  readonly _: "updateFile";

  /**
   * New data about the file
   * @type {file} {@link file}
   */
  readonly file?: file$Input;
};

/**
 * The file generation process needs to be started by the application
 */
export type updateFileGenerationStart = {
  _: "updateFileGenerationStart";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  generation_id: int64;

  /**
   * The path to a file from which a new file is generated; may be empty
   * @type {string} {@link string}
   */
  original_path: string;

  /**
   * The path to a file that must be created and where the new file is generated
   * @type {string} {@link string}
   */
  destination_path: string;

  /**
   * String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
   * @type {string} {@link string}
   */
  conversion: string;
};

/**
 * Version of {@link updateFileGenerationStart} for method parameters.
 *
 * The file generation process needs to be started by the application
 */
export type updateFileGenerationStart$Input = {
  readonly _: "updateFileGenerationStart";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * The path to a file from which a new file is generated; may be empty
   * @type {string} {@link string}
   */
  readonly original_path?: string;

  /**
   * The path to a file that must be created and where the new file is generated
   * @type {string} {@link string}
   */
  readonly destination_path?: string;

  /**
   * String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
   * @type {string} {@link string}
   */
  readonly conversion?: string;
};

/**
 * File generation is no longer needed
 */
export type updateFileGenerationStop = {
  _: "updateFileGenerationStop";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  generation_id: int64;
};

/**
 * Version of {@link updateFileGenerationStop} for method parameters.
 *
 * File generation is no longer needed
 */
export type updateFileGenerationStop$Input = {
  readonly _: "updateFileGenerationStop";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64$Input;
};

/**
 * The state of the file download list has changed
 */
export type updateFileDownloads = {
  _: "updateFileDownloads";

  /**
   * Total size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  total_size: int53;

  /**
   * Total number of files in the file download list
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Total downloaded size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  downloaded_size: int53;
};

/**
 * Version of {@link updateFileDownloads} for method parameters.
 *
 * The state of the file download list has changed
 */
export type updateFileDownloads$Input = {
  readonly _: "updateFileDownloads";

  /**
   * Total size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  readonly total_size?: int53;

  /**
   * Total number of files in the file download list
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Total downloaded size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  readonly downloaded_size?: int53;
};

/**
 * A file was added to the file download list. This update is sent only after file download list is loaded for the first time
 */
export type updateFileAddedToDownloads = {
  _: "updateFileAddedToDownloads";

  /**
   * The added file download
   * @type {fileDownload} {@link fileDownload}
   */
  file_download: fileDownload;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  counts: downloadedFileCounts;
};

/**
 * Version of {@link updateFileAddedToDownloads} for method parameters.
 *
 * A file was added to the file download list. This update is sent only after file download list is loaded for the first time
 */
export type updateFileAddedToDownloads$Input = {
  readonly _: "updateFileAddedToDownloads";

  /**
   * The added file download
   * @type {fileDownload} {@link fileDownload}
   */
  readonly file_download?: fileDownload$Input;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly counts?: downloadedFileCounts$Input;
};

/**
 * A file download was changed. This update is sent only after file download list is loaded for the first time
 */
export type updateFileDownload = {
  _: "updateFileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  file_id: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  complete_date: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  is_paused: Bool;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  counts: downloadedFileCounts;
};

/**
 * Version of {@link updateFileDownload} for method parameters.
 *
 * A file download was changed. This update is sent only after file download list is loaded for the first time
 */
export type updateFileDownload$Input = {
  readonly _: "updateFileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  readonly complete_date?: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  readonly is_paused?: Bool$Input;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly counts?: downloadedFileCounts$Input;
};

/**
 * A file was removed from the file download list. This update is sent only after file download list is loaded for the first time
 */
export type updateFileRemovedFromDownloads = {
  _: "updateFileRemovedFromDownloads";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  file_id: int32;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  counts: downloadedFileCounts;
};

/**
 * Version of {@link updateFileRemovedFromDownloads} for method parameters.
 *
 * A file was removed from the file download list. This update is sent only after file download list is loaded for the first time
 */
export type updateFileRemovedFromDownloads$Input = {
  readonly _: "updateFileRemovedFromDownloads";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly counts?: downloadedFileCounts$Input;
};

/**
 * New call was created or information about a call was updated
 */
export type updateCall = {
  _: "updateCall";

  /**
   * New data about a call
   * @type {call} {@link call}
   */
  call: call;
};

/**
 * Version of {@link updateCall} for method parameters.
 *
 * New call was created or information about a call was updated
 */
export type updateCall$Input = {
  readonly _: "updateCall";

  /**
   * New data about a call
   * @type {call} {@link call}
   */
  readonly call?: call$Input;
};

/**
 * Information about a group call was updated
 */
export type updateGroupCall = {
  _: "updateGroupCall";

  /**
   * New data about a group call
   * @type {groupCall} {@link groupCall}
   */
  group_call: groupCall;
};

/**
 * Version of {@link updateGroupCall} for method parameters.
 *
 * Information about a group call was updated
 */
export type updateGroupCall$Input = {
  readonly _: "updateGroupCall";

  /**
   * New data about a group call
   * @type {groupCall} {@link groupCall}
   */
  readonly group_call?: groupCall$Input;
};

/**
 * Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
 */
export type updateGroupCallParticipant = {
  _: "updateGroupCallParticipant";

  /**
   * Identifier of group call
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * New data about a participant
   * @type {groupCallParticipant} {@link groupCallParticipant}
   */
  participant: groupCallParticipant;
};

/**
 * Version of {@link updateGroupCallParticipant} for method parameters.
 *
 * Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
 */
export type updateGroupCallParticipant$Input = {
  readonly _: "updateGroupCallParticipant";

  /**
   * Identifier of group call
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New data about a participant
   * @type {groupCallParticipant} {@link groupCallParticipant}
   */
  readonly participant?: groupCallParticipant$Input;
};

/**
 * New call signaling data arrived
 */
export type updateNewCallSignalingData = {
  _: "updateNewCallSignalingData";

  /**
   * The call identifier
   * @type {int32} {@link int32}
   */
  call_id: int32;

  /**
   * The data
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

/**
 * Version of {@link updateNewCallSignalingData} for method parameters.
 *
 * New call signaling data arrived
 */
export type updateNewCallSignalingData$Input = {
  readonly _: "updateNewCallSignalingData";

  /**
   * The call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The data
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * Some privacy setting rules have been changed
 */
export type updateUserPrivacySettingRules = {
  _: "updateUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting} {@link UserPrivacySetting}
   */
  setting: UserPrivacySetting;

  /**
   * New privacy rules
   * @type {userPrivacySettingRules} {@link userPrivacySettingRules}
   */
  rules: userPrivacySettingRules;
};

/**
 * Version of {@link updateUserPrivacySettingRules} for method parameters.
 *
 * Some privacy setting rules have been changed
 */
export type updateUserPrivacySettingRules$Input = {
  readonly _: "updateUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;

  /**
   * New privacy rules
   * @type {userPrivacySettingRules} {@link userPrivacySettingRules}
   */
  readonly rules?: userPrivacySettingRules$Input;
};

/**
 * Number of unread messages in a chat list has changed. This update is sent only if the message database is used
 */
export type updateUnreadMessageCount = {
  _: "updateUnreadMessageCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  chat_list: ChatList;

  /**
   * Total number of unread messages
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Total number of unread messages in unmuted chats
   * @type {int32} {@link int32}
   */
  unread_unmuted_count: int32;
};

/**
 * Version of {@link updateUnreadMessageCount} for method parameters.
 *
 * Number of unread messages in a chat list has changed. This update is sent only if the message database is used
 */
export type updateUnreadMessageCount$Input = {
  readonly _: "updateUnreadMessageCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Total number of unread messages
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Total number of unread messages in unmuted chats
   * @type {int32} {@link int32}
   */
  readonly unread_unmuted_count?: int32;
};

/**
 * Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
 */
export type updateUnreadChatCount = {
  _: "updateUnreadChatCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  chat_list: ChatList;

  /**
   * Approximate total number of chats in the chat list
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Total number of unread chats
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Total number of unread unmuted chats
   * @type {int32} {@link int32}
   */
  unread_unmuted_count: int32;

  /**
   * Total number of chats marked as unread
   * @type {int32} {@link int32}
   */
  marked_as_unread_count: int32;

  /**
   * Total number of unmuted chats marked as unread
   * @type {int32} {@link int32}
   */
  marked_as_unread_unmuted_count: int32;
};

/**
 * Version of {@link updateUnreadChatCount} for method parameters.
 *
 * Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
 */
export type updateUnreadChatCount$Input = {
  readonly _: "updateUnreadChatCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Approximate total number of chats in the chat list
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Total number of unread chats
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Total number of unread unmuted chats
   * @type {int32} {@link int32}
   */
  readonly unread_unmuted_count?: int32;

  /**
   * Total number of chats marked as unread
   * @type {int32} {@link int32}
   */
  readonly marked_as_unread_count?: int32;

  /**
   * Total number of unmuted chats marked as unread
   * @type {int32} {@link int32}
   */
  readonly marked_as_unread_unmuted_count?: int32;
};

/**
 * A story was changed
 */
export type updateStory = {
  _: "updateStory";

  /**
   * The new information about the story
   * @type {story} {@link story}
   */
  story: story;
};

/**
 * Version of {@link updateStory} for method parameters.
 *
 * A story was changed
 */
export type updateStory$Input = {
  readonly _: "updateStory";

  /**
   * The new information about the story
   * @type {story} {@link story}
   */
  readonly story?: story$Input;
};

/**
 * A story became inaccessible
 */
export type updateStoryDeleted = {
  _: "updateStoryDeleted";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  story_sender_chat_id: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  story_id: int32;
};

/**
 * Version of {@link updateStoryDeleted} for method parameters.
 *
 * A story became inaccessible
 */
export type updateStoryDeleted$Input = {
  readonly _: "updateStoryDeleted";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * A story has been successfully sent
 */
export type updateStorySendSucceeded = {
  _: "updateStorySendSucceeded";

  /**
   * The sent story
   * @type {story} {@link story}
   */
  story: story;

  /**
   * The previous temporary story identifier
   * @type {int32} {@link int32}
   */
  old_story_id: int32;
};

/**
 * Version of {@link updateStorySendSucceeded} for method parameters.
 *
 * A story has been successfully sent
 */
export type updateStorySendSucceeded$Input = {
  readonly _: "updateStorySendSucceeded";

  /**
   * The sent story
   * @type {story} {@link story}
   */
  readonly story?: story$Input;

  /**
   * The previous temporary story identifier
   * @type {int32} {@link int32}
   */
  readonly old_story_id?: int32;
};

/**
 * A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update
 */
export type updateStorySendFailed = {
  _: "updateStorySendFailed";

  /**
   * The failed to send story
   * @type {story} {@link story}
   */
  story: story;

  /**
   * The cause of the story sending failure
   * @type {error} {@link error}
   */
  error: error;

  /**
   * Type of the error; may be null if unknown
   * @type {CanSendStoryResult} {@link CanSendStoryResult}
   */
  error_type: CanSendStoryResult | null;
};

/**
 * Version of {@link updateStorySendFailed} for method parameters.
 *
 * A story failed to send. If the story sending is canceled, then updateStoryDeleted will be received instead of this update
 */
export type updateStorySendFailed$Input = {
  readonly _: "updateStorySendFailed";

  /**
   * The failed to send story
   * @type {story} {@link story}
   */
  readonly story?: story$Input;

  /**
   * The cause of the story sending failure
   * @type {error} {@link error}
   */
  readonly error?: error$Input;

  /**
   * Type of the error; may be null if unknown
   * @type {CanSendStoryResult} {@link CanSendStoryResult}
   */
  readonly error_type?: CanSendStoryResult$Input | null;
};

/**
 * The list of active stories posted by a specific chat has changed
 */
export type updateChatActiveStories = {
  _: "updateChatActiveStories";

  /**
   * The new list of active stories
   * @type {chatActiveStories} {@link chatActiveStories}
   */
  active_stories: chatActiveStories;
};

/**
 * Version of {@link updateChatActiveStories} for method parameters.
 *
 * The list of active stories posted by a specific chat has changed
 */
export type updateChatActiveStories$Input = {
  readonly _: "updateChatActiveStories";

  /**
   * The new list of active stories
   * @type {chatActiveStories} {@link chatActiveStories}
   */
  readonly active_stories?: chatActiveStories$Input;
};

/**
 * Number of chats in a story list has changed
 */
export type updateStoryListChatCount = {
  _: "updateStoryListChatCount";

  /**
   * The story list
   * @type {StoryList} {@link StoryList}
   */
  story_list: StoryList;

  /**
   * Approximate total number of chats with active stories in the list
   * @type {int32} {@link int32}
   */
  chat_count: int32;
};

/**
 * Version of {@link updateStoryListChatCount} for method parameters.
 *
 * Number of chats in a story list has changed
 */
export type updateStoryListChatCount$Input = {
  readonly _: "updateStoryListChatCount";

  /**
   * The story list
   * @type {StoryList} {@link StoryList}
   */
  readonly story_list?: StoryList$Input;

  /**
   * Approximate total number of chats with active stories in the list
   * @type {int32} {@link int32}
   */
  readonly chat_count?: int32;
};

/**
 * Story stealth mode settings have changed
 */
export type updateStoryStealthMode = {
  _: "updateStoryStealthMode";

  /**
   * Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
   * @type {int32} {@link int32}
   */
  active_until_date: int32;

  /**
   * Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
   * @type {int32} {@link int32}
   */
  cooldown_until_date: int32;
};

/**
 * Version of {@link updateStoryStealthMode} for method parameters.
 *
 * Story stealth mode settings have changed
 */
export type updateStoryStealthMode$Input = {
  readonly _: "updateStoryStealthMode";

  /**
   * Point in time (Unix timestamp) until stealth mode is active; 0 if it is disabled
   * @type {int32} {@link int32}
   */
  readonly active_until_date?: int32;

  /**
   * Point in time (Unix timestamp) when stealth mode can be enabled again; 0 if there is no active cooldown
   * @type {int32} {@link int32}
   */
  readonly cooldown_until_date?: int32;
};

/**
 * An option changed its value
 */
export type updateOption = {
  _: "updateOption";

  /**
   * The option name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * The new option value
   * @type {OptionValue} {@link OptionValue}
   */
  value: OptionValue;
};

/**
 * Version of {@link updateOption} for method parameters.
 *
 * An option changed its value
 */
export type updateOption$Input = {
  readonly _: "updateOption";

  /**
   * The option name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * The new option value
   * @type {OptionValue} {@link OptionValue}
   */
  readonly value?: OptionValue$Input;
};

/**
 * A sticker set has changed
 */
export type updateStickerSet = {
  _: "updateStickerSet";

  /**
   * The sticker set
   * @type {stickerSet} {@link stickerSet}
   */
  sticker_set: stickerSet;
};

/**
 * Version of {@link updateStickerSet} for method parameters.
 *
 * A sticker set has changed
 */
export type updateStickerSet$Input = {
  readonly _: "updateStickerSet";

  /**
   * The sticker set
   * @type {stickerSet} {@link stickerSet}
   */
  readonly sticker_set?: stickerSet$Input;
};

/**
 * The list of installed sticker sets was updated
 */
export type updateInstalledStickerSets = {
  _: "updateInstalledStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * The new list of installed ordinary sticker sets
   * @type {vector<int64>} {@link vector<int64>}
   */
  sticker_set_ids: vector<int64>;
};

/**
 * Version of {@link updateInstalledStickerSets} for method parameters.
 *
 * The list of installed sticker sets was updated
 */
export type updateInstalledStickerSets$Input = {
  readonly _: "updateInstalledStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The new list of installed ordinary sticker sets
   * @type {vector<int64>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64$Input>;
};

/**
 * The list of trending sticker sets was updated or some of them were viewed
 */
export type updateTrendingStickerSets = {
  _: "updateTrendingStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * The prefix of the list of trending sticker sets with the newest trending sticker sets
   * @type {trendingStickerSets} {@link trendingStickerSets}
   */
  sticker_sets: trendingStickerSets;
};

/**
 * Version of {@link updateTrendingStickerSets} for method parameters.
 *
 * The list of trending sticker sets was updated or some of them were viewed
 */
export type updateTrendingStickerSets$Input = {
  readonly _: "updateTrendingStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The prefix of the list of trending sticker sets with the newest trending sticker sets
   * @type {trendingStickerSets} {@link trendingStickerSets}
   */
  readonly sticker_sets?: trendingStickerSets$Input;
};

/**
 * The list of recently used stickers was updated
 */
export type updateRecentStickers = {
  _: "updateRecentStickers";

  /**
   * True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
   * @type {Bool} {@link Bool}
   */
  is_attached: Bool;

  /**
   * The new list of file identifiers of recently used stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  sticker_ids: vector<int32>;
};

/**
 * Version of {@link updateRecentStickers} for method parameters.
 *
 * The list of recently used stickers was updated
 */
export type updateRecentStickers$Input = {
  readonly _: "updateRecentStickers";

  /**
   * True, if the list of stickers attached to photo or video files was updated; otherwise, the list of sent stickers is updated
   * @type {Bool} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * The new list of file identifiers of recently used stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly sticker_ids?: vector$Input<int32>;
};

/**
 * The list of favorite stickers was updated
 */
export type updateFavoriteStickers = {
  _: "updateFavoriteStickers";

  /**
   * The new list of file identifiers of favorite stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  sticker_ids: vector<int32>;
};

/**
 * Version of {@link updateFavoriteStickers} for method parameters.
 *
 * The list of favorite stickers was updated
 */
export type updateFavoriteStickers$Input = {
  readonly _: "updateFavoriteStickers";

  /**
   * The new list of file identifiers of favorite stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly sticker_ids?: vector$Input<int32>;
};

/**
 * The list of saved animations was updated
 */
export type updateSavedAnimations = {
  _: "updateSavedAnimations";

  /**
   * The new list of file identifiers of saved animations
   * @type {vector<int32>} {@link vector<int32>}
   */
  animation_ids: vector<int32>;
};

/**
 * Version of {@link updateSavedAnimations} for method parameters.
 *
 * The list of saved animations was updated
 */
export type updateSavedAnimations$Input = {
  readonly _: "updateSavedAnimations";

  /**
   * The new list of file identifiers of saved animations
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly animation_ids?: vector$Input<int32>;
};

/**
 * The list of saved notification sounds was updated. This update may not be sent until information about a notification sound was requested for the first time
 */
export type updateSavedNotificationSounds = {
  _: "updateSavedNotificationSounds";

  /**
   * The new list of identifiers of saved notification sounds
   * @type {vector<int64>} {@link vector<int64>}
   */
  notification_sound_ids: vector<int64>;
};

/**
 * Version of {@link updateSavedNotificationSounds} for method parameters.
 *
 * The list of saved notification sounds was updated. This update may not be sent until information about a notification sound was requested for the first time
 */
export type updateSavedNotificationSounds$Input = {
  readonly _: "updateSavedNotificationSounds";

  /**
   * The new list of identifiers of saved notification sounds
   * @type {vector<int64>} {@link vector<int64>}
   */
  readonly notification_sound_ids?: vector$Input<int64$Input>;
};

/**
 * The default background has changed
 */
export type updateDefaultBackground = {
  _: "updateDefaultBackground";

  /**
   * True, if default background for dark theme has changed
   * @type {Bool} {@link Bool}
   */
  for_dark_theme: Bool;

  /**
   * The new default background; may be null
   * @type {background} {@link background}
   */
  background: background | null;
};

/**
 * Version of {@link updateDefaultBackground} for method parameters.
 *
 * The default background has changed
 */
export type updateDefaultBackground$Input = {
  readonly _: "updateDefaultBackground";

  /**
   * True, if default background for dark theme has changed
   * @type {Bool} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;

  /**
   * The new default background; may be null
   * @type {background} {@link background}
   */
  readonly background?: background$Input | null;
};

/**
 * The list of available chat themes has changed
 */
export type updateChatThemes = {
  _: "updateChatThemes";

  /**
   * The new list of chat themes
   * @type {vector<chatTheme>} {@link vector<chatTheme>}
   */
  chat_themes: vector<chatTheme>;
};

/**
 * Version of {@link updateChatThemes} for method parameters.
 *
 * The list of available chat themes has changed
 */
export type updateChatThemes$Input = {
  readonly _: "updateChatThemes";

  /**
   * The new list of chat themes
   * @type {vector<chatTheme>} {@link vector<chatTheme>}
   */
  readonly chat_themes?: vector$Input<chatTheme$Input>;
};

/**
 * The list of supported accent colors has changed
 */
export type updateAccentColors = {
  _: "updateAccentColors";

  /**
   * Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported
   *
   * - and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
   * @type {vector<accentColor>} {@link vector<accentColor>}
   */
  colors: vector<accentColor>;

  /**
   * The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specififed order
   * @type {vector<int32>} {@link vector<int32>}
   */
  available_accent_color_ids: vector<int32>;
};

/**
 * Version of {@link updateAccentColors} for method parameters.
 *
 * The list of supported accent colors has changed
 */
export type updateAccentColors$Input = {
  readonly _: "updateAccentColors";

  /**
   * Information about supported colors; colors with identifiers 0 (red), 1 (orange), 2 (purple/violet), 3 (green), 4 (cyan), 5 (blue), 6 (pink) must always be supported
   *
   * - and aren't included in the list. The exact colors for the accent colors with identifiers 0-6 must be taken from the app theme
   * @type {vector<accentColor>} {@link vector<accentColor>}
   */
  readonly colors?: vector$Input<accentColor$Input>;

  /**
   * The list of accent color identifiers, which can be set through setAccentColor and setChatAccentColor. The colors must be shown in the specififed order
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly available_accent_color_ids?: vector$Input<int32>;
};

/**
 * The list of supported accent colors for user profiles has changed
 */
export type updateProfileAccentColors = {
  _: "updateProfileAccentColors";

  /**
   * Information about supported colors
   * @type {vector<profileAccentColor>} {@link vector<profileAccentColor>}
   */
  colors: vector<profileAccentColor>;

  /**
   * The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specififed order
   * @type {vector<int32>} {@link vector<int32>}
   */
  available_accent_color_ids: vector<int32>;
};

/**
 * Version of {@link updateProfileAccentColors} for method parameters.
 *
 * The list of supported accent colors for user profiles has changed
 */
export type updateProfileAccentColors$Input = {
  readonly _: "updateProfileAccentColors";

  /**
   * Information about supported colors
   * @type {vector<profileAccentColor>} {@link vector<profileAccentColor>}
   */
  readonly colors?: vector$Input<profileAccentColor$Input>;

  /**
   * The list of accent color identifiers, which can be set through setProfileAccentColor and setChatProfileAccentColor. The colors must be shown in the specififed order
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly available_accent_color_ids?: vector$Input<int32>;
};

/**
 * Some language pack strings have been updated
 */
export type updateLanguagePackStrings = {
  _: "updateLanguagePackStrings";

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  localization_target: string;

  /**
   * Identifier of the updated language pack
   * @type {string} {@link string}
   */
  language_pack_id: string;

  /**
   * List of changed language pack strings; empty if all strings have changed
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  strings: vector<languagePackString>;
};

/**
 * Version of {@link updateLanguagePackStrings} for method parameters.
 *
 * Some language pack strings have been updated
 */
export type updateLanguagePackStrings$Input = {
  readonly _: "updateLanguagePackStrings";

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  readonly localization_target?: string;

  /**
   * Identifier of the updated language pack
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * List of changed language pack strings; empty if all strings have changed
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/**
 * The connection state has changed. This update must be used only to show a human-readable description of the connection state
 */
export type updateConnectionState = {
  _: "updateConnectionState";

  /**
   * The new connection state
   * @type {ConnectionState} {@link ConnectionState}
   */
  state: ConnectionState;
};

/**
 * Version of {@link updateConnectionState} for method parameters.
 *
 * The connection state has changed. This update must be used only to show a human-readable description of the connection state
 */
export type updateConnectionState$Input = {
  readonly _: "updateConnectionState";

  /**
   * The new connection state
   * @type {ConnectionState} {@link ConnectionState}
   */
  readonly state?: ConnectionState$Input;
};

/**
 * New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
 */
export type updateTermsOfService = {
  _: "updateTermsOfService";

  /**
   * Identifier of the terms of service
   * @type {string} {@link string}
   */
  terms_of_service_id: string;

  /**
   * The new terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  terms_of_service: termsOfService;
};

/**
 * Version of {@link updateTermsOfService} for method parameters.
 *
 * New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
 */
export type updateTermsOfService$Input = {
  readonly _: "updateTermsOfService";

  /**
   * Identifier of the terms of service
   * @type {string} {@link string}
   */
  readonly terms_of_service_id?: string;

  /**
   * The new terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  readonly terms_of_service?: termsOfService$Input;
};

/**
 * The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
 */
export type updateUsersNearby = {
  _: "updateUsersNearby";

  /**
   * The new list of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  users_nearby: vector<chatNearby>;
};

/**
 * Version of {@link updateUsersNearby} for method parameters.
 *
 * The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
 */
export type updateUsersNearby$Input = {
  readonly _: "updateUsersNearby";

  /**
   * The new list of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  readonly users_nearby?: vector$Input<chatNearby$Input>;
};

/**
 * The first unconfirmed session has changed
 */
export type updateUnconfirmedSession = {
  _: "updateUnconfirmedSession";

  /**
   * The unconfirmed session; may be null if none
   * @type {unconfirmedSession} {@link unconfirmedSession}
   */
  session: unconfirmedSession | null;
};

/**
 * Version of {@link updateUnconfirmedSession} for method parameters.
 *
 * The first unconfirmed session has changed
 */
export type updateUnconfirmedSession$Input = {
  readonly _: "updateUnconfirmedSession";

  /**
   * The unconfirmed session; may be null if none
   * @type {unconfirmedSession} {@link unconfirmedSession}
   */
  readonly session?: unconfirmedSession$Input | null;
};

/**
 * The list of bots added to attachment or side menu has changed
 */
export type updateAttachmentMenuBots = {
  _: "updateAttachmentMenuBots";

  /**
   * The new list of bots. The bots must not be shown on scheduled messages screen
   * @type {vector<attachmentMenuBot>} {@link vector<attachmentMenuBot>}
   */
  bots: vector<attachmentMenuBot>;
};

/**
 * Version of {@link updateAttachmentMenuBots} for method parameters.
 *
 * The list of bots added to attachment or side menu has changed
 */
export type updateAttachmentMenuBots$Input = {
  readonly _: "updateAttachmentMenuBots";

  /**
   * The new list of bots. The bots must not be shown on scheduled messages screen
   * @type {vector<attachmentMenuBot>} {@link vector<attachmentMenuBot>}
   */
  readonly bots?: vector$Input<attachmentMenuBot$Input>;
};

/**
 * A message was sent by an opened Web App, so the Web App needs to be closed
 */
export type updateWebAppMessageSent = {
  _: "updateWebAppMessageSent";

  /**
   * Identifier of Web App launch
   * @type {int64} {@link int64}
   */
  web_app_launch_id: int64;
};

/**
 * Version of {@link updateWebAppMessageSent} for method parameters.
 *
 * A message was sent by an opened Web App, so the Web App needs to be closed
 */
export type updateWebAppMessageSent$Input = {
  readonly _: "updateWebAppMessageSent";

  /**
   * Identifier of Web App launch
   * @type {int64} {@link int64}
   */
  readonly web_app_launch_id?: int64$Input;
};

/**
 * The list of active emoji reactions has changed
 */
export type updateActiveEmojiReactions = {
  _: "updateActiveEmojiReactions";

  /**
   * The new list of active emoji reactions
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

/**
 * Version of {@link updateActiveEmojiReactions} for method parameters.
 *
 * The list of active emoji reactions has changed
 */
export type updateActiveEmojiReactions$Input = {
  readonly _: "updateActiveEmojiReactions";

  /**
   * The new list of active emoji reactions
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/**
 * The type of default reaction has changed
 */
export type updateDefaultReactionType = {
  _: "updateDefaultReactionType";

  /**
   * The new type of the default reaction
   * @type {ReactionType} {@link ReactionType}
   */
  reaction_type: ReactionType;
};

/**
 * Version of {@link updateDefaultReactionType} for method parameters.
 *
 * The type of default reaction has changed
 */
export type updateDefaultReactionType$Input = {
  readonly _: "updateDefaultReactionType";

  /**
   * The new type of the default reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * The parameters of speech recognition without Telegram Premium subscription has changed
 */
export type updateSpeechRecognitionTrial = {
  _: "updateSpeechRecognitionTrial";

  /**
   * The maximum allowed duration of media for speech recognition without Telegram Premium subscription
   * @type {int32} {@link int32}
   */
  max_media_duration: int32;

  /**
   * The total number of allowed speech recognitions per week; 0 if none
   * @type {int32} {@link int32}
   */
  weekly_count: int32;

  /**
   * Number of left speech recognition attempts this week
   * @type {int32} {@link int32}
   */
  left_count: int32;

  /**
   * Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown
   * @type {int32} {@link int32}
   */
  next_reset_date: int32;
};

/**
 * Version of {@link updateSpeechRecognitionTrial} for method parameters.
 *
 * The parameters of speech recognition without Telegram Premium subscription has changed
 */
export type updateSpeechRecognitionTrial$Input = {
  readonly _: "updateSpeechRecognitionTrial";

  /**
   * The maximum allowed duration of media for speech recognition without Telegram Premium subscription
   * @type {int32} {@link int32}
   */
  readonly max_media_duration?: int32;

  /**
   * The total number of allowed speech recognitions per week; 0 if none
   * @type {int32} {@link int32}
   */
  readonly weekly_count?: int32;

  /**
   * Number of left speech recognition attempts this week
   * @type {int32} {@link int32}
   */
  readonly left_count?: int32;

  /**
   * Point in time (Unix timestamp) when the weekly number of tries will reset; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly next_reset_date?: int32;
};

/**
 * The list of supported dice emojis has changed
 */
export type updateDiceEmojis = {
  _: "updateDiceEmojis";

  /**
   * The new list of supported dice emojis
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

/**
 * Version of {@link updateDiceEmojis} for method parameters.
 *
 * The list of supported dice emojis has changed
 */
export type updateDiceEmojis$Input = {
  readonly _: "updateDiceEmojis";

  /**
   * The new list of supported dice emojis
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/**
 * Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
 */
export type updateAnimatedEmojiMessageClicked = {
  _: "updateAnimatedEmojiMessageClicked";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * The animated sticker to be played
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

/**
 * Version of {@link updateAnimatedEmojiMessageClicked} for method parameters.
 *
 * Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
 */
export type updateAnimatedEmojiMessageClicked$Input = {
  readonly _: "updateAnimatedEmojiMessageClicked";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The animated sticker to be played
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/**
 * The parameters of animation search through getOption("animation_search_bot_username") bot has changed
 */
export type updateAnimationSearchParameters = {
  _: "updateAnimationSearchParameters";

  /**
   * Name of the animation search provider
   * @type {string} {@link string}
   */
  provider: string;

  /**
   * The new list of emojis suggested for searching
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

/**
 * Version of {@link updateAnimationSearchParameters} for method parameters.
 *
 * The parameters of animation search through getOption("animation_search_bot_username") bot has changed
 */
export type updateAnimationSearchParameters$Input = {
  readonly _: "updateAnimationSearchParameters";

  /**
   * Name of the animation search provider
   * @type {string} {@link string}
   */
  readonly provider?: string;

  /**
   * The new list of emojis suggested for searching
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/**
 * The list of suggested to the user actions has changed
 */
export type updateSuggestedActions = {
  _: "updateSuggestedActions";

  /**
   * Added suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  added_actions: vector<SuggestedAction>;

  /**
   * Removed suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  removed_actions: vector<SuggestedAction>;
};

/**
 * Version of {@link updateSuggestedActions} for method parameters.
 *
 * The list of suggested to the user actions has changed
 */
export type updateSuggestedActions$Input = {
  readonly _: "updateSuggestedActions";

  /**
   * Added suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  readonly added_actions?: vector$Input<SuggestedAction$Input>;

  /**
   * Removed suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  readonly removed_actions?: vector$Input<SuggestedAction$Input>;
};

/**
 * Adding users to a chat has failed because of their privacy settings. An invite link can be shared with the users if appropriate
 */
export type updateAddChatMembersPrivacyForbidden = {
  _: "updateAddChatMembersPrivacyForbidden";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifiers of users, which weren't added because of their privacy settings
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

/**
 * Version of {@link updateAddChatMembersPrivacyForbidden} for method parameters.
 *
 * Adding users to a chat has failed because of their privacy settings. An invite link can be shared with the users if appropriate
 */
export type updateAddChatMembersPrivacyForbidden$Input = {
  readonly _: "updateAddChatMembersPrivacyForbidden";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of users, which weren't added because of their privacy settings
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Autosave settings for some type of chats were updated
 */
export type updateAutosaveSettings = {
  _: "updateAutosaveSettings";

  /**
   * Type of chats for which autosave settings were updated
   * @type {AutosaveSettingsScope} {@link AutosaveSettingsScope}
   */
  scope: AutosaveSettingsScope;

  /**
   * The new autosave settings; may be null if the settings are reset to default
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  settings: scopeAutosaveSettings | null;
};

/**
 * Version of {@link updateAutosaveSettings} for method parameters.
 *
 * Autosave settings for some type of chats were updated
 */
export type updateAutosaveSettings$Input = {
  readonly _: "updateAutosaveSettings";

  /**
   * Type of chats for which autosave settings were updated
   * @type {AutosaveSettingsScope} {@link AutosaveSettingsScope}
   */
  readonly scope?: AutosaveSettingsScope$Input;

  /**
   * The new autosave settings; may be null if the settings are reset to default
   * @type {scopeAutosaveSettings} {@link scopeAutosaveSettings}
   */
  readonly settings?: scopeAutosaveSettings$Input | null;
};

/**
 * A new incoming inline query; for bots only
 */
export type updateNewInlineQuery = {
  _: "updateNewInlineQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  user_location: location | null;

  /**
   * The type of the chat from which the query originated; may be null if unknown
   * @type {ChatType} {@link ChatType}
   */
  chat_type: ChatType | null;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  query: string;

  /**
   * Offset of the first entry to return
   * @type {string} {@link string}
   */
  offset: string;
};

/**
 * Version of {@link updateNewInlineQuery} for method parameters.
 *
 * A new incoming inline query; for bots only
 */
export type updateNewInlineQuery$Input = {
  readonly _: "updateNewInlineQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  readonly user_location?: location$Input | null;

  /**
   * The type of the chat from which the query originated; may be null if unknown
   * @type {ChatType} {@link ChatType}
   */
  readonly chat_type?: ChatType$Input | null;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return
   * @type {string} {@link string}
   */
  readonly offset?: string;
};

/**
 * The user has chosen a result of an inline query; for bots only
 */
export type updateNewChosenInlineResult = {
  _: "updateNewChosenInlineResult";

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  user_location: location | null;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  query: string;

  /**
   * Identifier of the chosen result
   * @type {string} {@link string}
   */
  result_id: string;

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  inline_message_id: string;
};

/**
 * Version of {@link updateNewChosenInlineResult} for method parameters.
 *
 * The user has chosen a result of an inline query; for bots only
 */
export type updateNewChosenInlineResult$Input = {
  readonly _: "updateNewChosenInlineResult";

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  readonly user_location?: location$Input | null;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of the chosen result
   * @type {string} {@link string}
   */
  readonly result_id?: string;

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;
};

/**
 * A new incoming callback query; for bots only
 */
export type updateNewCallbackQuery = {
  _: "updateNewCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Identifier that uniquely corresponds to the chat to which the message was sent
   * @type {int64} {@link int64}
   */
  chat_instance: int64;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  payload: CallbackQueryPayload;
};

/**
 * Version of {@link updateNewCallbackQuery} for method parameters.
 *
 * A new incoming callback query; for bots only
 */
export type updateNewCallbackQuery$Input = {
  readonly _: "updateNewCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier that uniquely corresponds to the chat to which the message was sent
   * @type {int64} {@link int64}
   */
  readonly chat_instance?: int64$Input;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/**
 * A new incoming callback query from a message sent via a bot; for bots only
 */
export type updateNewInlineCallbackQuery = {
  _: "updateNewInlineCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Identifier of the inline message from which the query originated
   * @type {string} {@link string}
   */
  inline_message_id: string;

  /**
   * An identifier uniquely corresponding to the chat a message was sent to
   * @type {int64} {@link int64}
   */
  chat_instance: int64;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  payload: CallbackQueryPayload;
};

/**
 * Version of {@link updateNewInlineCallbackQuery} for method parameters.
 *
 * A new incoming callback query from a message sent via a bot; for bots only
 */
export type updateNewInlineCallbackQuery$Input = {
  readonly _: "updateNewInlineCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Identifier of the inline message from which the query originated
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * An identifier uniquely corresponding to the chat a message was sent to
   * @type {int64} {@link int64}
   */
  readonly chat_instance?: int64$Input;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/**
 * A new incoming shipping query; for bots only. Only for invoices with flexible price
 */
export type updateNewShippingQuery = {
  _: "updateNewShippingQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Invoice payload
   * @type {string} {@link string}
   */
  invoice_payload: string;

  /**
   * User shipping address
   * @type {address} {@link address}
   */
  shipping_address: address;
};

/**
 * Version of {@link updateNewShippingQuery} for method parameters.
 *
 * A new incoming shipping query; for bots only. Only for invoices with flexible price
 */
export type updateNewShippingQuery$Input = {
  readonly _: "updateNewShippingQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Invoice payload
   * @type {string} {@link string}
   */
  readonly invoice_payload?: string;

  /**
   * User shipping address
   * @type {address} {@link address}
   */
  readonly shipping_address?: address$Input;
};

/**
 * A new incoming pre-checkout query; for bots only. Contains full information about a checkout
 */
export type updateNewPreCheckoutQuery = {
  _: "updateNewPreCheckoutQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  invoice_payload: bytes;

  /**
   * Identifier of a shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  shipping_option_id: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  order_info: orderInfo | null;
};

/**
 * Version of {@link updateNewPreCheckoutQuery} for method parameters.
 *
 * A new incoming pre-checkout query; for bots only. Contains full information about a checkout
 */
export type updateNewPreCheckoutQuery$Input = {
  readonly _: "updateNewPreCheckoutQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  readonly invoice_payload?: bytes$Input;

  /**
   * Identifier of a shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input | null;
};

/**
 * A new incoming event; for bots only
 */
export type updateNewCustomEvent = {
  _: "updateNewCustomEvent";

  /**
   * A JSON-serialized event
   * @type {string} {@link string}
   */
  event: string;
};

/**
 * Version of {@link updateNewCustomEvent} for method parameters.
 *
 * A new incoming event; for bots only
 */
export type updateNewCustomEvent$Input = {
  readonly _: "updateNewCustomEvent";

  /**
   * A JSON-serialized event
   * @type {string} {@link string}
   */
  readonly event?: string;
};

/**
 * A new incoming query; for bots only
 */
export type updateNewCustomQuery = {
  _: "updateNewCustomQuery";

  /**
   * The query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * JSON-serialized query data
   * @type {string} {@link string}
   */
  data: string;

  /**
   * Query timeout
   * @type {int32} {@link int32}
   */
  timeout: int32;
};

/**
 * Version of {@link updateNewCustomQuery} for method parameters.
 *
 * A new incoming query; for bots only
 */
export type updateNewCustomQuery$Input = {
  readonly _: "updateNewCustomQuery";

  /**
   * The query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64$Input;

  /**
   * JSON-serialized query data
   * @type {string} {@link string}
   */
  readonly data?: string;

  /**
   * Query timeout
   * @type {int32} {@link int32}
   */
  readonly timeout?: int32;
};

/**
 * A poll was updated; for bots only
 */
export type updatePoll = {
  _: "updatePoll";

  /**
   * New data about the poll
   * @type {poll} {@link poll}
   */
  poll: poll;
};

/**
 * Version of {@link updatePoll} for method parameters.
 *
 * A poll was updated; for bots only
 */
export type updatePoll$Input = {
  readonly _: "updatePoll";

  /**
   * New data about the poll
   * @type {poll} {@link poll}
   */
  readonly poll?: poll$Input;
};

/**
 * A user changed the answer to a poll; for bots only
 */
export type updatePollAnswer = {
  _: "updatePollAnswer";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  poll_id: int64;

  /**
   * Identifier of the message sender that changed the answer to the poll
   * @type {MessageSender} {@link MessageSender}
   */
  voter_id: MessageSender;

  /**
   * 0-based identifiers of answer options, chosen by the user
   * @type {vector<int32>} {@link vector<int32>}
   */
  option_ids: vector<int32>;
};

/**
 * Version of {@link updatePollAnswer} for method parameters.
 *
 * A user changed the answer to a poll; for bots only
 */
export type updatePollAnswer$Input = {
  readonly _: "updatePollAnswer";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  readonly poll_id?: int64$Input;

  /**
   * Identifier of the message sender that changed the answer to the poll
   * @type {MessageSender} {@link MessageSender}
   */
  readonly voter_id?: MessageSender$Input;

  /**
   * 0-based identifiers of answer options, chosen by the user
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly option_ids?: vector$Input<int32>;
};

/**
 * User rights changed in a chat; for bots only
 */
export type updateChatMember = {
  _: "updateChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the user, changing the rights
   * @type {int53} {@link int53}
   */
  actor_user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user rights were changed
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * If user has joined the chat using an invite link, the invite link; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink | null;

  /**
   * True, if the user has joined the chat using an invite link for a chat folder
   * @type {Bool} {@link Bool}
   */
  via_chat_folder_invite_link: Bool;

  /**
   * Previous chat member
   * @type {chatMember} {@link chatMember}
   */
  old_chat_member: chatMember;

  /**
   * New chat member
   * @type {chatMember} {@link chatMember}
   */
  new_chat_member: chatMember;
};

/**
 * Version of {@link updateChatMember} for method parameters.
 *
 * User rights changed in a chat; for bots only
 */
export type updateChatMember$Input = {
  readonly _: "updateChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user, changing the rights
   * @type {int53} {@link int53}
   */
  readonly actor_user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user rights were changed
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * If user has joined the chat using an invite link, the invite link; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input | null;

  /**
   * True, if the user has joined the chat using an invite link for a chat folder
   * @type {Bool} {@link Bool}
   */
  readonly via_chat_folder_invite_link?: Bool$Input;

  /**
   * Previous chat member
   * @type {chatMember} {@link chatMember}
   */
  readonly old_chat_member?: chatMember$Input;

  /**
   * New chat member
   * @type {chatMember} {@link chatMember}
   */
  readonly new_chat_member?: chatMember$Input;
};

/**
 * A user sent a join request to a chat; for bots only
 */
export type updateNewChatJoinRequest = {
  _: "updateNewChatJoinRequest";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Join request
   * @type {chatJoinRequest} {@link chatJoinRequest}
   */
  request: chatJoinRequest;

  /**
   * Chat identifier of the private chat with the user
   * @type {int53} {@link int53}
   */
  user_chat_id: int53;

  /**
   * The invite link, which was used to send join request; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink | null;
};

/**
 * Version of {@link updateNewChatJoinRequest} for method parameters.
 *
 * A user sent a join request to a chat; for bots only
 */
export type updateNewChatJoinRequest$Input = {
  readonly _: "updateNewChatJoinRequest";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Join request
   * @type {chatJoinRequest} {@link chatJoinRequest}
   */
  readonly request?: chatJoinRequest$Input;

  /**
   * Chat identifier of the private chat with the user
   * @type {int53} {@link int53}
   */
  readonly user_chat_id?: int53;

  /**
   * The invite link, which was used to send join request; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input | null;
};

/**
 * A chat boost has changed; for bots only
 */
export type updateChatBoost = {
  _: "updateChatBoost";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New information about the boost
   * @type {chatBoost} {@link chatBoost}
   */
  boost: chatBoost;
};

/**
 * Version of {@link updateChatBoost} for method parameters.
 *
 * A chat boost has changed; for bots only
 */
export type updateChatBoost$Input = {
  readonly _: "updateChatBoost";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New information about the boost
   * @type {chatBoost} {@link chatBoost}
   */
  readonly boost?: chatBoost$Input;
};

/**
 * User changed its reactions on a message with public reactions; for bots only
 */
export type updateMessageReaction = {
  _: "updateMessageReaction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Identifier of the user or chat that changed reactions
   * @type {MessageSender} {@link MessageSender}
   */
  actor_id: MessageSender;

  /**
   * Point in time (Unix timestamp) when the reactions were changed
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Old list of chosen reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  old_reaction_types: vector<ReactionType>;

  /**
   * New list of chosen reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  new_reaction_types: vector<ReactionType>;
};

/**
 * Version of {@link updateMessageReaction} for method parameters.
 *
 * User changed its reactions on a message with public reactions; for bots only
 */
export type updateMessageReaction$Input = {
  readonly _: "updateMessageReaction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the user or chat that changed reactions
   * @type {MessageSender} {@link MessageSender}
   */
  readonly actor_id?: MessageSender$Input;

  /**
   * Point in time (Unix timestamp) when the reactions were changed
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Old list of chosen reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  readonly old_reaction_types?: vector$Input<ReactionType$Input>;

  /**
   * New list of chosen reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  readonly new_reaction_types?: vector$Input<ReactionType$Input>;
};

/**
 * Reactions added to a message with anonymous reactions have changed; for bots only
 */
export type updateMessageReactions = {
  _: "updateMessageReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Point in time (Unix timestamp) when the reactions were changed
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * The list of reactions added to the message
   * @type {vector<messageReaction>} {@link vector<messageReaction>}
   */
  reactions: vector<messageReaction>;
};

/**
 * Version of {@link updateMessageReactions} for method parameters.
 *
 * Reactions added to a message with anonymous reactions have changed; for bots only
 */
export type updateMessageReactions$Input = {
  readonly _: "updateMessageReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Point in time (Unix timestamp) when the reactions were changed
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * The list of reactions added to the message
   * @type {vector<messageReaction>} {@link vector<messageReaction>}
   */
  readonly reactions?: vector$Input<messageReaction$Input>;
};

/**
 * Contains a list of updates
 */
export type updates = {
  _: "updates";

  /**
   * List of updates
   * @type {vector<Update>} {@link vector<Update>}
   */
  updates: vector<Update>;
};

/**
 * Version of {@link updates} for method parameters.
 *
 * Contains a list of updates
 */
export type updates$Input = {
  readonly _: "updates";

  /**
   * List of updates
   * @type {vector<Update>} {@link vector<Update>}
   */
  readonly updates?: vector$Input<Update$Input>;
};

/**
 * The log is written to stderr or an OS specific log
 */
export type logStreamDefault = {
  _: "logStreamDefault";
};

/**
 * Version of {@link logStreamDefault} for method parameters.
 *
 * The log is written to stderr or an OS specific log
 */
export type logStreamDefault$Input = {
  readonly _: "logStreamDefault";
};

/**
 * The log is written to a file
 */
export type logStreamFile = {
  _: "logStreamFile";

  /**
   * Path to the file to where the internal TDLib log will be written
   * @type {string} {@link string}
   */
  path: string;

  /**
   * The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
   * @type {int53} {@link int53}
   */
  max_file_size: int53;

  /**
   * Pass true to additionally redirect stderr to the log file. Ignored on Windows
   * @type {Bool} {@link Bool}
   */
  redirect_stderr: Bool;
};

/**
 * Version of {@link logStreamFile} for method parameters.
 *
 * The log is written to a file
 */
export type logStreamFile$Input = {
  readonly _: "logStreamFile";

  /**
   * Path to the file to where the internal TDLib log will be written
   * @type {string} {@link string}
   */
  readonly path?: string;

  /**
   * The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
   * @type {int53} {@link int53}
   */
  readonly max_file_size?: int53;

  /**
   * Pass true to additionally redirect stderr to the log file. Ignored on Windows
   * @type {Bool} {@link Bool}
   */
  readonly redirect_stderr?: Bool$Input;
};

/**
 * The log is written nowhere
 */
export type logStreamEmpty = {
  _: "logStreamEmpty";
};

/**
 * Version of {@link logStreamEmpty} for method parameters.
 *
 * The log is written nowhere
 */
export type logStreamEmpty$Input = {
  readonly _: "logStreamEmpty";
};

/**
 * Contains a TDLib internal log verbosity level
 */
export type logVerbosityLevel = {
  _: "logVerbosityLevel";

  /**
   * Log verbosity level
   * @type {int32} {@link int32}
   */
  verbosity_level: int32;
};

/**
 * Version of {@link logVerbosityLevel} for method parameters.
 *
 * Contains a TDLib internal log verbosity level
 */
export type logVerbosityLevel$Input = {
  readonly _: "logVerbosityLevel";

  /**
   * Log verbosity level
   * @type {int32} {@link int32}
   */
  readonly verbosity_level?: int32;
};

/**
 * Contains a list of available TDLib internal log tags
 */
export type logTags = {
  _: "logTags";

  /**
   * List of log tags
   * @type {vector<string>} {@link vector<string>}
   */
  tags: vector<string>;
};

/**
 * Version of {@link logTags} for method parameters.
 *
 * Contains a list of available TDLib internal log tags
 */
export type logTags$Input = {
  readonly _: "logTags";

  /**
   * List of log tags
   * @type {vector<string>} {@link vector<string>}
   */
  readonly tags?: vector$Input<string>;
};

/**
 * Contains custom information about the user
 */
export type userSupportInfo = {
  _: "userSupportInfo";

  /**
   * Information message
   * @type {formattedText} {@link formattedText}
   */
  message: formattedText;

  /**
   * Information author
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Information change date
   * @type {int32} {@link int32}
   */
  date: int32;
};

/**
 * Version of {@link userSupportInfo} for method parameters.
 *
 * Contains custom information about the user
 */
export type userSupportInfo$Input = {
  readonly _: "userSupportInfo";

  /**
   * Information message
   * @type {formattedText} {@link formattedText}
   */
  readonly message?: formattedText$Input;

  /**
   * Information author
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Information change date
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * A simple object containing a number; for testing only
 */
export type testInt = {
  _: "testInt";

  /**
   * Number
   * @type {int32} {@link int32}
   */
  value: int32;
};

/**
 * Version of {@link testInt} for method parameters.
 *
 * A simple object containing a number; for testing only
 */
export type testInt$Input = {
  readonly _: "testInt";

  /**
   * Number
   * @type {int32} {@link int32}
   */
  readonly value?: int32;
};

/**
 * A simple object containing a string; for testing only
 */
export type testString = {
  _: "testString";

  /**
   * String
   * @type {string} {@link string}
   */
  value: string;
};

/**
 * Version of {@link testString} for method parameters.
 *
 * A simple object containing a string; for testing only
 */
export type testString$Input = {
  readonly _: "testString";

  /**
   * String
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/**
 * A simple object containing a sequence of bytes; for testing only
 */
export type testBytes = {
  _: "testBytes";

  /**
   * Bytes
   * @type {bytes} {@link bytes}
   */
  value: bytes;
};

/**
 * Version of {@link testBytes} for method parameters.
 *
 * A simple object containing a sequence of bytes; for testing only
 */
export type testBytes$Input = {
  readonly _: "testBytes";

  /**
   * Bytes
   * @type {bytes} {@link bytes}
   */
  readonly value?: bytes$Input;
};

/**
 * A simple object containing a vector of numbers; for testing only
 */
export type testVectorInt = {
  _: "testVectorInt";

  /**
   * Vector of numbers
   * @type {vector<int32>} {@link vector<int32>}
   */
  value: vector<int32>;
};

/**
 * Version of {@link testVectorInt} for method parameters.
 *
 * A simple object containing a vector of numbers; for testing only
 */
export type testVectorInt$Input = {
  readonly _: "testVectorInt";

  /**
   * Vector of numbers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly value?: vector$Input<int32>;
};

/**
 * A simple object containing a vector of objects that hold a number; for testing only
 */
export type testVectorIntObject = {
  _: "testVectorIntObject";

  /**
   * Vector of objects
   * @type {vector<testInt>} {@link vector<testInt>}
   */
  value: vector<testInt>;
};

/**
 * Version of {@link testVectorIntObject} for method parameters.
 *
 * A simple object containing a vector of objects that hold a number; for testing only
 */
export type testVectorIntObject$Input = {
  readonly _: "testVectorIntObject";

  /**
   * Vector of objects
   * @type {vector<testInt>} {@link vector<testInt>}
   */
  readonly value?: vector$Input<testInt$Input>;
};

/**
 * A simple object containing a vector of strings; for testing only
 */
export type testVectorString = {
  _: "testVectorString";

  /**
   * Vector of strings
   * @type {vector<string>} {@link vector<string>}
   */
  value: vector<string>;
};

/**
 * Version of {@link testVectorString} for method parameters.
 *
 * A simple object containing a vector of strings; for testing only
 */
export type testVectorString$Input = {
  readonly _: "testVectorString";

  /**
   * Vector of strings
   * @type {vector<string>} {@link vector<string>}
   */
  readonly value?: vector$Input<string>;
};

/**
 * A simple object containing a vector of objects that hold a string; for testing only
 */
export type testVectorStringObject = {
  _: "testVectorStringObject";

  /**
   * Vector of objects
   * @type {vector<testString>} {@link vector<testString>}
   */
  value: vector<testString>;
};

/**
 * Version of {@link testVectorStringObject} for method parameters.
 *
 * A simple object containing a vector of objects that hold a string; for testing only
 */
export type testVectorStringObject$Input = {
  readonly _: "testVectorStringObject";

  /**
   * Vector of objects
   * @type {vector<testString>} {@link vector<testString>}
   */
  readonly value?: vector$Input<testString$Input>;
};

/**
 * Any of:
 * - {@link double}
 */
export type Double = double;

/**
 * Version of {@link Double} for method parameters.
 * Any of:
 * - {@link double}
 */
export type Double$Input = double;

/**
 * Any of:
 * - {@link string}
 */
export type String = string;

/**
 * Version of {@link String} for method parameters.
 * Any of:
 * - {@link string}
 */
export type String$Input = string;

/**
 * Any of:
 * - {@link int32}
 */
export type Int32 = int32;

/**
 * Version of {@link Int32} for method parameters.
 * Any of:
 * - {@link int32}
 */
export type Int32$Input = int32;

/**
 * Any of:
 * - {@link int53}
 */
export type Int53 = int53;

/**
 * Version of {@link Int53} for method parameters.
 * Any of:
 * - {@link int53}
 */
export type Int53$Input = int53;

/**
 * Any of:
 * - {@link int64}
 */
export type Int64 = int64;

/**
 * Version of {@link Int64} for method parameters.
 * Any of:
 * - {@link int64$Input}
 */
export type Int64$Input = int64$Input;

/**
 * Any of:
 * - {@link bytes}
 */
export type Bytes = bytes;

/**
 * Version of {@link Bytes} for method parameters.
 * Any of:
 * - {@link bytes$Input}
 */
export type Bytes$Input = bytes$Input;

/**
 * Any of:
 * - {@link boolFalse}
 * - {@link boolTrue}
 */
export type Bool = boolFalse | boolTrue;

/**
 * Version of {@link Bool} for method parameters.
 * Any of:
 * - {@link boolFalse}
 * - {@link boolTrue}
 */
export type Bool$Input = boolFalse | boolTrue;

/**
 * Any of:
 * - {@link error}
 */
export type Error = error;

/**
 * Version of {@link Error} for method parameters.
 * Any of:
 * - {@link error$Input}
 */
export type Error$Input = error$Input;

/**
 * Any of:
 * - {@link ok}
 */
export type Ok = ok;

/**
 * Version of {@link Ok} for method parameters.
 * Any of:
 * - {@link ok$Input}
 */
export type Ok$Input = ok$Input;

/**
 * Any of:
 * - {@link authenticationCodeTypeTelegramMessage}
 * - {@link authenticationCodeTypeSms}
 * - {@link authenticationCodeTypeCall}
 * - {@link authenticationCodeTypeFlashCall}
 * - {@link authenticationCodeTypeMissedCall}
 * - {@link authenticationCodeTypeFragment}
 * - {@link authenticationCodeTypeFirebaseAndroid}
 * - {@link authenticationCodeTypeFirebaseIos}
 */
export type AuthenticationCodeType =
  | authenticationCodeTypeTelegramMessage
  | authenticationCodeTypeSms
  | authenticationCodeTypeCall
  | authenticationCodeTypeFlashCall
  | authenticationCodeTypeMissedCall
  | authenticationCodeTypeFragment
  | authenticationCodeTypeFirebaseAndroid
  | authenticationCodeTypeFirebaseIos;

/**
 * Version of {@link AuthenticationCodeType} for method parameters.
 * Any of:
 * - {@link authenticationCodeTypeTelegramMessage$Input}
 * - {@link authenticationCodeTypeSms$Input}
 * - {@link authenticationCodeTypeCall$Input}
 * - {@link authenticationCodeTypeFlashCall$Input}
 * - {@link authenticationCodeTypeMissedCall$Input}
 * - {@link authenticationCodeTypeFragment$Input}
 * - {@link authenticationCodeTypeFirebaseAndroid$Input}
 * - {@link authenticationCodeTypeFirebaseIos$Input}
 */
export type AuthenticationCodeType$Input =
  | authenticationCodeTypeTelegramMessage$Input
  | authenticationCodeTypeSms$Input
  | authenticationCodeTypeCall$Input
  | authenticationCodeTypeFlashCall$Input
  | authenticationCodeTypeMissedCall$Input
  | authenticationCodeTypeFragment$Input
  | authenticationCodeTypeFirebaseAndroid$Input
  | authenticationCodeTypeFirebaseIos$Input;

/**
 * Any of:
 * - {@link authenticationCodeInfo}
 */
export type AuthenticationCodeInfo = authenticationCodeInfo;

/**
 * Version of {@link AuthenticationCodeInfo} for method parameters.
 * Any of:
 * - {@link authenticationCodeInfo$Input}
 */
export type AuthenticationCodeInfo$Input = authenticationCodeInfo$Input;

/**
 * Any of:
 * - {@link emailAddressAuthenticationCodeInfo}
 */
export type EmailAddressAuthenticationCodeInfo = emailAddressAuthenticationCodeInfo;

/**
 * Version of {@link EmailAddressAuthenticationCodeInfo} for method parameters.
 * Any of:
 * - {@link emailAddressAuthenticationCodeInfo$Input}
 */
export type EmailAddressAuthenticationCodeInfo$Input =
  emailAddressAuthenticationCodeInfo$Input;

/**
 * Any of:
 * - {@link emailAddressAuthenticationCode}
 * - {@link emailAddressAuthenticationAppleId}
 * - {@link emailAddressAuthenticationGoogleId}
 */
export type EmailAddressAuthentication =
  | emailAddressAuthenticationCode
  | emailAddressAuthenticationAppleId
  | emailAddressAuthenticationGoogleId;

/**
 * Version of {@link EmailAddressAuthentication} for method parameters.
 * Any of:
 * - {@link emailAddressAuthenticationCode$Input}
 * - {@link emailAddressAuthenticationAppleId$Input}
 * - {@link emailAddressAuthenticationGoogleId$Input}
 */
export type EmailAddressAuthentication$Input =
  | emailAddressAuthenticationCode$Input
  | emailAddressAuthenticationAppleId$Input
  | emailAddressAuthenticationGoogleId$Input;

/**
 * Any of:
 * - {@link emailAddressResetStateAvailable}
 * - {@link emailAddressResetStatePending}
 */
export type EmailAddressResetState =
  | emailAddressResetStateAvailable
  | emailAddressResetStatePending;

/**
 * Version of {@link EmailAddressResetState} for method parameters.
 * Any of:
 * - {@link emailAddressResetStateAvailable$Input}
 * - {@link emailAddressResetStatePending$Input}
 */
export type EmailAddressResetState$Input =
  | emailAddressResetStateAvailable$Input
  | emailAddressResetStatePending$Input;

/**
 * Any of:
 * - {@link textEntity}
 */
export type TextEntity = textEntity;

/**
 * Version of {@link TextEntity} for method parameters.
 * Any of:
 * - {@link textEntity$Input}
 */
export type TextEntity$Input = textEntity$Input;

/**
 * Any of:
 * - {@link textEntities}
 */
export type TextEntities = textEntities;

/**
 * Version of {@link TextEntities} for method parameters.
 * Any of:
 * - {@link textEntities$Input}
 */
export type TextEntities$Input = textEntities$Input;

/**
 * Any of:
 * - {@link formattedText}
 */
export type FormattedText = formattedText;

/**
 * Version of {@link FormattedText} for method parameters.
 * Any of:
 * - {@link formattedText$Input}
 */
export type FormattedText$Input = formattedText$Input;

/**
 * Any of:
 * - {@link termsOfService}
 */
export type TermsOfService = termsOfService;

/**
 * Version of {@link TermsOfService} for method parameters.
 * Any of:
 * - {@link termsOfService$Input}
 */
export type TermsOfService$Input = termsOfService$Input;

/**
 * Any of:
 * - {@link authorizationStateWaitTdlibParameters}
 * - {@link authorizationStateWaitPhoneNumber}
 * - {@link authorizationStateWaitEmailAddress}
 * - {@link authorizationStateWaitEmailCode}
 * - {@link authorizationStateWaitCode}
 * - {@link authorizationStateWaitOtherDeviceConfirmation}
 * - {@link authorizationStateWaitRegistration}
 * - {@link authorizationStateWaitPassword}
 * - {@link authorizationStateReady}
 * - {@link authorizationStateLoggingOut}
 * - {@link authorizationStateClosing}
 * - {@link authorizationStateClosed}
 */
export type AuthorizationState =
  | authorizationStateWaitTdlibParameters
  | authorizationStateWaitPhoneNumber
  | authorizationStateWaitEmailAddress
  | authorizationStateWaitEmailCode
  | authorizationStateWaitCode
  | authorizationStateWaitOtherDeviceConfirmation
  | authorizationStateWaitRegistration
  | authorizationStateWaitPassword
  | authorizationStateReady
  | authorizationStateLoggingOut
  | authorizationStateClosing
  | authorizationStateClosed;

/**
 * Version of {@link AuthorizationState} for method parameters.
 * Any of:
 * - {@link authorizationStateWaitTdlibParameters$Input}
 * - {@link authorizationStateWaitPhoneNumber$Input}
 * - {@link authorizationStateWaitEmailAddress$Input}
 * - {@link authorizationStateWaitEmailCode$Input}
 * - {@link authorizationStateWaitCode$Input}
 * - {@link authorizationStateWaitOtherDeviceConfirmation$Input}
 * - {@link authorizationStateWaitRegistration$Input}
 * - {@link authorizationStateWaitPassword$Input}
 * - {@link authorizationStateReady$Input}
 * - {@link authorizationStateLoggingOut$Input}
 * - {@link authorizationStateClosing$Input}
 * - {@link authorizationStateClosed$Input}
 */
export type AuthorizationState$Input =
  | authorizationStateWaitTdlibParameters$Input
  | authorizationStateWaitPhoneNumber$Input
  | authorizationStateWaitEmailAddress$Input
  | authorizationStateWaitEmailCode$Input
  | authorizationStateWaitCode$Input
  | authorizationStateWaitOtherDeviceConfirmation$Input
  | authorizationStateWaitRegistration$Input
  | authorizationStateWaitPassword$Input
  | authorizationStateReady$Input
  | authorizationStateLoggingOut$Input
  | authorizationStateClosing$Input
  | authorizationStateClosed$Input;

/**
 * Any of:
 * - {@link passwordState}
 */
export type PasswordState = passwordState;

/**
 * Version of {@link PasswordState} for method parameters.
 * Any of:
 * - {@link passwordState$Input}
 */
export type PasswordState$Input = passwordState$Input;

/**
 * Any of:
 * - {@link recoveryEmailAddress}
 */
export type RecoveryEmailAddress = recoveryEmailAddress;

/**
 * Version of {@link RecoveryEmailAddress} for method parameters.
 * Any of:
 * - {@link recoveryEmailAddress$Input}
 */
export type RecoveryEmailAddress$Input = recoveryEmailAddress$Input;

/**
 * Any of:
 * - {@link temporaryPasswordState}
 */
export type TemporaryPasswordState = temporaryPasswordState;

/**
 * Version of {@link TemporaryPasswordState} for method parameters.
 * Any of:
 * - {@link temporaryPasswordState$Input}
 */
export type TemporaryPasswordState$Input = temporaryPasswordState$Input;

/**
 * Any of:
 * - {@link localFile}
 */
export type LocalFile = localFile;

/**
 * Version of {@link LocalFile} for method parameters.
 * Any of:
 * - {@link localFile$Input}
 */
export type LocalFile$Input = localFile$Input;

/**
 * Any of:
 * - {@link remoteFile}
 */
export type RemoteFile = remoteFile;

/**
 * Version of {@link RemoteFile} for method parameters.
 * Any of:
 * - {@link remoteFile$Input}
 */
export type RemoteFile$Input = remoteFile$Input;

/**
 * Any of:
 * - {@link file}
 */
export type File = file;

/**
 * Version of {@link File} for method parameters.
 * Any of:
 * - {@link file$Input}
 */
export type File$Input = file$Input;

/**
 * Any of:
 * - {@link inputFileId}
 * - {@link inputFileRemote}
 * - {@link inputFileLocal}
 * - {@link inputFileGenerated}
 */
export type InputFile =
  | inputFileId
  | inputFileRemote
  | inputFileLocal
  | inputFileGenerated;

/**
 * Version of {@link InputFile} for method parameters.
 * Any of:
 * - {@link inputFileId$Input}
 * - {@link inputFileRemote$Input}
 * - {@link inputFileLocal$Input}
 * - {@link inputFileGenerated$Input}
 */
export type InputFile$Input =
  | inputFileId$Input
  | inputFileRemote$Input
  | inputFileLocal$Input
  | inputFileGenerated$Input;

/**
 * Any of:
 * - {@link photoSize}
 */
export type PhotoSize = photoSize;

/**
 * Version of {@link PhotoSize} for method parameters.
 * Any of:
 * - {@link photoSize$Input}
 */
export type PhotoSize$Input = photoSize$Input;

/**
 * Any of:
 * - {@link minithumbnail}
 */
export type Minithumbnail = minithumbnail;

/**
 * Version of {@link Minithumbnail} for method parameters.
 * Any of:
 * - {@link minithumbnail$Input}
 */
export type Minithumbnail$Input = minithumbnail$Input;

/**
 * Any of:
 * - {@link thumbnailFormatJpeg}
 * - {@link thumbnailFormatGif}
 * - {@link thumbnailFormatMpeg4}
 * - {@link thumbnailFormatPng}
 * - {@link thumbnailFormatTgs}
 * - {@link thumbnailFormatWebm}
 * - {@link thumbnailFormatWebp}
 */
export type ThumbnailFormat =
  | thumbnailFormatJpeg
  | thumbnailFormatGif
  | thumbnailFormatMpeg4
  | thumbnailFormatPng
  | thumbnailFormatTgs
  | thumbnailFormatWebm
  | thumbnailFormatWebp;

/**
 * Version of {@link ThumbnailFormat} for method parameters.
 * Any of:
 * - {@link thumbnailFormatJpeg$Input}
 * - {@link thumbnailFormatGif$Input}
 * - {@link thumbnailFormatMpeg4$Input}
 * - {@link thumbnailFormatPng$Input}
 * - {@link thumbnailFormatTgs$Input}
 * - {@link thumbnailFormatWebm$Input}
 * - {@link thumbnailFormatWebp$Input}
 */
export type ThumbnailFormat$Input =
  | thumbnailFormatJpeg$Input
  | thumbnailFormatGif$Input
  | thumbnailFormatMpeg4$Input
  | thumbnailFormatPng$Input
  | thumbnailFormatTgs$Input
  | thumbnailFormatWebm$Input
  | thumbnailFormatWebp$Input;

/**
 * Any of:
 * - {@link thumbnail}
 */
export type Thumbnail = thumbnail;

/**
 * Version of {@link Thumbnail} for method parameters.
 * Any of:
 * - {@link thumbnail$Input}
 */
export type Thumbnail$Input = thumbnail$Input;

/**
 * Any of:
 * - {@link maskPointForehead}
 * - {@link maskPointEyes}
 * - {@link maskPointMouth}
 * - {@link maskPointChin}
 */
export type MaskPoint =
  | maskPointForehead
  | maskPointEyes
  | maskPointMouth
  | maskPointChin;

/**
 * Version of {@link MaskPoint} for method parameters.
 * Any of:
 * - {@link maskPointForehead$Input}
 * - {@link maskPointEyes$Input}
 * - {@link maskPointMouth$Input}
 * - {@link maskPointChin$Input}
 */
export type MaskPoint$Input =
  | maskPointForehead$Input
  | maskPointEyes$Input
  | maskPointMouth$Input
  | maskPointChin$Input;

/**
 * Any of:
 * - {@link maskPosition}
 */
export type MaskPosition = maskPosition;

/**
 * Version of {@link MaskPosition} for method parameters.
 * Any of:
 * - {@link maskPosition$Input}
 */
export type MaskPosition$Input = maskPosition$Input;

/**
 * Any of:
 * - {@link stickerFormatWebp}
 * - {@link stickerFormatTgs}
 * - {@link stickerFormatWebm}
 */
export type StickerFormat = stickerFormatWebp | stickerFormatTgs | stickerFormatWebm;

/**
 * Version of {@link StickerFormat} for method parameters.
 * Any of:
 * - {@link stickerFormatWebp$Input}
 * - {@link stickerFormatTgs$Input}
 * - {@link stickerFormatWebm$Input}
 */
export type StickerFormat$Input =
  | stickerFormatWebp$Input
  | stickerFormatTgs$Input
  | stickerFormatWebm$Input;

/**
 * Any of:
 * - {@link stickerTypeRegular}
 * - {@link stickerTypeMask}
 * - {@link stickerTypeCustomEmoji}
 */
export type StickerType =
  | stickerTypeRegular
  | stickerTypeMask
  | stickerTypeCustomEmoji;

/**
 * Version of {@link StickerType} for method parameters.
 * Any of:
 * - {@link stickerTypeRegular$Input}
 * - {@link stickerTypeMask$Input}
 * - {@link stickerTypeCustomEmoji$Input}
 */
export type StickerType$Input =
  | stickerTypeRegular$Input
  | stickerTypeMask$Input
  | stickerTypeCustomEmoji$Input;

/**
 * Any of:
 * - {@link stickerFullTypeRegular}
 * - {@link stickerFullTypeMask}
 * - {@link stickerFullTypeCustomEmoji}
 */
export type StickerFullType =
  | stickerFullTypeRegular
  | stickerFullTypeMask
  | stickerFullTypeCustomEmoji;

/**
 * Version of {@link StickerFullType} for method parameters.
 * Any of:
 * - {@link stickerFullTypeRegular$Input}
 * - {@link stickerFullTypeMask$Input}
 * - {@link stickerFullTypeCustomEmoji$Input}
 */
export type StickerFullType$Input =
  | stickerFullTypeRegular$Input
  | stickerFullTypeMask$Input
  | stickerFullTypeCustomEmoji$Input;

/**
 * Any of:
 * - {@link closedVectorPath}
 */
export type ClosedVectorPath = closedVectorPath;

/**
 * Version of {@link ClosedVectorPath} for method parameters.
 * Any of:
 * - {@link closedVectorPath$Input}
 */
export type ClosedVectorPath$Input = closedVectorPath$Input;

/**
 * Any of:
 * - {@link pollOption}
 */
export type PollOption = pollOption;

/**
 * Version of {@link PollOption} for method parameters.
 * Any of:
 * - {@link pollOption$Input}
 */
export type PollOption$Input = pollOption$Input;

/**
 * Any of:
 * - {@link pollTypeRegular}
 * - {@link pollTypeQuiz}
 */
export type PollType = pollTypeRegular | pollTypeQuiz;

/**
 * Version of {@link PollType} for method parameters.
 * Any of:
 * - {@link pollTypeRegular$Input}
 * - {@link pollTypeQuiz$Input}
 */
export type PollType$Input = pollTypeRegular$Input | pollTypeQuiz$Input;

/**
 * Any of:
 * - {@link animation}
 */
export type Animation = animation;

/**
 * Version of {@link Animation} for method parameters.
 * Any of:
 * - {@link animation$Input}
 */
export type Animation$Input = animation$Input;

/**
 * Any of:
 * - {@link audio}
 */
export type Audio = audio;

/**
 * Version of {@link Audio} for method parameters.
 * Any of:
 * - {@link audio$Input}
 */
export type Audio$Input = audio$Input;

/**
 * Any of:
 * - {@link document}
 */
export type Document = document;

/**
 * Version of {@link Document} for method parameters.
 * Any of:
 * - {@link document$Input}
 */
export type Document$Input = document$Input;

/**
 * Any of:
 * - {@link photo}
 */
export type Photo = photo;

/**
 * Version of {@link Photo} for method parameters.
 * Any of:
 * - {@link photo$Input}
 */
export type Photo$Input = photo$Input;

/**
 * Any of:
 * - {@link sticker}
 */
export type Sticker = sticker;

/**
 * Version of {@link Sticker} for method parameters.
 * Any of:
 * - {@link sticker$Input}
 */
export type Sticker$Input = sticker$Input;

/**
 * Any of:
 * - {@link video}
 */
export type Video = video;

/**
 * Version of {@link Video} for method parameters.
 * Any of:
 * - {@link video$Input}
 */
export type Video$Input = video$Input;

/**
 * Any of:
 * - {@link videoNote}
 */
export type VideoNote = videoNote;

/**
 * Version of {@link VideoNote} for method parameters.
 * Any of:
 * - {@link videoNote$Input}
 */
export type VideoNote$Input = videoNote$Input;

/**
 * Any of:
 * - {@link voiceNote}
 */
export type VoiceNote = voiceNote;

/**
 * Version of {@link VoiceNote} for method parameters.
 * Any of:
 * - {@link voiceNote$Input}
 */
export type VoiceNote$Input = voiceNote$Input;

/**
 * Any of:
 * - {@link animatedEmoji}
 */
export type AnimatedEmoji = animatedEmoji;

/**
 * Version of {@link AnimatedEmoji} for method parameters.
 * Any of:
 * - {@link animatedEmoji$Input}
 */
export type AnimatedEmoji$Input = animatedEmoji$Input;

/**
 * Any of:
 * - {@link contact}
 */
export type Contact = contact;

/**
 * Version of {@link Contact} for method parameters.
 * Any of:
 * - {@link contact$Input}
 */
export type Contact$Input = contact$Input;

/**
 * Any of:
 * - {@link location}
 */
export type Location = location;

/**
 * Version of {@link Location} for method parameters.
 * Any of:
 * - {@link location$Input}
 */
export type Location$Input = location$Input;

/**
 * Any of:
 * - {@link venue}
 */
export type Venue = venue;

/**
 * Version of {@link Venue} for method parameters.
 * Any of:
 * - {@link venue$Input}
 */
export type Venue$Input = venue$Input;

/**
 * Any of:
 * - {@link game}
 */
export type Game = game;

/**
 * Version of {@link Game} for method parameters.
 * Any of:
 * - {@link game$Input}
 */
export type Game$Input = game$Input;

/**
 * Any of:
 * - {@link webApp}
 */
export type WebApp = webApp;

/**
 * Version of {@link WebApp} for method parameters.
 * Any of:
 * - {@link webApp$Input}
 */
export type WebApp$Input = webApp$Input;

/**
 * Any of:
 * - {@link poll}
 */
export type Poll = poll;

/**
 * Version of {@link Poll} for method parameters.
 * Any of:
 * - {@link poll$Input}
 */
export type Poll$Input = poll$Input;

/**
 * Any of:
 * - {@link background}
 */
export type Background = background;

/**
 * Version of {@link Background} for method parameters.
 * Any of:
 * - {@link background$Input}
 */
export type Background$Input = background$Input;

/**
 * Any of:
 * - {@link backgrounds}
 */
export type Backgrounds = backgrounds;

/**
 * Version of {@link Backgrounds} for method parameters.
 * Any of:
 * - {@link backgrounds$Input}
 */
export type Backgrounds$Input = backgrounds$Input;

/**
 * Any of:
 * - {@link chatBackground}
 */
export type ChatBackground = chatBackground;

/**
 * Version of {@link ChatBackground} for method parameters.
 * Any of:
 * - {@link chatBackground$Input}
 */
export type ChatBackground$Input = chatBackground$Input;

/**
 * Any of:
 * - {@link profilePhoto}
 */
export type ProfilePhoto = profilePhoto;

/**
 * Version of {@link ProfilePhoto} for method parameters.
 * Any of:
 * - {@link profilePhoto$Input}
 */
export type ProfilePhoto$Input = profilePhoto$Input;

/**
 * Any of:
 * - {@link chatPhotoInfo}
 */
export type ChatPhotoInfo = chatPhotoInfo;

/**
 * Version of {@link ChatPhotoInfo} for method parameters.
 * Any of:
 * - {@link chatPhotoInfo$Input}
 */
export type ChatPhotoInfo$Input = chatPhotoInfo$Input;

/**
 * Any of:
 * - {@link userTypeRegular}
 * - {@link userTypeDeleted}
 * - {@link userTypeBot}
 * - {@link userTypeUnknown}
 */
export type UserType =
  | userTypeRegular
  | userTypeDeleted
  | userTypeBot
  | userTypeUnknown;

/**
 * Version of {@link UserType} for method parameters.
 * Any of:
 * - {@link userTypeRegular$Input}
 * - {@link userTypeDeleted$Input}
 * - {@link userTypeBot$Input}
 * - {@link userTypeUnknown$Input}
 */
export type UserType$Input =
  | userTypeRegular$Input
  | userTypeDeleted$Input
  | userTypeBot$Input
  | userTypeUnknown$Input;

/**
 * Any of:
 * - {@link botCommand}
 */
export type BotCommand = botCommand;

/**
 * Version of {@link BotCommand} for method parameters.
 * Any of:
 * - {@link botCommand$Input}
 */
export type BotCommand$Input = botCommand$Input;

/**
 * Any of:
 * - {@link botCommands}
 */
export type BotCommands = botCommands;

/**
 * Version of {@link BotCommands} for method parameters.
 * Any of:
 * - {@link botCommands$Input}
 */
export type BotCommands$Input = botCommands$Input;

/**
 * Any of:
 * - {@link botMenuButton}
 */
export type BotMenuButton = botMenuButton;

/**
 * Version of {@link BotMenuButton} for method parameters.
 * Any of:
 * - {@link botMenuButton$Input}
 */
export type BotMenuButton$Input = botMenuButton$Input;

/**
 * Any of:
 * - {@link chatLocation}
 */
export type ChatLocation = chatLocation;

/**
 * Version of {@link ChatLocation} for method parameters.
 * Any of:
 * - {@link chatLocation$Input}
 */
export type ChatLocation$Input = chatLocation$Input;

/**
 * Any of:
 * - {@link chatPhotoStickerTypeRegularOrMask}
 * - {@link chatPhotoStickerTypeCustomEmoji}
 */
export type ChatPhotoStickerType =
  | chatPhotoStickerTypeRegularOrMask
  | chatPhotoStickerTypeCustomEmoji;

/**
 * Version of {@link ChatPhotoStickerType} for method parameters.
 * Any of:
 * - {@link chatPhotoStickerTypeRegularOrMask$Input}
 * - {@link chatPhotoStickerTypeCustomEmoji$Input}
 */
export type ChatPhotoStickerType$Input =
  | chatPhotoStickerTypeRegularOrMask$Input
  | chatPhotoStickerTypeCustomEmoji$Input;

/**
 * Any of:
 * - {@link chatPhotoSticker}
 */
export type ChatPhotoSticker = chatPhotoSticker;

/**
 * Version of {@link ChatPhotoSticker} for method parameters.
 * Any of:
 * - {@link chatPhotoSticker$Input}
 */
export type ChatPhotoSticker$Input = chatPhotoSticker$Input;

/**
 * Any of:
 * - {@link animatedChatPhoto}
 */
export type AnimatedChatPhoto = animatedChatPhoto;

/**
 * Version of {@link AnimatedChatPhoto} for method parameters.
 * Any of:
 * - {@link animatedChatPhoto$Input}
 */
export type AnimatedChatPhoto$Input = animatedChatPhoto$Input;

/**
 * Any of:
 * - {@link chatPhoto}
 */
export type ChatPhoto = chatPhoto;

/**
 * Version of {@link ChatPhoto} for method parameters.
 * Any of:
 * - {@link chatPhoto$Input}
 */
export type ChatPhoto$Input = chatPhoto$Input;

/**
 * Any of:
 * - {@link chatPhotos}
 */
export type ChatPhotos = chatPhotos;

/**
 * Version of {@link ChatPhotos} for method parameters.
 * Any of:
 * - {@link chatPhotos$Input}
 */
export type ChatPhotos$Input = chatPhotos$Input;

/**
 * Any of:
 * - {@link inputChatPhotoPrevious}
 * - {@link inputChatPhotoStatic}
 * - {@link inputChatPhotoAnimation}
 * - {@link inputChatPhotoSticker}
 */
export type InputChatPhoto =
  | inputChatPhotoPrevious
  | inputChatPhotoStatic
  | inputChatPhotoAnimation
  | inputChatPhotoSticker;

/**
 * Version of {@link InputChatPhoto} for method parameters.
 * Any of:
 * - {@link inputChatPhotoPrevious$Input}
 * - {@link inputChatPhotoStatic$Input}
 * - {@link inputChatPhotoAnimation$Input}
 * - {@link inputChatPhotoSticker$Input}
 */
export type InputChatPhoto$Input =
  | inputChatPhotoPrevious$Input
  | inputChatPhotoStatic$Input
  | inputChatPhotoAnimation$Input
  | inputChatPhotoSticker$Input;

/**
 * Any of:
 * - {@link chatPermissions}
 */
export type ChatPermissions = chatPermissions;

/**
 * Version of {@link ChatPermissions} for method parameters.
 * Any of:
 * - {@link chatPermissions$Input}
 */
export type ChatPermissions$Input = chatPermissions$Input;

/**
 * Any of:
 * - {@link chatAdministratorRights}
 */
export type ChatAdministratorRights = chatAdministratorRights;

/**
 * Version of {@link ChatAdministratorRights} for method parameters.
 * Any of:
 * - {@link chatAdministratorRights$Input}
 */
export type ChatAdministratorRights$Input = chatAdministratorRights$Input;

/**
 * Any of:
 * - {@link premiumPaymentOption}
 */
export type PremiumPaymentOption = premiumPaymentOption;

/**
 * Version of {@link PremiumPaymentOption} for method parameters.
 * Any of:
 * - {@link premiumPaymentOption$Input}
 */
export type PremiumPaymentOption$Input = premiumPaymentOption$Input;

/**
 * Any of:
 * - {@link premiumStatePaymentOption}
 */
export type PremiumStatePaymentOption = premiumStatePaymentOption;

/**
 * Version of {@link PremiumStatePaymentOption} for method parameters.
 * Any of:
 * - {@link premiumStatePaymentOption$Input}
 */
export type PremiumStatePaymentOption$Input = premiumStatePaymentOption$Input;

/**
 * Any of:
 * - {@link premiumGiftCodePaymentOption}
 */
export type PremiumGiftCodePaymentOption = premiumGiftCodePaymentOption;

/**
 * Version of {@link PremiumGiftCodePaymentOption} for method parameters.
 * Any of:
 * - {@link premiumGiftCodePaymentOption$Input}
 */
export type PremiumGiftCodePaymentOption$Input = premiumGiftCodePaymentOption$Input;

/**
 * Any of:
 * - {@link premiumGiftCodePaymentOptions}
 */
export type PremiumGiftCodePaymentOptions = premiumGiftCodePaymentOptions;

/**
 * Version of {@link PremiumGiftCodePaymentOptions} for method parameters.
 * Any of:
 * - {@link premiumGiftCodePaymentOptions$Input}
 */
export type PremiumGiftCodePaymentOptions$Input =
  premiumGiftCodePaymentOptions$Input;

/**
 * Any of:
 * - {@link premiumGiftCodeInfo}
 */
export type PremiumGiftCodeInfo = premiumGiftCodeInfo;

/**
 * Version of {@link PremiumGiftCodeInfo} for method parameters.
 * Any of:
 * - {@link premiumGiftCodeInfo$Input}
 */
export type PremiumGiftCodeInfo$Input = premiumGiftCodeInfo$Input;

/**
 * Any of:
 * - {@link premiumGiveawayParticipantStatusEligible}
 * - {@link premiumGiveawayParticipantStatusParticipating}
 * - {@link premiumGiveawayParticipantStatusAlreadyWasMember}
 * - {@link premiumGiveawayParticipantStatusAdministrator}
 * - {@link premiumGiveawayParticipantStatusDisallowedCountry}
 */
export type PremiumGiveawayParticipantStatus =
  | premiumGiveawayParticipantStatusEligible
  | premiumGiveawayParticipantStatusParticipating
  | premiumGiveawayParticipantStatusAlreadyWasMember
  | premiumGiveawayParticipantStatusAdministrator
  | premiumGiveawayParticipantStatusDisallowedCountry;

/**
 * Version of {@link PremiumGiveawayParticipantStatus} for method parameters.
 * Any of:
 * - {@link premiumGiveawayParticipantStatusEligible$Input}
 * - {@link premiumGiveawayParticipantStatusParticipating$Input}
 * - {@link premiumGiveawayParticipantStatusAlreadyWasMember$Input}
 * - {@link premiumGiveawayParticipantStatusAdministrator$Input}
 * - {@link premiumGiveawayParticipantStatusDisallowedCountry$Input}
 */
export type PremiumGiveawayParticipantStatus$Input =
  | premiumGiveawayParticipantStatusEligible$Input
  | premiumGiveawayParticipantStatusParticipating$Input
  | premiumGiveawayParticipantStatusAlreadyWasMember$Input
  | premiumGiveawayParticipantStatusAdministrator$Input
  | premiumGiveawayParticipantStatusDisallowedCountry$Input;

/**
 * Any of:
 * - {@link premiumGiveawayInfoOngoing}
 * - {@link premiumGiveawayInfoCompleted}
 */
export type PremiumGiveawayInfo =
  | premiumGiveawayInfoOngoing
  | premiumGiveawayInfoCompleted;

/**
 * Version of {@link PremiumGiveawayInfo} for method parameters.
 * Any of:
 * - {@link premiumGiveawayInfoOngoing$Input}
 * - {@link premiumGiveawayInfoCompleted$Input}
 */
export type PremiumGiveawayInfo$Input =
  | premiumGiveawayInfoOngoing$Input
  | premiumGiveawayInfoCompleted$Input;

/**
 * Any of:
 * - {@link accentColor}
 */
export type AccentColor = accentColor;

/**
 * Version of {@link AccentColor} for method parameters.
 * Any of:
 * - {@link accentColor$Input}
 */
export type AccentColor$Input = accentColor$Input;

/**
 * Any of:
 * - {@link profileAccentColors}
 */
export type ProfileAccentColors = profileAccentColors;

/**
 * Version of {@link ProfileAccentColors} for method parameters.
 * Any of:
 * - {@link profileAccentColors$Input}
 */
export type ProfileAccentColors$Input = profileAccentColors$Input;

/**
 * Any of:
 * - {@link profileAccentColor}
 */
export type ProfileAccentColor = profileAccentColor;

/**
 * Version of {@link ProfileAccentColor} for method parameters.
 * Any of:
 * - {@link profileAccentColor$Input}
 */
export type ProfileAccentColor$Input = profileAccentColor$Input;

/**
 * Any of:
 * - {@link emojiStatus}
 */
export type EmojiStatus = emojiStatus;

/**
 * Version of {@link EmojiStatus} for method parameters.
 * Any of:
 * - {@link emojiStatus$Input}
 */
export type EmojiStatus$Input = emojiStatus$Input;

/**
 * Any of:
 * - {@link emojiStatuses}
 */
export type EmojiStatuses = emojiStatuses;

/**
 * Version of {@link EmojiStatuses} for method parameters.
 * Any of:
 * - {@link emojiStatuses$Input}
 */
export type EmojiStatuses$Input = emojiStatuses$Input;

/**
 * Any of:
 * - {@link usernames}
 */
export type Usernames = usernames;

/**
 * Version of {@link Usernames} for method parameters.
 * Any of:
 * - {@link usernames$Input}
 */
export type Usernames$Input = usernames$Input;

/**
 * Any of:
 * - {@link user}
 */
export type User = user;

/**
 * Version of {@link User} for method parameters.
 * Any of:
 * - {@link user$Input}
 */
export type User$Input = user$Input;

/**
 * Any of:
 * - {@link botInfo}
 */
export type BotInfo = botInfo;

/**
 * Version of {@link BotInfo} for method parameters.
 * Any of:
 * - {@link botInfo$Input}
 */
export type BotInfo$Input = botInfo$Input;

/**
 * Any of:
 * - {@link userFullInfo}
 */
export type UserFullInfo = userFullInfo;

/**
 * Version of {@link UserFullInfo} for method parameters.
 * Any of:
 * - {@link userFullInfo$Input}
 */
export type UserFullInfo$Input = userFullInfo$Input;

/**
 * Any of:
 * - {@link users}
 */
export type Users = users;

/**
 * Version of {@link Users} for method parameters.
 * Any of:
 * - {@link users$Input}
 */
export type Users$Input = users$Input;

/**
 * Any of:
 * - {@link chatAdministrator}
 */
export type ChatAdministrator = chatAdministrator;

/**
 * Version of {@link ChatAdministrator} for method parameters.
 * Any of:
 * - {@link chatAdministrator$Input}
 */
export type ChatAdministrator$Input = chatAdministrator$Input;

/**
 * Any of:
 * - {@link chatAdministrators}
 */
export type ChatAdministrators = chatAdministrators;

/**
 * Version of {@link ChatAdministrators} for method parameters.
 * Any of:
 * - {@link chatAdministrators$Input}
 */
export type ChatAdministrators$Input = chatAdministrators$Input;

/**
 * Any of:
 * - {@link chatMemberStatusCreator}
 * - {@link chatMemberStatusAdministrator}
 * - {@link chatMemberStatusMember}
 * - {@link chatMemberStatusRestricted}
 * - {@link chatMemberStatusLeft}
 * - {@link chatMemberStatusBanned}
 */
export type ChatMemberStatus =
  | chatMemberStatusCreator
  | chatMemberStatusAdministrator
  | chatMemberStatusMember
  | chatMemberStatusRestricted
  | chatMemberStatusLeft
  | chatMemberStatusBanned;

/**
 * Version of {@link ChatMemberStatus} for method parameters.
 * Any of:
 * - {@link chatMemberStatusCreator$Input}
 * - {@link chatMemberStatusAdministrator$Input}
 * - {@link chatMemberStatusMember$Input}
 * - {@link chatMemberStatusRestricted$Input}
 * - {@link chatMemberStatusLeft$Input}
 * - {@link chatMemberStatusBanned$Input}
 */
export type ChatMemberStatus$Input =
  | chatMemberStatusCreator$Input
  | chatMemberStatusAdministrator$Input
  | chatMemberStatusMember$Input
  | chatMemberStatusRestricted$Input
  | chatMemberStatusLeft$Input
  | chatMemberStatusBanned$Input;

/**
 * Any of:
 * - {@link chatMember}
 */
export type ChatMember = chatMember;

/**
 * Version of {@link ChatMember} for method parameters.
 * Any of:
 * - {@link chatMember$Input}
 */
export type ChatMember$Input = chatMember$Input;

/**
 * Any of:
 * - {@link chatMembers}
 */
export type ChatMembers = chatMembers;

/**
 * Version of {@link ChatMembers} for method parameters.
 * Any of:
 * - {@link chatMembers$Input}
 */
export type ChatMembers$Input = chatMembers$Input;

/**
 * Any of:
 * - {@link chatMembersFilterContacts}
 * - {@link chatMembersFilterAdministrators}
 * - {@link chatMembersFilterMembers}
 * - {@link chatMembersFilterMention}
 * - {@link chatMembersFilterRestricted}
 * - {@link chatMembersFilterBanned}
 * - {@link chatMembersFilterBots}
 */
export type ChatMembersFilter =
  | chatMembersFilterContacts
  | chatMembersFilterAdministrators
  | chatMembersFilterMembers
  | chatMembersFilterMention
  | chatMembersFilterRestricted
  | chatMembersFilterBanned
  | chatMembersFilterBots;

/**
 * Version of {@link ChatMembersFilter} for method parameters.
 * Any of:
 * - {@link chatMembersFilterContacts$Input}
 * - {@link chatMembersFilterAdministrators$Input}
 * - {@link chatMembersFilterMembers$Input}
 * - {@link chatMembersFilterMention$Input}
 * - {@link chatMembersFilterRestricted$Input}
 * - {@link chatMembersFilterBanned$Input}
 * - {@link chatMembersFilterBots$Input}
 */
export type ChatMembersFilter$Input =
  | chatMembersFilterContacts$Input
  | chatMembersFilterAdministrators$Input
  | chatMembersFilterMembers$Input
  | chatMembersFilterMention$Input
  | chatMembersFilterRestricted$Input
  | chatMembersFilterBanned$Input
  | chatMembersFilterBots$Input;

/**
 * Any of:
 * - {@link supergroupMembersFilterRecent}
 * - {@link supergroupMembersFilterContacts}
 * - {@link supergroupMembersFilterAdministrators}
 * - {@link supergroupMembersFilterSearch}
 * - {@link supergroupMembersFilterRestricted}
 * - {@link supergroupMembersFilterBanned}
 * - {@link supergroupMembersFilterMention}
 * - {@link supergroupMembersFilterBots}
 */
export type SupergroupMembersFilter =
  | supergroupMembersFilterRecent
  | supergroupMembersFilterContacts
  | supergroupMembersFilterAdministrators
  | supergroupMembersFilterSearch
  | supergroupMembersFilterRestricted
  | supergroupMembersFilterBanned
  | supergroupMembersFilterMention
  | supergroupMembersFilterBots;

/**
 * Version of {@link SupergroupMembersFilter} for method parameters.
 * Any of:
 * - {@link supergroupMembersFilterRecent$Input}
 * - {@link supergroupMembersFilterContacts$Input}
 * - {@link supergroupMembersFilterAdministrators$Input}
 * - {@link supergroupMembersFilterSearch$Input}
 * - {@link supergroupMembersFilterRestricted$Input}
 * - {@link supergroupMembersFilterBanned$Input}
 * - {@link supergroupMembersFilterMention$Input}
 * - {@link supergroupMembersFilterBots$Input}
 */
export type SupergroupMembersFilter$Input =
  | supergroupMembersFilterRecent$Input
  | supergroupMembersFilterContacts$Input
  | supergroupMembersFilterAdministrators$Input
  | supergroupMembersFilterSearch$Input
  | supergroupMembersFilterRestricted$Input
  | supergroupMembersFilterBanned$Input
  | supergroupMembersFilterMention$Input
  | supergroupMembersFilterBots$Input;

/**
 * Any of:
 * - {@link chatInviteLink}
 */
export type ChatInviteLink = chatInviteLink;

/**
 * Version of {@link ChatInviteLink} for method parameters.
 * Any of:
 * - {@link chatInviteLink$Input}
 */
export type ChatInviteLink$Input = chatInviteLink$Input;

/**
 * Any of:
 * - {@link chatInviteLinks}
 */
export type ChatInviteLinks = chatInviteLinks;

/**
 * Version of {@link ChatInviteLinks} for method parameters.
 * Any of:
 * - {@link chatInviteLinks$Input}
 */
export type ChatInviteLinks$Input = chatInviteLinks$Input;

/**
 * Any of:
 * - {@link chatInviteLinkCount}
 */
export type ChatInviteLinkCount = chatInviteLinkCount;

/**
 * Version of {@link ChatInviteLinkCount} for method parameters.
 * Any of:
 * - {@link chatInviteLinkCount$Input}
 */
export type ChatInviteLinkCount$Input = chatInviteLinkCount$Input;

/**
 * Any of:
 * - {@link chatInviteLinkCounts}
 */
export type ChatInviteLinkCounts = chatInviteLinkCounts;

/**
 * Version of {@link ChatInviteLinkCounts} for method parameters.
 * Any of:
 * - {@link chatInviteLinkCounts$Input}
 */
export type ChatInviteLinkCounts$Input = chatInviteLinkCounts$Input;

/**
 * Any of:
 * - {@link chatInviteLinkMember}
 */
export type ChatInviteLinkMember = chatInviteLinkMember;

/**
 * Version of {@link ChatInviteLinkMember} for method parameters.
 * Any of:
 * - {@link chatInviteLinkMember$Input}
 */
export type ChatInviteLinkMember$Input = chatInviteLinkMember$Input;

/**
 * Any of:
 * - {@link chatInviteLinkMembers}
 */
export type ChatInviteLinkMembers = chatInviteLinkMembers;

/**
 * Version of {@link ChatInviteLinkMembers} for method parameters.
 * Any of:
 * - {@link chatInviteLinkMembers$Input}
 */
export type ChatInviteLinkMembers$Input = chatInviteLinkMembers$Input;

/**
 * Any of:
 * - {@link inviteLinkChatTypeBasicGroup}
 * - {@link inviteLinkChatTypeSupergroup}
 * - {@link inviteLinkChatTypeChannel}
 */
export type InviteLinkChatType =
  | inviteLinkChatTypeBasicGroup
  | inviteLinkChatTypeSupergroup
  | inviteLinkChatTypeChannel;

/**
 * Version of {@link InviteLinkChatType} for method parameters.
 * Any of:
 * - {@link inviteLinkChatTypeBasicGroup$Input}
 * - {@link inviteLinkChatTypeSupergroup$Input}
 * - {@link inviteLinkChatTypeChannel$Input}
 */
export type InviteLinkChatType$Input =
  | inviteLinkChatTypeBasicGroup$Input
  | inviteLinkChatTypeSupergroup$Input
  | inviteLinkChatTypeChannel$Input;

/**
 * Any of:
 * - {@link chatInviteLinkInfo}
 */
export type ChatInviteLinkInfo = chatInviteLinkInfo;

/**
 * Version of {@link ChatInviteLinkInfo} for method parameters.
 * Any of:
 * - {@link chatInviteLinkInfo$Input}
 */
export type ChatInviteLinkInfo$Input = chatInviteLinkInfo$Input;

/**
 * Any of:
 * - {@link chatJoinRequest}
 */
export type ChatJoinRequest = chatJoinRequest;

/**
 * Version of {@link ChatJoinRequest} for method parameters.
 * Any of:
 * - {@link chatJoinRequest$Input}
 */
export type ChatJoinRequest$Input = chatJoinRequest$Input;

/**
 * Any of:
 * - {@link chatJoinRequests}
 */
export type ChatJoinRequests = chatJoinRequests;

/**
 * Version of {@link ChatJoinRequests} for method parameters.
 * Any of:
 * - {@link chatJoinRequests$Input}
 */
export type ChatJoinRequests$Input = chatJoinRequests$Input;

/**
 * Any of:
 * - {@link chatJoinRequestsInfo}
 */
export type ChatJoinRequestsInfo = chatJoinRequestsInfo;

/**
 * Version of {@link ChatJoinRequestsInfo} for method parameters.
 * Any of:
 * - {@link chatJoinRequestsInfo$Input}
 */
export type ChatJoinRequestsInfo$Input = chatJoinRequestsInfo$Input;

/**
 * Any of:
 * - {@link basicGroup}
 */
export type BasicGroup = basicGroup;

/**
 * Version of {@link BasicGroup} for method parameters.
 * Any of:
 * - {@link basicGroup$Input}
 */
export type BasicGroup$Input = basicGroup$Input;

/**
 * Any of:
 * - {@link basicGroupFullInfo}
 */
export type BasicGroupFullInfo = basicGroupFullInfo;

/**
 * Version of {@link BasicGroupFullInfo} for method parameters.
 * Any of:
 * - {@link basicGroupFullInfo$Input}
 */
export type BasicGroupFullInfo$Input = basicGroupFullInfo$Input;

/**
 * Any of:
 * - {@link supergroup}
 */
export type Supergroup = supergroup;

/**
 * Version of {@link Supergroup} for method parameters.
 * Any of:
 * - {@link supergroup$Input}
 */
export type Supergroup$Input = supergroup$Input;

/**
 * Any of:
 * - {@link supergroupFullInfo}
 */
export type SupergroupFullInfo = supergroupFullInfo;

/**
 * Version of {@link SupergroupFullInfo} for method parameters.
 * Any of:
 * - {@link supergroupFullInfo$Input}
 */
export type SupergroupFullInfo$Input = supergroupFullInfo$Input;

/**
 * Any of:
 * - {@link secretChatStatePending}
 * - {@link secretChatStateReady}
 * - {@link secretChatStateClosed}
 */
export type SecretChatState =
  | secretChatStatePending
  | secretChatStateReady
  | secretChatStateClosed;

/**
 * Version of {@link SecretChatState} for method parameters.
 * Any of:
 * - {@link secretChatStatePending$Input}
 * - {@link secretChatStateReady$Input}
 * - {@link secretChatStateClosed$Input}
 */
export type SecretChatState$Input =
  | secretChatStatePending$Input
  | secretChatStateReady$Input
  | secretChatStateClosed$Input;

/**
 * Any of:
 * - {@link secretChat}
 */
export type SecretChat = secretChat;

/**
 * Version of {@link SecretChat} for method parameters.
 * Any of:
 * - {@link secretChat$Input}
 */
export type SecretChat$Input = secretChat$Input;

/**
 * Any of:
 * - {@link messageSenderUser}
 * - {@link messageSenderChat}
 */
export type MessageSender = messageSenderUser | messageSenderChat;

/**
 * Version of {@link MessageSender} for method parameters.
 * Any of:
 * - {@link messageSenderUser$Input}
 * - {@link messageSenderChat$Input}
 */
export type MessageSender$Input = messageSenderUser$Input | messageSenderChat$Input;

/**
 * Any of:
 * - {@link messageSenders}
 */
export type MessageSenders = messageSenders;

/**
 * Version of {@link MessageSenders} for method parameters.
 * Any of:
 * - {@link messageSenders$Input}
 */
export type MessageSenders$Input = messageSenders$Input;

/**
 * Any of:
 * - {@link chatMessageSender}
 */
export type ChatMessageSender = chatMessageSender;

/**
 * Version of {@link ChatMessageSender} for method parameters.
 * Any of:
 * - {@link chatMessageSender$Input}
 */
export type ChatMessageSender$Input = chatMessageSender$Input;

/**
 * Any of:
 * - {@link chatMessageSenders}
 */
export type ChatMessageSenders = chatMessageSenders;

/**
 * Version of {@link ChatMessageSenders} for method parameters.
 * Any of:
 * - {@link chatMessageSenders$Input}
 */
export type ChatMessageSenders$Input = chatMessageSenders$Input;

/**
 * Any of:
 * - {@link messageViewer}
 */
export type MessageViewer = messageViewer;

/**
 * Version of {@link MessageViewer} for method parameters.
 * Any of:
 * - {@link messageViewer$Input}
 */
export type MessageViewer$Input = messageViewer$Input;

/**
 * Any of:
 * - {@link messageViewers}
 */
export type MessageViewers = messageViewers;

/**
 * Version of {@link MessageViewers} for method parameters.
 * Any of:
 * - {@link messageViewers$Input}
 */
export type MessageViewers$Input = messageViewers$Input;

/**
 * Any of:
 * - {@link messageOriginUser}
 * - {@link messageOriginHiddenUser}
 * - {@link messageOriginChat}
 * - {@link messageOriginChannel}
 */
export type MessageOrigin =
  | messageOriginUser
  | messageOriginHiddenUser
  | messageOriginChat
  | messageOriginChannel;

/**
 * Version of {@link MessageOrigin} for method parameters.
 * Any of:
 * - {@link messageOriginUser$Input}
 * - {@link messageOriginHiddenUser$Input}
 * - {@link messageOriginChat$Input}
 * - {@link messageOriginChannel$Input}
 */
export type MessageOrigin$Input =
  | messageOriginUser$Input
  | messageOriginHiddenUser$Input
  | messageOriginChat$Input
  | messageOriginChannel$Input;

/**
 * Any of:
 * - {@link reactionTypeEmoji}
 * - {@link reactionTypeCustomEmoji}
 */
export type ReactionType = reactionTypeEmoji | reactionTypeCustomEmoji;

/**
 * Version of {@link ReactionType} for method parameters.
 * Any of:
 * - {@link reactionTypeEmoji$Input}
 * - {@link reactionTypeCustomEmoji$Input}
 */
export type ReactionType$Input =
  | reactionTypeEmoji$Input
  | reactionTypeCustomEmoji$Input;

/**
 * Any of:
 * - {@link messageForwardInfo}
 */
export type MessageForwardInfo = messageForwardInfo;

/**
 * Version of {@link MessageForwardInfo} for method parameters.
 * Any of:
 * - {@link messageForwardInfo$Input}
 */
export type MessageForwardInfo$Input = messageForwardInfo$Input;

/**
 * Any of:
 * - {@link messageImportInfo}
 */
export type MessageImportInfo = messageImportInfo;

/**
 * Version of {@link MessageImportInfo} for method parameters.
 * Any of:
 * - {@link messageImportInfo$Input}
 */
export type MessageImportInfo$Input = messageImportInfo$Input;

/**
 * Any of:
 * - {@link messageReplyInfo}
 */
export type MessageReplyInfo = messageReplyInfo;

/**
 * Version of {@link MessageReplyInfo} for method parameters.
 * Any of:
 * - {@link messageReplyInfo$Input}
 */
export type MessageReplyInfo$Input = messageReplyInfo$Input;

/**
 * Any of:
 * - {@link messageReaction}
 */
export type MessageReaction = messageReaction;

/**
 * Version of {@link MessageReaction} for method parameters.
 * Any of:
 * - {@link messageReaction$Input}
 */
export type MessageReaction$Input = messageReaction$Input;

/**
 * Any of:
 * - {@link messageInteractionInfo}
 */
export type MessageInteractionInfo = messageInteractionInfo;

/**
 * Version of {@link MessageInteractionInfo} for method parameters.
 * Any of:
 * - {@link messageInteractionInfo$Input}
 */
export type MessageInteractionInfo$Input = messageInteractionInfo$Input;

/**
 * Any of:
 * - {@link unreadReaction}
 */
export type UnreadReaction = unreadReaction;

/**
 * Version of {@link UnreadReaction} for method parameters.
 * Any of:
 * - {@link unreadReaction$Input}
 */
export type UnreadReaction$Input = unreadReaction$Input;

/**
 * Any of:
 * - {@link messageSendingStatePending}
 * - {@link messageSendingStateFailed}
 */
export type MessageSendingState =
  | messageSendingStatePending
  | messageSendingStateFailed;

/**
 * Version of {@link MessageSendingState} for method parameters.
 * Any of:
 * - {@link messageSendingStatePending$Input}
 * - {@link messageSendingStateFailed$Input}
 */
export type MessageSendingState$Input =
  | messageSendingStatePending$Input
  | messageSendingStateFailed$Input;

/**
 * Any of:
 * - {@link textQuote}
 */
export type TextQuote = textQuote;

/**
 * Version of {@link TextQuote} for method parameters.
 * Any of:
 * - {@link textQuote$Input}
 */
export type TextQuote$Input = textQuote$Input;

/**
 * Any of:
 * - {@link inputTextQuote}
 */
export type InputTextQuote = inputTextQuote;

/**
 * Version of {@link InputTextQuote} for method parameters.
 * Any of:
 * - {@link inputTextQuote$Input}
 */
export type InputTextQuote$Input = inputTextQuote$Input;

/**
 * Any of:
 * - {@link messageReplyToMessage}
 * - {@link messageReplyToStory}
 */
export type MessageReplyTo = messageReplyToMessage | messageReplyToStory;

/**
 * Version of {@link MessageReplyTo} for method parameters.
 * Any of:
 * - {@link messageReplyToMessage$Input}
 * - {@link messageReplyToStory$Input}
 */
export type MessageReplyTo$Input =
  | messageReplyToMessage$Input
  | messageReplyToStory$Input;

/**
 * Any of:
 * - {@link inputMessageReplyToMessage}
 * - {@link inputMessageReplyToStory}
 */
export type InputMessageReplyTo =
  | inputMessageReplyToMessage
  | inputMessageReplyToStory;

/**
 * Version of {@link InputMessageReplyTo} for method parameters.
 * Any of:
 * - {@link inputMessageReplyToMessage$Input}
 * - {@link inputMessageReplyToStory$Input}
 */
export type InputMessageReplyTo$Input =
  | inputMessageReplyToMessage$Input
  | inputMessageReplyToStory$Input;

/**
 * Any of:
 * - {@link message}
 */
export type Message = message;

/**
 * Version of {@link Message} for method parameters.
 * Any of:
 * - {@link message$Input}
 */
export type Message$Input = message$Input;

/**
 * Any of:
 * - {@link messages}
 */
export type Messages = messages;

/**
 * Version of {@link Messages} for method parameters.
 * Any of:
 * - {@link messages$Input}
 */
export type Messages$Input = messages$Input;

/**
 * Any of:
 * - {@link foundMessages}
 */
export type FoundMessages = foundMessages;

/**
 * Version of {@link FoundMessages} for method parameters.
 * Any of:
 * - {@link foundMessages$Input}
 */
export type FoundMessages$Input = foundMessages$Input;

/**
 * Any of:
 * - {@link foundChatMessages}
 */
export type FoundChatMessages = foundChatMessages;

/**
 * Version of {@link FoundChatMessages} for method parameters.
 * Any of:
 * - {@link foundChatMessages$Input}
 */
export type FoundChatMessages$Input = foundChatMessages$Input;

/**
 * Any of:
 * - {@link messagePosition}
 */
export type MessagePosition = messagePosition;

/**
 * Version of {@link MessagePosition} for method parameters.
 * Any of:
 * - {@link messagePosition$Input}
 */
export type MessagePosition$Input = messagePosition$Input;

/**
 * Any of:
 * - {@link messagePositions}
 */
export type MessagePositions = messagePositions;

/**
 * Version of {@link MessagePositions} for method parameters.
 * Any of:
 * - {@link messagePositions$Input}
 */
export type MessagePositions$Input = messagePositions$Input;

/**
 * Any of:
 * - {@link messageCalendarDay}
 */
export type MessageCalendarDay = messageCalendarDay;

/**
 * Version of {@link MessageCalendarDay} for method parameters.
 * Any of:
 * - {@link messageCalendarDay$Input}
 */
export type MessageCalendarDay$Input = messageCalendarDay$Input;

/**
 * Any of:
 * - {@link messageCalendar}
 */
export type MessageCalendar = messageCalendar;

/**
 * Version of {@link MessageCalendar} for method parameters.
 * Any of:
 * - {@link messageCalendar$Input}
 */
export type MessageCalendar$Input = messageCalendar$Input;

/**
 * Any of:
 * - {@link messageSourceChatHistory}
 * - {@link messageSourceMessageThreadHistory}
 * - {@link messageSourceForumTopicHistory}
 * - {@link messageSourceHistoryPreview}
 * - {@link messageSourceChatList}
 * - {@link messageSourceSearch}
 * - {@link messageSourceChatEventLog}
 * - {@link messageSourceNotification}
 * - {@link messageSourceScreenshot}
 * - {@link messageSourceOther}
 */
export type MessageSource =
  | messageSourceChatHistory
  | messageSourceMessageThreadHistory
  | messageSourceForumTopicHistory
  | messageSourceHistoryPreview
  | messageSourceChatList
  | messageSourceSearch
  | messageSourceChatEventLog
  | messageSourceNotification
  | messageSourceScreenshot
  | messageSourceOther;

/**
 * Version of {@link MessageSource} for method parameters.
 * Any of:
 * - {@link messageSourceChatHistory$Input}
 * - {@link messageSourceMessageThreadHistory$Input}
 * - {@link messageSourceForumTopicHistory$Input}
 * - {@link messageSourceHistoryPreview$Input}
 * - {@link messageSourceChatList$Input}
 * - {@link messageSourceSearch$Input}
 * - {@link messageSourceChatEventLog$Input}
 * - {@link messageSourceNotification$Input}
 * - {@link messageSourceScreenshot$Input}
 * - {@link messageSourceOther$Input}
 */
export type MessageSource$Input =
  | messageSourceChatHistory$Input
  | messageSourceMessageThreadHistory$Input
  | messageSourceForumTopicHistory$Input
  | messageSourceHistoryPreview$Input
  | messageSourceChatList$Input
  | messageSourceSearch$Input
  | messageSourceChatEventLog$Input
  | messageSourceNotification$Input
  | messageSourceScreenshot$Input
  | messageSourceOther$Input;

/**
 * Any of:
 * - {@link messageSponsorTypeBot}
 * - {@link messageSponsorTypeWebApp}
 * - {@link messageSponsorTypePublicChannel}
 * - {@link messageSponsorTypePrivateChannel}
 * - {@link messageSponsorTypeWebsite}
 */
export type MessageSponsorType =
  | messageSponsorTypeBot
  | messageSponsorTypeWebApp
  | messageSponsorTypePublicChannel
  | messageSponsorTypePrivateChannel
  | messageSponsorTypeWebsite;

/**
 * Version of {@link MessageSponsorType} for method parameters.
 * Any of:
 * - {@link messageSponsorTypeBot$Input}
 * - {@link messageSponsorTypeWebApp$Input}
 * - {@link messageSponsorTypePublicChannel$Input}
 * - {@link messageSponsorTypePrivateChannel$Input}
 * - {@link messageSponsorTypeWebsite$Input}
 */
export type MessageSponsorType$Input =
  | messageSponsorTypeBot$Input
  | messageSponsorTypeWebApp$Input
  | messageSponsorTypePublicChannel$Input
  | messageSponsorTypePrivateChannel$Input
  | messageSponsorTypeWebsite$Input;

/**
 * Any of:
 * - {@link messageSponsor}
 */
export type MessageSponsor = messageSponsor;

/**
 * Version of {@link MessageSponsor} for method parameters.
 * Any of:
 * - {@link messageSponsor$Input}
 */
export type MessageSponsor$Input = messageSponsor$Input;

/**
 * Any of:
 * - {@link sponsoredMessage}
 */
export type SponsoredMessage = sponsoredMessage;

/**
 * Version of {@link SponsoredMessage} for method parameters.
 * Any of:
 * - {@link sponsoredMessage$Input}
 */
export type SponsoredMessage$Input = sponsoredMessage$Input;

/**
 * Any of:
 * - {@link sponsoredMessages}
 */
export type SponsoredMessages = sponsoredMessages;

/**
 * Version of {@link SponsoredMessages} for method parameters.
 * Any of:
 * - {@link sponsoredMessages$Input}
 */
export type SponsoredMessages$Input = sponsoredMessages$Input;

/**
 * Any of:
 * - {@link fileDownload}
 */
export type FileDownload = fileDownload;

/**
 * Version of {@link FileDownload} for method parameters.
 * Any of:
 * - {@link fileDownload$Input}
 */
export type FileDownload$Input = fileDownload$Input;

/**
 * Any of:
 * - {@link downloadedFileCounts}
 */
export type DownloadedFileCounts = downloadedFileCounts;

/**
 * Version of {@link DownloadedFileCounts} for method parameters.
 * Any of:
 * - {@link downloadedFileCounts$Input}
 */
export type DownloadedFileCounts$Input = downloadedFileCounts$Input;

/**
 * Any of:
 * - {@link foundFileDownloads}
 */
export type FoundFileDownloads = foundFileDownloads;

/**
 * Version of {@link FoundFileDownloads} for method parameters.
 * Any of:
 * - {@link foundFileDownloads$Input}
 */
export type FoundFileDownloads$Input = foundFileDownloads$Input;

/**
 * Any of:
 * - {@link notificationSettingsScopePrivateChats}
 * - {@link notificationSettingsScopeGroupChats}
 * - {@link notificationSettingsScopeChannelChats}
 */
export type NotificationSettingsScope =
  | notificationSettingsScopePrivateChats
  | notificationSettingsScopeGroupChats
  | notificationSettingsScopeChannelChats;

/**
 * Version of {@link NotificationSettingsScope} for method parameters.
 * Any of:
 * - {@link notificationSettingsScopePrivateChats$Input}
 * - {@link notificationSettingsScopeGroupChats$Input}
 * - {@link notificationSettingsScopeChannelChats$Input}
 */
export type NotificationSettingsScope$Input =
  | notificationSettingsScopePrivateChats$Input
  | notificationSettingsScopeGroupChats$Input
  | notificationSettingsScopeChannelChats$Input;

/**
 * Any of:
 * - {@link chatNotificationSettings}
 */
export type ChatNotificationSettings = chatNotificationSettings;

/**
 * Version of {@link ChatNotificationSettings} for method parameters.
 * Any of:
 * - {@link chatNotificationSettings$Input}
 */
export type ChatNotificationSettings$Input = chatNotificationSettings$Input;

/**
 * Any of:
 * - {@link scopeNotificationSettings}
 */
export type ScopeNotificationSettings = scopeNotificationSettings;

/**
 * Version of {@link ScopeNotificationSettings} for method parameters.
 * Any of:
 * - {@link scopeNotificationSettings$Input}
 */
export type ScopeNotificationSettings$Input = scopeNotificationSettings$Input;

/**
 * Any of:
 * - {@link draftMessage}
 */
export type DraftMessage = draftMessage;

/**
 * Version of {@link DraftMessage} for method parameters.
 * Any of:
 * - {@link draftMessage$Input}
 */
export type DraftMessage$Input = draftMessage$Input;

/**
 * Any of:
 * - {@link chatTypePrivate}
 * - {@link chatTypeBasicGroup}
 * - {@link chatTypeSupergroup}
 * - {@link chatTypeSecret}
 */
export type ChatType =
  | chatTypePrivate
  | chatTypeBasicGroup
  | chatTypeSupergroup
  | chatTypeSecret;

/**
 * Version of {@link ChatType} for method parameters.
 * Any of:
 * - {@link chatTypePrivate$Input}
 * - {@link chatTypeBasicGroup$Input}
 * - {@link chatTypeSupergroup$Input}
 * - {@link chatTypeSecret$Input}
 */
export type ChatType$Input =
  | chatTypePrivate$Input
  | chatTypeBasicGroup$Input
  | chatTypeSupergroup$Input
  | chatTypeSecret$Input;

/**
 * Any of:
 * - {@link chatFolderIcon}
 */
export type ChatFolderIcon = chatFolderIcon;

/**
 * Version of {@link ChatFolderIcon} for method parameters.
 * Any of:
 * - {@link chatFolderIcon$Input}
 */
export type ChatFolderIcon$Input = chatFolderIcon$Input;

/**
 * Any of:
 * - {@link chatFolder}
 */
export type ChatFolder = chatFolder;

/**
 * Version of {@link ChatFolder} for method parameters.
 * Any of:
 * - {@link chatFolder$Input}
 */
export type ChatFolder$Input = chatFolder$Input;

/**
 * Any of:
 * - {@link chatFolderInfo}
 */
export type ChatFolderInfo = chatFolderInfo;

/**
 * Version of {@link ChatFolderInfo} for method parameters.
 * Any of:
 * - {@link chatFolderInfo$Input}
 */
export type ChatFolderInfo$Input = chatFolderInfo$Input;

/**
 * Any of:
 * - {@link chatFolderInviteLink}
 */
export type ChatFolderInviteLink = chatFolderInviteLink;

/**
 * Version of {@link ChatFolderInviteLink} for method parameters.
 * Any of:
 * - {@link chatFolderInviteLink$Input}
 */
export type ChatFolderInviteLink$Input = chatFolderInviteLink$Input;

/**
 * Any of:
 * - {@link chatFolderInviteLinks}
 */
export type ChatFolderInviteLinks = chatFolderInviteLinks;

/**
 * Version of {@link ChatFolderInviteLinks} for method parameters.
 * Any of:
 * - {@link chatFolderInviteLinks$Input}
 */
export type ChatFolderInviteLinks$Input = chatFolderInviteLinks$Input;

/**
 * Any of:
 * - {@link chatFolderInviteLinkInfo}
 */
export type ChatFolderInviteLinkInfo = chatFolderInviteLinkInfo;

/**
 * Version of {@link ChatFolderInviteLinkInfo} for method parameters.
 * Any of:
 * - {@link chatFolderInviteLinkInfo$Input}
 */
export type ChatFolderInviteLinkInfo$Input = chatFolderInviteLinkInfo$Input;

/**
 * Any of:
 * - {@link recommendedChatFolder}
 */
export type RecommendedChatFolder = recommendedChatFolder;

/**
 * Version of {@link RecommendedChatFolder} for method parameters.
 * Any of:
 * - {@link recommendedChatFolder$Input}
 */
export type RecommendedChatFolder$Input = recommendedChatFolder$Input;

/**
 * Any of:
 * - {@link recommendedChatFolders}
 */
export type RecommendedChatFolders = recommendedChatFolders;

/**
 * Version of {@link RecommendedChatFolders} for method parameters.
 * Any of:
 * - {@link recommendedChatFolders$Input}
 */
export type RecommendedChatFolders$Input = recommendedChatFolders$Input;

/**
 * Any of:
 * - {@link archiveChatListSettings}
 */
export type ArchiveChatListSettings = archiveChatListSettings;

/**
 * Version of {@link ArchiveChatListSettings} for method parameters.
 * Any of:
 * - {@link archiveChatListSettings$Input}
 */
export type ArchiveChatListSettings$Input = archiveChatListSettings$Input;

/**
 * Any of:
 * - {@link chatListMain}
 * - {@link chatListArchive}
 * - {@link chatListFolder}
 */
export type ChatList = chatListMain | chatListArchive | chatListFolder;

/**
 * Version of {@link ChatList} for method parameters.
 * Any of:
 * - {@link chatListMain$Input}
 * - {@link chatListArchive$Input}
 * - {@link chatListFolder$Input}
 */
export type ChatList$Input =
  | chatListMain$Input
  | chatListArchive$Input
  | chatListFolder$Input;

/**
 * Any of:
 * - {@link chatLists}
 */
export type ChatLists = chatLists;

/**
 * Version of {@link ChatLists} for method parameters.
 * Any of:
 * - {@link chatLists$Input}
 */
export type ChatLists$Input = chatLists$Input;

/**
 * Any of:
 * - {@link chatSourceMtprotoProxy}
 * - {@link chatSourcePublicServiceAnnouncement}
 */
export type ChatSource =
  | chatSourceMtprotoProxy
  | chatSourcePublicServiceAnnouncement;

/**
 * Version of {@link ChatSource} for method parameters.
 * Any of:
 * - {@link chatSourceMtprotoProxy$Input}
 * - {@link chatSourcePublicServiceAnnouncement$Input}
 */
export type ChatSource$Input =
  | chatSourceMtprotoProxy$Input
  | chatSourcePublicServiceAnnouncement$Input;

/**
 * Any of:
 * - {@link chatPosition}
 */
export type ChatPosition = chatPosition;

/**
 * Version of {@link ChatPosition} for method parameters.
 * Any of:
 * - {@link chatPosition$Input}
 */
export type ChatPosition$Input = chatPosition$Input;

/**
 * Any of:
 * - {@link chatAvailableReactionsAll}
 * - {@link chatAvailableReactionsSome}
 */
export type ChatAvailableReactions =
  | chatAvailableReactionsAll
  | chatAvailableReactionsSome;

/**
 * Version of {@link ChatAvailableReactions} for method parameters.
 * Any of:
 * - {@link chatAvailableReactionsAll$Input}
 * - {@link chatAvailableReactionsSome$Input}
 */
export type ChatAvailableReactions$Input =
  | chatAvailableReactionsAll$Input
  | chatAvailableReactionsSome$Input;

/**
 * Any of:
 * - {@link videoChat}
 */
export type VideoChat = videoChat;

/**
 * Version of {@link VideoChat} for method parameters.
 * Any of:
 * - {@link videoChat$Input}
 */
export type VideoChat$Input = videoChat$Input;

/**
 * Any of:
 * - {@link chat}
 */
export type Chat = chat;

/**
 * Version of {@link Chat} for method parameters.
 * Any of:
 * - {@link chat$Input}
 */
export type Chat$Input = chat$Input;

/**
 * Any of:
 * - {@link chats}
 */
export type Chats = chats;

/**
 * Version of {@link Chats} for method parameters.
 * Any of:
 * - {@link chats$Input}
 */
export type Chats$Input = chats$Input;

/**
 * Any of:
 * - {@link chatNearby}
 */
export type ChatNearby = chatNearby;

/**
 * Version of {@link ChatNearby} for method parameters.
 * Any of:
 * - {@link chatNearby$Input}
 */
export type ChatNearby$Input = chatNearby$Input;

/**
 * Any of:
 * - {@link chatsNearby}
 */
export type ChatsNearby = chatsNearby;

/**
 * Version of {@link ChatsNearby} for method parameters.
 * Any of:
 * - {@link chatsNearby$Input}
 */
export type ChatsNearby$Input = chatsNearby$Input;

/**
 * Any of:
 * - {@link publicChatTypeHasUsername}
 * - {@link publicChatTypeIsLocationBased}
 */
export type PublicChatType =
  | publicChatTypeHasUsername
  | publicChatTypeIsLocationBased;

/**
 * Version of {@link PublicChatType} for method parameters.
 * Any of:
 * - {@link publicChatTypeHasUsername$Input}
 * - {@link publicChatTypeIsLocationBased$Input}
 */
export type PublicChatType$Input =
  | publicChatTypeHasUsername$Input
  | publicChatTypeIsLocationBased$Input;

/**
 * Any of:
 * - {@link chatActionBarReportSpam}
 * - {@link chatActionBarReportUnrelatedLocation}
 * - {@link chatActionBarInviteMembers}
 * - {@link chatActionBarReportAddBlock}
 * - {@link chatActionBarAddContact}
 * - {@link chatActionBarSharePhoneNumber}
 * - {@link chatActionBarJoinRequest}
 */
export type ChatActionBar =
  | chatActionBarReportSpam
  | chatActionBarReportUnrelatedLocation
  | chatActionBarInviteMembers
  | chatActionBarReportAddBlock
  | chatActionBarAddContact
  | chatActionBarSharePhoneNumber
  | chatActionBarJoinRequest;

/**
 * Version of {@link ChatActionBar} for method parameters.
 * Any of:
 * - {@link chatActionBarReportSpam$Input}
 * - {@link chatActionBarReportUnrelatedLocation$Input}
 * - {@link chatActionBarInviteMembers$Input}
 * - {@link chatActionBarReportAddBlock$Input}
 * - {@link chatActionBarAddContact$Input}
 * - {@link chatActionBarSharePhoneNumber$Input}
 * - {@link chatActionBarJoinRequest$Input}
 */
export type ChatActionBar$Input =
  | chatActionBarReportSpam$Input
  | chatActionBarReportUnrelatedLocation$Input
  | chatActionBarInviteMembers$Input
  | chatActionBarReportAddBlock$Input
  | chatActionBarAddContact$Input
  | chatActionBarSharePhoneNumber$Input
  | chatActionBarJoinRequest$Input;

/**
 * Any of:
 * - {@link keyboardButtonTypeText}
 * - {@link keyboardButtonTypeRequestPhoneNumber}
 * - {@link keyboardButtonTypeRequestLocation}
 * - {@link keyboardButtonTypeRequestPoll}
 * - {@link keyboardButtonTypeRequestUsers}
 * - {@link keyboardButtonTypeRequestChat}
 * - {@link keyboardButtonTypeWebApp}
 */
export type KeyboardButtonType =
  | keyboardButtonTypeText
  | keyboardButtonTypeRequestPhoneNumber
  | keyboardButtonTypeRequestLocation
  | keyboardButtonTypeRequestPoll
  | keyboardButtonTypeRequestUsers
  | keyboardButtonTypeRequestChat
  | keyboardButtonTypeWebApp;

/**
 * Version of {@link KeyboardButtonType} for method parameters.
 * Any of:
 * - {@link keyboardButtonTypeText$Input}
 * - {@link keyboardButtonTypeRequestPhoneNumber$Input}
 * - {@link keyboardButtonTypeRequestLocation$Input}
 * - {@link keyboardButtonTypeRequestPoll$Input}
 * - {@link keyboardButtonTypeRequestUsers$Input}
 * - {@link keyboardButtonTypeRequestChat$Input}
 * - {@link keyboardButtonTypeWebApp$Input}
 */
export type KeyboardButtonType$Input =
  | keyboardButtonTypeText$Input
  | keyboardButtonTypeRequestPhoneNumber$Input
  | keyboardButtonTypeRequestLocation$Input
  | keyboardButtonTypeRequestPoll$Input
  | keyboardButtonTypeRequestUsers$Input
  | keyboardButtonTypeRequestChat$Input
  | keyboardButtonTypeWebApp$Input;

/**
 * Any of:
 * - {@link keyboardButton}
 */
export type KeyboardButton = keyboardButton;

/**
 * Version of {@link KeyboardButton} for method parameters.
 * Any of:
 * - {@link keyboardButton$Input}
 */
export type KeyboardButton$Input = keyboardButton$Input;

/**
 * Any of:
 * - {@link inlineKeyboardButtonTypeUrl}
 * - {@link inlineKeyboardButtonTypeLoginUrl}
 * - {@link inlineKeyboardButtonTypeWebApp}
 * - {@link inlineKeyboardButtonTypeCallback}
 * - {@link inlineKeyboardButtonTypeCallbackWithPassword}
 * - {@link inlineKeyboardButtonTypeCallbackGame}
 * - {@link inlineKeyboardButtonTypeSwitchInline}
 * - {@link inlineKeyboardButtonTypeBuy}
 * - {@link inlineKeyboardButtonTypeUser}
 */
export type InlineKeyboardButtonType =
  | inlineKeyboardButtonTypeUrl
  | inlineKeyboardButtonTypeLoginUrl
  | inlineKeyboardButtonTypeWebApp
  | inlineKeyboardButtonTypeCallback
  | inlineKeyboardButtonTypeCallbackWithPassword
  | inlineKeyboardButtonTypeCallbackGame
  | inlineKeyboardButtonTypeSwitchInline
  | inlineKeyboardButtonTypeBuy
  | inlineKeyboardButtonTypeUser;

/**
 * Version of {@link InlineKeyboardButtonType} for method parameters.
 * Any of:
 * - {@link inlineKeyboardButtonTypeUrl$Input}
 * - {@link inlineKeyboardButtonTypeLoginUrl$Input}
 * - {@link inlineKeyboardButtonTypeWebApp$Input}
 * - {@link inlineKeyboardButtonTypeCallback$Input}
 * - {@link inlineKeyboardButtonTypeCallbackWithPassword$Input}
 * - {@link inlineKeyboardButtonTypeCallbackGame$Input}
 * - {@link inlineKeyboardButtonTypeSwitchInline$Input}
 * - {@link inlineKeyboardButtonTypeBuy$Input}
 * - {@link inlineKeyboardButtonTypeUser$Input}
 */
export type InlineKeyboardButtonType$Input =
  | inlineKeyboardButtonTypeUrl$Input
  | inlineKeyboardButtonTypeLoginUrl$Input
  | inlineKeyboardButtonTypeWebApp$Input
  | inlineKeyboardButtonTypeCallback$Input
  | inlineKeyboardButtonTypeCallbackWithPassword$Input
  | inlineKeyboardButtonTypeCallbackGame$Input
  | inlineKeyboardButtonTypeSwitchInline$Input
  | inlineKeyboardButtonTypeBuy$Input
  | inlineKeyboardButtonTypeUser$Input;

/**
 * Any of:
 * - {@link inlineKeyboardButton}
 */
export type InlineKeyboardButton = inlineKeyboardButton;

/**
 * Version of {@link InlineKeyboardButton} for method parameters.
 * Any of:
 * - {@link inlineKeyboardButton$Input}
 */
export type InlineKeyboardButton$Input = inlineKeyboardButton$Input;

/**
 * Any of:
 * - {@link replyMarkupRemoveKeyboard}
 * - {@link replyMarkupForceReply}
 * - {@link replyMarkupShowKeyboard}
 * - {@link replyMarkupInlineKeyboard}
 */
export type ReplyMarkup =
  | replyMarkupRemoveKeyboard
  | replyMarkupForceReply
  | replyMarkupShowKeyboard
  | replyMarkupInlineKeyboard;

/**
 * Version of {@link ReplyMarkup} for method parameters.
 * Any of:
 * - {@link replyMarkupRemoveKeyboard$Input}
 * - {@link replyMarkupForceReply$Input}
 * - {@link replyMarkupShowKeyboard$Input}
 * - {@link replyMarkupInlineKeyboard$Input}
 */
export type ReplyMarkup$Input =
  | replyMarkupRemoveKeyboard$Input
  | replyMarkupForceReply$Input
  | replyMarkupShowKeyboard$Input
  | replyMarkupInlineKeyboard$Input;

/**
 * Any of:
 * - {@link loginUrlInfoOpen}
 * - {@link loginUrlInfoRequestConfirmation}
 */
export type LoginUrlInfo = loginUrlInfoOpen | loginUrlInfoRequestConfirmation;

/**
 * Version of {@link LoginUrlInfo} for method parameters.
 * Any of:
 * - {@link loginUrlInfoOpen$Input}
 * - {@link loginUrlInfoRequestConfirmation$Input}
 */
export type LoginUrlInfo$Input =
  | loginUrlInfoOpen$Input
  | loginUrlInfoRequestConfirmation$Input;

/**
 * Any of:
 * - {@link foundWebApp}
 */
export type FoundWebApp = foundWebApp;

/**
 * Version of {@link FoundWebApp} for method parameters.
 * Any of:
 * - {@link foundWebApp$Input}
 */
export type FoundWebApp$Input = foundWebApp$Input;

/**
 * Any of:
 * - {@link webAppInfo}
 */
export type WebAppInfo = webAppInfo;

/**
 * Version of {@link WebAppInfo} for method parameters.
 * Any of:
 * - {@link webAppInfo$Input}
 */
export type WebAppInfo$Input = webAppInfo$Input;

/**
 * Any of:
 * - {@link messageThreadInfo}
 */
export type MessageThreadInfo = messageThreadInfo;

/**
 * Version of {@link MessageThreadInfo} for method parameters.
 * Any of:
 * - {@link messageThreadInfo$Input}
 */
export type MessageThreadInfo$Input = messageThreadInfo$Input;

/**
 * Any of:
 * - {@link forumTopicIcon}
 */
export type ForumTopicIcon = forumTopicIcon;

/**
 * Version of {@link ForumTopicIcon} for method parameters.
 * Any of:
 * - {@link forumTopicIcon$Input}
 */
export type ForumTopicIcon$Input = forumTopicIcon$Input;

/**
 * Any of:
 * - {@link forumTopicInfo}
 */
export type ForumTopicInfo = forumTopicInfo;

/**
 * Version of {@link ForumTopicInfo} for method parameters.
 * Any of:
 * - {@link forumTopicInfo$Input}
 */
export type ForumTopicInfo$Input = forumTopicInfo$Input;

/**
 * Any of:
 * - {@link forumTopic}
 */
export type ForumTopic = forumTopic;

/**
 * Version of {@link ForumTopic} for method parameters.
 * Any of:
 * - {@link forumTopic$Input}
 */
export type ForumTopic$Input = forumTopic$Input;

/**
 * Any of:
 * - {@link forumTopics}
 */
export type ForumTopics = forumTopics;

/**
 * Version of {@link ForumTopics} for method parameters.
 * Any of:
 * - {@link forumTopics$Input}
 */
export type ForumTopics$Input = forumTopics$Input;

/**
 * Any of:
 * - {@link linkPreviewOptions}
 */
export type LinkPreviewOptions = linkPreviewOptions;

/**
 * Version of {@link LinkPreviewOptions} for method parameters.
 * Any of:
 * - {@link linkPreviewOptions$Input}
 */
export type LinkPreviewOptions$Input = linkPreviewOptions$Input;

/**
 * Any of:
 * - {@link richTextPlain}
 * - {@link richTextBold}
 * - {@link richTextItalic}
 * - {@link richTextUnderline}
 * - {@link richTextStrikethrough}
 * - {@link richTextFixed}
 * - {@link richTextUrl}
 * - {@link richTextEmailAddress}
 * - {@link richTextSubscript}
 * - {@link richTextSuperscript}
 * - {@link richTextMarked}
 * - {@link richTextPhoneNumber}
 * - {@link richTextIcon}
 * - {@link richTextReference}
 * - {@link richTextAnchor}
 * - {@link richTextAnchorLink}
 * - {@link richTexts}
 */
export type RichText =
  | richTextPlain
  | richTextBold
  | richTextItalic
  | richTextUnderline
  | richTextStrikethrough
  | richTextFixed
  | richTextUrl
  | richTextEmailAddress
  | richTextSubscript
  | richTextSuperscript
  | richTextMarked
  | richTextPhoneNumber
  | richTextIcon
  | richTextReference
  | richTextAnchor
  | richTextAnchorLink
  | richTexts;

/**
 * Version of {@link RichText} for method parameters.
 * Any of:
 * - {@link richTextPlain$Input}
 * - {@link richTextBold$Input}
 * - {@link richTextItalic$Input}
 * - {@link richTextUnderline$Input}
 * - {@link richTextStrikethrough$Input}
 * - {@link richTextFixed$Input}
 * - {@link richTextUrl$Input}
 * - {@link richTextEmailAddress$Input}
 * - {@link richTextSubscript$Input}
 * - {@link richTextSuperscript$Input}
 * - {@link richTextMarked$Input}
 * - {@link richTextPhoneNumber$Input}
 * - {@link richTextIcon$Input}
 * - {@link richTextReference$Input}
 * - {@link richTextAnchor$Input}
 * - {@link richTextAnchorLink$Input}
 * - {@link richTexts$Input}
 */
export type RichText$Input =
  | richTextPlain$Input
  | richTextBold$Input
  | richTextItalic$Input
  | richTextUnderline$Input
  | richTextStrikethrough$Input
  | richTextFixed$Input
  | richTextUrl$Input
  | richTextEmailAddress$Input
  | richTextSubscript$Input
  | richTextSuperscript$Input
  | richTextMarked$Input
  | richTextPhoneNumber$Input
  | richTextIcon$Input
  | richTextReference$Input
  | richTextAnchor$Input
  | richTextAnchorLink$Input
  | richTexts$Input;

/**
 * Any of:
 * - {@link pageBlockCaption}
 */
export type PageBlockCaption = pageBlockCaption;

/**
 * Version of {@link PageBlockCaption} for method parameters.
 * Any of:
 * - {@link pageBlockCaption$Input}
 */
export type PageBlockCaption$Input = pageBlockCaption$Input;

/**
 * Any of:
 * - {@link pageBlockListItem}
 */
export type PageBlockListItem = pageBlockListItem;

/**
 * Version of {@link PageBlockListItem} for method parameters.
 * Any of:
 * - {@link pageBlockListItem$Input}
 */
export type PageBlockListItem$Input = pageBlockListItem$Input;

/**
 * Any of:
 * - {@link pageBlockHorizontalAlignmentLeft}
 * - {@link pageBlockHorizontalAlignmentCenter}
 * - {@link pageBlockHorizontalAlignmentRight}
 */
export type PageBlockHorizontalAlignment =
  | pageBlockHorizontalAlignmentLeft
  | pageBlockHorizontalAlignmentCenter
  | pageBlockHorizontalAlignmentRight;

/**
 * Version of {@link PageBlockHorizontalAlignment} for method parameters.
 * Any of:
 * - {@link pageBlockHorizontalAlignmentLeft$Input}
 * - {@link pageBlockHorizontalAlignmentCenter$Input}
 * - {@link pageBlockHorizontalAlignmentRight$Input}
 */
export type PageBlockHorizontalAlignment$Input =
  | pageBlockHorizontalAlignmentLeft$Input
  | pageBlockHorizontalAlignmentCenter$Input
  | pageBlockHorizontalAlignmentRight$Input;

/**
 * Any of:
 * - {@link pageBlockVerticalAlignmentTop}
 * - {@link pageBlockVerticalAlignmentMiddle}
 * - {@link pageBlockVerticalAlignmentBottom}
 */
export type PageBlockVerticalAlignment =
  | pageBlockVerticalAlignmentTop
  | pageBlockVerticalAlignmentMiddle
  | pageBlockVerticalAlignmentBottom;

/**
 * Version of {@link PageBlockVerticalAlignment} for method parameters.
 * Any of:
 * - {@link pageBlockVerticalAlignmentTop$Input}
 * - {@link pageBlockVerticalAlignmentMiddle$Input}
 * - {@link pageBlockVerticalAlignmentBottom$Input}
 */
export type PageBlockVerticalAlignment$Input =
  | pageBlockVerticalAlignmentTop$Input
  | pageBlockVerticalAlignmentMiddle$Input
  | pageBlockVerticalAlignmentBottom$Input;

/**
 * Any of:
 * - {@link pageBlockTableCell}
 */
export type PageBlockTableCell = pageBlockTableCell;

/**
 * Version of {@link PageBlockTableCell} for method parameters.
 * Any of:
 * - {@link pageBlockTableCell$Input}
 */
export type PageBlockTableCell$Input = pageBlockTableCell$Input;

/**
 * Any of:
 * - {@link pageBlockRelatedArticle}
 */
export type PageBlockRelatedArticle = pageBlockRelatedArticle;

/**
 * Version of {@link PageBlockRelatedArticle} for method parameters.
 * Any of:
 * - {@link pageBlockRelatedArticle$Input}
 */
export type PageBlockRelatedArticle$Input = pageBlockRelatedArticle$Input;

/**
 * Any of:
 * - {@link pageBlockTitle}
 * - {@link pageBlockSubtitle}
 * - {@link pageBlockAuthorDate}
 * - {@link pageBlockHeader}
 * - {@link pageBlockSubheader}
 * - {@link pageBlockKicker}
 * - {@link pageBlockParagraph}
 * - {@link pageBlockPreformatted}
 * - {@link pageBlockFooter}
 * - {@link pageBlockDivider}
 * - {@link pageBlockAnchor}
 * - {@link pageBlockList}
 * - {@link pageBlockBlockQuote}
 * - {@link pageBlockPullQuote}
 * - {@link pageBlockAnimation}
 * - {@link pageBlockAudio}
 * - {@link pageBlockPhoto}
 * - {@link pageBlockVideo}
 * - {@link pageBlockVoiceNote}
 * - {@link pageBlockCover}
 * - {@link pageBlockEmbedded}
 * - {@link pageBlockEmbeddedPost}
 * - {@link pageBlockCollage}
 * - {@link pageBlockSlideshow}
 * - {@link pageBlockChatLink}
 * - {@link pageBlockTable}
 * - {@link pageBlockDetails}
 * - {@link pageBlockRelatedArticles}
 * - {@link pageBlockMap}
 */
export type PageBlock =
  | pageBlockTitle
  | pageBlockSubtitle
  | pageBlockAuthorDate
  | pageBlockHeader
  | pageBlockSubheader
  | pageBlockKicker
  | pageBlockParagraph
  | pageBlockPreformatted
  | pageBlockFooter
  | pageBlockDivider
  | pageBlockAnchor
  | pageBlockList
  | pageBlockBlockQuote
  | pageBlockPullQuote
  | pageBlockAnimation
  | pageBlockAudio
  | pageBlockPhoto
  | pageBlockVideo
  | pageBlockVoiceNote
  | pageBlockCover
  | pageBlockEmbedded
  | pageBlockEmbeddedPost
  | pageBlockCollage
  | pageBlockSlideshow
  | pageBlockChatLink
  | pageBlockTable
  | pageBlockDetails
  | pageBlockRelatedArticles
  | pageBlockMap;

/**
 * Version of {@link PageBlock} for method parameters.
 * Any of:
 * - {@link pageBlockTitle$Input}
 * - {@link pageBlockSubtitle$Input}
 * - {@link pageBlockAuthorDate$Input}
 * - {@link pageBlockHeader$Input}
 * - {@link pageBlockSubheader$Input}
 * - {@link pageBlockKicker$Input}
 * - {@link pageBlockParagraph$Input}
 * - {@link pageBlockPreformatted$Input}
 * - {@link pageBlockFooter$Input}
 * - {@link pageBlockDivider$Input}
 * - {@link pageBlockAnchor$Input}
 * - {@link pageBlockList$Input}
 * - {@link pageBlockBlockQuote$Input}
 * - {@link pageBlockPullQuote$Input}
 * - {@link pageBlockAnimation$Input}
 * - {@link pageBlockAudio$Input}
 * - {@link pageBlockPhoto$Input}
 * - {@link pageBlockVideo$Input}
 * - {@link pageBlockVoiceNote$Input}
 * - {@link pageBlockCover$Input}
 * - {@link pageBlockEmbedded$Input}
 * - {@link pageBlockEmbeddedPost$Input}
 * - {@link pageBlockCollage$Input}
 * - {@link pageBlockSlideshow$Input}
 * - {@link pageBlockChatLink$Input}
 * - {@link pageBlockTable$Input}
 * - {@link pageBlockDetails$Input}
 * - {@link pageBlockRelatedArticles$Input}
 * - {@link pageBlockMap$Input}
 */
export type PageBlock$Input =
  | pageBlockTitle$Input
  | pageBlockSubtitle$Input
  | pageBlockAuthorDate$Input
  | pageBlockHeader$Input
  | pageBlockSubheader$Input
  | pageBlockKicker$Input
  | pageBlockParagraph$Input
  | pageBlockPreformatted$Input
  | pageBlockFooter$Input
  | pageBlockDivider$Input
  | pageBlockAnchor$Input
  | pageBlockList$Input
  | pageBlockBlockQuote$Input
  | pageBlockPullQuote$Input
  | pageBlockAnimation$Input
  | pageBlockAudio$Input
  | pageBlockPhoto$Input
  | pageBlockVideo$Input
  | pageBlockVoiceNote$Input
  | pageBlockCover$Input
  | pageBlockEmbedded$Input
  | pageBlockEmbeddedPost$Input
  | pageBlockCollage$Input
  | pageBlockSlideshow$Input
  | pageBlockChatLink$Input
  | pageBlockTable$Input
  | pageBlockDetails$Input
  | pageBlockRelatedArticles$Input
  | pageBlockMap$Input;

/**
 * Any of:
 * - {@link webPageInstantView}
 */
export type WebPageInstantView = webPageInstantView;

/**
 * Version of {@link WebPageInstantView} for method parameters.
 * Any of:
 * - {@link webPageInstantView$Input}
 */
export type WebPageInstantView$Input = webPageInstantView$Input;

/**
 * Any of:
 * - {@link webPage}
 */
export type WebPage = webPage;

/**
 * Version of {@link WebPage} for method parameters.
 * Any of:
 * - {@link webPage$Input}
 */
export type WebPage$Input = webPage$Input;

/**
 * Any of:
 * - {@link countryInfo}
 */
export type CountryInfo = countryInfo;

/**
 * Version of {@link CountryInfo} for method parameters.
 * Any of:
 * - {@link countryInfo$Input}
 */
export type CountryInfo$Input = countryInfo$Input;

/**
 * Any of:
 * - {@link countries}
 */
export type Countries = countries;

/**
 * Version of {@link Countries} for method parameters.
 * Any of:
 * - {@link countries$Input}
 */
export type Countries$Input = countries$Input;

/**
 * Any of:
 * - {@link phoneNumberInfo}
 */
export type PhoneNumberInfo = phoneNumberInfo;

/**
 * Version of {@link PhoneNumberInfo} for method parameters.
 * Any of:
 * - {@link phoneNumberInfo$Input}
 */
export type PhoneNumberInfo$Input = phoneNumberInfo$Input;

/**
 * Any of:
 * - {@link bankCardActionOpenUrl}
 */
export type BankCardActionOpenUrl = bankCardActionOpenUrl;

/**
 * Version of {@link BankCardActionOpenUrl} for method parameters.
 * Any of:
 * - {@link bankCardActionOpenUrl$Input}
 */
export type BankCardActionOpenUrl$Input = bankCardActionOpenUrl$Input;

/**
 * Any of:
 * - {@link bankCardInfo}
 */
export type BankCardInfo = bankCardInfo;

/**
 * Version of {@link BankCardInfo} for method parameters.
 * Any of:
 * - {@link bankCardInfo$Input}
 */
export type BankCardInfo$Input = bankCardInfo$Input;

/**
 * Any of:
 * - {@link address}
 */
export type Address = address;

/**
 * Version of {@link Address} for method parameters.
 * Any of:
 * - {@link address$Input}
 */
export type Address$Input = address$Input;

/**
 * Any of:
 * - {@link themeParameters}
 */
export type ThemeParameters = themeParameters;

/**
 * Version of {@link ThemeParameters} for method parameters.
 * Any of:
 * - {@link themeParameters$Input}
 */
export type ThemeParameters$Input = themeParameters$Input;

/**
 * Any of:
 * - {@link labeledPricePart}
 */
export type LabeledPricePart = labeledPricePart;

/**
 * Version of {@link LabeledPricePart} for method parameters.
 * Any of:
 * - {@link labeledPricePart$Input}
 */
export type LabeledPricePart$Input = labeledPricePart$Input;

/**
 * Any of:
 * - {@link invoice}
 */
export type Invoice = invoice;

/**
 * Version of {@link Invoice} for method parameters.
 * Any of:
 * - {@link invoice$Input}
 */
export type Invoice$Input = invoice$Input;

/**
 * Any of:
 * - {@link orderInfo}
 */
export type OrderInfo = orderInfo;

/**
 * Version of {@link OrderInfo} for method parameters.
 * Any of:
 * - {@link orderInfo$Input}
 */
export type OrderInfo$Input = orderInfo$Input;

/**
 * Any of:
 * - {@link shippingOption}
 */
export type ShippingOption = shippingOption;

/**
 * Version of {@link ShippingOption} for method parameters.
 * Any of:
 * - {@link shippingOption$Input}
 */
export type ShippingOption$Input = shippingOption$Input;

/**
 * Any of:
 * - {@link savedCredentials}
 */
export type SavedCredentials = savedCredentials;

/**
 * Version of {@link SavedCredentials} for method parameters.
 * Any of:
 * - {@link savedCredentials$Input}
 */
export type SavedCredentials$Input = savedCredentials$Input;

/**
 * Any of:
 * - {@link inputCredentialsSaved}
 * - {@link inputCredentialsNew}
 * - {@link inputCredentialsApplePay}
 * - {@link inputCredentialsGooglePay}
 */
export type InputCredentials =
  | inputCredentialsSaved
  | inputCredentialsNew
  | inputCredentialsApplePay
  | inputCredentialsGooglePay;

/**
 * Version of {@link InputCredentials} for method parameters.
 * Any of:
 * - {@link inputCredentialsSaved$Input}
 * - {@link inputCredentialsNew$Input}
 * - {@link inputCredentialsApplePay$Input}
 * - {@link inputCredentialsGooglePay$Input}
 */
export type InputCredentials$Input =
  | inputCredentialsSaved$Input
  | inputCredentialsNew$Input
  | inputCredentialsApplePay$Input
  | inputCredentialsGooglePay$Input;

/**
 * Any of:
 * - {@link paymentProviderSmartGlocal}
 * - {@link paymentProviderStripe}
 * - {@link paymentProviderOther}
 */
export type PaymentProvider =
  | paymentProviderSmartGlocal
  | paymentProviderStripe
  | paymentProviderOther;

/**
 * Version of {@link PaymentProvider} for method parameters.
 * Any of:
 * - {@link paymentProviderSmartGlocal$Input}
 * - {@link paymentProviderStripe$Input}
 * - {@link paymentProviderOther$Input}
 */
export type PaymentProvider$Input =
  | paymentProviderSmartGlocal$Input
  | paymentProviderStripe$Input
  | paymentProviderOther$Input;

/**
 * Any of:
 * - {@link paymentOption}
 */
export type PaymentOption = paymentOption;

/**
 * Version of {@link PaymentOption} for method parameters.
 * Any of:
 * - {@link paymentOption$Input}
 */
export type PaymentOption$Input = paymentOption$Input;

/**
 * Any of:
 * - {@link paymentForm}
 */
export type PaymentForm = paymentForm;

/**
 * Version of {@link PaymentForm} for method parameters.
 * Any of:
 * - {@link paymentForm$Input}
 */
export type PaymentForm$Input = paymentForm$Input;

/**
 * Any of:
 * - {@link validatedOrderInfo}
 */
export type ValidatedOrderInfo = validatedOrderInfo;

/**
 * Version of {@link ValidatedOrderInfo} for method parameters.
 * Any of:
 * - {@link validatedOrderInfo$Input}
 */
export type ValidatedOrderInfo$Input = validatedOrderInfo$Input;

/**
 * Any of:
 * - {@link paymentResult}
 */
export type PaymentResult = paymentResult;

/**
 * Version of {@link PaymentResult} for method parameters.
 * Any of:
 * - {@link paymentResult$Input}
 */
export type PaymentResult$Input = paymentResult$Input;

/**
 * Any of:
 * - {@link paymentReceipt}
 */
export type PaymentReceipt = paymentReceipt;

/**
 * Version of {@link PaymentReceipt} for method parameters.
 * Any of:
 * - {@link paymentReceipt$Input}
 */
export type PaymentReceipt$Input = paymentReceipt$Input;

/**
 * Any of:
 * - {@link inputInvoiceMessage}
 * - {@link inputInvoiceName}
 * - {@link inputInvoiceTelegram}
 */
export type InputInvoice =
  | inputInvoiceMessage
  | inputInvoiceName
  | inputInvoiceTelegram;

/**
 * Version of {@link InputInvoice} for method parameters.
 * Any of:
 * - {@link inputInvoiceMessage$Input}
 * - {@link inputInvoiceName$Input}
 * - {@link inputInvoiceTelegram$Input}
 */
export type InputInvoice$Input =
  | inputInvoiceMessage$Input
  | inputInvoiceName$Input
  | inputInvoiceTelegram$Input;

/**
 * Any of:
 * - {@link messageExtendedMediaPreview}
 * - {@link messageExtendedMediaPhoto}
 * - {@link messageExtendedMediaVideo}
 * - {@link messageExtendedMediaUnsupported}
 */
export type MessageExtendedMedia =
  | messageExtendedMediaPreview
  | messageExtendedMediaPhoto
  | messageExtendedMediaVideo
  | messageExtendedMediaUnsupported;

/**
 * Version of {@link MessageExtendedMedia} for method parameters.
 * Any of:
 * - {@link messageExtendedMediaPreview$Input}
 * - {@link messageExtendedMediaPhoto$Input}
 * - {@link messageExtendedMediaVideo$Input}
 * - {@link messageExtendedMediaUnsupported$Input}
 */
export type MessageExtendedMedia$Input =
  | messageExtendedMediaPreview$Input
  | messageExtendedMediaPhoto$Input
  | messageExtendedMediaVideo$Input
  | messageExtendedMediaUnsupported$Input;

/**
 * Any of:
 * - {@link premiumGiveawayParameters}
 */
export type PremiumGiveawayParameters = premiumGiveawayParameters;

/**
 * Version of {@link PremiumGiveawayParameters} for method parameters.
 * Any of:
 * - {@link premiumGiveawayParameters$Input}
 */
export type PremiumGiveawayParameters$Input = premiumGiveawayParameters$Input;

/**
 * Any of:
 * - {@link datedFile}
 */
export type DatedFile = datedFile;

/**
 * Version of {@link DatedFile} for method parameters.
 * Any of:
 * - {@link datedFile$Input}
 */
export type DatedFile$Input = datedFile$Input;

/**
 * Any of:
 * - {@link passportElementTypePersonalDetails}
 * - {@link passportElementTypePassport}
 * - {@link passportElementTypeDriverLicense}
 * - {@link passportElementTypeIdentityCard}
 * - {@link passportElementTypeInternalPassport}
 * - {@link passportElementTypeAddress}
 * - {@link passportElementTypeUtilityBill}
 * - {@link passportElementTypeBankStatement}
 * - {@link passportElementTypeRentalAgreement}
 * - {@link passportElementTypePassportRegistration}
 * - {@link passportElementTypeTemporaryRegistration}
 * - {@link passportElementTypePhoneNumber}
 * - {@link passportElementTypeEmailAddress}
 */
export type PassportElementType =
  | passportElementTypePersonalDetails
  | passportElementTypePassport
  | passportElementTypeDriverLicense
  | passportElementTypeIdentityCard
  | passportElementTypeInternalPassport
  | passportElementTypeAddress
  | passportElementTypeUtilityBill
  | passportElementTypeBankStatement
  | passportElementTypeRentalAgreement
  | passportElementTypePassportRegistration
  | passportElementTypeTemporaryRegistration
  | passportElementTypePhoneNumber
  | passportElementTypeEmailAddress;

/**
 * Version of {@link PassportElementType} for method parameters.
 * Any of:
 * - {@link passportElementTypePersonalDetails$Input}
 * - {@link passportElementTypePassport$Input}
 * - {@link passportElementTypeDriverLicense$Input}
 * - {@link passportElementTypeIdentityCard$Input}
 * - {@link passportElementTypeInternalPassport$Input}
 * - {@link passportElementTypeAddress$Input}
 * - {@link passportElementTypeUtilityBill$Input}
 * - {@link passportElementTypeBankStatement$Input}
 * - {@link passportElementTypeRentalAgreement$Input}
 * - {@link passportElementTypePassportRegistration$Input}
 * - {@link passportElementTypeTemporaryRegistration$Input}
 * - {@link passportElementTypePhoneNumber$Input}
 * - {@link passportElementTypeEmailAddress$Input}
 */
export type PassportElementType$Input =
  | passportElementTypePersonalDetails$Input
  | passportElementTypePassport$Input
  | passportElementTypeDriverLicense$Input
  | passportElementTypeIdentityCard$Input
  | passportElementTypeInternalPassport$Input
  | passportElementTypeAddress$Input
  | passportElementTypeUtilityBill$Input
  | passportElementTypeBankStatement$Input
  | passportElementTypeRentalAgreement$Input
  | passportElementTypePassportRegistration$Input
  | passportElementTypeTemporaryRegistration$Input
  | passportElementTypePhoneNumber$Input
  | passportElementTypeEmailAddress$Input;

/**
 * Any of:
 * - {@link date}
 */
export type Date = date;

/**
 * Version of {@link Date} for method parameters.
 * Any of:
 * - {@link date$Input}
 */
export type Date$Input = date$Input;

/**
 * Any of:
 * - {@link personalDetails}
 */
export type PersonalDetails = personalDetails;

/**
 * Version of {@link PersonalDetails} for method parameters.
 * Any of:
 * - {@link personalDetails$Input}
 */
export type PersonalDetails$Input = personalDetails$Input;

/**
 * Any of:
 * - {@link identityDocument}
 */
export type IdentityDocument = identityDocument;

/**
 * Version of {@link IdentityDocument} for method parameters.
 * Any of:
 * - {@link identityDocument$Input}
 */
export type IdentityDocument$Input = identityDocument$Input;

/**
 * Any of:
 * - {@link inputIdentityDocument}
 */
export type InputIdentityDocument = inputIdentityDocument;

/**
 * Version of {@link InputIdentityDocument} for method parameters.
 * Any of:
 * - {@link inputIdentityDocument$Input}
 */
export type InputIdentityDocument$Input = inputIdentityDocument$Input;

/**
 * Any of:
 * - {@link personalDocument}
 */
export type PersonalDocument = personalDocument;

/**
 * Version of {@link PersonalDocument} for method parameters.
 * Any of:
 * - {@link personalDocument$Input}
 */
export type PersonalDocument$Input = personalDocument$Input;

/**
 * Any of:
 * - {@link inputPersonalDocument}
 */
export type InputPersonalDocument = inputPersonalDocument;

/**
 * Version of {@link InputPersonalDocument} for method parameters.
 * Any of:
 * - {@link inputPersonalDocument$Input}
 */
export type InputPersonalDocument$Input = inputPersonalDocument$Input;

/**
 * Any of:
 * - {@link passportElementPersonalDetails}
 * - {@link passportElementPassport}
 * - {@link passportElementDriverLicense}
 * - {@link passportElementIdentityCard}
 * - {@link passportElementInternalPassport}
 * - {@link passportElementAddress}
 * - {@link passportElementUtilityBill}
 * - {@link passportElementBankStatement}
 * - {@link passportElementRentalAgreement}
 * - {@link passportElementPassportRegistration}
 * - {@link passportElementTemporaryRegistration}
 * - {@link passportElementPhoneNumber}
 * - {@link passportElementEmailAddress}
 */
export type PassportElement =
  | passportElementPersonalDetails
  | passportElementPassport
  | passportElementDriverLicense
  | passportElementIdentityCard
  | passportElementInternalPassport
  | passportElementAddress
  | passportElementUtilityBill
  | passportElementBankStatement
  | passportElementRentalAgreement
  | passportElementPassportRegistration
  | passportElementTemporaryRegistration
  | passportElementPhoneNumber
  | passportElementEmailAddress;

/**
 * Version of {@link PassportElement} for method parameters.
 * Any of:
 * - {@link passportElementPersonalDetails$Input}
 * - {@link passportElementPassport$Input}
 * - {@link passportElementDriverLicense$Input}
 * - {@link passportElementIdentityCard$Input}
 * - {@link passportElementInternalPassport$Input}
 * - {@link passportElementAddress$Input}
 * - {@link passportElementUtilityBill$Input}
 * - {@link passportElementBankStatement$Input}
 * - {@link passportElementRentalAgreement$Input}
 * - {@link passportElementPassportRegistration$Input}
 * - {@link passportElementTemporaryRegistration$Input}
 * - {@link passportElementPhoneNumber$Input}
 * - {@link passportElementEmailAddress$Input}
 */
export type PassportElement$Input =
  | passportElementPersonalDetails$Input
  | passportElementPassport$Input
  | passportElementDriverLicense$Input
  | passportElementIdentityCard$Input
  | passportElementInternalPassport$Input
  | passportElementAddress$Input
  | passportElementUtilityBill$Input
  | passportElementBankStatement$Input
  | passportElementRentalAgreement$Input
  | passportElementPassportRegistration$Input
  | passportElementTemporaryRegistration$Input
  | passportElementPhoneNumber$Input
  | passportElementEmailAddress$Input;

/**
 * Any of:
 * - {@link inputPassportElementPersonalDetails}
 * - {@link inputPassportElementPassport}
 * - {@link inputPassportElementDriverLicense}
 * - {@link inputPassportElementIdentityCard}
 * - {@link inputPassportElementInternalPassport}
 * - {@link inputPassportElementAddress}
 * - {@link inputPassportElementUtilityBill}
 * - {@link inputPassportElementBankStatement}
 * - {@link inputPassportElementRentalAgreement}
 * - {@link inputPassportElementPassportRegistration}
 * - {@link inputPassportElementTemporaryRegistration}
 * - {@link inputPassportElementPhoneNumber}
 * - {@link inputPassportElementEmailAddress}
 */
export type InputPassportElement =
  | inputPassportElementPersonalDetails
  | inputPassportElementPassport
  | inputPassportElementDriverLicense
  | inputPassportElementIdentityCard
  | inputPassportElementInternalPassport
  | inputPassportElementAddress
  | inputPassportElementUtilityBill
  | inputPassportElementBankStatement
  | inputPassportElementRentalAgreement
  | inputPassportElementPassportRegistration
  | inputPassportElementTemporaryRegistration
  | inputPassportElementPhoneNumber
  | inputPassportElementEmailAddress;

/**
 * Version of {@link InputPassportElement} for method parameters.
 * Any of:
 * - {@link inputPassportElementPersonalDetails$Input}
 * - {@link inputPassportElementPassport$Input}
 * - {@link inputPassportElementDriverLicense$Input}
 * - {@link inputPassportElementIdentityCard$Input}
 * - {@link inputPassportElementInternalPassport$Input}
 * - {@link inputPassportElementAddress$Input}
 * - {@link inputPassportElementUtilityBill$Input}
 * - {@link inputPassportElementBankStatement$Input}
 * - {@link inputPassportElementRentalAgreement$Input}
 * - {@link inputPassportElementPassportRegistration$Input}
 * - {@link inputPassportElementTemporaryRegistration$Input}
 * - {@link inputPassportElementPhoneNumber$Input}
 * - {@link inputPassportElementEmailAddress$Input}
 */
export type InputPassportElement$Input =
  | inputPassportElementPersonalDetails$Input
  | inputPassportElementPassport$Input
  | inputPassportElementDriverLicense$Input
  | inputPassportElementIdentityCard$Input
  | inputPassportElementInternalPassport$Input
  | inputPassportElementAddress$Input
  | inputPassportElementUtilityBill$Input
  | inputPassportElementBankStatement$Input
  | inputPassportElementRentalAgreement$Input
  | inputPassportElementPassportRegistration$Input
  | inputPassportElementTemporaryRegistration$Input
  | inputPassportElementPhoneNumber$Input
  | inputPassportElementEmailAddress$Input;

/**
 * Any of:
 * - {@link passportElements}
 */
export type PassportElements = passportElements;

/**
 * Version of {@link PassportElements} for method parameters.
 * Any of:
 * - {@link passportElements$Input}
 */
export type PassportElements$Input = passportElements$Input;

/**
 * Any of:
 * - {@link passportElementErrorSourceUnspecified}
 * - {@link passportElementErrorSourceDataField}
 * - {@link passportElementErrorSourceFrontSide}
 * - {@link passportElementErrorSourceReverseSide}
 * - {@link passportElementErrorSourceSelfie}
 * - {@link passportElementErrorSourceTranslationFile}
 * - {@link passportElementErrorSourceTranslationFiles}
 * - {@link passportElementErrorSourceFile}
 * - {@link passportElementErrorSourceFiles}
 */
export type PassportElementErrorSource =
  | passportElementErrorSourceUnspecified
  | passportElementErrorSourceDataField
  | passportElementErrorSourceFrontSide
  | passportElementErrorSourceReverseSide
  | passportElementErrorSourceSelfie
  | passportElementErrorSourceTranslationFile
  | passportElementErrorSourceTranslationFiles
  | passportElementErrorSourceFile
  | passportElementErrorSourceFiles;

/**
 * Version of {@link PassportElementErrorSource} for method parameters.
 * Any of:
 * - {@link passportElementErrorSourceUnspecified$Input}
 * - {@link passportElementErrorSourceDataField$Input}
 * - {@link passportElementErrorSourceFrontSide$Input}
 * - {@link passportElementErrorSourceReverseSide$Input}
 * - {@link passportElementErrorSourceSelfie$Input}
 * - {@link passportElementErrorSourceTranslationFile$Input}
 * - {@link passportElementErrorSourceTranslationFiles$Input}
 * - {@link passportElementErrorSourceFile$Input}
 * - {@link passportElementErrorSourceFiles$Input}
 */
export type PassportElementErrorSource$Input =
  | passportElementErrorSourceUnspecified$Input
  | passportElementErrorSourceDataField$Input
  | passportElementErrorSourceFrontSide$Input
  | passportElementErrorSourceReverseSide$Input
  | passportElementErrorSourceSelfie$Input
  | passportElementErrorSourceTranslationFile$Input
  | passportElementErrorSourceTranslationFiles$Input
  | passportElementErrorSourceFile$Input
  | passportElementErrorSourceFiles$Input;

/**
 * Any of:
 * - {@link passportElementError}
 */
export type PassportElementError = passportElementError;

/**
 * Version of {@link PassportElementError} for method parameters.
 * Any of:
 * - {@link passportElementError$Input}
 */
export type PassportElementError$Input = passportElementError$Input;

/**
 * Any of:
 * - {@link passportSuitableElement}
 */
export type PassportSuitableElement = passportSuitableElement;

/**
 * Version of {@link PassportSuitableElement} for method parameters.
 * Any of:
 * - {@link passportSuitableElement$Input}
 */
export type PassportSuitableElement$Input = passportSuitableElement$Input;

/**
 * Any of:
 * - {@link passportRequiredElement}
 */
export type PassportRequiredElement = passportRequiredElement;

/**
 * Version of {@link PassportRequiredElement} for method parameters.
 * Any of:
 * - {@link passportRequiredElement$Input}
 */
export type PassportRequiredElement$Input = passportRequiredElement$Input;

/**
 * Any of:
 * - {@link passportAuthorizationForm}
 */
export type PassportAuthorizationForm = passportAuthorizationForm;

/**
 * Version of {@link PassportAuthorizationForm} for method parameters.
 * Any of:
 * - {@link passportAuthorizationForm$Input}
 */
export type PassportAuthorizationForm$Input = passportAuthorizationForm$Input;

/**
 * Any of:
 * - {@link passportElementsWithErrors}
 */
export type PassportElementsWithErrors = passportElementsWithErrors;

/**
 * Version of {@link PassportElementsWithErrors} for method parameters.
 * Any of:
 * - {@link passportElementsWithErrors$Input}
 */
export type PassportElementsWithErrors$Input = passportElementsWithErrors$Input;

/**
 * Any of:
 * - {@link encryptedCredentials}
 */
export type EncryptedCredentials = encryptedCredentials;

/**
 * Version of {@link EncryptedCredentials} for method parameters.
 * Any of:
 * - {@link encryptedCredentials$Input}
 */
export type EncryptedCredentials$Input = encryptedCredentials$Input;

/**
 * Any of:
 * - {@link encryptedPassportElement}
 */
export type EncryptedPassportElement = encryptedPassportElement;

/**
 * Version of {@link EncryptedPassportElement} for method parameters.
 * Any of:
 * - {@link encryptedPassportElement$Input}
 */
export type EncryptedPassportElement$Input = encryptedPassportElement$Input;

/**
 * Any of:
 * - {@link inputPassportElementErrorSourceUnspecified}
 * - {@link inputPassportElementErrorSourceDataField}
 * - {@link inputPassportElementErrorSourceFrontSide}
 * - {@link inputPassportElementErrorSourceReverseSide}
 * - {@link inputPassportElementErrorSourceSelfie}
 * - {@link inputPassportElementErrorSourceTranslationFile}
 * - {@link inputPassportElementErrorSourceTranslationFiles}
 * - {@link inputPassportElementErrorSourceFile}
 * - {@link inputPassportElementErrorSourceFiles}
 */
export type InputPassportElementErrorSource =
  | inputPassportElementErrorSourceUnspecified
  | inputPassportElementErrorSourceDataField
  | inputPassportElementErrorSourceFrontSide
  | inputPassportElementErrorSourceReverseSide
  | inputPassportElementErrorSourceSelfie
  | inputPassportElementErrorSourceTranslationFile
  | inputPassportElementErrorSourceTranslationFiles
  | inputPassportElementErrorSourceFile
  | inputPassportElementErrorSourceFiles;

/**
 * Version of {@link InputPassportElementErrorSource} for method parameters.
 * Any of:
 * - {@link inputPassportElementErrorSourceUnspecified$Input}
 * - {@link inputPassportElementErrorSourceDataField$Input}
 * - {@link inputPassportElementErrorSourceFrontSide$Input}
 * - {@link inputPassportElementErrorSourceReverseSide$Input}
 * - {@link inputPassportElementErrorSourceSelfie$Input}
 * - {@link inputPassportElementErrorSourceTranslationFile$Input}
 * - {@link inputPassportElementErrorSourceTranslationFiles$Input}
 * - {@link inputPassportElementErrorSourceFile$Input}
 * - {@link inputPassportElementErrorSourceFiles$Input}
 */
export type InputPassportElementErrorSource$Input =
  | inputPassportElementErrorSourceUnspecified$Input
  | inputPassportElementErrorSourceDataField$Input
  | inputPassportElementErrorSourceFrontSide$Input
  | inputPassportElementErrorSourceReverseSide$Input
  | inputPassportElementErrorSourceSelfie$Input
  | inputPassportElementErrorSourceTranslationFile$Input
  | inputPassportElementErrorSourceTranslationFiles$Input
  | inputPassportElementErrorSourceFile$Input
  | inputPassportElementErrorSourceFiles$Input;

/**
 * Any of:
 * - {@link inputPassportElementError}
 */
export type InputPassportElementError = inputPassportElementError;

/**
 * Version of {@link InputPassportElementError} for method parameters.
 * Any of:
 * - {@link inputPassportElementError$Input}
 */
export type InputPassportElementError$Input = inputPassportElementError$Input;

/**
 * Any of:
 * - {@link messageText}
 * - {@link messageAnimation}
 * - {@link messageAudio}
 * - {@link messageDocument}
 * - {@link messagePhoto}
 * - {@link messageExpiredPhoto}
 * - {@link messageSticker}
 * - {@link messageVideo}
 * - {@link messageExpiredVideo}
 * - {@link messageVideoNote}
 * - {@link messageVoiceNote}
 * - {@link messageLocation}
 * - {@link messageVenue}
 * - {@link messageContact}
 * - {@link messageAnimatedEmoji}
 * - {@link messageDice}
 * - {@link messageGame}
 * - {@link messagePoll}
 * - {@link messageStory}
 * - {@link messageInvoice}
 * - {@link messageCall}
 * - {@link messageVideoChatScheduled}
 * - {@link messageVideoChatStarted}
 * - {@link messageVideoChatEnded}
 * - {@link messageInviteVideoChatParticipants}
 * - {@link messageBasicGroupChatCreate}
 * - {@link messageSupergroupChatCreate}
 * - {@link messageChatChangeTitle}
 * - {@link messageChatChangePhoto}
 * - {@link messageChatDeletePhoto}
 * - {@link messageChatAddMembers}
 * - {@link messageChatJoinByLink}
 * - {@link messageChatJoinByRequest}
 * - {@link messageChatDeleteMember}
 * - {@link messageChatUpgradeTo}
 * - {@link messageChatUpgradeFrom}
 * - {@link messagePinMessage}
 * - {@link messageScreenshotTaken}
 * - {@link messageChatSetBackground}
 * - {@link messageChatSetTheme}
 * - {@link messageChatSetMessageAutoDeleteTime}
 * - {@link messageForumTopicCreated}
 * - {@link messageForumTopicEdited}
 * - {@link messageForumTopicIsClosedToggled}
 * - {@link messageForumTopicIsHiddenToggled}
 * - {@link messageSuggestProfilePhoto}
 * - {@link messageCustomServiceAction}
 * - {@link messageGameScore}
 * - {@link messagePaymentSuccessful}
 * - {@link messagePaymentSuccessfulBot}
 * - {@link messageGiftedPremium}
 * - {@link messagePremiumGiftCode}
 * - {@link messagePremiumGiveawayCreated}
 * - {@link messagePremiumGiveaway}
 * - {@link messagePremiumGiveawayCompleted}
 * - {@link messagePremiumGiveawayWinners}
 * - {@link messageContactRegistered}
 * - {@link messageUsersShared}
 * - {@link messageChatShared}
 * - {@link messageBotWriteAccessAllowed}
 * - {@link messageWebAppDataSent}
 * - {@link messageWebAppDataReceived}
 * - {@link messagePassportDataSent}
 * - {@link messagePassportDataReceived}
 * - {@link messageProximityAlertTriggered}
 * - {@link messageUnsupported}
 */
export type MessageContent =
  | messageText
  | messageAnimation
  | messageAudio
  | messageDocument
  | messagePhoto
  | messageExpiredPhoto
  | messageSticker
  | messageVideo
  | messageExpiredVideo
  | messageVideoNote
  | messageVoiceNote
  | messageLocation
  | messageVenue
  | messageContact
  | messageAnimatedEmoji
  | messageDice
  | messageGame
  | messagePoll
  | messageStory
  | messageInvoice
  | messageCall
  | messageVideoChatScheduled
  | messageVideoChatStarted
  | messageVideoChatEnded
  | messageInviteVideoChatParticipants
  | messageBasicGroupChatCreate
  | messageSupergroupChatCreate
  | messageChatChangeTitle
  | messageChatChangePhoto
  | messageChatDeletePhoto
  | messageChatAddMembers
  | messageChatJoinByLink
  | messageChatJoinByRequest
  | messageChatDeleteMember
  | messageChatUpgradeTo
  | messageChatUpgradeFrom
  | messagePinMessage
  | messageScreenshotTaken
  | messageChatSetBackground
  | messageChatSetTheme
  | messageChatSetMessageAutoDeleteTime
  | messageForumTopicCreated
  | messageForumTopicEdited
  | messageForumTopicIsClosedToggled
  | messageForumTopicIsHiddenToggled
  | messageSuggestProfilePhoto
  | messageCustomServiceAction
  | messageGameScore
  | messagePaymentSuccessful
  | messagePaymentSuccessfulBot
  | messageGiftedPremium
  | messagePremiumGiftCode
  | messagePremiumGiveawayCreated
  | messagePremiumGiveaway
  | messagePremiumGiveawayCompleted
  | messagePremiumGiveawayWinners
  | messageContactRegistered
  | messageUsersShared
  | messageChatShared
  | messageBotWriteAccessAllowed
  | messageWebAppDataSent
  | messageWebAppDataReceived
  | messagePassportDataSent
  | messagePassportDataReceived
  | messageProximityAlertTriggered
  | messageUnsupported;

/**
 * Version of {@link MessageContent} for method parameters.
 * Any of:
 * - {@link messageText$Input}
 * - {@link messageAnimation$Input}
 * - {@link messageAudio$Input}
 * - {@link messageDocument$Input}
 * - {@link messagePhoto$Input}
 * - {@link messageExpiredPhoto$Input}
 * - {@link messageSticker$Input}
 * - {@link messageVideo$Input}
 * - {@link messageExpiredVideo$Input}
 * - {@link messageVideoNote$Input}
 * - {@link messageVoiceNote$Input}
 * - {@link messageLocation$Input}
 * - {@link messageVenue$Input}
 * - {@link messageContact$Input}
 * - {@link messageAnimatedEmoji$Input}
 * - {@link messageDice$Input}
 * - {@link messageGame$Input}
 * - {@link messagePoll$Input}
 * - {@link messageStory$Input}
 * - {@link messageInvoice$Input}
 * - {@link messageCall$Input}
 * - {@link messageVideoChatScheduled$Input}
 * - {@link messageVideoChatStarted$Input}
 * - {@link messageVideoChatEnded$Input}
 * - {@link messageInviteVideoChatParticipants$Input}
 * - {@link messageBasicGroupChatCreate$Input}
 * - {@link messageSupergroupChatCreate$Input}
 * - {@link messageChatChangeTitle$Input}
 * - {@link messageChatChangePhoto$Input}
 * - {@link messageChatDeletePhoto$Input}
 * - {@link messageChatAddMembers$Input}
 * - {@link messageChatJoinByLink$Input}
 * - {@link messageChatJoinByRequest$Input}
 * - {@link messageChatDeleteMember$Input}
 * - {@link messageChatUpgradeTo$Input}
 * - {@link messageChatUpgradeFrom$Input}
 * - {@link messagePinMessage$Input}
 * - {@link messageScreenshotTaken$Input}
 * - {@link messageChatSetBackground$Input}
 * - {@link messageChatSetTheme$Input}
 * - {@link messageChatSetMessageAutoDeleteTime$Input}
 * - {@link messageForumTopicCreated$Input}
 * - {@link messageForumTopicEdited$Input}
 * - {@link messageForumTopicIsClosedToggled$Input}
 * - {@link messageForumTopicIsHiddenToggled$Input}
 * - {@link messageSuggestProfilePhoto$Input}
 * - {@link messageCustomServiceAction$Input}
 * - {@link messageGameScore$Input}
 * - {@link messagePaymentSuccessful$Input}
 * - {@link messagePaymentSuccessfulBot$Input}
 * - {@link messageGiftedPremium$Input}
 * - {@link messagePremiumGiftCode$Input}
 * - {@link messagePremiumGiveawayCreated$Input}
 * - {@link messagePremiumGiveaway$Input}
 * - {@link messagePremiumGiveawayCompleted$Input}
 * - {@link messagePremiumGiveawayWinners$Input}
 * - {@link messageContactRegistered$Input}
 * - {@link messageUsersShared$Input}
 * - {@link messageChatShared$Input}
 * - {@link messageBotWriteAccessAllowed$Input}
 * - {@link messageWebAppDataSent$Input}
 * - {@link messageWebAppDataReceived$Input}
 * - {@link messagePassportDataSent$Input}
 * - {@link messagePassportDataReceived$Input}
 * - {@link messageProximityAlertTriggered$Input}
 * - {@link messageUnsupported$Input}
 */
export type MessageContent$Input =
  | messageText$Input
  | messageAnimation$Input
  | messageAudio$Input
  | messageDocument$Input
  | messagePhoto$Input
  | messageExpiredPhoto$Input
  | messageSticker$Input
  | messageVideo$Input
  | messageExpiredVideo$Input
  | messageVideoNote$Input
  | messageVoiceNote$Input
  | messageLocation$Input
  | messageVenue$Input
  | messageContact$Input
  | messageAnimatedEmoji$Input
  | messageDice$Input
  | messageGame$Input
  | messagePoll$Input
  | messageStory$Input
  | messageInvoice$Input
  | messageCall$Input
  | messageVideoChatScheduled$Input
  | messageVideoChatStarted$Input
  | messageVideoChatEnded$Input
  | messageInviteVideoChatParticipants$Input
  | messageBasicGroupChatCreate$Input
  | messageSupergroupChatCreate$Input
  | messageChatChangeTitle$Input
  | messageChatChangePhoto$Input
  | messageChatDeletePhoto$Input
  | messageChatAddMembers$Input
  | messageChatJoinByLink$Input
  | messageChatJoinByRequest$Input
  | messageChatDeleteMember$Input
  | messageChatUpgradeTo$Input
  | messageChatUpgradeFrom$Input
  | messagePinMessage$Input
  | messageScreenshotTaken$Input
  | messageChatSetBackground$Input
  | messageChatSetTheme$Input
  | messageChatSetMessageAutoDeleteTime$Input
  | messageForumTopicCreated$Input
  | messageForumTopicEdited$Input
  | messageForumTopicIsClosedToggled$Input
  | messageForumTopicIsHiddenToggled$Input
  | messageSuggestProfilePhoto$Input
  | messageCustomServiceAction$Input
  | messageGameScore$Input
  | messagePaymentSuccessful$Input
  | messagePaymentSuccessfulBot$Input
  | messageGiftedPremium$Input
  | messagePremiumGiftCode$Input
  | messagePremiumGiveawayCreated$Input
  | messagePremiumGiveaway$Input
  | messagePremiumGiveawayCompleted$Input
  | messagePremiumGiveawayWinners$Input
  | messageContactRegistered$Input
  | messageUsersShared$Input
  | messageChatShared$Input
  | messageBotWriteAccessAllowed$Input
  | messageWebAppDataSent$Input
  | messageWebAppDataReceived$Input
  | messagePassportDataSent$Input
  | messagePassportDataReceived$Input
  | messageProximityAlertTriggered$Input
  | messageUnsupported$Input;

/**
 * Any of:
 * - {@link textEntityTypeMention}
 * - {@link textEntityTypeHashtag}
 * - {@link textEntityTypeCashtag}
 * - {@link textEntityTypeBotCommand}
 * - {@link textEntityTypeUrl}
 * - {@link textEntityTypeEmailAddress}
 * - {@link textEntityTypePhoneNumber}
 * - {@link textEntityTypeBankCardNumber}
 * - {@link textEntityTypeBold}
 * - {@link textEntityTypeItalic}
 * - {@link textEntityTypeUnderline}
 * - {@link textEntityTypeStrikethrough}
 * - {@link textEntityTypeSpoiler}
 * - {@link textEntityTypeCode}
 * - {@link textEntityTypePre}
 * - {@link textEntityTypePreCode}
 * - {@link textEntityTypeBlockQuote}
 * - {@link textEntityTypeTextUrl}
 * - {@link textEntityTypeMentionName}
 * - {@link textEntityTypeCustomEmoji}
 * - {@link textEntityTypeMediaTimestamp}
 */
export type TextEntityType =
  | textEntityTypeMention
  | textEntityTypeHashtag
  | textEntityTypeCashtag
  | textEntityTypeBotCommand
  | textEntityTypeUrl
  | textEntityTypeEmailAddress
  | textEntityTypePhoneNumber
  | textEntityTypeBankCardNumber
  | textEntityTypeBold
  | textEntityTypeItalic
  | textEntityTypeUnderline
  | textEntityTypeStrikethrough
  | textEntityTypeSpoiler
  | textEntityTypeCode
  | textEntityTypePre
  | textEntityTypePreCode
  | textEntityTypeBlockQuote
  | textEntityTypeTextUrl
  | textEntityTypeMentionName
  | textEntityTypeCustomEmoji
  | textEntityTypeMediaTimestamp;

/**
 * Version of {@link TextEntityType} for method parameters.
 * Any of:
 * - {@link textEntityTypeMention$Input}
 * - {@link textEntityTypeHashtag$Input}
 * - {@link textEntityTypeCashtag$Input}
 * - {@link textEntityTypeBotCommand$Input}
 * - {@link textEntityTypeUrl$Input}
 * - {@link textEntityTypeEmailAddress$Input}
 * - {@link textEntityTypePhoneNumber$Input}
 * - {@link textEntityTypeBankCardNumber$Input}
 * - {@link textEntityTypeBold$Input}
 * - {@link textEntityTypeItalic$Input}
 * - {@link textEntityTypeUnderline$Input}
 * - {@link textEntityTypeStrikethrough$Input}
 * - {@link textEntityTypeSpoiler$Input}
 * - {@link textEntityTypeCode$Input}
 * - {@link textEntityTypePre$Input}
 * - {@link textEntityTypePreCode$Input}
 * - {@link textEntityTypeBlockQuote$Input}
 * - {@link textEntityTypeTextUrl$Input}
 * - {@link textEntityTypeMentionName$Input}
 * - {@link textEntityTypeCustomEmoji$Input}
 * - {@link textEntityTypeMediaTimestamp$Input}
 */
export type TextEntityType$Input =
  | textEntityTypeMention$Input
  | textEntityTypeHashtag$Input
  | textEntityTypeCashtag$Input
  | textEntityTypeBotCommand$Input
  | textEntityTypeUrl$Input
  | textEntityTypeEmailAddress$Input
  | textEntityTypePhoneNumber$Input
  | textEntityTypeBankCardNumber$Input
  | textEntityTypeBold$Input
  | textEntityTypeItalic$Input
  | textEntityTypeUnderline$Input
  | textEntityTypeStrikethrough$Input
  | textEntityTypeSpoiler$Input
  | textEntityTypeCode$Input
  | textEntityTypePre$Input
  | textEntityTypePreCode$Input
  | textEntityTypeBlockQuote$Input
  | textEntityTypeTextUrl$Input
  | textEntityTypeMentionName$Input
  | textEntityTypeCustomEmoji$Input
  | textEntityTypeMediaTimestamp$Input;

/**
 * Any of:
 * - {@link inputThumbnail}
 */
export type InputThumbnail = inputThumbnail;

/**
 * Version of {@link InputThumbnail} for method parameters.
 * Any of:
 * - {@link inputThumbnail$Input}
 */
export type InputThumbnail$Input = inputThumbnail$Input;

/**
 * Any of:
 * - {@link messageSchedulingStateSendAtDate}
 * - {@link messageSchedulingStateSendWhenOnline}
 */
export type MessageSchedulingState =
  | messageSchedulingStateSendAtDate
  | messageSchedulingStateSendWhenOnline;

/**
 * Version of {@link MessageSchedulingState} for method parameters.
 * Any of:
 * - {@link messageSchedulingStateSendAtDate$Input}
 * - {@link messageSchedulingStateSendWhenOnline$Input}
 */
export type MessageSchedulingState$Input =
  | messageSchedulingStateSendAtDate$Input
  | messageSchedulingStateSendWhenOnline$Input;

/**
 * Any of:
 * - {@link messageSelfDestructTypeTimer}
 * - {@link messageSelfDestructTypeImmediately}
 */
export type MessageSelfDestructType =
  | messageSelfDestructTypeTimer
  | messageSelfDestructTypeImmediately;

/**
 * Version of {@link MessageSelfDestructType} for method parameters.
 * Any of:
 * - {@link messageSelfDestructTypeTimer$Input}
 * - {@link messageSelfDestructTypeImmediately$Input}
 */
export type MessageSelfDestructType$Input =
  | messageSelfDestructTypeTimer$Input
  | messageSelfDestructTypeImmediately$Input;

/**
 * Any of:
 * - {@link messageSendOptions}
 */
export type MessageSendOptions = messageSendOptions;

/**
 * Version of {@link MessageSendOptions} for method parameters.
 * Any of:
 * - {@link messageSendOptions$Input}
 */
export type MessageSendOptions$Input = messageSendOptions$Input;

/**
 * Any of:
 * - {@link messageCopyOptions}
 */
export type MessageCopyOptions = messageCopyOptions;

/**
 * Version of {@link MessageCopyOptions} for method parameters.
 * Any of:
 * - {@link messageCopyOptions$Input}
 */
export type MessageCopyOptions$Input = messageCopyOptions$Input;

/**
 * Any of:
 * - {@link inputMessageText}
 * - {@link inputMessageAnimation}
 * - {@link inputMessageAudio}
 * - {@link inputMessageDocument}
 * - {@link inputMessagePhoto}
 * - {@link inputMessageSticker}
 * - {@link inputMessageVideo}
 * - {@link inputMessageVideoNote}
 * - {@link inputMessageVoiceNote}
 * - {@link inputMessageLocation}
 * - {@link inputMessageVenue}
 * - {@link inputMessageContact}
 * - {@link inputMessageDice}
 * - {@link inputMessageGame}
 * - {@link inputMessageInvoice}
 * - {@link inputMessagePoll}
 * - {@link inputMessageStory}
 * - {@link inputMessageForwarded}
 */
export type InputMessageContent =
  | inputMessageText
  | inputMessageAnimation
  | inputMessageAudio
  | inputMessageDocument
  | inputMessagePhoto
  | inputMessageSticker
  | inputMessageVideo
  | inputMessageVideoNote
  | inputMessageVoiceNote
  | inputMessageLocation
  | inputMessageVenue
  | inputMessageContact
  | inputMessageDice
  | inputMessageGame
  | inputMessageInvoice
  | inputMessagePoll
  | inputMessageStory
  | inputMessageForwarded;

/**
 * Version of {@link InputMessageContent} for method parameters.
 * Any of:
 * - {@link inputMessageText$Input}
 * - {@link inputMessageAnimation$Input}
 * - {@link inputMessageAudio$Input}
 * - {@link inputMessageDocument$Input}
 * - {@link inputMessagePhoto$Input}
 * - {@link inputMessageSticker$Input}
 * - {@link inputMessageVideo$Input}
 * - {@link inputMessageVideoNote$Input}
 * - {@link inputMessageVoiceNote$Input}
 * - {@link inputMessageLocation$Input}
 * - {@link inputMessageVenue$Input}
 * - {@link inputMessageContact$Input}
 * - {@link inputMessageDice$Input}
 * - {@link inputMessageGame$Input}
 * - {@link inputMessageInvoice$Input}
 * - {@link inputMessagePoll$Input}
 * - {@link inputMessageStory$Input}
 * - {@link inputMessageForwarded$Input}
 */
export type InputMessageContent$Input =
  | inputMessageText$Input
  | inputMessageAnimation$Input
  | inputMessageAudio$Input
  | inputMessageDocument$Input
  | inputMessagePhoto$Input
  | inputMessageSticker$Input
  | inputMessageVideo$Input
  | inputMessageVideoNote$Input
  | inputMessageVoiceNote$Input
  | inputMessageLocation$Input
  | inputMessageVenue$Input
  | inputMessageContact$Input
  | inputMessageDice$Input
  | inputMessageGame$Input
  | inputMessageInvoice$Input
  | inputMessagePoll$Input
  | inputMessageStory$Input
  | inputMessageForwarded$Input;

/**
 * Any of:
 * - {@link searchMessagesFilterEmpty}
 * - {@link searchMessagesFilterAnimation}
 * - {@link searchMessagesFilterAudio}
 * - {@link searchMessagesFilterDocument}
 * - {@link searchMessagesFilterPhoto}
 * - {@link searchMessagesFilterVideo}
 * - {@link searchMessagesFilterVoiceNote}
 * - {@link searchMessagesFilterPhotoAndVideo}
 * - {@link searchMessagesFilterUrl}
 * - {@link searchMessagesFilterChatPhoto}
 * - {@link searchMessagesFilterVideoNote}
 * - {@link searchMessagesFilterVoiceAndVideoNote}
 * - {@link searchMessagesFilterMention}
 * - {@link searchMessagesFilterUnreadMention}
 * - {@link searchMessagesFilterUnreadReaction}
 * - {@link searchMessagesFilterFailedToSend}
 * - {@link searchMessagesFilterPinned}
 */
export type SearchMessagesFilter =
  | searchMessagesFilterEmpty
  | searchMessagesFilterAnimation
  | searchMessagesFilterAudio
  | searchMessagesFilterDocument
  | searchMessagesFilterPhoto
  | searchMessagesFilterVideo
  | searchMessagesFilterVoiceNote
  | searchMessagesFilterPhotoAndVideo
  | searchMessagesFilterUrl
  | searchMessagesFilterChatPhoto
  | searchMessagesFilterVideoNote
  | searchMessagesFilterVoiceAndVideoNote
  | searchMessagesFilterMention
  | searchMessagesFilterUnreadMention
  | searchMessagesFilterUnreadReaction
  | searchMessagesFilterFailedToSend
  | searchMessagesFilterPinned;

/**
 * Version of {@link SearchMessagesFilter} for method parameters.
 * Any of:
 * - {@link searchMessagesFilterEmpty$Input}
 * - {@link searchMessagesFilterAnimation$Input}
 * - {@link searchMessagesFilterAudio$Input}
 * - {@link searchMessagesFilterDocument$Input}
 * - {@link searchMessagesFilterPhoto$Input}
 * - {@link searchMessagesFilterVideo$Input}
 * - {@link searchMessagesFilterVoiceNote$Input}
 * - {@link searchMessagesFilterPhotoAndVideo$Input}
 * - {@link searchMessagesFilterUrl$Input}
 * - {@link searchMessagesFilterChatPhoto$Input}
 * - {@link searchMessagesFilterVideoNote$Input}
 * - {@link searchMessagesFilterVoiceAndVideoNote$Input}
 * - {@link searchMessagesFilterMention$Input}
 * - {@link searchMessagesFilterUnreadMention$Input}
 * - {@link searchMessagesFilterUnreadReaction$Input}
 * - {@link searchMessagesFilterFailedToSend$Input}
 * - {@link searchMessagesFilterPinned$Input}
 */
export type SearchMessagesFilter$Input =
  | searchMessagesFilterEmpty$Input
  | searchMessagesFilterAnimation$Input
  | searchMessagesFilterAudio$Input
  | searchMessagesFilterDocument$Input
  | searchMessagesFilterPhoto$Input
  | searchMessagesFilterVideo$Input
  | searchMessagesFilterVoiceNote$Input
  | searchMessagesFilterPhotoAndVideo$Input
  | searchMessagesFilterUrl$Input
  | searchMessagesFilterChatPhoto$Input
  | searchMessagesFilterVideoNote$Input
  | searchMessagesFilterVoiceAndVideoNote$Input
  | searchMessagesFilterMention$Input
  | searchMessagesFilterUnreadMention$Input
  | searchMessagesFilterUnreadReaction$Input
  | searchMessagesFilterFailedToSend$Input
  | searchMessagesFilterPinned$Input;

/**
 * Any of:
 * - {@link chatActionTyping}
 * - {@link chatActionRecordingVideo}
 * - {@link chatActionUploadingVideo}
 * - {@link chatActionRecordingVoiceNote}
 * - {@link chatActionUploadingVoiceNote}
 * - {@link chatActionUploadingPhoto}
 * - {@link chatActionUploadingDocument}
 * - {@link chatActionChoosingSticker}
 * - {@link chatActionChoosingLocation}
 * - {@link chatActionChoosingContact}
 * - {@link chatActionStartPlayingGame}
 * - {@link chatActionRecordingVideoNote}
 * - {@link chatActionUploadingVideoNote}
 * - {@link chatActionWatchingAnimations}
 * - {@link chatActionCancel}
 */
export type ChatAction =
  | chatActionTyping
  | chatActionRecordingVideo
  | chatActionUploadingVideo
  | chatActionRecordingVoiceNote
  | chatActionUploadingVoiceNote
  | chatActionUploadingPhoto
  | chatActionUploadingDocument
  | chatActionChoosingSticker
  | chatActionChoosingLocation
  | chatActionChoosingContact
  | chatActionStartPlayingGame
  | chatActionRecordingVideoNote
  | chatActionUploadingVideoNote
  | chatActionWatchingAnimations
  | chatActionCancel;

/**
 * Version of {@link ChatAction} for method parameters.
 * Any of:
 * - {@link chatActionTyping$Input}
 * - {@link chatActionRecordingVideo$Input}
 * - {@link chatActionUploadingVideo$Input}
 * - {@link chatActionRecordingVoiceNote$Input}
 * - {@link chatActionUploadingVoiceNote$Input}
 * - {@link chatActionUploadingPhoto$Input}
 * - {@link chatActionUploadingDocument$Input}
 * - {@link chatActionChoosingSticker$Input}
 * - {@link chatActionChoosingLocation$Input}
 * - {@link chatActionChoosingContact$Input}
 * - {@link chatActionStartPlayingGame$Input}
 * - {@link chatActionRecordingVideoNote$Input}
 * - {@link chatActionUploadingVideoNote$Input}
 * - {@link chatActionWatchingAnimations$Input}
 * - {@link chatActionCancel$Input}
 */
export type ChatAction$Input =
  | chatActionTyping$Input
  | chatActionRecordingVideo$Input
  | chatActionUploadingVideo$Input
  | chatActionRecordingVoiceNote$Input
  | chatActionUploadingVoiceNote$Input
  | chatActionUploadingPhoto$Input
  | chatActionUploadingDocument$Input
  | chatActionChoosingSticker$Input
  | chatActionChoosingLocation$Input
  | chatActionChoosingContact$Input
  | chatActionStartPlayingGame$Input
  | chatActionRecordingVideoNote$Input
  | chatActionUploadingVideoNote$Input
  | chatActionWatchingAnimations$Input
  | chatActionCancel$Input;

/**
 * Any of:
 * - {@link userStatusEmpty}
 * - {@link userStatusOnline}
 * - {@link userStatusOffline}
 * - {@link userStatusRecently}
 * - {@link userStatusLastWeek}
 * - {@link userStatusLastMonth}
 */
export type UserStatus =
  | userStatusEmpty
  | userStatusOnline
  | userStatusOffline
  | userStatusRecently
  | userStatusLastWeek
  | userStatusLastMonth;

/**
 * Version of {@link UserStatus} for method parameters.
 * Any of:
 * - {@link userStatusEmpty$Input}
 * - {@link userStatusOnline$Input}
 * - {@link userStatusOffline$Input}
 * - {@link userStatusRecently$Input}
 * - {@link userStatusLastWeek$Input}
 * - {@link userStatusLastMonth$Input}
 */
export type UserStatus$Input =
  | userStatusEmpty$Input
  | userStatusOnline$Input
  | userStatusOffline$Input
  | userStatusRecently$Input
  | userStatusLastWeek$Input
  | userStatusLastMonth$Input;

/**
 * Any of:
 * - {@link stickers}
 */
export type Stickers = stickers;

/**
 * Version of {@link Stickers} for method parameters.
 * Any of:
 * - {@link stickers$Input}
 */
export type Stickers$Input = stickers$Input;

/**
 * Any of:
 * - {@link emojis}
 */
export type Emojis = emojis;

/**
 * Version of {@link Emojis} for method parameters.
 * Any of:
 * - {@link emojis$Input}
 */
export type Emojis$Input = emojis$Input;

/**
 * Any of:
 * - {@link stickerSet}
 */
export type StickerSet = stickerSet;

/**
 * Version of {@link StickerSet} for method parameters.
 * Any of:
 * - {@link stickerSet$Input}
 */
export type StickerSet$Input = stickerSet$Input;

/**
 * Any of:
 * - {@link stickerSetInfo}
 */
export type StickerSetInfo = stickerSetInfo;

/**
 * Version of {@link StickerSetInfo} for method parameters.
 * Any of:
 * - {@link stickerSetInfo$Input}
 */
export type StickerSetInfo$Input = stickerSetInfo$Input;

/**
 * Any of:
 * - {@link stickerSets}
 */
export type StickerSets = stickerSets;

/**
 * Version of {@link StickerSets} for method parameters.
 * Any of:
 * - {@link stickerSets$Input}
 */
export type StickerSets$Input = stickerSets$Input;

/**
 * Any of:
 * - {@link trendingStickerSets}
 */
export type TrendingStickerSets = trendingStickerSets;

/**
 * Version of {@link TrendingStickerSets} for method parameters.
 * Any of:
 * - {@link trendingStickerSets$Input}
 */
export type TrendingStickerSets$Input = trendingStickerSets$Input;

/**
 * Any of:
 * - {@link emojiCategory}
 */
export type EmojiCategory = emojiCategory;

/**
 * Version of {@link EmojiCategory} for method parameters.
 * Any of:
 * - {@link emojiCategory$Input}
 */
export type EmojiCategory$Input = emojiCategory$Input;

/**
 * Any of:
 * - {@link emojiCategories}
 */
export type EmojiCategories = emojiCategories;

/**
 * Version of {@link EmojiCategories} for method parameters.
 * Any of:
 * - {@link emojiCategories$Input}
 */
export type EmojiCategories$Input = emojiCategories$Input;

/**
 * Any of:
 * - {@link emojiCategoryTypeDefault}
 * - {@link emojiCategoryTypeEmojiStatus}
 * - {@link emojiCategoryTypeChatPhoto}
 */
export type EmojiCategoryType =
  | emojiCategoryTypeDefault
  | emojiCategoryTypeEmojiStatus
  | emojiCategoryTypeChatPhoto;

/**
 * Version of {@link EmojiCategoryType} for method parameters.
 * Any of:
 * - {@link emojiCategoryTypeDefault$Input}
 * - {@link emojiCategoryTypeEmojiStatus$Input}
 * - {@link emojiCategoryTypeChatPhoto$Input}
 */
export type EmojiCategoryType$Input =
  | emojiCategoryTypeDefault$Input
  | emojiCategoryTypeEmojiStatus$Input
  | emojiCategoryTypeChatPhoto$Input;

/**
 * Any of:
 * - {@link storyAreaPosition}
 */
export type StoryAreaPosition = storyAreaPosition;

/**
 * Version of {@link StoryAreaPosition} for method parameters.
 * Any of:
 * - {@link storyAreaPosition$Input}
 */
export type StoryAreaPosition$Input = storyAreaPosition$Input;

/**
 * Any of:
 * - {@link storyAreaTypeLocation}
 * - {@link storyAreaTypeVenue}
 * - {@link storyAreaTypeSuggestedReaction}
 * - {@link storyAreaTypeMessage}
 */
export type StoryAreaType =
  | storyAreaTypeLocation
  | storyAreaTypeVenue
  | storyAreaTypeSuggestedReaction
  | storyAreaTypeMessage;

/**
 * Version of {@link StoryAreaType} for method parameters.
 * Any of:
 * - {@link storyAreaTypeLocation$Input}
 * - {@link storyAreaTypeVenue$Input}
 * - {@link storyAreaTypeSuggestedReaction$Input}
 * - {@link storyAreaTypeMessage$Input}
 */
export type StoryAreaType$Input =
  | storyAreaTypeLocation$Input
  | storyAreaTypeVenue$Input
  | storyAreaTypeSuggestedReaction$Input
  | storyAreaTypeMessage$Input;

/**
 * Any of:
 * - {@link storyArea}
 */
export type StoryArea = storyArea;

/**
 * Version of {@link StoryArea} for method parameters.
 * Any of:
 * - {@link storyArea$Input}
 */
export type StoryArea$Input = storyArea$Input;

/**
 * Any of:
 * - {@link inputStoryAreaTypeLocation}
 * - {@link inputStoryAreaTypeFoundVenue}
 * - {@link inputStoryAreaTypePreviousVenue}
 * - {@link inputStoryAreaTypeSuggestedReaction}
 * - {@link inputStoryAreaTypeMessage}
 */
export type InputStoryAreaType =
  | inputStoryAreaTypeLocation
  | inputStoryAreaTypeFoundVenue
  | inputStoryAreaTypePreviousVenue
  | inputStoryAreaTypeSuggestedReaction
  | inputStoryAreaTypeMessage;

/**
 * Version of {@link InputStoryAreaType} for method parameters.
 * Any of:
 * - {@link inputStoryAreaTypeLocation$Input}
 * - {@link inputStoryAreaTypeFoundVenue$Input}
 * - {@link inputStoryAreaTypePreviousVenue$Input}
 * - {@link inputStoryAreaTypeSuggestedReaction$Input}
 * - {@link inputStoryAreaTypeMessage$Input}
 */
export type InputStoryAreaType$Input =
  | inputStoryAreaTypeLocation$Input
  | inputStoryAreaTypeFoundVenue$Input
  | inputStoryAreaTypePreviousVenue$Input
  | inputStoryAreaTypeSuggestedReaction$Input
  | inputStoryAreaTypeMessage$Input;

/**
 * Any of:
 * - {@link inputStoryArea}
 */
export type InputStoryArea = inputStoryArea;

/**
 * Version of {@link InputStoryArea} for method parameters.
 * Any of:
 * - {@link inputStoryArea$Input}
 */
export type InputStoryArea$Input = inputStoryArea$Input;

/**
 * Any of:
 * - {@link inputStoryAreas}
 */
export type InputStoryAreas = inputStoryAreas;

/**
 * Version of {@link InputStoryAreas} for method parameters.
 * Any of:
 * - {@link inputStoryAreas$Input}
 */
export type InputStoryAreas$Input = inputStoryAreas$Input;

/**
 * Any of:
 * - {@link storyVideo}
 */
export type StoryVideo = storyVideo;

/**
 * Version of {@link StoryVideo} for method parameters.
 * Any of:
 * - {@link storyVideo$Input}
 */
export type StoryVideo$Input = storyVideo$Input;

/**
 * Any of:
 * - {@link storyContentPhoto}
 * - {@link storyContentVideo}
 * - {@link storyContentUnsupported}
 */
export type StoryContent =
  | storyContentPhoto
  | storyContentVideo
  | storyContentUnsupported;

/**
 * Version of {@link StoryContent} for method parameters.
 * Any of:
 * - {@link storyContentPhoto$Input}
 * - {@link storyContentVideo$Input}
 * - {@link storyContentUnsupported$Input}
 */
export type StoryContent$Input =
  | storyContentPhoto$Input
  | storyContentVideo$Input
  | storyContentUnsupported$Input;

/**
 * Any of:
 * - {@link inputStoryContentPhoto}
 * - {@link inputStoryContentVideo}
 */
export type InputStoryContent = inputStoryContentPhoto | inputStoryContentVideo;

/**
 * Version of {@link InputStoryContent} for method parameters.
 * Any of:
 * - {@link inputStoryContentPhoto$Input}
 * - {@link inputStoryContentVideo$Input}
 */
export type InputStoryContent$Input =
  | inputStoryContentPhoto$Input
  | inputStoryContentVideo$Input;

/**
 * Any of:
 * - {@link storyListMain}
 * - {@link storyListArchive}
 */
export type StoryList = storyListMain | storyListArchive;

/**
 * Version of {@link StoryList} for method parameters.
 * Any of:
 * - {@link storyListMain$Input}
 * - {@link storyListArchive$Input}
 */
export type StoryList$Input = storyListMain$Input | storyListArchive$Input;

/**
 * Any of:
 * - {@link storyOriginPublicStory}
 * - {@link storyOriginHiddenUser}
 */
export type StoryOrigin = storyOriginPublicStory | storyOriginHiddenUser;

/**
 * Version of {@link StoryOrigin} for method parameters.
 * Any of:
 * - {@link storyOriginPublicStory$Input}
 * - {@link storyOriginHiddenUser$Input}
 */
export type StoryOrigin$Input =
  | storyOriginPublicStory$Input
  | storyOriginHiddenUser$Input;

/**
 * Any of:
 * - {@link storyRepostInfo}
 */
export type StoryRepostInfo = storyRepostInfo;

/**
 * Version of {@link StoryRepostInfo} for method parameters.
 * Any of:
 * - {@link storyRepostInfo$Input}
 */
export type StoryRepostInfo$Input = storyRepostInfo$Input;

/**
 * Any of:
 * - {@link storyInteractionInfo}
 */
export type StoryInteractionInfo = storyInteractionInfo;

/**
 * Version of {@link StoryInteractionInfo} for method parameters.
 * Any of:
 * - {@link storyInteractionInfo$Input}
 */
export type StoryInteractionInfo$Input = storyInteractionInfo$Input;

/**
 * Any of:
 * - {@link story}
 */
export type Story = story;

/**
 * Version of {@link Story} for method parameters.
 * Any of:
 * - {@link story$Input}
 */
export type Story$Input = story$Input;

/**
 * Any of:
 * - {@link stories}
 */
export type Stories = stories;

/**
 * Version of {@link Stories} for method parameters.
 * Any of:
 * - {@link stories$Input}
 */
export type Stories$Input = stories$Input;

/**
 * Any of:
 * - {@link storyFullId}
 */
export type StoryFullId = storyFullId;

/**
 * Version of {@link StoryFullId} for method parameters.
 * Any of:
 * - {@link storyFullId$Input}
 */
export type StoryFullId$Input = storyFullId$Input;

/**
 * Any of:
 * - {@link storyInfo}
 */
export type StoryInfo = storyInfo;

/**
 * Version of {@link StoryInfo} for method parameters.
 * Any of:
 * - {@link storyInfo$Input}
 */
export type StoryInfo$Input = storyInfo$Input;

/**
 * Any of:
 * - {@link chatActiveStories}
 */
export type ChatActiveStories = chatActiveStories;

/**
 * Version of {@link ChatActiveStories} for method parameters.
 * Any of:
 * - {@link chatActiveStories$Input}
 */
export type ChatActiveStories$Input = chatActiveStories$Input;

/**
 * Any of:
 * - {@link storyInteractionTypeView}
 * - {@link storyInteractionTypeForward}
 * - {@link storyInteractionTypeRepost}
 */
export type StoryInteractionType =
  | storyInteractionTypeView
  | storyInteractionTypeForward
  | storyInteractionTypeRepost;

/**
 * Version of {@link StoryInteractionType} for method parameters.
 * Any of:
 * - {@link storyInteractionTypeView$Input}
 * - {@link storyInteractionTypeForward$Input}
 * - {@link storyInteractionTypeRepost$Input}
 */
export type StoryInteractionType$Input =
  | storyInteractionTypeView$Input
  | storyInteractionTypeForward$Input
  | storyInteractionTypeRepost$Input;

/**
 * Any of:
 * - {@link storyInteraction}
 */
export type StoryInteraction = storyInteraction;

/**
 * Version of {@link StoryInteraction} for method parameters.
 * Any of:
 * - {@link storyInteraction$Input}
 */
export type StoryInteraction$Input = storyInteraction$Input;

/**
 * Any of:
 * - {@link storyInteractions}
 */
export type StoryInteractions = storyInteractions;

/**
 * Version of {@link StoryInteractions} for method parameters.
 * Any of:
 * - {@link storyInteractions$Input}
 */
export type StoryInteractions$Input = storyInteractions$Input;

/**
 * Any of:
 * - {@link publicForwardMessage}
 * - {@link publicForwardStory}
 */
export type PublicForward = publicForwardMessage | publicForwardStory;

/**
 * Version of {@link PublicForward} for method parameters.
 * Any of:
 * - {@link publicForwardMessage$Input}
 * - {@link publicForwardStory$Input}
 */
export type PublicForward$Input =
  | publicForwardMessage$Input
  | publicForwardStory$Input;

/**
 * Any of:
 * - {@link publicForwards}
 */
export type PublicForwards = publicForwards;

/**
 * Version of {@link PublicForwards} for method parameters.
 * Any of:
 * - {@link publicForwards$Input}
 */
export type PublicForwards$Input = publicForwards$Input;

/**
 * Any of:
 * - {@link chatBoostLevelFeatures}
 */
export type ChatBoostLevelFeatures = chatBoostLevelFeatures;

/**
 * Version of {@link ChatBoostLevelFeatures} for method parameters.
 * Any of:
 * - {@link chatBoostLevelFeatures$Input}
 */
export type ChatBoostLevelFeatures$Input = chatBoostLevelFeatures$Input;

/**
 * Any of:
 * - {@link chatBoostFeatures}
 */
export type ChatBoostFeatures = chatBoostFeatures;

/**
 * Version of {@link ChatBoostFeatures} for method parameters.
 * Any of:
 * - {@link chatBoostFeatures$Input}
 */
export type ChatBoostFeatures$Input = chatBoostFeatures$Input;

/**
 * Any of:
 * - {@link chatBoostSourceGiftCode}
 * - {@link chatBoostSourceGiveaway}
 * - {@link chatBoostSourcePremium}
 */
export type ChatBoostSource =
  | chatBoostSourceGiftCode
  | chatBoostSourceGiveaway
  | chatBoostSourcePremium;

/**
 * Version of {@link ChatBoostSource} for method parameters.
 * Any of:
 * - {@link chatBoostSourceGiftCode$Input}
 * - {@link chatBoostSourceGiveaway$Input}
 * - {@link chatBoostSourcePremium$Input}
 */
export type ChatBoostSource$Input =
  | chatBoostSourceGiftCode$Input
  | chatBoostSourceGiveaway$Input
  | chatBoostSourcePremium$Input;

/**
 * Any of:
 * - {@link prepaidPremiumGiveaway}
 */
export type PrepaidPremiumGiveaway = prepaidPremiumGiveaway;

/**
 * Version of {@link PrepaidPremiumGiveaway} for method parameters.
 * Any of:
 * - {@link prepaidPremiumGiveaway$Input}
 */
export type PrepaidPremiumGiveaway$Input = prepaidPremiumGiveaway$Input;

/**
 * Any of:
 * - {@link chatBoostStatus}
 */
export type ChatBoostStatus = chatBoostStatus;

/**
 * Version of {@link ChatBoostStatus} for method parameters.
 * Any of:
 * - {@link chatBoostStatus$Input}
 */
export type ChatBoostStatus$Input = chatBoostStatus$Input;

/**
 * Any of:
 * - {@link chatBoost}
 */
export type ChatBoost = chatBoost;

/**
 * Version of {@link ChatBoost} for method parameters.
 * Any of:
 * - {@link chatBoost$Input}
 */
export type ChatBoost$Input = chatBoost$Input;

/**
 * Any of:
 * - {@link foundChatBoosts}
 */
export type FoundChatBoosts = foundChatBoosts;

/**
 * Version of {@link FoundChatBoosts} for method parameters.
 * Any of:
 * - {@link foundChatBoosts$Input}
 */
export type FoundChatBoosts$Input = foundChatBoosts$Input;

/**
 * Any of:
 * - {@link chatBoostSlot}
 */
export type ChatBoostSlot = chatBoostSlot;

/**
 * Version of {@link ChatBoostSlot} for method parameters.
 * Any of:
 * - {@link chatBoostSlot$Input}
 */
export type ChatBoostSlot$Input = chatBoostSlot$Input;

/**
 * Any of:
 * - {@link chatBoostSlots}
 */
export type ChatBoostSlots = chatBoostSlots;

/**
 * Version of {@link ChatBoostSlots} for method parameters.
 * Any of:
 * - {@link chatBoostSlots$Input}
 */
export type ChatBoostSlots$Input = chatBoostSlots$Input;

/**
 * Any of:
 * - {@link callDiscardReasonEmpty}
 * - {@link callDiscardReasonMissed}
 * - {@link callDiscardReasonDeclined}
 * - {@link callDiscardReasonDisconnected}
 * - {@link callDiscardReasonHungUp}
 */
export type CallDiscardReason =
  | callDiscardReasonEmpty
  | callDiscardReasonMissed
  | callDiscardReasonDeclined
  | callDiscardReasonDisconnected
  | callDiscardReasonHungUp;

/**
 * Version of {@link CallDiscardReason} for method parameters.
 * Any of:
 * - {@link callDiscardReasonEmpty$Input}
 * - {@link callDiscardReasonMissed$Input}
 * - {@link callDiscardReasonDeclined$Input}
 * - {@link callDiscardReasonDisconnected$Input}
 * - {@link callDiscardReasonHungUp$Input}
 */
export type CallDiscardReason$Input =
  | callDiscardReasonEmpty$Input
  | callDiscardReasonMissed$Input
  | callDiscardReasonDeclined$Input
  | callDiscardReasonDisconnected$Input
  | callDiscardReasonHungUp$Input;

/**
 * Any of:
 * - {@link callProtocol}
 */
export type CallProtocol = callProtocol;

/**
 * Version of {@link CallProtocol} for method parameters.
 * Any of:
 * - {@link callProtocol$Input}
 */
export type CallProtocol$Input = callProtocol$Input;

/**
 * Any of:
 * - {@link callServerTypeTelegramReflector}
 * - {@link callServerTypeWebrtc}
 */
export type CallServerType = callServerTypeTelegramReflector | callServerTypeWebrtc;

/**
 * Version of {@link CallServerType} for method parameters.
 * Any of:
 * - {@link callServerTypeTelegramReflector$Input}
 * - {@link callServerTypeWebrtc$Input}
 */
export type CallServerType$Input =
  | callServerTypeTelegramReflector$Input
  | callServerTypeWebrtc$Input;

/**
 * Any of:
 * - {@link callServer}
 */
export type CallServer = callServer;

/**
 * Version of {@link CallServer} for method parameters.
 * Any of:
 * - {@link callServer$Input}
 */
export type CallServer$Input = callServer$Input;

/**
 * Any of:
 * - {@link callId}
 */
export type CallId = callId;

/**
 * Version of {@link CallId} for method parameters.
 * Any of:
 * - {@link callId$Input}
 */
export type CallId$Input = callId$Input;

/**
 * Any of:
 * - {@link groupCallId}
 */
export type GroupCallId = groupCallId;

/**
 * Version of {@link GroupCallId} for method parameters.
 * Any of:
 * - {@link groupCallId$Input}
 */
export type GroupCallId$Input = groupCallId$Input;

/**
 * Any of:
 * - {@link callStatePending}
 * - {@link callStateExchangingKeys}
 * - {@link callStateReady}
 * - {@link callStateHangingUp}
 * - {@link callStateDiscarded}
 * - {@link callStateError}
 */
export type CallState =
  | callStatePending
  | callStateExchangingKeys
  | callStateReady
  | callStateHangingUp
  | callStateDiscarded
  | callStateError;

/**
 * Version of {@link CallState} for method parameters.
 * Any of:
 * - {@link callStatePending$Input}
 * - {@link callStateExchangingKeys$Input}
 * - {@link callStateReady$Input}
 * - {@link callStateHangingUp$Input}
 * - {@link callStateDiscarded$Input}
 * - {@link callStateError$Input}
 */
export type CallState$Input =
  | callStatePending$Input
  | callStateExchangingKeys$Input
  | callStateReady$Input
  | callStateHangingUp$Input
  | callStateDiscarded$Input
  | callStateError$Input;

/**
 * Any of:
 * - {@link groupCallVideoQualityThumbnail}
 * - {@link groupCallVideoQualityMedium}
 * - {@link groupCallVideoQualityFull}
 */
export type GroupCallVideoQuality =
  | groupCallVideoQualityThumbnail
  | groupCallVideoQualityMedium
  | groupCallVideoQualityFull;

/**
 * Version of {@link GroupCallVideoQuality} for method parameters.
 * Any of:
 * - {@link groupCallVideoQualityThumbnail$Input}
 * - {@link groupCallVideoQualityMedium$Input}
 * - {@link groupCallVideoQualityFull$Input}
 */
export type GroupCallVideoQuality$Input =
  | groupCallVideoQualityThumbnail$Input
  | groupCallVideoQualityMedium$Input
  | groupCallVideoQualityFull$Input;

/**
 * Any of:
 * - {@link groupCallStream}
 */
export type GroupCallStream = groupCallStream;

/**
 * Version of {@link GroupCallStream} for method parameters.
 * Any of:
 * - {@link groupCallStream$Input}
 */
export type GroupCallStream$Input = groupCallStream$Input;

/**
 * Any of:
 * - {@link groupCallStreams}
 */
export type GroupCallStreams = groupCallStreams;

/**
 * Version of {@link GroupCallStreams} for method parameters.
 * Any of:
 * - {@link groupCallStreams$Input}
 */
export type GroupCallStreams$Input = groupCallStreams$Input;

/**
 * Any of:
 * - {@link rtmpUrl}
 */
export type RtmpUrl = rtmpUrl;

/**
 * Version of {@link RtmpUrl} for method parameters.
 * Any of:
 * - {@link rtmpUrl$Input}
 */
export type RtmpUrl$Input = rtmpUrl$Input;

/**
 * Any of:
 * - {@link groupCallRecentSpeaker}
 */
export type GroupCallRecentSpeaker = groupCallRecentSpeaker;

/**
 * Version of {@link GroupCallRecentSpeaker} for method parameters.
 * Any of:
 * - {@link groupCallRecentSpeaker$Input}
 */
export type GroupCallRecentSpeaker$Input = groupCallRecentSpeaker$Input;

/**
 * Any of:
 * - {@link groupCall}
 */
export type GroupCall = groupCall;

/**
 * Version of {@link GroupCall} for method parameters.
 * Any of:
 * - {@link groupCall$Input}
 */
export type GroupCall$Input = groupCall$Input;

/**
 * Any of:
 * - {@link groupCallVideoSourceGroup}
 */
export type GroupCallVideoSourceGroup = groupCallVideoSourceGroup;

/**
 * Version of {@link GroupCallVideoSourceGroup} for method parameters.
 * Any of:
 * - {@link groupCallVideoSourceGroup$Input}
 */
export type GroupCallVideoSourceGroup$Input = groupCallVideoSourceGroup$Input;

/**
 * Any of:
 * - {@link groupCallParticipantVideoInfo}
 */
export type GroupCallParticipantVideoInfo = groupCallParticipantVideoInfo;

/**
 * Version of {@link GroupCallParticipantVideoInfo} for method parameters.
 * Any of:
 * - {@link groupCallParticipantVideoInfo$Input}
 */
export type GroupCallParticipantVideoInfo$Input =
  groupCallParticipantVideoInfo$Input;

/**
 * Any of:
 * - {@link groupCallParticipant}
 */
export type GroupCallParticipant = groupCallParticipant;

/**
 * Version of {@link GroupCallParticipant} for method parameters.
 * Any of:
 * - {@link groupCallParticipant$Input}
 */
export type GroupCallParticipant$Input = groupCallParticipant$Input;

/**
 * Any of:
 * - {@link callProblemEcho}
 * - {@link callProblemNoise}
 * - {@link callProblemInterruptions}
 * - {@link callProblemDistortedSpeech}
 * - {@link callProblemSilentLocal}
 * - {@link callProblemSilentRemote}
 * - {@link callProblemDropped}
 * - {@link callProblemDistortedVideo}
 * - {@link callProblemPixelatedVideo}
 */
export type CallProblem =
  | callProblemEcho
  | callProblemNoise
  | callProblemInterruptions
  | callProblemDistortedSpeech
  | callProblemSilentLocal
  | callProblemSilentRemote
  | callProblemDropped
  | callProblemDistortedVideo
  | callProblemPixelatedVideo;

/**
 * Version of {@link CallProblem} for method parameters.
 * Any of:
 * - {@link callProblemEcho$Input}
 * - {@link callProblemNoise$Input}
 * - {@link callProblemInterruptions$Input}
 * - {@link callProblemDistortedSpeech$Input}
 * - {@link callProblemSilentLocal$Input}
 * - {@link callProblemSilentRemote$Input}
 * - {@link callProblemDropped$Input}
 * - {@link callProblemDistortedVideo$Input}
 * - {@link callProblemPixelatedVideo$Input}
 */
export type CallProblem$Input =
  | callProblemEcho$Input
  | callProblemNoise$Input
  | callProblemInterruptions$Input
  | callProblemDistortedSpeech$Input
  | callProblemSilentLocal$Input
  | callProblemSilentRemote$Input
  | callProblemDropped$Input
  | callProblemDistortedVideo$Input
  | callProblemPixelatedVideo$Input;

/**
 * Any of:
 * - {@link call}
 */
export type Call = call;

/**
 * Version of {@link Call} for method parameters.
 * Any of:
 * - {@link call$Input}
 */
export type Call$Input = call$Input;

/**
 * Any of:
 * - {@link firebaseAuthenticationSettingsAndroid}
 * - {@link firebaseAuthenticationSettingsIos}
 */
export type FirebaseAuthenticationSettings =
  | firebaseAuthenticationSettingsAndroid
  | firebaseAuthenticationSettingsIos;

/**
 * Version of {@link FirebaseAuthenticationSettings} for method parameters.
 * Any of:
 * - {@link firebaseAuthenticationSettingsAndroid$Input}
 * - {@link firebaseAuthenticationSettingsIos$Input}
 */
export type FirebaseAuthenticationSettings$Input =
  | firebaseAuthenticationSettingsAndroid$Input
  | firebaseAuthenticationSettingsIos$Input;

/**
 * Any of:
 * - {@link phoneNumberAuthenticationSettings}
 */
export type PhoneNumberAuthenticationSettings = phoneNumberAuthenticationSettings;

/**
 * Version of {@link PhoneNumberAuthenticationSettings} for method parameters.
 * Any of:
 * - {@link phoneNumberAuthenticationSettings$Input}
 */
export type PhoneNumberAuthenticationSettings$Input =
  phoneNumberAuthenticationSettings$Input;

/**
 * Any of:
 * - {@link addedReaction}
 */
export type AddedReaction = addedReaction;

/**
 * Version of {@link AddedReaction} for method parameters.
 * Any of:
 * - {@link addedReaction$Input}
 */
export type AddedReaction$Input = addedReaction$Input;

/**
 * Any of:
 * - {@link addedReactions}
 */
export type AddedReactions = addedReactions;

/**
 * Version of {@link AddedReactions} for method parameters.
 * Any of:
 * - {@link addedReactions$Input}
 */
export type AddedReactions$Input = addedReactions$Input;

/**
 * Any of:
 * - {@link availableReaction}
 */
export type AvailableReaction = availableReaction;

/**
 * Version of {@link AvailableReaction} for method parameters.
 * Any of:
 * - {@link availableReaction$Input}
 */
export type AvailableReaction$Input = availableReaction$Input;

/**
 * Any of:
 * - {@link availableReactions}
 */
export type AvailableReactions = availableReactions;

/**
 * Version of {@link AvailableReactions} for method parameters.
 * Any of:
 * - {@link availableReactions$Input}
 */
export type AvailableReactions$Input = availableReactions$Input;

/**
 * Any of:
 * - {@link emojiReaction}
 */
export type EmojiReaction = emojiReaction;

/**
 * Version of {@link EmojiReaction} for method parameters.
 * Any of:
 * - {@link emojiReaction$Input}
 */
export type EmojiReaction$Input = emojiReaction$Input;

/**
 * Any of:
 * - {@link animations}
 */
export type Animations = animations;

/**
 * Version of {@link Animations} for method parameters.
 * Any of:
 * - {@link animations$Input}
 */
export type Animations$Input = animations$Input;

/**
 * Any of:
 * - {@link diceStickersRegular}
 * - {@link diceStickersSlotMachine}
 */
export type DiceStickers = diceStickersRegular | diceStickersSlotMachine;

/**
 * Version of {@link DiceStickers} for method parameters.
 * Any of:
 * - {@link diceStickersRegular$Input}
 * - {@link diceStickersSlotMachine$Input}
 */
export type DiceStickers$Input =
  | diceStickersRegular$Input
  | diceStickersSlotMachine$Input;

/**
 * Any of:
 * - {@link importedContacts}
 */
export type ImportedContacts = importedContacts;

/**
 * Version of {@link ImportedContacts} for method parameters.
 * Any of:
 * - {@link importedContacts$Input}
 */
export type ImportedContacts$Input = importedContacts$Input;

/**
 * Any of:
 * - {@link speechRecognitionResultPending}
 * - {@link speechRecognitionResultText}
 * - {@link speechRecognitionResultError}
 */
export type SpeechRecognitionResult =
  | speechRecognitionResultPending
  | speechRecognitionResultText
  | speechRecognitionResultError;

/**
 * Version of {@link SpeechRecognitionResult} for method parameters.
 * Any of:
 * - {@link speechRecognitionResultPending$Input}
 * - {@link speechRecognitionResultText$Input}
 * - {@link speechRecognitionResultError$Input}
 */
export type SpeechRecognitionResult$Input =
  | speechRecognitionResultPending$Input
  | speechRecognitionResultText$Input
  | speechRecognitionResultError$Input;

/**
 * Any of:
 * - {@link attachmentMenuBotColor}
 */
export type AttachmentMenuBotColor = attachmentMenuBotColor;

/**
 * Version of {@link AttachmentMenuBotColor} for method parameters.
 * Any of:
 * - {@link attachmentMenuBotColor$Input}
 */
export type AttachmentMenuBotColor$Input = attachmentMenuBotColor$Input;

/**
 * Any of:
 * - {@link attachmentMenuBot}
 */
export type AttachmentMenuBot = attachmentMenuBot;

/**
 * Version of {@link AttachmentMenuBot} for method parameters.
 * Any of:
 * - {@link attachmentMenuBot$Input}
 */
export type AttachmentMenuBot$Input = attachmentMenuBot$Input;

/**
 * Any of:
 * - {@link sentWebAppMessage}
 */
export type SentWebAppMessage = sentWebAppMessage;

/**
 * Version of {@link SentWebAppMessage} for method parameters.
 * Any of:
 * - {@link sentWebAppMessage$Input}
 */
export type SentWebAppMessage$Input = sentWebAppMessage$Input;

/**
 * Any of:
 * - {@link botWriteAccessAllowReasonConnectedWebsite}
 * - {@link botWriteAccessAllowReasonAddedToAttachmentMenu}
 * - {@link botWriteAccessAllowReasonLaunchedWebApp}
 * - {@link botWriteAccessAllowReasonAcceptedRequest}
 */
export type BotWriteAccessAllowReason =
  | botWriteAccessAllowReasonConnectedWebsite
  | botWriteAccessAllowReasonAddedToAttachmentMenu
  | botWriteAccessAllowReasonLaunchedWebApp
  | botWriteAccessAllowReasonAcceptedRequest;

/**
 * Version of {@link BotWriteAccessAllowReason} for method parameters.
 * Any of:
 * - {@link botWriteAccessAllowReasonConnectedWebsite$Input}
 * - {@link botWriteAccessAllowReasonAddedToAttachmentMenu$Input}
 * - {@link botWriteAccessAllowReasonLaunchedWebApp$Input}
 * - {@link botWriteAccessAllowReasonAcceptedRequest$Input}
 */
export type BotWriteAccessAllowReason$Input =
  | botWriteAccessAllowReasonConnectedWebsite$Input
  | botWriteAccessAllowReasonAddedToAttachmentMenu$Input
  | botWriteAccessAllowReasonLaunchedWebApp$Input
  | botWriteAccessAllowReasonAcceptedRequest$Input;

/**
 * Any of:
 * - {@link httpUrl}
 */
export type HttpUrl = httpUrl;

/**
 * Version of {@link HttpUrl} for method parameters.
 * Any of:
 * - {@link httpUrl$Input}
 */
export type HttpUrl$Input = httpUrl$Input;

/**
 * Any of:
 * - {@link userLink}
 */
export type UserLink = userLink;

/**
 * Version of {@link UserLink} for method parameters.
 * Any of:
 * - {@link userLink$Input}
 */
export type UserLink$Input = userLink$Input;

/**
 * Any of:
 * - {@link inputInlineQueryResultAnimation}
 * - {@link inputInlineQueryResultArticle}
 * - {@link inputInlineQueryResultAudio}
 * - {@link inputInlineQueryResultContact}
 * - {@link inputInlineQueryResultDocument}
 * - {@link inputInlineQueryResultGame}
 * - {@link inputInlineQueryResultLocation}
 * - {@link inputInlineQueryResultPhoto}
 * - {@link inputInlineQueryResultSticker}
 * - {@link inputInlineQueryResultVenue}
 * - {@link inputInlineQueryResultVideo}
 * - {@link inputInlineQueryResultVoiceNote}
 */
export type InputInlineQueryResult =
  | inputInlineQueryResultAnimation
  | inputInlineQueryResultArticle
  | inputInlineQueryResultAudio
  | inputInlineQueryResultContact
  | inputInlineQueryResultDocument
  | inputInlineQueryResultGame
  | inputInlineQueryResultLocation
  | inputInlineQueryResultPhoto
  | inputInlineQueryResultSticker
  | inputInlineQueryResultVenue
  | inputInlineQueryResultVideo
  | inputInlineQueryResultVoiceNote;

/**
 * Version of {@link InputInlineQueryResult} for method parameters.
 * Any of:
 * - {@link inputInlineQueryResultAnimation$Input}
 * - {@link inputInlineQueryResultArticle$Input}
 * - {@link inputInlineQueryResultAudio$Input}
 * - {@link inputInlineQueryResultContact$Input}
 * - {@link inputInlineQueryResultDocument$Input}
 * - {@link inputInlineQueryResultGame$Input}
 * - {@link inputInlineQueryResultLocation$Input}
 * - {@link inputInlineQueryResultPhoto$Input}
 * - {@link inputInlineQueryResultSticker$Input}
 * - {@link inputInlineQueryResultVenue$Input}
 * - {@link inputInlineQueryResultVideo$Input}
 * - {@link inputInlineQueryResultVoiceNote$Input}
 */
export type InputInlineQueryResult$Input =
  | inputInlineQueryResultAnimation$Input
  | inputInlineQueryResultArticle$Input
  | inputInlineQueryResultAudio$Input
  | inputInlineQueryResultContact$Input
  | inputInlineQueryResultDocument$Input
  | inputInlineQueryResultGame$Input
  | inputInlineQueryResultLocation$Input
  | inputInlineQueryResultPhoto$Input
  | inputInlineQueryResultSticker$Input
  | inputInlineQueryResultVenue$Input
  | inputInlineQueryResultVideo$Input
  | inputInlineQueryResultVoiceNote$Input;

/**
 * Any of:
 * - {@link inlineQueryResultArticle}
 * - {@link inlineQueryResultContact}
 * - {@link inlineQueryResultLocation}
 * - {@link inlineQueryResultVenue}
 * - {@link inlineQueryResultGame}
 * - {@link inlineQueryResultAnimation}
 * - {@link inlineQueryResultAudio}
 * - {@link inlineQueryResultDocument}
 * - {@link inlineQueryResultPhoto}
 * - {@link inlineQueryResultSticker}
 * - {@link inlineQueryResultVideo}
 * - {@link inlineQueryResultVoiceNote}
 */
export type InlineQueryResult =
  | inlineQueryResultArticle
  | inlineQueryResultContact
  | inlineQueryResultLocation
  | inlineQueryResultVenue
  | inlineQueryResultGame
  | inlineQueryResultAnimation
  | inlineQueryResultAudio
  | inlineQueryResultDocument
  | inlineQueryResultPhoto
  | inlineQueryResultSticker
  | inlineQueryResultVideo
  | inlineQueryResultVoiceNote;

/**
 * Version of {@link InlineQueryResult} for method parameters.
 * Any of:
 * - {@link inlineQueryResultArticle$Input}
 * - {@link inlineQueryResultContact$Input}
 * - {@link inlineQueryResultLocation$Input}
 * - {@link inlineQueryResultVenue$Input}
 * - {@link inlineQueryResultGame$Input}
 * - {@link inlineQueryResultAnimation$Input}
 * - {@link inlineQueryResultAudio$Input}
 * - {@link inlineQueryResultDocument$Input}
 * - {@link inlineQueryResultPhoto$Input}
 * - {@link inlineQueryResultSticker$Input}
 * - {@link inlineQueryResultVideo$Input}
 * - {@link inlineQueryResultVoiceNote$Input}
 */
export type InlineQueryResult$Input =
  | inlineQueryResultArticle$Input
  | inlineQueryResultContact$Input
  | inlineQueryResultLocation$Input
  | inlineQueryResultVenue$Input
  | inlineQueryResultGame$Input
  | inlineQueryResultAnimation$Input
  | inlineQueryResultAudio$Input
  | inlineQueryResultDocument$Input
  | inlineQueryResultPhoto$Input
  | inlineQueryResultSticker$Input
  | inlineQueryResultVideo$Input
  | inlineQueryResultVoiceNote$Input;

/**
 * Any of:
 * - {@link inlineQueryResultsButtonTypeStartBot}
 * - {@link inlineQueryResultsButtonTypeWebApp}
 */
export type InlineQueryResultsButtonType =
  | inlineQueryResultsButtonTypeStartBot
  | inlineQueryResultsButtonTypeWebApp;

/**
 * Version of {@link InlineQueryResultsButtonType} for method parameters.
 * Any of:
 * - {@link inlineQueryResultsButtonTypeStartBot$Input}
 * - {@link inlineQueryResultsButtonTypeWebApp$Input}
 */
export type InlineQueryResultsButtonType$Input =
  | inlineQueryResultsButtonTypeStartBot$Input
  | inlineQueryResultsButtonTypeWebApp$Input;

/**
 * Any of:
 * - {@link inlineQueryResultsButton}
 */
export type InlineQueryResultsButton = inlineQueryResultsButton;

/**
 * Version of {@link InlineQueryResultsButton} for method parameters.
 * Any of:
 * - {@link inlineQueryResultsButton$Input}
 */
export type InlineQueryResultsButton$Input = inlineQueryResultsButton$Input;

/**
 * Any of:
 * - {@link inlineQueryResults}
 */
export type InlineQueryResults = inlineQueryResults;

/**
 * Version of {@link InlineQueryResults} for method parameters.
 * Any of:
 * - {@link inlineQueryResults$Input}
 */
export type InlineQueryResults$Input = inlineQueryResults$Input;

/**
 * Any of:
 * - {@link callbackQueryPayloadData}
 * - {@link callbackQueryPayloadDataWithPassword}
 * - {@link callbackQueryPayloadGame}
 */
export type CallbackQueryPayload =
  | callbackQueryPayloadData
  | callbackQueryPayloadDataWithPassword
  | callbackQueryPayloadGame;

/**
 * Version of {@link CallbackQueryPayload} for method parameters.
 * Any of:
 * - {@link callbackQueryPayloadData$Input}
 * - {@link callbackQueryPayloadDataWithPassword$Input}
 * - {@link callbackQueryPayloadGame$Input}
 */
export type CallbackQueryPayload$Input =
  | callbackQueryPayloadData$Input
  | callbackQueryPayloadDataWithPassword$Input
  | callbackQueryPayloadGame$Input;

/**
 * Any of:
 * - {@link callbackQueryAnswer}
 */
export type CallbackQueryAnswer = callbackQueryAnswer;

/**
 * Version of {@link CallbackQueryAnswer} for method parameters.
 * Any of:
 * - {@link callbackQueryAnswer$Input}
 */
export type CallbackQueryAnswer$Input = callbackQueryAnswer$Input;

/**
 * Any of:
 * - {@link customRequestResult}
 */
export type CustomRequestResult = customRequestResult;

/**
 * Version of {@link CustomRequestResult} for method parameters.
 * Any of:
 * - {@link customRequestResult$Input}
 */
export type CustomRequestResult$Input = customRequestResult$Input;

/**
 * Any of:
 * - {@link gameHighScore}
 */
export type GameHighScore = gameHighScore;

/**
 * Version of {@link GameHighScore} for method parameters.
 * Any of:
 * - {@link gameHighScore$Input}
 */
export type GameHighScore$Input = gameHighScore$Input;

/**
 * Any of:
 * - {@link gameHighScores}
 */
export type GameHighScores = gameHighScores;

/**
 * Version of {@link GameHighScores} for method parameters.
 * Any of:
 * - {@link gameHighScores$Input}
 */
export type GameHighScores$Input = gameHighScores$Input;

/**
 * Any of:
 * - {@link chatEventMessageEdited}
 * - {@link chatEventMessageDeleted}
 * - {@link chatEventMessagePinned}
 * - {@link chatEventMessageUnpinned}
 * - {@link chatEventPollStopped}
 * - {@link chatEventMemberJoined}
 * - {@link chatEventMemberJoinedByInviteLink}
 * - {@link chatEventMemberJoinedByRequest}
 * - {@link chatEventMemberInvited}
 * - {@link chatEventMemberLeft}
 * - {@link chatEventMemberPromoted}
 * - {@link chatEventMemberRestricted}
 * - {@link chatEventAvailableReactionsChanged}
 * - {@link chatEventBackgroundChanged}
 * - {@link chatEventDescriptionChanged}
 * - {@link chatEventEmojiStatusChanged}
 * - {@link chatEventLinkedChatChanged}
 * - {@link chatEventLocationChanged}
 * - {@link chatEventMessageAutoDeleteTimeChanged}
 * - {@link chatEventPermissionsChanged}
 * - {@link chatEventPhotoChanged}
 * - {@link chatEventSlowModeDelayChanged}
 * - {@link chatEventStickerSetChanged}
 * - {@link chatEventTitleChanged}
 * - {@link chatEventUsernameChanged}
 * - {@link chatEventActiveUsernamesChanged}
 * - {@link chatEventAccentColorChanged}
 * - {@link chatEventProfileAccentColorChanged}
 * - {@link chatEventHasProtectedContentToggled}
 * - {@link chatEventInvitesToggled}
 * - {@link chatEventIsAllHistoryAvailableToggled}
 * - {@link chatEventHasAggressiveAntiSpamEnabledToggled}
 * - {@link chatEventSignMessagesToggled}
 * - {@link chatEventInviteLinkEdited}
 * - {@link chatEventInviteLinkRevoked}
 * - {@link chatEventInviteLinkDeleted}
 * - {@link chatEventVideoChatCreated}
 * - {@link chatEventVideoChatEnded}
 * - {@link chatEventVideoChatMuteNewParticipantsToggled}
 * - {@link chatEventVideoChatParticipantIsMutedToggled}
 * - {@link chatEventVideoChatParticipantVolumeLevelChanged}
 * - {@link chatEventIsForumToggled}
 * - {@link chatEventForumTopicCreated}
 * - {@link chatEventForumTopicEdited}
 * - {@link chatEventForumTopicToggleIsClosed}
 * - {@link chatEventForumTopicToggleIsHidden}
 * - {@link chatEventForumTopicDeleted}
 * - {@link chatEventForumTopicPinned}
 */
export type ChatEventAction =
  | chatEventMessageEdited
  | chatEventMessageDeleted
  | chatEventMessagePinned
  | chatEventMessageUnpinned
  | chatEventPollStopped
  | chatEventMemberJoined
  | chatEventMemberJoinedByInviteLink
  | chatEventMemberJoinedByRequest
  | chatEventMemberInvited
  | chatEventMemberLeft
  | chatEventMemberPromoted
  | chatEventMemberRestricted
  | chatEventAvailableReactionsChanged
  | chatEventBackgroundChanged
  | chatEventDescriptionChanged
  | chatEventEmojiStatusChanged
  | chatEventLinkedChatChanged
  | chatEventLocationChanged
  | chatEventMessageAutoDeleteTimeChanged
  | chatEventPermissionsChanged
  | chatEventPhotoChanged
  | chatEventSlowModeDelayChanged
  | chatEventStickerSetChanged
  | chatEventTitleChanged
  | chatEventUsernameChanged
  | chatEventActiveUsernamesChanged
  | chatEventAccentColorChanged
  | chatEventProfileAccentColorChanged
  | chatEventHasProtectedContentToggled
  | chatEventInvitesToggled
  | chatEventIsAllHistoryAvailableToggled
  | chatEventHasAggressiveAntiSpamEnabledToggled
  | chatEventSignMessagesToggled
  | chatEventInviteLinkEdited
  | chatEventInviteLinkRevoked
  | chatEventInviteLinkDeleted
  | chatEventVideoChatCreated
  | chatEventVideoChatEnded
  | chatEventVideoChatMuteNewParticipantsToggled
  | chatEventVideoChatParticipantIsMutedToggled
  | chatEventVideoChatParticipantVolumeLevelChanged
  | chatEventIsForumToggled
  | chatEventForumTopicCreated
  | chatEventForumTopicEdited
  | chatEventForumTopicToggleIsClosed
  | chatEventForumTopicToggleIsHidden
  | chatEventForumTopicDeleted
  | chatEventForumTopicPinned;

/**
 * Version of {@link ChatEventAction} for method parameters.
 * Any of:
 * - {@link chatEventMessageEdited$Input}
 * - {@link chatEventMessageDeleted$Input}
 * - {@link chatEventMessagePinned$Input}
 * - {@link chatEventMessageUnpinned$Input}
 * - {@link chatEventPollStopped$Input}
 * - {@link chatEventMemberJoined$Input}
 * - {@link chatEventMemberJoinedByInviteLink$Input}
 * - {@link chatEventMemberJoinedByRequest$Input}
 * - {@link chatEventMemberInvited$Input}
 * - {@link chatEventMemberLeft$Input}
 * - {@link chatEventMemberPromoted$Input}
 * - {@link chatEventMemberRestricted$Input}
 * - {@link chatEventAvailableReactionsChanged$Input}
 * - {@link chatEventBackgroundChanged$Input}
 * - {@link chatEventDescriptionChanged$Input}
 * - {@link chatEventEmojiStatusChanged$Input}
 * - {@link chatEventLinkedChatChanged$Input}
 * - {@link chatEventLocationChanged$Input}
 * - {@link chatEventMessageAutoDeleteTimeChanged$Input}
 * - {@link chatEventPermissionsChanged$Input}
 * - {@link chatEventPhotoChanged$Input}
 * - {@link chatEventSlowModeDelayChanged$Input}
 * - {@link chatEventStickerSetChanged$Input}
 * - {@link chatEventTitleChanged$Input}
 * - {@link chatEventUsernameChanged$Input}
 * - {@link chatEventActiveUsernamesChanged$Input}
 * - {@link chatEventAccentColorChanged$Input}
 * - {@link chatEventProfileAccentColorChanged$Input}
 * - {@link chatEventHasProtectedContentToggled$Input}
 * - {@link chatEventInvitesToggled$Input}
 * - {@link chatEventIsAllHistoryAvailableToggled$Input}
 * - {@link chatEventHasAggressiveAntiSpamEnabledToggled$Input}
 * - {@link chatEventSignMessagesToggled$Input}
 * - {@link chatEventInviteLinkEdited$Input}
 * - {@link chatEventInviteLinkRevoked$Input}
 * - {@link chatEventInviteLinkDeleted$Input}
 * - {@link chatEventVideoChatCreated$Input}
 * - {@link chatEventVideoChatEnded$Input}
 * - {@link chatEventVideoChatMuteNewParticipantsToggled$Input}
 * - {@link chatEventVideoChatParticipantIsMutedToggled$Input}
 * - {@link chatEventVideoChatParticipantVolumeLevelChanged$Input}
 * - {@link chatEventIsForumToggled$Input}
 * - {@link chatEventForumTopicCreated$Input}
 * - {@link chatEventForumTopicEdited$Input}
 * - {@link chatEventForumTopicToggleIsClosed$Input}
 * - {@link chatEventForumTopicToggleIsHidden$Input}
 * - {@link chatEventForumTopicDeleted$Input}
 * - {@link chatEventForumTopicPinned$Input}
 */
export type ChatEventAction$Input =
  | chatEventMessageEdited$Input
  | chatEventMessageDeleted$Input
  | chatEventMessagePinned$Input
  | chatEventMessageUnpinned$Input
  | chatEventPollStopped$Input
  | chatEventMemberJoined$Input
  | chatEventMemberJoinedByInviteLink$Input
  | chatEventMemberJoinedByRequest$Input
  | chatEventMemberInvited$Input
  | chatEventMemberLeft$Input
  | chatEventMemberPromoted$Input
  | chatEventMemberRestricted$Input
  | chatEventAvailableReactionsChanged$Input
  | chatEventBackgroundChanged$Input
  | chatEventDescriptionChanged$Input
  | chatEventEmojiStatusChanged$Input
  | chatEventLinkedChatChanged$Input
  | chatEventLocationChanged$Input
  | chatEventMessageAutoDeleteTimeChanged$Input
  | chatEventPermissionsChanged$Input
  | chatEventPhotoChanged$Input
  | chatEventSlowModeDelayChanged$Input
  | chatEventStickerSetChanged$Input
  | chatEventTitleChanged$Input
  | chatEventUsernameChanged$Input
  | chatEventActiveUsernamesChanged$Input
  | chatEventAccentColorChanged$Input
  | chatEventProfileAccentColorChanged$Input
  | chatEventHasProtectedContentToggled$Input
  | chatEventInvitesToggled$Input
  | chatEventIsAllHistoryAvailableToggled$Input
  | chatEventHasAggressiveAntiSpamEnabledToggled$Input
  | chatEventSignMessagesToggled$Input
  | chatEventInviteLinkEdited$Input
  | chatEventInviteLinkRevoked$Input
  | chatEventInviteLinkDeleted$Input
  | chatEventVideoChatCreated$Input
  | chatEventVideoChatEnded$Input
  | chatEventVideoChatMuteNewParticipantsToggled$Input
  | chatEventVideoChatParticipantIsMutedToggled$Input
  | chatEventVideoChatParticipantVolumeLevelChanged$Input
  | chatEventIsForumToggled$Input
  | chatEventForumTopicCreated$Input
  | chatEventForumTopicEdited$Input
  | chatEventForumTopicToggleIsClosed$Input
  | chatEventForumTopicToggleIsHidden$Input
  | chatEventForumTopicDeleted$Input
  | chatEventForumTopicPinned$Input;

/**
 * Any of:
 * - {@link chatEvent}
 */
export type ChatEvent = chatEvent;

/**
 * Version of {@link ChatEvent} for method parameters.
 * Any of:
 * - {@link chatEvent$Input}
 */
export type ChatEvent$Input = chatEvent$Input;

/**
 * Any of:
 * - {@link chatEvents}
 */
export type ChatEvents = chatEvents;

/**
 * Version of {@link ChatEvents} for method parameters.
 * Any of:
 * - {@link chatEvents$Input}
 */
export type ChatEvents$Input = chatEvents$Input;

/**
 * Any of:
 * - {@link chatEventLogFilters}
 */
export type ChatEventLogFilters = chatEventLogFilters;

/**
 * Version of {@link ChatEventLogFilters} for method parameters.
 * Any of:
 * - {@link chatEventLogFilters$Input}
 */
export type ChatEventLogFilters$Input = chatEventLogFilters$Input;

/**
 * Any of:
 * - {@link languagePackStringValueOrdinary}
 * - {@link languagePackStringValuePluralized}
 * - {@link languagePackStringValueDeleted}
 */
export type LanguagePackStringValue =
  | languagePackStringValueOrdinary
  | languagePackStringValuePluralized
  | languagePackStringValueDeleted;

/**
 * Version of {@link LanguagePackStringValue} for method parameters.
 * Any of:
 * - {@link languagePackStringValueOrdinary$Input}
 * - {@link languagePackStringValuePluralized$Input}
 * - {@link languagePackStringValueDeleted$Input}
 */
export type LanguagePackStringValue$Input =
  | languagePackStringValueOrdinary$Input
  | languagePackStringValuePluralized$Input
  | languagePackStringValueDeleted$Input;

/**
 * Any of:
 * - {@link languagePackString}
 */
export type LanguagePackString = languagePackString;

/**
 * Version of {@link LanguagePackString} for method parameters.
 * Any of:
 * - {@link languagePackString$Input}
 */
export type LanguagePackString$Input = languagePackString$Input;

/**
 * Any of:
 * - {@link languagePackStrings}
 */
export type LanguagePackStrings = languagePackStrings;

/**
 * Version of {@link LanguagePackStrings} for method parameters.
 * Any of:
 * - {@link languagePackStrings$Input}
 */
export type LanguagePackStrings$Input = languagePackStrings$Input;

/**
 * Any of:
 * - {@link languagePackInfo}
 */
export type LanguagePackInfo = languagePackInfo;

/**
 * Version of {@link LanguagePackInfo} for method parameters.
 * Any of:
 * - {@link languagePackInfo$Input}
 */
export type LanguagePackInfo$Input = languagePackInfo$Input;

/**
 * Any of:
 * - {@link localizationTargetInfo}
 */
export type LocalizationTargetInfo = localizationTargetInfo;

/**
 * Version of {@link LocalizationTargetInfo} for method parameters.
 * Any of:
 * - {@link localizationTargetInfo$Input}
 */
export type LocalizationTargetInfo$Input = localizationTargetInfo$Input;

/**
 * Any of:
 * - {@link premiumLimitTypeSupergroupCount}
 * - {@link premiumLimitTypePinnedChatCount}
 * - {@link premiumLimitTypeCreatedPublicChatCount}
 * - {@link premiumLimitTypeSavedAnimationCount}
 * - {@link premiumLimitTypeFavoriteStickerCount}
 * - {@link premiumLimitTypeChatFolderCount}
 * - {@link premiumLimitTypeChatFolderChosenChatCount}
 * - {@link premiumLimitTypePinnedArchivedChatCount}
 * - {@link premiumLimitTypeCaptionLength}
 * - {@link premiumLimitTypeBioLength}
 * - {@link premiumLimitTypeChatFolderInviteLinkCount}
 * - {@link premiumLimitTypeShareableChatFolderCount}
 * - {@link premiumLimitTypeActiveStoryCount}
 * - {@link premiumLimitTypeWeeklySentStoryCount}
 * - {@link premiumLimitTypeMonthlySentStoryCount}
 * - {@link premiumLimitTypeStoryCaptionLength}
 * - {@link premiumLimitTypeStorySuggestedReactionAreaCount}
 * - {@link premiumLimitTypeSimilarChatCount}
 */
export type PremiumLimitType =
  | premiumLimitTypeSupergroupCount
  | premiumLimitTypePinnedChatCount
  | premiumLimitTypeCreatedPublicChatCount
  | premiumLimitTypeSavedAnimationCount
  | premiumLimitTypeFavoriteStickerCount
  | premiumLimitTypeChatFolderCount
  | premiumLimitTypeChatFolderChosenChatCount
  | premiumLimitTypePinnedArchivedChatCount
  | premiumLimitTypeCaptionLength
  | premiumLimitTypeBioLength
  | premiumLimitTypeChatFolderInviteLinkCount
  | premiumLimitTypeShareableChatFolderCount
  | premiumLimitTypeActiveStoryCount
  | premiumLimitTypeWeeklySentStoryCount
  | premiumLimitTypeMonthlySentStoryCount
  | premiumLimitTypeStoryCaptionLength
  | premiumLimitTypeStorySuggestedReactionAreaCount
  | premiumLimitTypeSimilarChatCount;

/**
 * Version of {@link PremiumLimitType} for method parameters.
 * Any of:
 * - {@link premiumLimitTypeSupergroupCount$Input}
 * - {@link premiumLimitTypePinnedChatCount$Input}
 * - {@link premiumLimitTypeCreatedPublicChatCount$Input}
 * - {@link premiumLimitTypeSavedAnimationCount$Input}
 * - {@link premiumLimitTypeFavoriteStickerCount$Input}
 * - {@link premiumLimitTypeChatFolderCount$Input}
 * - {@link premiumLimitTypeChatFolderChosenChatCount$Input}
 * - {@link premiumLimitTypePinnedArchivedChatCount$Input}
 * - {@link premiumLimitTypeCaptionLength$Input}
 * - {@link premiumLimitTypeBioLength$Input}
 * - {@link premiumLimitTypeChatFolderInviteLinkCount$Input}
 * - {@link premiumLimitTypeShareableChatFolderCount$Input}
 * - {@link premiumLimitTypeActiveStoryCount$Input}
 * - {@link premiumLimitTypeWeeklySentStoryCount$Input}
 * - {@link premiumLimitTypeMonthlySentStoryCount$Input}
 * - {@link premiumLimitTypeStoryCaptionLength$Input}
 * - {@link premiumLimitTypeStorySuggestedReactionAreaCount$Input}
 * - {@link premiumLimitTypeSimilarChatCount$Input}
 */
export type PremiumLimitType$Input =
  | premiumLimitTypeSupergroupCount$Input
  | premiumLimitTypePinnedChatCount$Input
  | premiumLimitTypeCreatedPublicChatCount$Input
  | premiumLimitTypeSavedAnimationCount$Input
  | premiumLimitTypeFavoriteStickerCount$Input
  | premiumLimitTypeChatFolderCount$Input
  | premiumLimitTypeChatFolderChosenChatCount$Input
  | premiumLimitTypePinnedArchivedChatCount$Input
  | premiumLimitTypeCaptionLength$Input
  | premiumLimitTypeBioLength$Input
  | premiumLimitTypeChatFolderInviteLinkCount$Input
  | premiumLimitTypeShareableChatFolderCount$Input
  | premiumLimitTypeActiveStoryCount$Input
  | premiumLimitTypeWeeklySentStoryCount$Input
  | premiumLimitTypeMonthlySentStoryCount$Input
  | premiumLimitTypeStoryCaptionLength$Input
  | premiumLimitTypeStorySuggestedReactionAreaCount$Input
  | premiumLimitTypeSimilarChatCount$Input;

/**
 * Any of:
 * - {@link premiumFeatureIncreasedLimits}
 * - {@link premiumFeatureIncreasedUploadFileSize}
 * - {@link premiumFeatureImprovedDownloadSpeed}
 * - {@link premiumFeatureVoiceRecognition}
 * - {@link premiumFeatureDisabledAds}
 * - {@link premiumFeatureUniqueReactions}
 * - {@link premiumFeatureUniqueStickers}
 * - {@link premiumFeatureCustomEmoji}
 * - {@link premiumFeatureAdvancedChatManagement}
 * - {@link premiumFeatureProfileBadge}
 * - {@link premiumFeatureEmojiStatus}
 * - {@link premiumFeatureAnimatedProfilePhoto}
 * - {@link premiumFeatureForumTopicIcon}
 * - {@link premiumFeatureAppIcons}
 * - {@link premiumFeatureRealTimeChatTranslation}
 * - {@link premiumFeatureUpgradedStories}
 * - {@link premiumFeatureChatBoost}
 * - {@link premiumFeatureAccentColor}
 * - {@link premiumFeatureBackgroundForBoth}
 */
export type PremiumFeature =
  | premiumFeatureIncreasedLimits
  | premiumFeatureIncreasedUploadFileSize
  | premiumFeatureImprovedDownloadSpeed
  | premiumFeatureVoiceRecognition
  | premiumFeatureDisabledAds
  | premiumFeatureUniqueReactions
  | premiumFeatureUniqueStickers
  | premiumFeatureCustomEmoji
  | premiumFeatureAdvancedChatManagement
  | premiumFeatureProfileBadge
  | premiumFeatureEmojiStatus
  | premiumFeatureAnimatedProfilePhoto
  | premiumFeatureForumTopicIcon
  | premiumFeatureAppIcons
  | premiumFeatureRealTimeChatTranslation
  | premiumFeatureUpgradedStories
  | premiumFeatureChatBoost
  | premiumFeatureAccentColor
  | premiumFeatureBackgroundForBoth;

/**
 * Version of {@link PremiumFeature} for method parameters.
 * Any of:
 * - {@link premiumFeatureIncreasedLimits$Input}
 * - {@link premiumFeatureIncreasedUploadFileSize$Input}
 * - {@link premiumFeatureImprovedDownloadSpeed$Input}
 * - {@link premiumFeatureVoiceRecognition$Input}
 * - {@link premiumFeatureDisabledAds$Input}
 * - {@link premiumFeatureUniqueReactions$Input}
 * - {@link premiumFeatureUniqueStickers$Input}
 * - {@link premiumFeatureCustomEmoji$Input}
 * - {@link premiumFeatureAdvancedChatManagement$Input}
 * - {@link premiumFeatureProfileBadge$Input}
 * - {@link premiumFeatureEmojiStatus$Input}
 * - {@link premiumFeatureAnimatedProfilePhoto$Input}
 * - {@link premiumFeatureForumTopicIcon$Input}
 * - {@link premiumFeatureAppIcons$Input}
 * - {@link premiumFeatureRealTimeChatTranslation$Input}
 * - {@link premiumFeatureUpgradedStories$Input}
 * - {@link premiumFeatureChatBoost$Input}
 * - {@link premiumFeatureAccentColor$Input}
 * - {@link premiumFeatureBackgroundForBoth$Input}
 */
export type PremiumFeature$Input =
  | premiumFeatureIncreasedLimits$Input
  | premiumFeatureIncreasedUploadFileSize$Input
  | premiumFeatureImprovedDownloadSpeed$Input
  | premiumFeatureVoiceRecognition$Input
  | premiumFeatureDisabledAds$Input
  | premiumFeatureUniqueReactions$Input
  | premiumFeatureUniqueStickers$Input
  | premiumFeatureCustomEmoji$Input
  | premiumFeatureAdvancedChatManagement$Input
  | premiumFeatureProfileBadge$Input
  | premiumFeatureEmojiStatus$Input
  | premiumFeatureAnimatedProfilePhoto$Input
  | premiumFeatureForumTopicIcon$Input
  | premiumFeatureAppIcons$Input
  | premiumFeatureRealTimeChatTranslation$Input
  | premiumFeatureUpgradedStories$Input
  | premiumFeatureChatBoost$Input
  | premiumFeatureAccentColor$Input
  | premiumFeatureBackgroundForBoth$Input;

/**
 * Any of:
 * - {@link premiumStoryFeaturePriorityOrder}
 * - {@link premiumStoryFeatureStealthMode}
 * - {@link premiumStoryFeaturePermanentViewsHistory}
 * - {@link premiumStoryFeatureCustomExpirationDuration}
 * - {@link premiumStoryFeatureSaveStories}
 * - {@link premiumStoryFeatureLinksAndFormatting}
 */
export type PremiumStoryFeature =
  | premiumStoryFeaturePriorityOrder
  | premiumStoryFeatureStealthMode
  | premiumStoryFeaturePermanentViewsHistory
  | premiumStoryFeatureCustomExpirationDuration
  | premiumStoryFeatureSaveStories
  | premiumStoryFeatureLinksAndFormatting;

/**
 * Version of {@link PremiumStoryFeature} for method parameters.
 * Any of:
 * - {@link premiumStoryFeaturePriorityOrder$Input}
 * - {@link premiumStoryFeatureStealthMode$Input}
 * - {@link premiumStoryFeaturePermanentViewsHistory$Input}
 * - {@link premiumStoryFeatureCustomExpirationDuration$Input}
 * - {@link premiumStoryFeatureSaveStories$Input}
 * - {@link premiumStoryFeatureLinksAndFormatting$Input}
 */
export type PremiumStoryFeature$Input =
  | premiumStoryFeaturePriorityOrder$Input
  | premiumStoryFeatureStealthMode$Input
  | premiumStoryFeaturePermanentViewsHistory$Input
  | premiumStoryFeatureCustomExpirationDuration$Input
  | premiumStoryFeatureSaveStories$Input
  | premiumStoryFeatureLinksAndFormatting$Input;

/**
 * Any of:
 * - {@link premiumLimit}
 */
export type PremiumLimit = premiumLimit;

/**
 * Version of {@link PremiumLimit} for method parameters.
 * Any of:
 * - {@link premiumLimit$Input}
 */
export type PremiumLimit$Input = premiumLimit$Input;

/**
 * Any of:
 * - {@link premiumFeatures}
 */
export type PremiumFeatures = premiumFeatures;

/**
 * Version of {@link PremiumFeatures} for method parameters.
 * Any of:
 * - {@link premiumFeatures$Input}
 */
export type PremiumFeatures$Input = premiumFeatures$Input;

/**
 * Any of:
 * - {@link premiumSourceLimitExceeded}
 * - {@link premiumSourceFeature}
 * - {@link premiumSourceStoryFeature}
 * - {@link premiumSourceLink}
 * - {@link premiumSourceSettings}
 */
export type PremiumSource =
  | premiumSourceLimitExceeded
  | premiumSourceFeature
  | premiumSourceStoryFeature
  | premiumSourceLink
  | premiumSourceSettings;

/**
 * Version of {@link PremiumSource} for method parameters.
 * Any of:
 * - {@link premiumSourceLimitExceeded$Input}
 * - {@link premiumSourceFeature$Input}
 * - {@link premiumSourceStoryFeature$Input}
 * - {@link premiumSourceLink$Input}
 * - {@link premiumSourceSettings$Input}
 */
export type PremiumSource$Input =
  | premiumSourceLimitExceeded$Input
  | premiumSourceFeature$Input
  | premiumSourceStoryFeature$Input
  | premiumSourceLink$Input
  | premiumSourceSettings$Input;

/**
 * Any of:
 * - {@link premiumFeaturePromotionAnimation}
 */
export type PremiumFeaturePromotionAnimation = premiumFeaturePromotionAnimation;

/**
 * Version of {@link PremiumFeaturePromotionAnimation} for method parameters.
 * Any of:
 * - {@link premiumFeaturePromotionAnimation$Input}
 */
export type PremiumFeaturePromotionAnimation$Input =
  premiumFeaturePromotionAnimation$Input;

/**
 * Any of:
 * - {@link premiumState}
 */
export type PremiumState = premiumState;

/**
 * Version of {@link PremiumState} for method parameters.
 * Any of:
 * - {@link premiumState$Input}
 */
export type PremiumState$Input = premiumState$Input;

/**
 * Any of:
 * - {@link storePaymentPurposePremiumSubscription}
 * - {@link storePaymentPurposeGiftedPremium}
 * - {@link storePaymentPurposePremiumGiftCodes}
 * - {@link storePaymentPurposePremiumGiveaway}
 */
export type StorePaymentPurpose =
  | storePaymentPurposePremiumSubscription
  | storePaymentPurposeGiftedPremium
  | storePaymentPurposePremiumGiftCodes
  | storePaymentPurposePremiumGiveaway;

/**
 * Version of {@link StorePaymentPurpose} for method parameters.
 * Any of:
 * - {@link storePaymentPurposePremiumSubscription$Input}
 * - {@link storePaymentPurposeGiftedPremium$Input}
 * - {@link storePaymentPurposePremiumGiftCodes$Input}
 * - {@link storePaymentPurposePremiumGiveaway$Input}
 */
export type StorePaymentPurpose$Input =
  | storePaymentPurposePremiumSubscription$Input
  | storePaymentPurposeGiftedPremium$Input
  | storePaymentPurposePremiumGiftCodes$Input
  | storePaymentPurposePremiumGiveaway$Input;

/**
 * Any of:
 * - {@link telegramPaymentPurposePremiumGiftCodes}
 * - {@link telegramPaymentPurposePremiumGiveaway}
 */
export type TelegramPaymentPurpose =
  | telegramPaymentPurposePremiumGiftCodes
  | telegramPaymentPurposePremiumGiveaway;

/**
 * Version of {@link TelegramPaymentPurpose} for method parameters.
 * Any of:
 * - {@link telegramPaymentPurposePremiumGiftCodes$Input}
 * - {@link telegramPaymentPurposePremiumGiveaway$Input}
 */
export type TelegramPaymentPurpose$Input =
  | telegramPaymentPurposePremiumGiftCodes$Input
  | telegramPaymentPurposePremiumGiveaway$Input;

/**
 * Any of:
 * - {@link deviceTokenFirebaseCloudMessaging}
 * - {@link deviceTokenApplePush}
 * - {@link deviceTokenApplePushVoIP}
 * - {@link deviceTokenWindowsPush}
 * - {@link deviceTokenMicrosoftPush}
 * - {@link deviceTokenMicrosoftPushVoIP}
 * - {@link deviceTokenWebPush}
 * - {@link deviceTokenSimplePush}
 * - {@link deviceTokenUbuntuPush}
 * - {@link deviceTokenBlackBerryPush}
 * - {@link deviceTokenTizenPush}
 * - {@link deviceTokenHuaweiPush}
 */
export type DeviceToken =
  | deviceTokenFirebaseCloudMessaging
  | deviceTokenApplePush
  | deviceTokenApplePushVoIP
  | deviceTokenWindowsPush
  | deviceTokenMicrosoftPush
  | deviceTokenMicrosoftPushVoIP
  | deviceTokenWebPush
  | deviceTokenSimplePush
  | deviceTokenUbuntuPush
  | deviceTokenBlackBerryPush
  | deviceTokenTizenPush
  | deviceTokenHuaweiPush;

/**
 * Version of {@link DeviceToken} for method parameters.
 * Any of:
 * - {@link deviceTokenFirebaseCloudMessaging$Input}
 * - {@link deviceTokenApplePush$Input}
 * - {@link deviceTokenApplePushVoIP$Input}
 * - {@link deviceTokenWindowsPush$Input}
 * - {@link deviceTokenMicrosoftPush$Input}
 * - {@link deviceTokenMicrosoftPushVoIP$Input}
 * - {@link deviceTokenWebPush$Input}
 * - {@link deviceTokenSimplePush$Input}
 * - {@link deviceTokenUbuntuPush$Input}
 * - {@link deviceTokenBlackBerryPush$Input}
 * - {@link deviceTokenTizenPush$Input}
 * - {@link deviceTokenHuaweiPush$Input}
 */
export type DeviceToken$Input =
  | deviceTokenFirebaseCloudMessaging$Input
  | deviceTokenApplePush$Input
  | deviceTokenApplePushVoIP$Input
  | deviceTokenWindowsPush$Input
  | deviceTokenMicrosoftPush$Input
  | deviceTokenMicrosoftPushVoIP$Input
  | deviceTokenWebPush$Input
  | deviceTokenSimplePush$Input
  | deviceTokenUbuntuPush$Input
  | deviceTokenBlackBerryPush$Input
  | deviceTokenTizenPush$Input
  | deviceTokenHuaweiPush$Input;

/**
 * Any of:
 * - {@link pushReceiverId}
 */
export type PushReceiverId = pushReceiverId;

/**
 * Version of {@link PushReceiverId} for method parameters.
 * Any of:
 * - {@link pushReceiverId$Input}
 */
export type PushReceiverId$Input = pushReceiverId$Input;

/**
 * Any of:
 * - {@link backgroundFillSolid}
 * - {@link backgroundFillGradient}
 * - {@link backgroundFillFreeformGradient}
 */
export type BackgroundFill =
  | backgroundFillSolid
  | backgroundFillGradient
  | backgroundFillFreeformGradient;

/**
 * Version of {@link BackgroundFill} for method parameters.
 * Any of:
 * - {@link backgroundFillSolid$Input}
 * - {@link backgroundFillGradient$Input}
 * - {@link backgroundFillFreeformGradient$Input}
 */
export type BackgroundFill$Input =
  | backgroundFillSolid$Input
  | backgroundFillGradient$Input
  | backgroundFillFreeformGradient$Input;

/**
 * Any of:
 * - {@link backgroundTypeWallpaper}
 * - {@link backgroundTypePattern}
 * - {@link backgroundTypeFill}
 * - {@link backgroundTypeChatTheme}
 */
export type BackgroundType =
  | backgroundTypeWallpaper
  | backgroundTypePattern
  | backgroundTypeFill
  | backgroundTypeChatTheme;

/**
 * Version of {@link BackgroundType} for method parameters.
 * Any of:
 * - {@link backgroundTypeWallpaper$Input}
 * - {@link backgroundTypePattern$Input}
 * - {@link backgroundTypeFill$Input}
 * - {@link backgroundTypeChatTheme$Input}
 */
export type BackgroundType$Input =
  | backgroundTypeWallpaper$Input
  | backgroundTypePattern$Input
  | backgroundTypeFill$Input
  | backgroundTypeChatTheme$Input;

/**
 * Any of:
 * - {@link inputBackgroundLocal}
 * - {@link inputBackgroundRemote}
 * - {@link inputBackgroundPrevious}
 */
export type InputBackground =
  | inputBackgroundLocal
  | inputBackgroundRemote
  | inputBackgroundPrevious;

/**
 * Version of {@link InputBackground} for method parameters.
 * Any of:
 * - {@link inputBackgroundLocal$Input}
 * - {@link inputBackgroundRemote$Input}
 * - {@link inputBackgroundPrevious$Input}
 */
export type InputBackground$Input =
  | inputBackgroundLocal$Input
  | inputBackgroundRemote$Input
  | inputBackgroundPrevious$Input;

/**
 * Any of:
 * - {@link themeSettings}
 */
export type ThemeSettings = themeSettings;

/**
 * Version of {@link ThemeSettings} for method parameters.
 * Any of:
 * - {@link themeSettings$Input}
 */
export type ThemeSettings$Input = themeSettings$Input;

/**
 * Any of:
 * - {@link chatTheme}
 */
export type ChatTheme = chatTheme;

/**
 * Version of {@link ChatTheme} for method parameters.
 * Any of:
 * - {@link chatTheme$Input}
 */
export type ChatTheme$Input = chatTheme$Input;

/**
 * Any of:
 * - {@link hashtags}
 */
export type Hashtags = hashtags;

/**
 * Version of {@link Hashtags} for method parameters.
 * Any of:
 * - {@link hashtags$Input}
 */
export type Hashtags$Input = hashtags$Input;

/**
 * Any of:
 * - {@link canSendStoryResultOk}
 * - {@link canSendStoryResultPremiumNeeded}
 * - {@link canSendStoryResultBoostNeeded}
 * - {@link canSendStoryResultActiveStoryLimitExceeded}
 * - {@link canSendStoryResultWeeklyLimitExceeded}
 * - {@link canSendStoryResultMonthlyLimitExceeded}
 */
export type CanSendStoryResult =
  | canSendStoryResultOk
  | canSendStoryResultPremiumNeeded
  | canSendStoryResultBoostNeeded
  | canSendStoryResultActiveStoryLimitExceeded
  | canSendStoryResultWeeklyLimitExceeded
  | canSendStoryResultMonthlyLimitExceeded;

/**
 * Version of {@link CanSendStoryResult} for method parameters.
 * Any of:
 * - {@link canSendStoryResultOk$Input}
 * - {@link canSendStoryResultPremiumNeeded$Input}
 * - {@link canSendStoryResultBoostNeeded$Input}
 * - {@link canSendStoryResultActiveStoryLimitExceeded$Input}
 * - {@link canSendStoryResultWeeklyLimitExceeded$Input}
 * - {@link canSendStoryResultMonthlyLimitExceeded$Input}
 */
export type CanSendStoryResult$Input =
  | canSendStoryResultOk$Input
  | canSendStoryResultPremiumNeeded$Input
  | canSendStoryResultBoostNeeded$Input
  | canSendStoryResultActiveStoryLimitExceeded$Input
  | canSendStoryResultWeeklyLimitExceeded$Input
  | canSendStoryResultMonthlyLimitExceeded$Input;

/**
 * Any of:
 * - {@link canTransferOwnershipResultOk}
 * - {@link canTransferOwnershipResultPasswordNeeded}
 * - {@link canTransferOwnershipResultPasswordTooFresh}
 * - {@link canTransferOwnershipResultSessionTooFresh}
 */
export type CanTransferOwnershipResult =
  | canTransferOwnershipResultOk
  | canTransferOwnershipResultPasswordNeeded
  | canTransferOwnershipResultPasswordTooFresh
  | canTransferOwnershipResultSessionTooFresh;

/**
 * Version of {@link CanTransferOwnershipResult} for method parameters.
 * Any of:
 * - {@link canTransferOwnershipResultOk$Input}
 * - {@link canTransferOwnershipResultPasswordNeeded$Input}
 * - {@link canTransferOwnershipResultPasswordTooFresh$Input}
 * - {@link canTransferOwnershipResultSessionTooFresh$Input}
 */
export type CanTransferOwnershipResult$Input =
  | canTransferOwnershipResultOk$Input
  | canTransferOwnershipResultPasswordNeeded$Input
  | canTransferOwnershipResultPasswordTooFresh$Input
  | canTransferOwnershipResultSessionTooFresh$Input;

/**
 * Any of:
 * - {@link checkChatUsernameResultOk}
 * - {@link checkChatUsernameResultUsernameInvalid}
 * - {@link checkChatUsernameResultUsernameOccupied}
 * - {@link checkChatUsernameResultUsernamePurchasable}
 * - {@link checkChatUsernameResultPublicChatsTooMany}
 * - {@link checkChatUsernameResultPublicGroupsUnavailable}
 */
export type CheckChatUsernameResult =
  | checkChatUsernameResultOk
  | checkChatUsernameResultUsernameInvalid
  | checkChatUsernameResultUsernameOccupied
  | checkChatUsernameResultUsernamePurchasable
  | checkChatUsernameResultPublicChatsTooMany
  | checkChatUsernameResultPublicGroupsUnavailable;

/**
 * Version of {@link CheckChatUsernameResult} for method parameters.
 * Any of:
 * - {@link checkChatUsernameResultOk$Input}
 * - {@link checkChatUsernameResultUsernameInvalid$Input}
 * - {@link checkChatUsernameResultUsernameOccupied$Input}
 * - {@link checkChatUsernameResultUsernamePurchasable$Input}
 * - {@link checkChatUsernameResultPublicChatsTooMany$Input}
 * - {@link checkChatUsernameResultPublicGroupsUnavailable$Input}
 */
export type CheckChatUsernameResult$Input =
  | checkChatUsernameResultOk$Input
  | checkChatUsernameResultUsernameInvalid$Input
  | checkChatUsernameResultUsernameOccupied$Input
  | checkChatUsernameResultUsernamePurchasable$Input
  | checkChatUsernameResultPublicChatsTooMany$Input
  | checkChatUsernameResultPublicGroupsUnavailable$Input;

/**
 * Any of:
 * - {@link checkStickerSetNameResultOk}
 * - {@link checkStickerSetNameResultNameInvalid}
 * - {@link checkStickerSetNameResultNameOccupied}
 */
export type CheckStickerSetNameResult =
  | checkStickerSetNameResultOk
  | checkStickerSetNameResultNameInvalid
  | checkStickerSetNameResultNameOccupied;

/**
 * Version of {@link CheckStickerSetNameResult} for method parameters.
 * Any of:
 * - {@link checkStickerSetNameResultOk$Input}
 * - {@link checkStickerSetNameResultNameInvalid$Input}
 * - {@link checkStickerSetNameResultNameOccupied$Input}
 */
export type CheckStickerSetNameResult$Input =
  | checkStickerSetNameResultOk$Input
  | checkStickerSetNameResultNameInvalid$Input
  | checkStickerSetNameResultNameOccupied$Input;

/**
 * Any of:
 * - {@link resetPasswordResultOk}
 * - {@link resetPasswordResultPending}
 * - {@link resetPasswordResultDeclined}
 */
export type ResetPasswordResult =
  | resetPasswordResultOk
  | resetPasswordResultPending
  | resetPasswordResultDeclined;

/**
 * Version of {@link ResetPasswordResult} for method parameters.
 * Any of:
 * - {@link resetPasswordResultOk$Input}
 * - {@link resetPasswordResultPending$Input}
 * - {@link resetPasswordResultDeclined$Input}
 */
export type ResetPasswordResult$Input =
  | resetPasswordResultOk$Input
  | resetPasswordResultPending$Input
  | resetPasswordResultDeclined$Input;

/**
 * Any of:
 * - {@link messageFileTypePrivate}
 * - {@link messageFileTypeGroup}
 * - {@link messageFileTypeUnknown}
 */
export type MessageFileType =
  | messageFileTypePrivate
  | messageFileTypeGroup
  | messageFileTypeUnknown;

/**
 * Version of {@link MessageFileType} for method parameters.
 * Any of:
 * - {@link messageFileTypePrivate$Input}
 * - {@link messageFileTypeGroup$Input}
 * - {@link messageFileTypeUnknown$Input}
 */
export type MessageFileType$Input =
  | messageFileTypePrivate$Input
  | messageFileTypeGroup$Input
  | messageFileTypeUnknown$Input;

/**
 * Any of:
 * - {@link pushMessageContentHidden}
 * - {@link pushMessageContentAnimation}
 * - {@link pushMessageContentAudio}
 * - {@link pushMessageContentContact}
 * - {@link pushMessageContentContactRegistered}
 * - {@link pushMessageContentDocument}
 * - {@link pushMessageContentGame}
 * - {@link pushMessageContentGameScore}
 * - {@link pushMessageContentInvoice}
 * - {@link pushMessageContentLocation}
 * - {@link pushMessageContentPhoto}
 * - {@link pushMessageContentPoll}
 * - {@link pushMessageContentPremiumGiftCode}
 * - {@link pushMessageContentPremiumGiveaway}
 * - {@link pushMessageContentScreenshotTaken}
 * - {@link pushMessageContentSticker}
 * - {@link pushMessageContentStory}
 * - {@link pushMessageContentText}
 * - {@link pushMessageContentVideo}
 * - {@link pushMessageContentVideoNote}
 * - {@link pushMessageContentVoiceNote}
 * - {@link pushMessageContentBasicGroupChatCreate}
 * - {@link pushMessageContentChatAddMembers}
 * - {@link pushMessageContentChatChangePhoto}
 * - {@link pushMessageContentChatChangeTitle}
 * - {@link pushMessageContentChatSetBackground}
 * - {@link pushMessageContentChatSetTheme}
 * - {@link pushMessageContentChatDeleteMember}
 * - {@link pushMessageContentChatJoinByLink}
 * - {@link pushMessageContentChatJoinByRequest}
 * - {@link pushMessageContentRecurringPayment}
 * - {@link pushMessageContentSuggestProfilePhoto}
 * - {@link pushMessageContentMessageForwards}
 * - {@link pushMessageContentMediaAlbum}
 */
export type PushMessageContent =
  | pushMessageContentHidden
  | pushMessageContentAnimation
  | pushMessageContentAudio
  | pushMessageContentContact
  | pushMessageContentContactRegistered
  | pushMessageContentDocument
  | pushMessageContentGame
  | pushMessageContentGameScore
  | pushMessageContentInvoice
  | pushMessageContentLocation
  | pushMessageContentPhoto
  | pushMessageContentPoll
  | pushMessageContentPremiumGiftCode
  | pushMessageContentPremiumGiveaway
  | pushMessageContentScreenshotTaken
  | pushMessageContentSticker
  | pushMessageContentStory
  | pushMessageContentText
  | pushMessageContentVideo
  | pushMessageContentVideoNote
  | pushMessageContentVoiceNote
  | pushMessageContentBasicGroupChatCreate
  | pushMessageContentChatAddMembers
  | pushMessageContentChatChangePhoto
  | pushMessageContentChatChangeTitle
  | pushMessageContentChatSetBackground
  | pushMessageContentChatSetTheme
  | pushMessageContentChatDeleteMember
  | pushMessageContentChatJoinByLink
  | pushMessageContentChatJoinByRequest
  | pushMessageContentRecurringPayment
  | pushMessageContentSuggestProfilePhoto
  | pushMessageContentMessageForwards
  | pushMessageContentMediaAlbum;

/**
 * Version of {@link PushMessageContent} for method parameters.
 * Any of:
 * - {@link pushMessageContentHidden$Input}
 * - {@link pushMessageContentAnimation$Input}
 * - {@link pushMessageContentAudio$Input}
 * - {@link pushMessageContentContact$Input}
 * - {@link pushMessageContentContactRegistered$Input}
 * - {@link pushMessageContentDocument$Input}
 * - {@link pushMessageContentGame$Input}
 * - {@link pushMessageContentGameScore$Input}
 * - {@link pushMessageContentInvoice$Input}
 * - {@link pushMessageContentLocation$Input}
 * - {@link pushMessageContentPhoto$Input}
 * - {@link pushMessageContentPoll$Input}
 * - {@link pushMessageContentPremiumGiftCode$Input}
 * - {@link pushMessageContentPremiumGiveaway$Input}
 * - {@link pushMessageContentScreenshotTaken$Input}
 * - {@link pushMessageContentSticker$Input}
 * - {@link pushMessageContentStory$Input}
 * - {@link pushMessageContentText$Input}
 * - {@link pushMessageContentVideo$Input}
 * - {@link pushMessageContentVideoNote$Input}
 * - {@link pushMessageContentVoiceNote$Input}
 * - {@link pushMessageContentBasicGroupChatCreate$Input}
 * - {@link pushMessageContentChatAddMembers$Input}
 * - {@link pushMessageContentChatChangePhoto$Input}
 * - {@link pushMessageContentChatChangeTitle$Input}
 * - {@link pushMessageContentChatSetBackground$Input}
 * - {@link pushMessageContentChatSetTheme$Input}
 * - {@link pushMessageContentChatDeleteMember$Input}
 * - {@link pushMessageContentChatJoinByLink$Input}
 * - {@link pushMessageContentChatJoinByRequest$Input}
 * - {@link pushMessageContentRecurringPayment$Input}
 * - {@link pushMessageContentSuggestProfilePhoto$Input}
 * - {@link pushMessageContentMessageForwards$Input}
 * - {@link pushMessageContentMediaAlbum$Input}
 */
export type PushMessageContent$Input =
  | pushMessageContentHidden$Input
  | pushMessageContentAnimation$Input
  | pushMessageContentAudio$Input
  | pushMessageContentContact$Input
  | pushMessageContentContactRegistered$Input
  | pushMessageContentDocument$Input
  | pushMessageContentGame$Input
  | pushMessageContentGameScore$Input
  | pushMessageContentInvoice$Input
  | pushMessageContentLocation$Input
  | pushMessageContentPhoto$Input
  | pushMessageContentPoll$Input
  | pushMessageContentPremiumGiftCode$Input
  | pushMessageContentPremiumGiveaway$Input
  | pushMessageContentScreenshotTaken$Input
  | pushMessageContentSticker$Input
  | pushMessageContentStory$Input
  | pushMessageContentText$Input
  | pushMessageContentVideo$Input
  | pushMessageContentVideoNote$Input
  | pushMessageContentVoiceNote$Input
  | pushMessageContentBasicGroupChatCreate$Input
  | pushMessageContentChatAddMembers$Input
  | pushMessageContentChatChangePhoto$Input
  | pushMessageContentChatChangeTitle$Input
  | pushMessageContentChatSetBackground$Input
  | pushMessageContentChatSetTheme$Input
  | pushMessageContentChatDeleteMember$Input
  | pushMessageContentChatJoinByLink$Input
  | pushMessageContentChatJoinByRequest$Input
  | pushMessageContentRecurringPayment$Input
  | pushMessageContentSuggestProfilePhoto$Input
  | pushMessageContentMessageForwards$Input
  | pushMessageContentMediaAlbum$Input;

/**
 * Any of:
 * - {@link notificationTypeNewMessage}
 * - {@link notificationTypeNewSecretChat}
 * - {@link notificationTypeNewCall}
 * - {@link notificationTypeNewPushMessage}
 */
export type NotificationType =
  | notificationTypeNewMessage
  | notificationTypeNewSecretChat
  | notificationTypeNewCall
  | notificationTypeNewPushMessage;

/**
 * Version of {@link NotificationType} for method parameters.
 * Any of:
 * - {@link notificationTypeNewMessage$Input}
 * - {@link notificationTypeNewSecretChat$Input}
 * - {@link notificationTypeNewCall$Input}
 * - {@link notificationTypeNewPushMessage$Input}
 */
export type NotificationType$Input =
  | notificationTypeNewMessage$Input
  | notificationTypeNewSecretChat$Input
  | notificationTypeNewCall$Input
  | notificationTypeNewPushMessage$Input;

/**
 * Any of:
 * - {@link notificationGroupTypeMessages}
 * - {@link notificationGroupTypeMentions}
 * - {@link notificationGroupTypeSecretChat}
 * - {@link notificationGroupTypeCalls}
 */
export type NotificationGroupType =
  | notificationGroupTypeMessages
  | notificationGroupTypeMentions
  | notificationGroupTypeSecretChat
  | notificationGroupTypeCalls;

/**
 * Version of {@link NotificationGroupType} for method parameters.
 * Any of:
 * - {@link notificationGroupTypeMessages$Input}
 * - {@link notificationGroupTypeMentions$Input}
 * - {@link notificationGroupTypeSecretChat$Input}
 * - {@link notificationGroupTypeCalls$Input}
 */
export type NotificationGroupType$Input =
  | notificationGroupTypeMessages$Input
  | notificationGroupTypeMentions$Input
  | notificationGroupTypeSecretChat$Input
  | notificationGroupTypeCalls$Input;

/**
 * Any of:
 * - {@link notificationSound}
 */
export type NotificationSound = notificationSound;

/**
 * Version of {@link NotificationSound} for method parameters.
 * Any of:
 * - {@link notificationSound$Input}
 */
export type NotificationSound$Input = notificationSound$Input;

/**
 * Any of:
 * - {@link notificationSounds}
 */
export type NotificationSounds = notificationSounds;

/**
 * Version of {@link NotificationSounds} for method parameters.
 * Any of:
 * - {@link notificationSounds$Input}
 */
export type NotificationSounds$Input = notificationSounds$Input;

/**
 * Any of:
 * - {@link notification}
 */
export type Notification = notification;

/**
 * Version of {@link Notification} for method parameters.
 * Any of:
 * - {@link notification$Input}
 */
export type Notification$Input = notification$Input;

/**
 * Any of:
 * - {@link notificationGroup}
 */
export type NotificationGroup = notificationGroup;

/**
 * Version of {@link NotificationGroup} for method parameters.
 * Any of:
 * - {@link notificationGroup$Input}
 */
export type NotificationGroup$Input = notificationGroup$Input;

/**
 * Any of:
 * - {@link optionValueBoolean}
 * - {@link optionValueEmpty}
 * - {@link optionValueInteger}
 * - {@link optionValueString}
 */
export type OptionValue =
  | optionValueBoolean
  | optionValueEmpty
  | optionValueInteger
  | optionValueString;

/**
 * Version of {@link OptionValue} for method parameters.
 * Any of:
 * - {@link optionValueBoolean$Input}
 * - {@link optionValueEmpty$Input}
 * - {@link optionValueInteger$Input}
 * - {@link optionValueString$Input}
 */
export type OptionValue$Input =
  | optionValueBoolean$Input
  | optionValueEmpty$Input
  | optionValueInteger$Input
  | optionValueString$Input;

/**
 * Any of:
 * - {@link jsonObjectMember}
 */
export type JsonObjectMember = jsonObjectMember;

/**
 * Version of {@link JsonObjectMember} for method parameters.
 * Any of:
 * - {@link jsonObjectMember$Input}
 */
export type JsonObjectMember$Input = jsonObjectMember$Input;

/**
 * Any of:
 * - {@link jsonValueNull}
 * - {@link jsonValueBoolean}
 * - {@link jsonValueNumber}
 * - {@link jsonValueString}
 * - {@link jsonValueArray}
 * - {@link jsonValueObject}
 */
export type JsonValue =
  | jsonValueNull
  | jsonValueBoolean
  | jsonValueNumber
  | jsonValueString
  | jsonValueArray
  | jsonValueObject;

/**
 * Version of {@link JsonValue} for method parameters.
 * Any of:
 * - {@link jsonValueNull$Input}
 * - {@link jsonValueBoolean$Input}
 * - {@link jsonValueNumber$Input}
 * - {@link jsonValueString$Input}
 * - {@link jsonValueArray$Input}
 * - {@link jsonValueObject$Input}
 */
export type JsonValue$Input =
  | jsonValueNull$Input
  | jsonValueBoolean$Input
  | jsonValueNumber$Input
  | jsonValueString$Input
  | jsonValueArray$Input
  | jsonValueObject$Input;

/**
 * Any of:
 * - {@link storyPrivacySettingsEveryone}
 * - {@link storyPrivacySettingsContacts}
 * - {@link storyPrivacySettingsCloseFriends}
 * - {@link storyPrivacySettingsSelectedUsers}
 */
export type StoryPrivacySettings =
  | storyPrivacySettingsEveryone
  | storyPrivacySettingsContacts
  | storyPrivacySettingsCloseFriends
  | storyPrivacySettingsSelectedUsers;

/**
 * Version of {@link StoryPrivacySettings} for method parameters.
 * Any of:
 * - {@link storyPrivacySettingsEveryone$Input}
 * - {@link storyPrivacySettingsContacts$Input}
 * - {@link storyPrivacySettingsCloseFriends$Input}
 * - {@link storyPrivacySettingsSelectedUsers$Input}
 */
export type StoryPrivacySettings$Input =
  | storyPrivacySettingsEveryone$Input
  | storyPrivacySettingsContacts$Input
  | storyPrivacySettingsCloseFriends$Input
  | storyPrivacySettingsSelectedUsers$Input;

/**
 * Any of:
 * - {@link userPrivacySettingRuleAllowAll}
 * - {@link userPrivacySettingRuleAllowContacts}
 * - {@link userPrivacySettingRuleAllowUsers}
 * - {@link userPrivacySettingRuleAllowChatMembers}
 * - {@link userPrivacySettingRuleRestrictAll}
 * - {@link userPrivacySettingRuleRestrictContacts}
 * - {@link userPrivacySettingRuleRestrictUsers}
 * - {@link userPrivacySettingRuleRestrictChatMembers}
 */
export type UserPrivacySettingRule =
  | userPrivacySettingRuleAllowAll
  | userPrivacySettingRuleAllowContacts
  | userPrivacySettingRuleAllowUsers
  | userPrivacySettingRuleAllowChatMembers
  | userPrivacySettingRuleRestrictAll
  | userPrivacySettingRuleRestrictContacts
  | userPrivacySettingRuleRestrictUsers
  | userPrivacySettingRuleRestrictChatMembers;

/**
 * Version of {@link UserPrivacySettingRule} for method parameters.
 * Any of:
 * - {@link userPrivacySettingRuleAllowAll$Input}
 * - {@link userPrivacySettingRuleAllowContacts$Input}
 * - {@link userPrivacySettingRuleAllowUsers$Input}
 * - {@link userPrivacySettingRuleAllowChatMembers$Input}
 * - {@link userPrivacySettingRuleRestrictAll$Input}
 * - {@link userPrivacySettingRuleRestrictContacts$Input}
 * - {@link userPrivacySettingRuleRestrictUsers$Input}
 * - {@link userPrivacySettingRuleRestrictChatMembers$Input}
 */
export type UserPrivacySettingRule$Input =
  | userPrivacySettingRuleAllowAll$Input
  | userPrivacySettingRuleAllowContacts$Input
  | userPrivacySettingRuleAllowUsers$Input
  | userPrivacySettingRuleAllowChatMembers$Input
  | userPrivacySettingRuleRestrictAll$Input
  | userPrivacySettingRuleRestrictContacts$Input
  | userPrivacySettingRuleRestrictUsers$Input
  | userPrivacySettingRuleRestrictChatMembers$Input;

/**
 * Any of:
 * - {@link userPrivacySettingRules}
 */
export type UserPrivacySettingRules = userPrivacySettingRules;

/**
 * Version of {@link UserPrivacySettingRules} for method parameters.
 * Any of:
 * - {@link userPrivacySettingRules$Input}
 */
export type UserPrivacySettingRules$Input = userPrivacySettingRules$Input;

/**
 * Any of:
 * - {@link userPrivacySettingShowStatus}
 * - {@link userPrivacySettingShowProfilePhoto}
 * - {@link userPrivacySettingShowLinkInForwardedMessages}
 * - {@link userPrivacySettingShowPhoneNumber}
 * - {@link userPrivacySettingShowBio}
 * - {@link userPrivacySettingAllowChatInvites}
 * - {@link userPrivacySettingAllowCalls}
 * - {@link userPrivacySettingAllowPeerToPeerCalls}
 * - {@link userPrivacySettingAllowFindingByPhoneNumber}
 * - {@link userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages}
 */
export type UserPrivacySetting =
  | userPrivacySettingShowStatus
  | userPrivacySettingShowProfilePhoto
  | userPrivacySettingShowLinkInForwardedMessages
  | userPrivacySettingShowPhoneNumber
  | userPrivacySettingShowBio
  | userPrivacySettingAllowChatInvites
  | userPrivacySettingAllowCalls
  | userPrivacySettingAllowPeerToPeerCalls
  | userPrivacySettingAllowFindingByPhoneNumber
  | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages;

/**
 * Version of {@link UserPrivacySetting} for method parameters.
 * Any of:
 * - {@link userPrivacySettingShowStatus$Input}
 * - {@link userPrivacySettingShowProfilePhoto$Input}
 * - {@link userPrivacySettingShowLinkInForwardedMessages$Input}
 * - {@link userPrivacySettingShowPhoneNumber$Input}
 * - {@link userPrivacySettingShowBio$Input}
 * - {@link userPrivacySettingAllowChatInvites$Input}
 * - {@link userPrivacySettingAllowCalls$Input}
 * - {@link userPrivacySettingAllowPeerToPeerCalls$Input}
 * - {@link userPrivacySettingAllowFindingByPhoneNumber$Input}
 * - {@link userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input}
 */
export type UserPrivacySetting$Input =
  | userPrivacySettingShowStatus$Input
  | userPrivacySettingShowProfilePhoto$Input
  | userPrivacySettingShowLinkInForwardedMessages$Input
  | userPrivacySettingShowPhoneNumber$Input
  | userPrivacySettingShowBio$Input
  | userPrivacySettingAllowChatInvites$Input
  | userPrivacySettingAllowCalls$Input
  | userPrivacySettingAllowPeerToPeerCalls$Input
  | userPrivacySettingAllowFindingByPhoneNumber$Input
  | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input;

/**
 * Any of:
 * - {@link accountTtl}
 */
export type AccountTtl = accountTtl;

/**
 * Version of {@link AccountTtl} for method parameters.
 * Any of:
 * - {@link accountTtl$Input}
 */
export type AccountTtl$Input = accountTtl$Input;

/**
 * Any of:
 * - {@link messageAutoDeleteTime}
 */
export type MessageAutoDeleteTime = messageAutoDeleteTime;

/**
 * Version of {@link MessageAutoDeleteTime} for method parameters.
 * Any of:
 * - {@link messageAutoDeleteTime$Input}
 */
export type MessageAutoDeleteTime$Input = messageAutoDeleteTime$Input;

/**
 * Any of:
 * - {@link sessionTypeAndroid}
 * - {@link sessionTypeApple}
 * - {@link sessionTypeBrave}
 * - {@link sessionTypeChrome}
 * - {@link sessionTypeEdge}
 * - {@link sessionTypeFirefox}
 * - {@link sessionTypeIpad}
 * - {@link sessionTypeIphone}
 * - {@link sessionTypeLinux}
 * - {@link sessionTypeMac}
 * - {@link sessionTypeOpera}
 * - {@link sessionTypeSafari}
 * - {@link sessionTypeUbuntu}
 * - {@link sessionTypeUnknown}
 * - {@link sessionTypeVivaldi}
 * - {@link sessionTypeWindows}
 * - {@link sessionTypeXbox}
 */
export type SessionType =
  | sessionTypeAndroid
  | sessionTypeApple
  | sessionTypeBrave
  | sessionTypeChrome
  | sessionTypeEdge
  | sessionTypeFirefox
  | sessionTypeIpad
  | sessionTypeIphone
  | sessionTypeLinux
  | sessionTypeMac
  | sessionTypeOpera
  | sessionTypeSafari
  | sessionTypeUbuntu
  | sessionTypeUnknown
  | sessionTypeVivaldi
  | sessionTypeWindows
  | sessionTypeXbox;

/**
 * Version of {@link SessionType} for method parameters.
 * Any of:
 * - {@link sessionTypeAndroid$Input}
 * - {@link sessionTypeApple$Input}
 * - {@link sessionTypeBrave$Input}
 * - {@link sessionTypeChrome$Input}
 * - {@link sessionTypeEdge$Input}
 * - {@link sessionTypeFirefox$Input}
 * - {@link sessionTypeIpad$Input}
 * - {@link sessionTypeIphone$Input}
 * - {@link sessionTypeLinux$Input}
 * - {@link sessionTypeMac$Input}
 * - {@link sessionTypeOpera$Input}
 * - {@link sessionTypeSafari$Input}
 * - {@link sessionTypeUbuntu$Input}
 * - {@link sessionTypeUnknown$Input}
 * - {@link sessionTypeVivaldi$Input}
 * - {@link sessionTypeWindows$Input}
 * - {@link sessionTypeXbox$Input}
 */
export type SessionType$Input =
  | sessionTypeAndroid$Input
  | sessionTypeApple$Input
  | sessionTypeBrave$Input
  | sessionTypeChrome$Input
  | sessionTypeEdge$Input
  | sessionTypeFirefox$Input
  | sessionTypeIpad$Input
  | sessionTypeIphone$Input
  | sessionTypeLinux$Input
  | sessionTypeMac$Input
  | sessionTypeOpera$Input
  | sessionTypeSafari$Input
  | sessionTypeUbuntu$Input
  | sessionTypeUnknown$Input
  | sessionTypeVivaldi$Input
  | sessionTypeWindows$Input
  | sessionTypeXbox$Input;

/**
 * Any of:
 * - {@link session}
 */
export type Session = session;

/**
 * Version of {@link Session} for method parameters.
 * Any of:
 * - {@link session$Input}
 */
export type Session$Input = session$Input;

/**
 * Any of:
 * - {@link sessions}
 */
export type Sessions = sessions;

/**
 * Version of {@link Sessions} for method parameters.
 * Any of:
 * - {@link sessions$Input}
 */
export type Sessions$Input = sessions$Input;

/**
 * Any of:
 * - {@link unconfirmedSession}
 */
export type UnconfirmedSession = unconfirmedSession;

/**
 * Version of {@link UnconfirmedSession} for method parameters.
 * Any of:
 * - {@link unconfirmedSession$Input}
 */
export type UnconfirmedSession$Input = unconfirmedSession$Input;

/**
 * Any of:
 * - {@link connectedWebsite}
 */
export type ConnectedWebsite = connectedWebsite;

/**
 * Version of {@link ConnectedWebsite} for method parameters.
 * Any of:
 * - {@link connectedWebsite$Input}
 */
export type ConnectedWebsite$Input = connectedWebsite$Input;

/**
 * Any of:
 * - {@link connectedWebsites}
 */
export type ConnectedWebsites = connectedWebsites;

/**
 * Version of {@link ConnectedWebsites} for method parameters.
 * Any of:
 * - {@link connectedWebsites$Input}
 */
export type ConnectedWebsites$Input = connectedWebsites$Input;

/**
 * Any of:
 * - {@link reportReasonSpam}
 * - {@link reportReasonViolence}
 * - {@link reportReasonPornography}
 * - {@link reportReasonChildAbuse}
 * - {@link reportReasonCopyright}
 * - {@link reportReasonUnrelatedLocation}
 * - {@link reportReasonFake}
 * - {@link reportReasonIllegalDrugs}
 * - {@link reportReasonPersonalDetails}
 * - {@link reportReasonCustom}
 */
export type ReportReason =
  | reportReasonSpam
  | reportReasonViolence
  | reportReasonPornography
  | reportReasonChildAbuse
  | reportReasonCopyright
  | reportReasonUnrelatedLocation
  | reportReasonFake
  | reportReasonIllegalDrugs
  | reportReasonPersonalDetails
  | reportReasonCustom;

/**
 * Version of {@link ReportReason} for method parameters.
 * Any of:
 * - {@link reportReasonSpam$Input}
 * - {@link reportReasonViolence$Input}
 * - {@link reportReasonPornography$Input}
 * - {@link reportReasonChildAbuse$Input}
 * - {@link reportReasonCopyright$Input}
 * - {@link reportReasonUnrelatedLocation$Input}
 * - {@link reportReasonFake$Input}
 * - {@link reportReasonIllegalDrugs$Input}
 * - {@link reportReasonPersonalDetails$Input}
 * - {@link reportReasonCustom$Input}
 */
export type ReportReason$Input =
  | reportReasonSpam$Input
  | reportReasonViolence$Input
  | reportReasonPornography$Input
  | reportReasonChildAbuse$Input
  | reportReasonCopyright$Input
  | reportReasonUnrelatedLocation$Input
  | reportReasonFake$Input
  | reportReasonIllegalDrugs$Input
  | reportReasonPersonalDetails$Input
  | reportReasonCustom$Input;

/**
 * Any of:
 * - {@link targetChatCurrent}
 * - {@link targetChatChosen}
 * - {@link targetChatInternalLink}
 */
export type TargetChat =
  | targetChatCurrent
  | targetChatChosen
  | targetChatInternalLink;

/**
 * Version of {@link TargetChat} for method parameters.
 * Any of:
 * - {@link targetChatCurrent$Input}
 * - {@link targetChatChosen$Input}
 * - {@link targetChatInternalLink$Input}
 */
export type TargetChat$Input =
  | targetChatCurrent$Input
  | targetChatChosen$Input
  | targetChatInternalLink$Input;

/**
 * Any of:
 * - {@link internalLinkTypeActiveSessions}
 * - {@link internalLinkTypeAttachmentMenuBot}
 * - {@link internalLinkTypeAuthenticationCode}
 * - {@link internalLinkTypeBackground}
 * - {@link internalLinkTypeBotAddToChannel}
 * - {@link internalLinkTypeBotStart}
 * - {@link internalLinkTypeBotStartInGroup}
 * - {@link internalLinkTypeChangePhoneNumber}
 * - {@link internalLinkTypeChatBoost}
 * - {@link internalLinkTypeChatFolderInvite}
 * - {@link internalLinkTypeChatFolderSettings}
 * - {@link internalLinkTypeChatInvite}
 * - {@link internalLinkTypeDefaultMessageAutoDeleteTimerSettings}
 * - {@link internalLinkTypeEditProfileSettings}
 * - {@link internalLinkTypeGame}
 * - {@link internalLinkTypeInstantView}
 * - {@link internalLinkTypeInvoice}
 * - {@link internalLinkTypeLanguagePack}
 * - {@link internalLinkTypeLanguageSettings}
 * - {@link internalLinkTypeMessage}
 * - {@link internalLinkTypeMessageDraft}
 * - {@link internalLinkTypePassportDataRequest}
 * - {@link internalLinkTypePhoneNumberConfirmation}
 * - {@link internalLinkTypePremiumFeatures}
 * - {@link internalLinkTypePremiumGift}
 * - {@link internalLinkTypePremiumGiftCode}
 * - {@link internalLinkTypePrivacyAndSecuritySettings}
 * - {@link internalLinkTypeProxy}
 * - {@link internalLinkTypePublicChat}
 * - {@link internalLinkTypeQrCodeAuthentication}
 * - {@link internalLinkTypeRestorePurchases}
 * - {@link internalLinkTypeSettings}
 * - {@link internalLinkTypeSideMenuBot}
 * - {@link internalLinkTypeStickerSet}
 * - {@link internalLinkTypeStory}
 * - {@link internalLinkTypeTheme}
 * - {@link internalLinkTypeThemeSettings}
 * - {@link internalLinkTypeUnknownDeepLink}
 * - {@link internalLinkTypeUnsupportedProxy}
 * - {@link internalLinkTypeUserPhoneNumber}
 * - {@link internalLinkTypeUserToken}
 * - {@link internalLinkTypeVideoChat}
 * - {@link internalLinkTypeWebApp}
 */
export type InternalLinkType =
  | internalLinkTypeActiveSessions
  | internalLinkTypeAttachmentMenuBot
  | internalLinkTypeAuthenticationCode
  | internalLinkTypeBackground
  | internalLinkTypeBotAddToChannel
  | internalLinkTypeBotStart
  | internalLinkTypeBotStartInGroup
  | internalLinkTypeChangePhoneNumber
  | internalLinkTypeChatBoost
  | internalLinkTypeChatFolderInvite
  | internalLinkTypeChatFolderSettings
  | internalLinkTypeChatInvite
  | internalLinkTypeDefaultMessageAutoDeleteTimerSettings
  | internalLinkTypeEditProfileSettings
  | internalLinkTypeGame
  | internalLinkTypeInstantView
  | internalLinkTypeInvoice
  | internalLinkTypeLanguagePack
  | internalLinkTypeLanguageSettings
  | internalLinkTypeMessage
  | internalLinkTypeMessageDraft
  | internalLinkTypePassportDataRequest
  | internalLinkTypePhoneNumberConfirmation
  | internalLinkTypePremiumFeatures
  | internalLinkTypePremiumGift
  | internalLinkTypePremiumGiftCode
  | internalLinkTypePrivacyAndSecuritySettings
  | internalLinkTypeProxy
  | internalLinkTypePublicChat
  | internalLinkTypeQrCodeAuthentication
  | internalLinkTypeRestorePurchases
  | internalLinkTypeSettings
  | internalLinkTypeSideMenuBot
  | internalLinkTypeStickerSet
  | internalLinkTypeStory
  | internalLinkTypeTheme
  | internalLinkTypeThemeSettings
  | internalLinkTypeUnknownDeepLink
  | internalLinkTypeUnsupportedProxy
  | internalLinkTypeUserPhoneNumber
  | internalLinkTypeUserToken
  | internalLinkTypeVideoChat
  | internalLinkTypeWebApp;

/**
 * Version of {@link InternalLinkType} for method parameters.
 * Any of:
 * - {@link internalLinkTypeActiveSessions$Input}
 * - {@link internalLinkTypeAttachmentMenuBot$Input}
 * - {@link internalLinkTypeAuthenticationCode$Input}
 * - {@link internalLinkTypeBackground$Input}
 * - {@link internalLinkTypeBotAddToChannel$Input}
 * - {@link internalLinkTypeBotStart$Input}
 * - {@link internalLinkTypeBotStartInGroup$Input}
 * - {@link internalLinkTypeChangePhoneNumber$Input}
 * - {@link internalLinkTypeChatBoost$Input}
 * - {@link internalLinkTypeChatFolderInvite$Input}
 * - {@link internalLinkTypeChatFolderSettings$Input}
 * - {@link internalLinkTypeChatInvite$Input}
 * - {@link internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input}
 * - {@link internalLinkTypeEditProfileSettings$Input}
 * - {@link internalLinkTypeGame$Input}
 * - {@link internalLinkTypeInstantView$Input}
 * - {@link internalLinkTypeInvoice$Input}
 * - {@link internalLinkTypeLanguagePack$Input}
 * - {@link internalLinkTypeLanguageSettings$Input}
 * - {@link internalLinkTypeMessage$Input}
 * - {@link internalLinkTypeMessageDraft$Input}
 * - {@link internalLinkTypePassportDataRequest$Input}
 * - {@link internalLinkTypePhoneNumberConfirmation$Input}
 * - {@link internalLinkTypePremiumFeatures$Input}
 * - {@link internalLinkTypePremiumGift$Input}
 * - {@link internalLinkTypePremiumGiftCode$Input}
 * - {@link internalLinkTypePrivacyAndSecuritySettings$Input}
 * - {@link internalLinkTypeProxy$Input}
 * - {@link internalLinkTypePublicChat$Input}
 * - {@link internalLinkTypeQrCodeAuthentication$Input}
 * - {@link internalLinkTypeRestorePurchases$Input}
 * - {@link internalLinkTypeSettings$Input}
 * - {@link internalLinkTypeSideMenuBot$Input}
 * - {@link internalLinkTypeStickerSet$Input}
 * - {@link internalLinkTypeStory$Input}
 * - {@link internalLinkTypeTheme$Input}
 * - {@link internalLinkTypeThemeSettings$Input}
 * - {@link internalLinkTypeUnknownDeepLink$Input}
 * - {@link internalLinkTypeUnsupportedProxy$Input}
 * - {@link internalLinkTypeUserPhoneNumber$Input}
 * - {@link internalLinkTypeUserToken$Input}
 * - {@link internalLinkTypeVideoChat$Input}
 * - {@link internalLinkTypeWebApp$Input}
 */
export type InternalLinkType$Input =
  | internalLinkTypeActiveSessions$Input
  | internalLinkTypeAttachmentMenuBot$Input
  | internalLinkTypeAuthenticationCode$Input
  | internalLinkTypeBackground$Input
  | internalLinkTypeBotAddToChannel$Input
  | internalLinkTypeBotStart$Input
  | internalLinkTypeBotStartInGroup$Input
  | internalLinkTypeChangePhoneNumber$Input
  | internalLinkTypeChatBoost$Input
  | internalLinkTypeChatFolderInvite$Input
  | internalLinkTypeChatFolderSettings$Input
  | internalLinkTypeChatInvite$Input
  | internalLinkTypeDefaultMessageAutoDeleteTimerSettings$Input
  | internalLinkTypeEditProfileSettings$Input
  | internalLinkTypeGame$Input
  | internalLinkTypeInstantView$Input
  | internalLinkTypeInvoice$Input
  | internalLinkTypeLanguagePack$Input
  | internalLinkTypeLanguageSettings$Input
  | internalLinkTypeMessage$Input
  | internalLinkTypeMessageDraft$Input
  | internalLinkTypePassportDataRequest$Input
  | internalLinkTypePhoneNumberConfirmation$Input
  | internalLinkTypePremiumFeatures$Input
  | internalLinkTypePremiumGift$Input
  | internalLinkTypePremiumGiftCode$Input
  | internalLinkTypePrivacyAndSecuritySettings$Input
  | internalLinkTypeProxy$Input
  | internalLinkTypePublicChat$Input
  | internalLinkTypeQrCodeAuthentication$Input
  | internalLinkTypeRestorePurchases$Input
  | internalLinkTypeSettings$Input
  | internalLinkTypeSideMenuBot$Input
  | internalLinkTypeStickerSet$Input
  | internalLinkTypeStory$Input
  | internalLinkTypeTheme$Input
  | internalLinkTypeThemeSettings$Input
  | internalLinkTypeUnknownDeepLink$Input
  | internalLinkTypeUnsupportedProxy$Input
  | internalLinkTypeUserPhoneNumber$Input
  | internalLinkTypeUserToken$Input
  | internalLinkTypeVideoChat$Input
  | internalLinkTypeWebApp$Input;

/**
 * Any of:
 * - {@link messageLink}
 */
export type MessageLink = messageLink;

/**
 * Version of {@link MessageLink} for method parameters.
 * Any of:
 * - {@link messageLink$Input}
 */
export type MessageLink$Input = messageLink$Input;

/**
 * Any of:
 * - {@link messageLinkInfo}
 */
export type MessageLinkInfo = messageLinkInfo;

/**
 * Version of {@link MessageLinkInfo} for method parameters.
 * Any of:
 * - {@link messageLinkInfo$Input}
 */
export type MessageLinkInfo$Input = messageLinkInfo$Input;

/**
 * Any of:
 * - {@link chatBoostLink}
 */
export type ChatBoostLink = chatBoostLink;

/**
 * Version of {@link ChatBoostLink} for method parameters.
 * Any of:
 * - {@link chatBoostLink$Input}
 */
export type ChatBoostLink$Input = chatBoostLink$Input;

/**
 * Any of:
 * - {@link chatBoostLinkInfo}
 */
export type ChatBoostLinkInfo = chatBoostLinkInfo;

/**
 * Version of {@link ChatBoostLinkInfo} for method parameters.
 * Any of:
 * - {@link chatBoostLinkInfo$Input}
 */
export type ChatBoostLinkInfo$Input = chatBoostLinkInfo$Input;

/**
 * Any of:
 * - {@link blockListMain}
 * - {@link blockListStories}
 */
export type BlockList = blockListMain | blockListStories;

/**
 * Version of {@link BlockList} for method parameters.
 * Any of:
 * - {@link blockListMain$Input}
 * - {@link blockListStories$Input}
 */
export type BlockList$Input = blockListMain$Input | blockListStories$Input;

/**
 * Any of:
 * - {@link filePart}
 */
export type FilePart = filePart;

/**
 * Version of {@link FilePart} for method parameters.
 * Any of:
 * - {@link filePart$Input}
 */
export type FilePart$Input = filePart$Input;

/**
 * Any of:
 * - {@link fileTypeNone}
 * - {@link fileTypeAnimation}
 * - {@link fileTypeAudio}
 * - {@link fileTypeDocument}
 * - {@link fileTypeNotificationSound}
 * - {@link fileTypePhoto}
 * - {@link fileTypePhotoStory}
 * - {@link fileTypeProfilePhoto}
 * - {@link fileTypeSecret}
 * - {@link fileTypeSecretThumbnail}
 * - {@link fileTypeSecure}
 * - {@link fileTypeSticker}
 * - {@link fileTypeThumbnail}
 * - {@link fileTypeUnknown}
 * - {@link fileTypeVideo}
 * - {@link fileTypeVideoNote}
 * - {@link fileTypeVideoStory}
 * - {@link fileTypeVoiceNote}
 * - {@link fileTypeWallpaper}
 */
export type FileType =
  | fileTypeNone
  | fileTypeAnimation
  | fileTypeAudio
  | fileTypeDocument
  | fileTypeNotificationSound
  | fileTypePhoto
  | fileTypePhotoStory
  | fileTypeProfilePhoto
  | fileTypeSecret
  | fileTypeSecretThumbnail
  | fileTypeSecure
  | fileTypeSticker
  | fileTypeThumbnail
  | fileTypeUnknown
  | fileTypeVideo
  | fileTypeVideoNote
  | fileTypeVideoStory
  | fileTypeVoiceNote
  | fileTypeWallpaper;

/**
 * Version of {@link FileType} for method parameters.
 * Any of:
 * - {@link fileTypeNone$Input}
 * - {@link fileTypeAnimation$Input}
 * - {@link fileTypeAudio$Input}
 * - {@link fileTypeDocument$Input}
 * - {@link fileTypeNotificationSound$Input}
 * - {@link fileTypePhoto$Input}
 * - {@link fileTypePhotoStory$Input}
 * - {@link fileTypeProfilePhoto$Input}
 * - {@link fileTypeSecret$Input}
 * - {@link fileTypeSecretThumbnail$Input}
 * - {@link fileTypeSecure$Input}
 * - {@link fileTypeSticker$Input}
 * - {@link fileTypeThumbnail$Input}
 * - {@link fileTypeUnknown$Input}
 * - {@link fileTypeVideo$Input}
 * - {@link fileTypeVideoNote$Input}
 * - {@link fileTypeVideoStory$Input}
 * - {@link fileTypeVoiceNote$Input}
 * - {@link fileTypeWallpaper$Input}
 */
export type FileType$Input =
  | fileTypeNone$Input
  | fileTypeAnimation$Input
  | fileTypeAudio$Input
  | fileTypeDocument$Input
  | fileTypeNotificationSound$Input
  | fileTypePhoto$Input
  | fileTypePhotoStory$Input
  | fileTypeProfilePhoto$Input
  | fileTypeSecret$Input
  | fileTypeSecretThumbnail$Input
  | fileTypeSecure$Input
  | fileTypeSticker$Input
  | fileTypeThumbnail$Input
  | fileTypeUnknown$Input
  | fileTypeVideo$Input
  | fileTypeVideoNote$Input
  | fileTypeVideoStory$Input
  | fileTypeVoiceNote$Input
  | fileTypeWallpaper$Input;

/**
 * Any of:
 * - {@link storageStatisticsByFileType}
 */
export type StorageStatisticsByFileType = storageStatisticsByFileType;

/**
 * Version of {@link StorageStatisticsByFileType} for method parameters.
 * Any of:
 * - {@link storageStatisticsByFileType$Input}
 */
export type StorageStatisticsByFileType$Input = storageStatisticsByFileType$Input;

/**
 * Any of:
 * - {@link storageStatisticsByChat}
 */
export type StorageStatisticsByChat = storageStatisticsByChat;

/**
 * Version of {@link StorageStatisticsByChat} for method parameters.
 * Any of:
 * - {@link storageStatisticsByChat$Input}
 */
export type StorageStatisticsByChat$Input = storageStatisticsByChat$Input;

/**
 * Any of:
 * - {@link storageStatistics}
 */
export type StorageStatistics = storageStatistics;

/**
 * Version of {@link StorageStatistics} for method parameters.
 * Any of:
 * - {@link storageStatistics$Input}
 */
export type StorageStatistics$Input = storageStatistics$Input;

/**
 * Any of:
 * - {@link storageStatisticsFast}
 */
export type StorageStatisticsFast = storageStatisticsFast;

/**
 * Version of {@link StorageStatisticsFast} for method parameters.
 * Any of:
 * - {@link storageStatisticsFast$Input}
 */
export type StorageStatisticsFast$Input = storageStatisticsFast$Input;

/**
 * Any of:
 * - {@link databaseStatistics}
 */
export type DatabaseStatistics = databaseStatistics;

/**
 * Version of {@link DatabaseStatistics} for method parameters.
 * Any of:
 * - {@link databaseStatistics$Input}
 */
export type DatabaseStatistics$Input = databaseStatistics$Input;

/**
 * Any of:
 * - {@link networkTypeNone}
 * - {@link networkTypeMobile}
 * - {@link networkTypeMobileRoaming}
 * - {@link networkTypeWiFi}
 * - {@link networkTypeOther}
 */
export type NetworkType =
  | networkTypeNone
  | networkTypeMobile
  | networkTypeMobileRoaming
  | networkTypeWiFi
  | networkTypeOther;

/**
 * Version of {@link NetworkType} for method parameters.
 * Any of:
 * - {@link networkTypeNone$Input}
 * - {@link networkTypeMobile$Input}
 * - {@link networkTypeMobileRoaming$Input}
 * - {@link networkTypeWiFi$Input}
 * - {@link networkTypeOther$Input}
 */
export type NetworkType$Input =
  | networkTypeNone$Input
  | networkTypeMobile$Input
  | networkTypeMobileRoaming$Input
  | networkTypeWiFi$Input
  | networkTypeOther$Input;

/**
 * Any of:
 * - {@link networkStatisticsEntryFile}
 * - {@link networkStatisticsEntryCall}
 */
export type NetworkStatisticsEntry =
  | networkStatisticsEntryFile
  | networkStatisticsEntryCall;

/**
 * Version of {@link NetworkStatisticsEntry} for method parameters.
 * Any of:
 * - {@link networkStatisticsEntryFile$Input}
 * - {@link networkStatisticsEntryCall$Input}
 */
export type NetworkStatisticsEntry$Input =
  | networkStatisticsEntryFile$Input
  | networkStatisticsEntryCall$Input;

/**
 * Any of:
 * - {@link networkStatistics}
 */
export type NetworkStatistics = networkStatistics;

/**
 * Version of {@link NetworkStatistics} for method parameters.
 * Any of:
 * - {@link networkStatistics$Input}
 */
export type NetworkStatistics$Input = networkStatistics$Input;

/**
 * Any of:
 * - {@link autoDownloadSettings}
 */
export type AutoDownloadSettings = autoDownloadSettings;

/**
 * Version of {@link AutoDownloadSettings} for method parameters.
 * Any of:
 * - {@link autoDownloadSettings$Input}
 */
export type AutoDownloadSettings$Input = autoDownloadSettings$Input;

/**
 * Any of:
 * - {@link autoDownloadSettingsPresets}
 */
export type AutoDownloadSettingsPresets = autoDownloadSettingsPresets;

/**
 * Version of {@link AutoDownloadSettingsPresets} for method parameters.
 * Any of:
 * - {@link autoDownloadSettingsPresets$Input}
 */
export type AutoDownloadSettingsPresets$Input = autoDownloadSettingsPresets$Input;

/**
 * Any of:
 * - {@link autosaveSettingsScopePrivateChats}
 * - {@link autosaveSettingsScopeGroupChats}
 * - {@link autosaveSettingsScopeChannelChats}
 * - {@link autosaveSettingsScopeChat}
 */
export type AutosaveSettingsScope =
  | autosaveSettingsScopePrivateChats
  | autosaveSettingsScopeGroupChats
  | autosaveSettingsScopeChannelChats
  | autosaveSettingsScopeChat;

/**
 * Version of {@link AutosaveSettingsScope} for method parameters.
 * Any of:
 * - {@link autosaveSettingsScopePrivateChats$Input}
 * - {@link autosaveSettingsScopeGroupChats$Input}
 * - {@link autosaveSettingsScopeChannelChats$Input}
 * - {@link autosaveSettingsScopeChat$Input}
 */
export type AutosaveSettingsScope$Input =
  | autosaveSettingsScopePrivateChats$Input
  | autosaveSettingsScopeGroupChats$Input
  | autosaveSettingsScopeChannelChats$Input
  | autosaveSettingsScopeChat$Input;

/**
 * Any of:
 * - {@link scopeAutosaveSettings}
 */
export type ScopeAutosaveSettings = scopeAutosaveSettings;

/**
 * Version of {@link ScopeAutosaveSettings} for method parameters.
 * Any of:
 * - {@link scopeAutosaveSettings$Input}
 */
export type ScopeAutosaveSettings$Input = scopeAutosaveSettings$Input;

/**
 * Any of:
 * - {@link autosaveSettingsException}
 */
export type AutosaveSettingsException = autosaveSettingsException;

/**
 * Version of {@link AutosaveSettingsException} for method parameters.
 * Any of:
 * - {@link autosaveSettingsException$Input}
 */
export type AutosaveSettingsException$Input = autosaveSettingsException$Input;

/**
 * Any of:
 * - {@link autosaveSettings}
 */
export type AutosaveSettings = autosaveSettings;

/**
 * Version of {@link AutosaveSettings} for method parameters.
 * Any of:
 * - {@link autosaveSettings$Input}
 */
export type AutosaveSettings$Input = autosaveSettings$Input;

/**
 * Any of:
 * - {@link connectionStateWaitingForNetwork}
 * - {@link connectionStateConnectingToProxy}
 * - {@link connectionStateConnecting}
 * - {@link connectionStateUpdating}
 * - {@link connectionStateReady}
 */
export type ConnectionState =
  | connectionStateWaitingForNetwork
  | connectionStateConnectingToProxy
  | connectionStateConnecting
  | connectionStateUpdating
  | connectionStateReady;

/**
 * Version of {@link ConnectionState} for method parameters.
 * Any of:
 * - {@link connectionStateWaitingForNetwork$Input}
 * - {@link connectionStateConnectingToProxy$Input}
 * - {@link connectionStateConnecting$Input}
 * - {@link connectionStateUpdating$Input}
 * - {@link connectionStateReady$Input}
 */
export type ConnectionState$Input =
  | connectionStateWaitingForNetwork$Input
  | connectionStateConnectingToProxy$Input
  | connectionStateConnecting$Input
  | connectionStateUpdating$Input
  | connectionStateReady$Input;

/**
 * Any of:
 * - {@link topChatCategoryUsers}
 * - {@link topChatCategoryBots}
 * - {@link topChatCategoryGroups}
 * - {@link topChatCategoryChannels}
 * - {@link topChatCategoryInlineBots}
 * - {@link topChatCategoryCalls}
 * - {@link topChatCategoryForwardChats}
 */
export type TopChatCategory =
  | topChatCategoryUsers
  | topChatCategoryBots
  | topChatCategoryGroups
  | topChatCategoryChannels
  | topChatCategoryInlineBots
  | topChatCategoryCalls
  | topChatCategoryForwardChats;

/**
 * Version of {@link TopChatCategory} for method parameters.
 * Any of:
 * - {@link topChatCategoryUsers$Input}
 * - {@link topChatCategoryBots$Input}
 * - {@link topChatCategoryGroups$Input}
 * - {@link topChatCategoryChannels$Input}
 * - {@link topChatCategoryInlineBots$Input}
 * - {@link topChatCategoryCalls$Input}
 * - {@link topChatCategoryForwardChats$Input}
 */
export type TopChatCategory$Input =
  | topChatCategoryUsers$Input
  | topChatCategoryBots$Input
  | topChatCategoryGroups$Input
  | topChatCategoryChannels$Input
  | topChatCategoryInlineBots$Input
  | topChatCategoryCalls$Input
  | topChatCategoryForwardChats$Input;

/**
 * Any of:
 * - {@link foundPosition}
 */
export type FoundPosition = foundPosition;

/**
 * Version of {@link FoundPosition} for method parameters.
 * Any of:
 * - {@link foundPosition$Input}
 */
export type FoundPosition$Input = foundPosition$Input;

/**
 * Any of:
 * - {@link foundPositions}
 */
export type FoundPositions = foundPositions;

/**
 * Version of {@link FoundPositions} for method parameters.
 * Any of:
 * - {@link foundPositions$Input}
 */
export type FoundPositions$Input = foundPositions$Input;

/**
 * Any of:
 * - {@link tMeUrlTypeUser}
 * - {@link tMeUrlTypeSupergroup}
 * - {@link tMeUrlTypeChatInvite}
 * - {@link tMeUrlTypeStickerSet}
 */
export type TMeUrlType =
  | tMeUrlTypeUser
  | tMeUrlTypeSupergroup
  | tMeUrlTypeChatInvite
  | tMeUrlTypeStickerSet;

/**
 * Version of {@link TMeUrlType} for method parameters.
 * Any of:
 * - {@link tMeUrlTypeUser$Input}
 * - {@link tMeUrlTypeSupergroup$Input}
 * - {@link tMeUrlTypeChatInvite$Input}
 * - {@link tMeUrlTypeStickerSet$Input}
 */
export type TMeUrlType$Input =
  | tMeUrlTypeUser$Input
  | tMeUrlTypeSupergroup$Input
  | tMeUrlTypeChatInvite$Input
  | tMeUrlTypeStickerSet$Input;

/**
 * Any of:
 * - {@link tMeUrl}
 */
export type TMeUrl = tMeUrl;

/**
 * Version of {@link TMeUrl} for method parameters.
 * Any of:
 * - {@link tMeUrl$Input}
 */
export type TMeUrl$Input = tMeUrl$Input;

/**
 * Any of:
 * - {@link tMeUrls}
 */
export type TMeUrls = tMeUrls;

/**
 * Version of {@link TMeUrls} for method parameters.
 * Any of:
 * - {@link tMeUrls$Input}
 */
export type TMeUrls$Input = tMeUrls$Input;

/**
 * Any of:
 * - {@link suggestedActionEnableArchiveAndMuteNewChats}
 * - {@link suggestedActionCheckPassword}
 * - {@link suggestedActionCheckPhoneNumber}
 * - {@link suggestedActionViewChecksHint}
 * - {@link suggestedActionConvertToBroadcastGroup}
 * - {@link suggestedActionSetPassword}
 * - {@link suggestedActionUpgradePremium}
 * - {@link suggestedActionRestorePremium}
 * - {@link suggestedActionSubscribeToAnnualPremium}
 * - {@link suggestedActionGiftPremiumForChristmas}
 */
export type SuggestedAction =
  | suggestedActionEnableArchiveAndMuteNewChats
  | suggestedActionCheckPassword
  | suggestedActionCheckPhoneNumber
  | suggestedActionViewChecksHint
  | suggestedActionConvertToBroadcastGroup
  | suggestedActionSetPassword
  | suggestedActionUpgradePremium
  | suggestedActionRestorePremium
  | suggestedActionSubscribeToAnnualPremium
  | suggestedActionGiftPremiumForChristmas;

/**
 * Version of {@link SuggestedAction} for method parameters.
 * Any of:
 * - {@link suggestedActionEnableArchiveAndMuteNewChats$Input}
 * - {@link suggestedActionCheckPassword$Input}
 * - {@link suggestedActionCheckPhoneNumber$Input}
 * - {@link suggestedActionViewChecksHint$Input}
 * - {@link suggestedActionConvertToBroadcastGroup$Input}
 * - {@link suggestedActionSetPassword$Input}
 * - {@link suggestedActionUpgradePremium$Input}
 * - {@link suggestedActionRestorePremium$Input}
 * - {@link suggestedActionSubscribeToAnnualPremium$Input}
 * - {@link suggestedActionGiftPremiumForChristmas$Input}
 */
export type SuggestedAction$Input =
  | suggestedActionEnableArchiveAndMuteNewChats$Input
  | suggestedActionCheckPassword$Input
  | suggestedActionCheckPhoneNumber$Input
  | suggestedActionViewChecksHint$Input
  | suggestedActionConvertToBroadcastGroup$Input
  | suggestedActionSetPassword$Input
  | suggestedActionUpgradePremium$Input
  | suggestedActionRestorePremium$Input
  | suggestedActionSubscribeToAnnualPremium$Input
  | suggestedActionGiftPremiumForChristmas$Input;

/**
 * Any of:
 * - {@link count}
 */
export type Count = count;

/**
 * Version of {@link Count} for method parameters.
 * Any of:
 * - {@link count$Input}
 */
export type Count$Input = count$Input;

/**
 * Any of:
 * - {@link text}
 */
export type Text = text;

/**
 * Version of {@link Text} for method parameters.
 * Any of:
 * - {@link text$Input}
 */
export type Text$Input = text$Input;

/**
 * Any of:
 * - {@link seconds}
 */
export type Seconds = seconds;

/**
 * Version of {@link Seconds} for method parameters.
 * Any of:
 * - {@link seconds$Input}
 */
export type Seconds$Input = seconds$Input;

/**
 * Any of:
 * - {@link fileDownloadedPrefixSize}
 */
export type FileDownloadedPrefixSize = fileDownloadedPrefixSize;

/**
 * Version of {@link FileDownloadedPrefixSize} for method parameters.
 * Any of:
 * - {@link fileDownloadedPrefixSize$Input}
 */
export type FileDownloadedPrefixSize$Input = fileDownloadedPrefixSize$Input;

/**
 * Any of:
 * - {@link deepLinkInfo}
 */
export type DeepLinkInfo = deepLinkInfo;

/**
 * Version of {@link DeepLinkInfo} for method parameters.
 * Any of:
 * - {@link deepLinkInfo$Input}
 */
export type DeepLinkInfo$Input = deepLinkInfo$Input;

/**
 * Any of:
 * - {@link textParseModeMarkdown}
 * - {@link textParseModeHTML}
 */
export type TextParseMode = textParseModeMarkdown | textParseModeHTML;

/**
 * Version of {@link TextParseMode} for method parameters.
 * Any of:
 * - {@link textParseModeMarkdown$Input}
 * - {@link textParseModeHTML$Input}
 */
export type TextParseMode$Input =
  | textParseModeMarkdown$Input
  | textParseModeHTML$Input;

/**
 * Any of:
 * - {@link proxyTypeSocks5}
 * - {@link proxyTypeHttp}
 * - {@link proxyTypeMtproto}
 */
export type ProxyType = proxyTypeSocks5 | proxyTypeHttp | proxyTypeMtproto;

/**
 * Version of {@link ProxyType} for method parameters.
 * Any of:
 * - {@link proxyTypeSocks5$Input}
 * - {@link proxyTypeHttp$Input}
 * - {@link proxyTypeMtproto$Input}
 */
export type ProxyType$Input =
  | proxyTypeSocks5$Input
  | proxyTypeHttp$Input
  | proxyTypeMtproto$Input;

/**
 * Any of:
 * - {@link proxy}
 */
export type Proxy = proxy;

/**
 * Version of {@link Proxy} for method parameters.
 * Any of:
 * - {@link proxy$Input}
 */
export type Proxy$Input = proxy$Input;

/**
 * Any of:
 * - {@link proxies}
 */
export type Proxies = proxies;

/**
 * Version of {@link Proxies} for method parameters.
 * Any of:
 * - {@link proxies$Input}
 */
export type Proxies$Input = proxies$Input;

/**
 * Any of:
 * - {@link inputSticker}
 */
export type InputSticker = inputSticker;

/**
 * Version of {@link InputSticker} for method parameters.
 * Any of:
 * - {@link inputSticker$Input}
 */
export type InputSticker$Input = inputSticker$Input;

/**
 * Any of:
 * - {@link dateRange}
 */
export type DateRange = dateRange;

/**
 * Version of {@link DateRange} for method parameters.
 * Any of:
 * - {@link dateRange$Input}
 */
export type DateRange$Input = dateRange$Input;

/**
 * Any of:
 * - {@link statisticalValue}
 */
export type StatisticalValue = statisticalValue;

/**
 * Version of {@link StatisticalValue} for method parameters.
 * Any of:
 * - {@link statisticalValue$Input}
 */
export type StatisticalValue$Input = statisticalValue$Input;

/**
 * Any of:
 * - {@link statisticalGraphData}
 * - {@link statisticalGraphAsync}
 * - {@link statisticalGraphError}
 */
export type StatisticalGraph =
  | statisticalGraphData
  | statisticalGraphAsync
  | statisticalGraphError;

/**
 * Version of {@link StatisticalGraph} for method parameters.
 * Any of:
 * - {@link statisticalGraphData$Input}
 * - {@link statisticalGraphAsync$Input}
 * - {@link statisticalGraphError$Input}
 */
export type StatisticalGraph$Input =
  | statisticalGraphData$Input
  | statisticalGraphAsync$Input
  | statisticalGraphError$Input;

/**
 * Any of:
 * - {@link chatStatisticsObjectTypeMessage}
 * - {@link chatStatisticsObjectTypeStory}
 */
export type ChatStatisticsObjectType =
  | chatStatisticsObjectTypeMessage
  | chatStatisticsObjectTypeStory;

/**
 * Version of {@link ChatStatisticsObjectType} for method parameters.
 * Any of:
 * - {@link chatStatisticsObjectTypeMessage$Input}
 * - {@link chatStatisticsObjectTypeStory$Input}
 */
export type ChatStatisticsObjectType$Input =
  | chatStatisticsObjectTypeMessage$Input
  | chatStatisticsObjectTypeStory$Input;

/**
 * Any of:
 * - {@link chatStatisticsInteractionInfo}
 */
export type ChatStatisticsInteractionInfo = chatStatisticsInteractionInfo;

/**
 * Version of {@link ChatStatisticsInteractionInfo} for method parameters.
 * Any of:
 * - {@link chatStatisticsInteractionInfo$Input}
 */
export type ChatStatisticsInteractionInfo$Input =
  chatStatisticsInteractionInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsMessageSenderInfo}
 */
export type ChatStatisticsMessageSenderInfo = chatStatisticsMessageSenderInfo;

/**
 * Version of {@link ChatStatisticsMessageSenderInfo} for method parameters.
 * Any of:
 * - {@link chatStatisticsMessageSenderInfo$Input}
 */
export type ChatStatisticsMessageSenderInfo$Input =
  chatStatisticsMessageSenderInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsAdministratorActionsInfo}
 */
export type ChatStatisticsAdministratorActionsInfo =
  chatStatisticsAdministratorActionsInfo;

/**
 * Version of {@link ChatStatisticsAdministratorActionsInfo} for method parameters.
 * Any of:
 * - {@link chatStatisticsAdministratorActionsInfo$Input}
 */
export type ChatStatisticsAdministratorActionsInfo$Input =
  chatStatisticsAdministratorActionsInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsInviterInfo}
 */
export type ChatStatisticsInviterInfo = chatStatisticsInviterInfo;

/**
 * Version of {@link ChatStatisticsInviterInfo} for method parameters.
 * Any of:
 * - {@link chatStatisticsInviterInfo$Input}
 */
export type ChatStatisticsInviterInfo$Input = chatStatisticsInviterInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsSupergroup}
 * - {@link chatStatisticsChannel}
 */
export type ChatStatistics = chatStatisticsSupergroup | chatStatisticsChannel;

/**
 * Version of {@link ChatStatistics} for method parameters.
 * Any of:
 * - {@link chatStatisticsSupergroup$Input}
 * - {@link chatStatisticsChannel$Input}
 */
export type ChatStatistics$Input =
  | chatStatisticsSupergroup$Input
  | chatStatisticsChannel$Input;

/**
 * Any of:
 * - {@link messageStatistics}
 */
export type MessageStatistics = messageStatistics;

/**
 * Version of {@link MessageStatistics} for method parameters.
 * Any of:
 * - {@link messageStatistics$Input}
 */
export type MessageStatistics$Input = messageStatistics$Input;

/**
 * Any of:
 * - {@link storyStatistics}
 */
export type StoryStatistics = storyStatistics;

/**
 * Version of {@link StoryStatistics} for method parameters.
 * Any of:
 * - {@link storyStatistics$Input}
 */
export type StoryStatistics$Input = storyStatistics$Input;

/**
 * Any of:
 * - {@link point}
 */
export type Point = point;

/**
 * Version of {@link Point} for method parameters.
 * Any of:
 * - {@link point$Input}
 */
export type Point$Input = point$Input;

/**
 * Any of:
 * - {@link vectorPathCommandLine}
 * - {@link vectorPathCommandCubicBezierCurve}
 */
export type VectorPathCommand =
  | vectorPathCommandLine
  | vectorPathCommandCubicBezierCurve;

/**
 * Version of {@link VectorPathCommand} for method parameters.
 * Any of:
 * - {@link vectorPathCommandLine$Input}
 * - {@link vectorPathCommandCubicBezierCurve$Input}
 */
export type VectorPathCommand$Input =
  | vectorPathCommandLine$Input
  | vectorPathCommandCubicBezierCurve$Input;

/**
 * Any of:
 * - {@link botCommandScopeDefault}
 * - {@link botCommandScopeAllPrivateChats}
 * - {@link botCommandScopeAllGroupChats}
 * - {@link botCommandScopeAllChatAdministrators}
 * - {@link botCommandScopeChat}
 * - {@link botCommandScopeChatAdministrators}
 * - {@link botCommandScopeChatMember}
 */
export type BotCommandScope =
  | botCommandScopeDefault
  | botCommandScopeAllPrivateChats
  | botCommandScopeAllGroupChats
  | botCommandScopeAllChatAdministrators
  | botCommandScopeChat
  | botCommandScopeChatAdministrators
  | botCommandScopeChatMember;

/**
 * Version of {@link BotCommandScope} for method parameters.
 * Any of:
 * - {@link botCommandScopeDefault$Input}
 * - {@link botCommandScopeAllPrivateChats$Input}
 * - {@link botCommandScopeAllGroupChats$Input}
 * - {@link botCommandScopeAllChatAdministrators$Input}
 * - {@link botCommandScopeChat$Input}
 * - {@link botCommandScopeChatAdministrators$Input}
 * - {@link botCommandScopeChatMember$Input}
 */
export type BotCommandScope$Input =
  | botCommandScopeDefault$Input
  | botCommandScopeAllPrivateChats$Input
  | botCommandScopeAllGroupChats$Input
  | botCommandScopeAllChatAdministrators$Input
  | botCommandScopeChat$Input
  | botCommandScopeChatAdministrators$Input
  | botCommandScopeChatMember$Input;

/**
 * Any of:
 * - {@link updateAuthorizationState}
 * - {@link updateNewMessage}
 * - {@link updateMessageSendAcknowledged}
 * - {@link updateMessageSendSucceeded}
 * - {@link updateMessageSendFailed}
 * - {@link updateMessageContent}
 * - {@link updateMessageEdited}
 * - {@link updateMessageIsPinned}
 * - {@link updateMessageInteractionInfo}
 * - {@link updateMessageContentOpened}
 * - {@link updateMessageMentionRead}
 * - {@link updateMessageUnreadReactions}
 * - {@link updateMessageLiveLocationViewed}
 * - {@link updateNewChat}
 * - {@link updateChatTitle}
 * - {@link updateChatPhoto}
 * - {@link updateChatAccentColors}
 * - {@link updateChatPermissions}
 * - {@link updateChatLastMessage}
 * - {@link updateChatPosition}
 * - {@link updateChatReadInbox}
 * - {@link updateChatReadOutbox}
 * - {@link updateChatActionBar}
 * - {@link updateChatAvailableReactions}
 * - {@link updateChatDraftMessage}
 * - {@link updateChatEmojiStatus}
 * - {@link updateChatMessageSender}
 * - {@link updateChatMessageAutoDeleteTime}
 * - {@link updateChatNotificationSettings}
 * - {@link updateChatPendingJoinRequests}
 * - {@link updateChatReplyMarkup}
 * - {@link updateChatBackground}
 * - {@link updateChatTheme}
 * - {@link updateChatUnreadMentionCount}
 * - {@link updateChatUnreadReactionCount}
 * - {@link updateChatVideoChat}
 * - {@link updateChatDefaultDisableNotification}
 * - {@link updateChatHasProtectedContent}
 * - {@link updateChatIsTranslatable}
 * - {@link updateChatIsMarkedAsUnread}
 * - {@link updateChatViewAsTopics}
 * - {@link updateChatBlockList}
 * - {@link updateChatHasScheduledMessages}
 * - {@link updateChatFolders}
 * - {@link updateChatOnlineMemberCount}
 * - {@link updateForumTopicInfo}
 * - {@link updateScopeNotificationSettings}
 * - {@link updateNotification}
 * - {@link updateNotificationGroup}
 * - {@link updateActiveNotifications}
 * - {@link updateHavePendingNotifications}
 * - {@link updateDeleteMessages}
 * - {@link updateChatAction}
 * - {@link updateUserStatus}
 * - {@link updateUser}
 * - {@link updateBasicGroup}
 * - {@link updateSupergroup}
 * - {@link updateSecretChat}
 * - {@link updateUserFullInfo}
 * - {@link updateBasicGroupFullInfo}
 * - {@link updateSupergroupFullInfo}
 * - {@link updateServiceNotification}
 * - {@link updateFile}
 * - {@link updateFileGenerationStart}
 * - {@link updateFileGenerationStop}
 * - {@link updateFileDownloads}
 * - {@link updateFileAddedToDownloads}
 * - {@link updateFileDownload}
 * - {@link updateFileRemovedFromDownloads}
 * - {@link updateCall}
 * - {@link updateGroupCall}
 * - {@link updateGroupCallParticipant}
 * - {@link updateNewCallSignalingData}
 * - {@link updateUserPrivacySettingRules}
 * - {@link updateUnreadMessageCount}
 * - {@link updateUnreadChatCount}
 * - {@link updateStory}
 * - {@link updateStoryDeleted}
 * - {@link updateStorySendSucceeded}
 * - {@link updateStorySendFailed}
 * - {@link updateChatActiveStories}
 * - {@link updateStoryListChatCount}
 * - {@link updateStoryStealthMode}
 * - {@link updateOption}
 * - {@link updateStickerSet}
 * - {@link updateInstalledStickerSets}
 * - {@link updateTrendingStickerSets}
 * - {@link updateRecentStickers}
 * - {@link updateFavoriteStickers}
 * - {@link updateSavedAnimations}
 * - {@link updateSavedNotificationSounds}
 * - {@link updateDefaultBackground}
 * - {@link updateChatThemes}
 * - {@link updateAccentColors}
 * - {@link updateProfileAccentColors}
 * - {@link updateLanguagePackStrings}
 * - {@link updateConnectionState}
 * - {@link updateTermsOfService}
 * - {@link updateUsersNearby}
 * - {@link updateUnconfirmedSession}
 * - {@link updateAttachmentMenuBots}
 * - {@link updateWebAppMessageSent}
 * - {@link updateActiveEmojiReactions}
 * - {@link updateDefaultReactionType}
 * - {@link updateSpeechRecognitionTrial}
 * - {@link updateDiceEmojis}
 * - {@link updateAnimatedEmojiMessageClicked}
 * - {@link updateAnimationSearchParameters}
 * - {@link updateSuggestedActions}
 * - {@link updateAddChatMembersPrivacyForbidden}
 * - {@link updateAutosaveSettings}
 * - {@link updateNewInlineQuery}
 * - {@link updateNewChosenInlineResult}
 * - {@link updateNewCallbackQuery}
 * - {@link updateNewInlineCallbackQuery}
 * - {@link updateNewShippingQuery}
 * - {@link updateNewPreCheckoutQuery}
 * - {@link updateNewCustomEvent}
 * - {@link updateNewCustomQuery}
 * - {@link updatePoll}
 * - {@link updatePollAnswer}
 * - {@link updateChatMember}
 * - {@link updateNewChatJoinRequest}
 * - {@link updateChatBoost}
 * - {@link updateMessageReaction}
 * - {@link updateMessageReactions}
 */
export type Update =
  | updateAuthorizationState
  | updateNewMessage
  | updateMessageSendAcknowledged
  | updateMessageSendSucceeded
  | updateMessageSendFailed
  | updateMessageContent
  | updateMessageEdited
  | updateMessageIsPinned
  | updateMessageInteractionInfo
  | updateMessageContentOpened
  | updateMessageMentionRead
  | updateMessageUnreadReactions
  | updateMessageLiveLocationViewed
  | updateNewChat
  | updateChatTitle
  | updateChatPhoto
  | updateChatAccentColors
  | updateChatPermissions
  | updateChatLastMessage
  | updateChatPosition
  | updateChatReadInbox
  | updateChatReadOutbox
  | updateChatActionBar
  | updateChatAvailableReactions
  | updateChatDraftMessage
  | updateChatEmojiStatus
  | updateChatMessageSender
  | updateChatMessageAutoDeleteTime
  | updateChatNotificationSettings
  | updateChatPendingJoinRequests
  | updateChatReplyMarkup
  | updateChatBackground
  | updateChatTheme
  | updateChatUnreadMentionCount
  | updateChatUnreadReactionCount
  | updateChatVideoChat
  | updateChatDefaultDisableNotification
  | updateChatHasProtectedContent
  | updateChatIsTranslatable
  | updateChatIsMarkedAsUnread
  | updateChatViewAsTopics
  | updateChatBlockList
  | updateChatHasScheduledMessages
  | updateChatFolders
  | updateChatOnlineMemberCount
  | updateForumTopicInfo
  | updateScopeNotificationSettings
  | updateNotification
  | updateNotificationGroup
  | updateActiveNotifications
  | updateHavePendingNotifications
  | updateDeleteMessages
  | updateChatAction
  | updateUserStatus
  | updateUser
  | updateBasicGroup
  | updateSupergroup
  | updateSecretChat
  | updateUserFullInfo
  | updateBasicGroupFullInfo
  | updateSupergroupFullInfo
  | updateServiceNotification
  | updateFile
  | updateFileGenerationStart
  | updateFileGenerationStop
  | updateFileDownloads
  | updateFileAddedToDownloads
  | updateFileDownload
  | updateFileRemovedFromDownloads
  | updateCall
  | updateGroupCall
  | updateGroupCallParticipant
  | updateNewCallSignalingData
  | updateUserPrivacySettingRules
  | updateUnreadMessageCount
  | updateUnreadChatCount
  | updateStory
  | updateStoryDeleted
  | updateStorySendSucceeded
  | updateStorySendFailed
  | updateChatActiveStories
  | updateStoryListChatCount
  | updateStoryStealthMode
  | updateOption
  | updateStickerSet
  | updateInstalledStickerSets
  | updateTrendingStickerSets
  | updateRecentStickers
  | updateFavoriteStickers
  | updateSavedAnimations
  | updateSavedNotificationSounds
  | updateDefaultBackground
  | updateChatThemes
  | updateAccentColors
  | updateProfileAccentColors
  | updateLanguagePackStrings
  | updateConnectionState
  | updateTermsOfService
  | updateUsersNearby
  | updateUnconfirmedSession
  | updateAttachmentMenuBots
  | updateWebAppMessageSent
  | updateActiveEmojiReactions
  | updateDefaultReactionType
  | updateSpeechRecognitionTrial
  | updateDiceEmojis
  | updateAnimatedEmojiMessageClicked
  | updateAnimationSearchParameters
  | updateSuggestedActions
  | updateAddChatMembersPrivacyForbidden
  | updateAutosaveSettings
  | updateNewInlineQuery
  | updateNewChosenInlineResult
  | updateNewCallbackQuery
  | updateNewInlineCallbackQuery
  | updateNewShippingQuery
  | updateNewPreCheckoutQuery
  | updateNewCustomEvent
  | updateNewCustomQuery
  | updatePoll
  | updatePollAnswer
  | updateChatMember
  | updateNewChatJoinRequest
  | updateChatBoost
  | updateMessageReaction
  | updateMessageReactions;

/**
 * Version of {@link Update} for method parameters.
 * Any of:
 * - {@link updateAuthorizationState$Input}
 * - {@link updateNewMessage$Input}
 * - {@link updateMessageSendAcknowledged$Input}
 * - {@link updateMessageSendSucceeded$Input}
 * - {@link updateMessageSendFailed$Input}
 * - {@link updateMessageContent$Input}
 * - {@link updateMessageEdited$Input}
 * - {@link updateMessageIsPinned$Input}
 * - {@link updateMessageInteractionInfo$Input}
 * - {@link updateMessageContentOpened$Input}
 * - {@link updateMessageMentionRead$Input}
 * - {@link updateMessageUnreadReactions$Input}
 * - {@link updateMessageLiveLocationViewed$Input}
 * - {@link updateNewChat$Input}
 * - {@link updateChatTitle$Input}
 * - {@link updateChatPhoto$Input}
 * - {@link updateChatAccentColors$Input}
 * - {@link updateChatPermissions$Input}
 * - {@link updateChatLastMessage$Input}
 * - {@link updateChatPosition$Input}
 * - {@link updateChatReadInbox$Input}
 * - {@link updateChatReadOutbox$Input}
 * - {@link updateChatActionBar$Input}
 * - {@link updateChatAvailableReactions$Input}
 * - {@link updateChatDraftMessage$Input}
 * - {@link updateChatEmojiStatus$Input}
 * - {@link updateChatMessageSender$Input}
 * - {@link updateChatMessageAutoDeleteTime$Input}
 * - {@link updateChatNotificationSettings$Input}
 * - {@link updateChatPendingJoinRequests$Input}
 * - {@link updateChatReplyMarkup$Input}
 * - {@link updateChatBackground$Input}
 * - {@link updateChatTheme$Input}
 * - {@link updateChatUnreadMentionCount$Input}
 * - {@link updateChatUnreadReactionCount$Input}
 * - {@link updateChatVideoChat$Input}
 * - {@link updateChatDefaultDisableNotification$Input}
 * - {@link updateChatHasProtectedContent$Input}
 * - {@link updateChatIsTranslatable$Input}
 * - {@link updateChatIsMarkedAsUnread$Input}
 * - {@link updateChatViewAsTopics$Input}
 * - {@link updateChatBlockList$Input}
 * - {@link updateChatHasScheduledMessages$Input}
 * - {@link updateChatFolders$Input}
 * - {@link updateChatOnlineMemberCount$Input}
 * - {@link updateForumTopicInfo$Input}
 * - {@link updateScopeNotificationSettings$Input}
 * - {@link updateNotification$Input}
 * - {@link updateNotificationGroup$Input}
 * - {@link updateActiveNotifications$Input}
 * - {@link updateHavePendingNotifications$Input}
 * - {@link updateDeleteMessages$Input}
 * - {@link updateChatAction$Input}
 * - {@link updateUserStatus$Input}
 * - {@link updateUser$Input}
 * - {@link updateBasicGroup$Input}
 * - {@link updateSupergroup$Input}
 * - {@link updateSecretChat$Input}
 * - {@link updateUserFullInfo$Input}
 * - {@link updateBasicGroupFullInfo$Input}
 * - {@link updateSupergroupFullInfo$Input}
 * - {@link updateServiceNotification$Input}
 * - {@link updateFile$Input}
 * - {@link updateFileGenerationStart$Input}
 * - {@link updateFileGenerationStop$Input}
 * - {@link updateFileDownloads$Input}
 * - {@link updateFileAddedToDownloads$Input}
 * - {@link updateFileDownload$Input}
 * - {@link updateFileRemovedFromDownloads$Input}
 * - {@link updateCall$Input}
 * - {@link updateGroupCall$Input}
 * - {@link updateGroupCallParticipant$Input}
 * - {@link updateNewCallSignalingData$Input}
 * - {@link updateUserPrivacySettingRules$Input}
 * - {@link updateUnreadMessageCount$Input}
 * - {@link updateUnreadChatCount$Input}
 * - {@link updateStory$Input}
 * - {@link updateStoryDeleted$Input}
 * - {@link updateStorySendSucceeded$Input}
 * - {@link updateStorySendFailed$Input}
 * - {@link updateChatActiveStories$Input}
 * - {@link updateStoryListChatCount$Input}
 * - {@link updateStoryStealthMode$Input}
 * - {@link updateOption$Input}
 * - {@link updateStickerSet$Input}
 * - {@link updateInstalledStickerSets$Input}
 * - {@link updateTrendingStickerSets$Input}
 * - {@link updateRecentStickers$Input}
 * - {@link updateFavoriteStickers$Input}
 * - {@link updateSavedAnimations$Input}
 * - {@link updateSavedNotificationSounds$Input}
 * - {@link updateDefaultBackground$Input}
 * - {@link updateChatThemes$Input}
 * - {@link updateAccentColors$Input}
 * - {@link updateProfileAccentColors$Input}
 * - {@link updateLanguagePackStrings$Input}
 * - {@link updateConnectionState$Input}
 * - {@link updateTermsOfService$Input}
 * - {@link updateUsersNearby$Input}
 * - {@link updateUnconfirmedSession$Input}
 * - {@link updateAttachmentMenuBots$Input}
 * - {@link updateWebAppMessageSent$Input}
 * - {@link updateActiveEmojiReactions$Input}
 * - {@link updateDefaultReactionType$Input}
 * - {@link updateSpeechRecognitionTrial$Input}
 * - {@link updateDiceEmojis$Input}
 * - {@link updateAnimatedEmojiMessageClicked$Input}
 * - {@link updateAnimationSearchParameters$Input}
 * - {@link updateSuggestedActions$Input}
 * - {@link updateAddChatMembersPrivacyForbidden$Input}
 * - {@link updateAutosaveSettings$Input}
 * - {@link updateNewInlineQuery$Input}
 * - {@link updateNewChosenInlineResult$Input}
 * - {@link updateNewCallbackQuery$Input}
 * - {@link updateNewInlineCallbackQuery$Input}
 * - {@link updateNewShippingQuery$Input}
 * - {@link updateNewPreCheckoutQuery$Input}
 * - {@link updateNewCustomEvent$Input}
 * - {@link updateNewCustomQuery$Input}
 * - {@link updatePoll$Input}
 * - {@link updatePollAnswer$Input}
 * - {@link updateChatMember$Input}
 * - {@link updateNewChatJoinRequest$Input}
 * - {@link updateChatBoost$Input}
 * - {@link updateMessageReaction$Input}
 * - {@link updateMessageReactions$Input}
 */
export type Update$Input =
  | updateAuthorizationState$Input
  | updateNewMessage$Input
  | updateMessageSendAcknowledged$Input
  | updateMessageSendSucceeded$Input
  | updateMessageSendFailed$Input
  | updateMessageContent$Input
  | updateMessageEdited$Input
  | updateMessageIsPinned$Input
  | updateMessageInteractionInfo$Input
  | updateMessageContentOpened$Input
  | updateMessageMentionRead$Input
  | updateMessageUnreadReactions$Input
  | updateMessageLiveLocationViewed$Input
  | updateNewChat$Input
  | updateChatTitle$Input
  | updateChatPhoto$Input
  | updateChatAccentColors$Input
  | updateChatPermissions$Input
  | updateChatLastMessage$Input
  | updateChatPosition$Input
  | updateChatReadInbox$Input
  | updateChatReadOutbox$Input
  | updateChatActionBar$Input
  | updateChatAvailableReactions$Input
  | updateChatDraftMessage$Input
  | updateChatEmojiStatus$Input
  | updateChatMessageSender$Input
  | updateChatMessageAutoDeleteTime$Input
  | updateChatNotificationSettings$Input
  | updateChatPendingJoinRequests$Input
  | updateChatReplyMarkup$Input
  | updateChatBackground$Input
  | updateChatTheme$Input
  | updateChatUnreadMentionCount$Input
  | updateChatUnreadReactionCount$Input
  | updateChatVideoChat$Input
  | updateChatDefaultDisableNotification$Input
  | updateChatHasProtectedContent$Input
  | updateChatIsTranslatable$Input
  | updateChatIsMarkedAsUnread$Input
  | updateChatViewAsTopics$Input
  | updateChatBlockList$Input
  | updateChatHasScheduledMessages$Input
  | updateChatFolders$Input
  | updateChatOnlineMemberCount$Input
  | updateForumTopicInfo$Input
  | updateScopeNotificationSettings$Input
  | updateNotification$Input
  | updateNotificationGroup$Input
  | updateActiveNotifications$Input
  | updateHavePendingNotifications$Input
  | updateDeleteMessages$Input
  | updateChatAction$Input
  | updateUserStatus$Input
  | updateUser$Input
  | updateBasicGroup$Input
  | updateSupergroup$Input
  | updateSecretChat$Input
  | updateUserFullInfo$Input
  | updateBasicGroupFullInfo$Input
  | updateSupergroupFullInfo$Input
  | updateServiceNotification$Input
  | updateFile$Input
  | updateFileGenerationStart$Input
  | updateFileGenerationStop$Input
  | updateFileDownloads$Input
  | updateFileAddedToDownloads$Input
  | updateFileDownload$Input
  | updateFileRemovedFromDownloads$Input
  | updateCall$Input
  | updateGroupCall$Input
  | updateGroupCallParticipant$Input
  | updateNewCallSignalingData$Input
  | updateUserPrivacySettingRules$Input
  | updateUnreadMessageCount$Input
  | updateUnreadChatCount$Input
  | updateStory$Input
  | updateStoryDeleted$Input
  | updateStorySendSucceeded$Input
  | updateStorySendFailed$Input
  | updateChatActiveStories$Input
  | updateStoryListChatCount$Input
  | updateStoryStealthMode$Input
  | updateOption$Input
  | updateStickerSet$Input
  | updateInstalledStickerSets$Input
  | updateTrendingStickerSets$Input
  | updateRecentStickers$Input
  | updateFavoriteStickers$Input
  | updateSavedAnimations$Input
  | updateSavedNotificationSounds$Input
  | updateDefaultBackground$Input
  | updateChatThemes$Input
  | updateAccentColors$Input
  | updateProfileAccentColors$Input
  | updateLanguagePackStrings$Input
  | updateConnectionState$Input
  | updateTermsOfService$Input
  | updateUsersNearby$Input
  | updateUnconfirmedSession$Input
  | updateAttachmentMenuBots$Input
  | updateWebAppMessageSent$Input
  | updateActiveEmojiReactions$Input
  | updateDefaultReactionType$Input
  | updateSpeechRecognitionTrial$Input
  | updateDiceEmojis$Input
  | updateAnimatedEmojiMessageClicked$Input
  | updateAnimationSearchParameters$Input
  | updateSuggestedActions$Input
  | updateAddChatMembersPrivacyForbidden$Input
  | updateAutosaveSettings$Input
  | updateNewInlineQuery$Input
  | updateNewChosenInlineResult$Input
  | updateNewCallbackQuery$Input
  | updateNewInlineCallbackQuery$Input
  | updateNewShippingQuery$Input
  | updateNewPreCheckoutQuery$Input
  | updateNewCustomEvent$Input
  | updateNewCustomQuery$Input
  | updatePoll$Input
  | updatePollAnswer$Input
  | updateChatMember$Input
  | updateNewChatJoinRequest$Input
  | updateChatBoost$Input
  | updateMessageReaction$Input
  | updateMessageReactions$Input;

/**
 * Any of:
 * - {@link updates}
 */
export type Updates = updates;

/**
 * Version of {@link Updates} for method parameters.
 * Any of:
 * - {@link updates$Input}
 */
export type Updates$Input = updates$Input;

/**
 * Any of:
 * - {@link logStreamDefault}
 * - {@link logStreamFile}
 * - {@link logStreamEmpty}
 */
export type LogStream = logStreamDefault | logStreamFile | logStreamEmpty;

/**
 * Version of {@link LogStream} for method parameters.
 * Any of:
 * - {@link logStreamDefault$Input}
 * - {@link logStreamFile$Input}
 * - {@link logStreamEmpty$Input}
 */
export type LogStream$Input =
  | logStreamDefault$Input
  | logStreamFile$Input
  | logStreamEmpty$Input;

/**
 * Any of:
 * - {@link logVerbosityLevel}
 */
export type LogVerbosityLevel = logVerbosityLevel;

/**
 * Version of {@link LogVerbosityLevel} for method parameters.
 * Any of:
 * - {@link logVerbosityLevel$Input}
 */
export type LogVerbosityLevel$Input = logVerbosityLevel$Input;

/**
 * Any of:
 * - {@link logTags}
 */
export type LogTags = logTags;

/**
 * Version of {@link LogTags} for method parameters.
 * Any of:
 * - {@link logTags$Input}
 */
export type LogTags$Input = logTags$Input;

/**
 * Any of:
 * - {@link userSupportInfo}
 */
export type UserSupportInfo = userSupportInfo;

/**
 * Version of {@link UserSupportInfo} for method parameters.
 * Any of:
 * - {@link userSupportInfo$Input}
 */
export type UserSupportInfo$Input = userSupportInfo$Input;

/**
 * Any of:
 * - {@link testInt}
 */
export type TestInt = testInt;

/**
 * Version of {@link TestInt} for method parameters.
 * Any of:
 * - {@link testInt$Input}
 */
export type TestInt$Input = testInt$Input;

/**
 * Any of:
 * - {@link testString}
 */
export type TestString = testString;

/**
 * Version of {@link TestString} for method parameters.
 * Any of:
 * - {@link testString$Input}
 */
export type TestString$Input = testString$Input;

/**
 * Any of:
 * - {@link testBytes}
 */
export type TestBytes = testBytes;

/**
 * Version of {@link TestBytes} for method parameters.
 * Any of:
 * - {@link testBytes$Input}
 */
export type TestBytes$Input = testBytes$Input;

/**
 * Any of:
 * - {@link testVectorInt}
 */
export type TestVectorInt = testVectorInt;

/**
 * Version of {@link TestVectorInt} for method parameters.
 * Any of:
 * - {@link testVectorInt$Input}
 */
export type TestVectorInt$Input = testVectorInt$Input;

/**
 * Any of:
 * - {@link testVectorIntObject}
 */
export type TestVectorIntObject = testVectorIntObject;

/**
 * Version of {@link TestVectorIntObject} for method parameters.
 * Any of:
 * - {@link testVectorIntObject$Input}
 */
export type TestVectorIntObject$Input = testVectorIntObject$Input;

/**
 * Any of:
 * - {@link testVectorString}
 */
export type TestVectorString = testVectorString;

/**
 * Version of {@link TestVectorString} for method parameters.
 * Any of:
 * - {@link testVectorString$Input}
 */
export type TestVectorString$Input = testVectorString$Input;

/**
 * Any of:
 * - {@link testVectorStringObject}
 */
export type TestVectorStringObject = testVectorStringObject;

/**
 * Version of {@link TestVectorStringObject} for method parameters.
 * Any of:
 * - {@link testVectorStringObject$Input}
 */
export type TestVectorStringObject$Input = testVectorStringObject$Input;

export type $MethodsDict = {
  readonly getAuthorizationState: getAuthorizationState;
  readonly setTdlibParameters: setTdlibParameters;
  readonly setAuthenticationPhoneNumber: setAuthenticationPhoneNumber;
  readonly setAuthenticationEmailAddress: setAuthenticationEmailAddress;
  readonly resendAuthenticationCode: resendAuthenticationCode;
  readonly checkAuthenticationEmailCode: checkAuthenticationEmailCode;
  readonly checkAuthenticationCode: checkAuthenticationCode;
  readonly requestQrCodeAuthentication: requestQrCodeAuthentication;
  readonly registerUser: registerUser;
  readonly resetAuthenticationEmailAddress: resetAuthenticationEmailAddress;
  readonly checkAuthenticationPassword: checkAuthenticationPassword;
  readonly requestAuthenticationPasswordRecovery: requestAuthenticationPasswordRecovery;
  readonly checkAuthenticationPasswordRecoveryCode: checkAuthenticationPasswordRecoveryCode;
  readonly recoverAuthenticationPassword: recoverAuthenticationPassword;
  readonly sendAuthenticationFirebaseSms: sendAuthenticationFirebaseSms;
  readonly checkAuthenticationBotToken: checkAuthenticationBotToken;
  readonly logOut: logOut;
  readonly close: close;
  readonly destroy: destroy;
  readonly confirmQrCodeAuthentication: confirmQrCodeAuthentication;
  readonly getCurrentState: getCurrentState;
  readonly setDatabaseEncryptionKey: setDatabaseEncryptionKey;
  readonly getPasswordState: getPasswordState;
  readonly setPassword: setPassword;
  readonly setLoginEmailAddress: setLoginEmailAddress;
  readonly resendLoginEmailAddressCode: resendLoginEmailAddressCode;
  readonly checkLoginEmailAddressCode: checkLoginEmailAddressCode;
  readonly getRecoveryEmailAddress: getRecoveryEmailAddress;
  readonly setRecoveryEmailAddress: setRecoveryEmailAddress;
  readonly checkRecoveryEmailAddressCode: checkRecoveryEmailAddressCode;
  readonly resendRecoveryEmailAddressCode: resendRecoveryEmailAddressCode;
  readonly requestPasswordRecovery: requestPasswordRecovery;
  readonly checkPasswordRecoveryCode: checkPasswordRecoveryCode;
  readonly recoverPassword: recoverPassword;
  readonly resetPassword: resetPassword;
  readonly cancelPasswordReset: cancelPasswordReset;
  readonly createTemporaryPassword: createTemporaryPassword;
  readonly getTemporaryPasswordState: getTemporaryPasswordState;
  readonly getMe: getMe;
  readonly getUser: getUser;
  readonly getUserFullInfo: getUserFullInfo;
  readonly getBasicGroup: getBasicGroup;
  readonly getBasicGroupFullInfo: getBasicGroupFullInfo;
  readonly getSupergroup: getSupergroup;
  readonly getSupergroupFullInfo: getSupergroupFullInfo;
  readonly getSecretChat: getSecretChat;
  readonly getChat: getChat;
  readonly getMessage: getMessage;
  readonly getMessageLocally: getMessageLocally;
  readonly getRepliedMessage: getRepliedMessage;
  readonly getChatPinnedMessage: getChatPinnedMessage;
  readonly getCallbackQueryMessage: getCallbackQueryMessage;
  readonly getMessages: getMessages;
  readonly getMessageThread: getMessageThread;
  readonly getMessageViewers: getMessageViewers;
  readonly getFile: getFile;
  readonly getRemoteFile: getRemoteFile;
  readonly loadChats: loadChats;
  readonly getChats: getChats;
  readonly searchPublicChat: searchPublicChat;
  readonly searchPublicChats: searchPublicChats;
  readonly searchChats: searchChats;
  readonly searchChatsOnServer: searchChatsOnServer;
  readonly searchChatsNearby: searchChatsNearby;
  readonly getChatSimilarChats: getChatSimilarChats;
  readonly getChatSimilarChatCount: getChatSimilarChatCount;
  readonly openChatSimilarChat: openChatSimilarChat;
  readonly getTopChats: getTopChats;
  readonly removeTopChat: removeTopChat;
  readonly searchRecentlyFoundChats: searchRecentlyFoundChats;
  readonly addRecentlyFoundChat: addRecentlyFoundChat;
  readonly removeRecentlyFoundChat: removeRecentlyFoundChat;
  readonly clearRecentlyFoundChats: clearRecentlyFoundChats;
  readonly getRecentlyOpenedChats: getRecentlyOpenedChats;
  readonly checkChatUsername: checkChatUsername;
  readonly getCreatedPublicChats: getCreatedPublicChats;
  readonly checkCreatedPublicChatsLimit: checkCreatedPublicChatsLimit;
  readonly getSuitableDiscussionChats: getSuitableDiscussionChats;
  readonly getInactiveSupergroupChats: getInactiveSupergroupChats;
  readonly getGroupsInCommon: getGroupsInCommon;
  readonly getChatHistory: getChatHistory;
  readonly getMessageThreadHistory: getMessageThreadHistory;
  readonly deleteChatHistory: deleteChatHistory;
  readonly deleteChat: deleteChat;
  readonly searchChatMessages: searchChatMessages;
  readonly searchMessages: searchMessages;
  readonly searchSecretMessages: searchSecretMessages;
  readonly searchCallMessages: searchCallMessages;
  readonly searchOutgoingDocumentMessages: searchOutgoingDocumentMessages;
  readonly deleteAllCallMessages: deleteAllCallMessages;
  readonly searchChatRecentLocationMessages: searchChatRecentLocationMessages;
  readonly getActiveLiveLocationMessages: getActiveLiveLocationMessages;
  readonly getChatMessageByDate: getChatMessageByDate;
  readonly getChatSparseMessagePositions: getChatSparseMessagePositions;
  readonly getChatMessageCalendar: getChatMessageCalendar;
  readonly getChatMessageCount: getChatMessageCount;
  readonly getChatMessagePosition: getChatMessagePosition;
  readonly getChatScheduledMessages: getChatScheduledMessages;
  readonly getChatSponsoredMessages: getChatSponsoredMessages;
  readonly clickChatSponsoredMessage: clickChatSponsoredMessage;
  readonly removeNotification: removeNotification;
  readonly removeNotificationGroup: removeNotificationGroup;
  readonly getMessageLink: getMessageLink;
  readonly getMessageEmbeddingCode: getMessageEmbeddingCode;
  readonly getMessageLinkInfo: getMessageLinkInfo;
  readonly translateText: translateText;
  readonly translateMessageText: translateMessageText;
  readonly recognizeSpeech: recognizeSpeech;
  readonly rateSpeechRecognition: rateSpeechRecognition;
  readonly getChatAvailableMessageSenders: getChatAvailableMessageSenders;
  readonly setChatMessageSender: setChatMessageSender;
  readonly sendMessage: sendMessage;
  readonly sendMessageAlbum: sendMessageAlbum;
  readonly sendBotStartMessage: sendBotStartMessage;
  readonly sendInlineQueryResultMessage: sendInlineQueryResultMessage;
  readonly forwardMessages: forwardMessages;
  readonly resendMessages: resendMessages;
  readonly addLocalMessage: addLocalMessage;
  readonly deleteMessages: deleteMessages;
  readonly deleteChatMessagesBySender: deleteChatMessagesBySender;
  readonly deleteChatMessagesByDate: deleteChatMessagesByDate;
  readonly editMessageText: editMessageText;
  readonly editMessageLiveLocation: editMessageLiveLocation;
  readonly editMessageMedia: editMessageMedia;
  readonly editMessageCaption: editMessageCaption;
  readonly editMessageReplyMarkup: editMessageReplyMarkup;
  readonly editInlineMessageText: editInlineMessageText;
  readonly editInlineMessageLiveLocation: editInlineMessageLiveLocation;
  readonly editInlineMessageMedia: editInlineMessageMedia;
  readonly editInlineMessageCaption: editInlineMessageCaption;
  readonly editInlineMessageReplyMarkup: editInlineMessageReplyMarkup;
  readonly editMessageSchedulingState: editMessageSchedulingState;
  readonly getForumTopicDefaultIcons: getForumTopicDefaultIcons;
  readonly createForumTopic: createForumTopic;
  readonly editForumTopic: editForumTopic;
  readonly getForumTopic: getForumTopic;
  readonly getForumTopicLink: getForumTopicLink;
  readonly getForumTopics: getForumTopics;
  readonly setForumTopicNotificationSettings: setForumTopicNotificationSettings;
  readonly toggleForumTopicIsClosed: toggleForumTopicIsClosed;
  readonly toggleGeneralForumTopicIsHidden: toggleGeneralForumTopicIsHidden;
  readonly toggleForumTopicIsPinned: toggleForumTopicIsPinned;
  readonly setPinnedForumTopics: setPinnedForumTopics;
  readonly deleteForumTopic: deleteForumTopic;
  readonly getEmojiReaction: getEmojiReaction;
  readonly getCustomEmojiReactionAnimations: getCustomEmojiReactionAnimations;
  readonly getMessageAvailableReactions: getMessageAvailableReactions;
  readonly clearRecentReactions: clearRecentReactions;
  readonly addMessageReaction: addMessageReaction;
  readonly removeMessageReaction: removeMessageReaction;
  readonly setMessageReactions: setMessageReactions;
  readonly getMessageAddedReactions: getMessageAddedReactions;
  readonly setDefaultReactionType: setDefaultReactionType;
  readonly searchQuote: searchQuote;
  readonly getTextEntities: getTextEntities;
  readonly parseTextEntities: parseTextEntities;
  readonly parseMarkdown: parseMarkdown;
  readonly getMarkdownText: getMarkdownText;
  readonly getFileMimeType: getFileMimeType;
  readonly getFileExtension: getFileExtension;
  readonly cleanFileName: cleanFileName;
  readonly getLanguagePackString: getLanguagePackString;
  readonly getJsonValue: getJsonValue;
  readonly getJsonString: getJsonString;
  readonly getThemeParametersJsonString: getThemeParametersJsonString;
  readonly setPollAnswer: setPollAnswer;
  readonly getPollVoters: getPollVoters;
  readonly stopPoll: stopPoll;
  readonly hideSuggestedAction: hideSuggestedAction;
  readonly getLoginUrlInfo: getLoginUrlInfo;
  readonly getLoginUrl: getLoginUrl;
  readonly shareUsersWithBot: shareUsersWithBot;
  readonly shareChatWithBot: shareChatWithBot;
  readonly getInlineQueryResults: getInlineQueryResults;
  readonly answerInlineQuery: answerInlineQuery;
  readonly searchWebApp: searchWebApp;
  readonly getWebAppLinkUrl: getWebAppLinkUrl;
  readonly getWebAppUrl: getWebAppUrl;
  readonly sendWebAppData: sendWebAppData;
  readonly openWebApp: openWebApp;
  readonly closeWebApp: closeWebApp;
  readonly answerWebAppQuery: answerWebAppQuery;
  readonly getCallbackQueryAnswer: getCallbackQueryAnswer;
  readonly answerCallbackQuery: answerCallbackQuery;
  readonly answerShippingQuery: answerShippingQuery;
  readonly answerPreCheckoutQuery: answerPreCheckoutQuery;
  readonly setGameScore: setGameScore;
  readonly setInlineGameScore: setInlineGameScore;
  readonly getGameHighScores: getGameHighScores;
  readonly getInlineGameHighScores: getInlineGameHighScores;
  readonly deleteChatReplyMarkup: deleteChatReplyMarkup;
  readonly sendChatAction: sendChatAction;
  readonly openChat: openChat;
  readonly closeChat: closeChat;
  readonly viewMessages: viewMessages;
  readonly openMessageContent: openMessageContent;
  readonly clickAnimatedEmojiMessage: clickAnimatedEmojiMessage;
  readonly getInternalLink: getInternalLink;
  readonly getInternalLinkType: getInternalLinkType;
  readonly getExternalLinkInfo: getExternalLinkInfo;
  readonly getExternalLink: getExternalLink;
  readonly readAllChatMentions: readAllChatMentions;
  readonly readAllMessageThreadMentions: readAllMessageThreadMentions;
  readonly readAllChatReactions: readAllChatReactions;
  readonly readAllMessageThreadReactions: readAllMessageThreadReactions;
  readonly createPrivateChat: createPrivateChat;
  readonly createBasicGroupChat: createBasicGroupChat;
  readonly createSupergroupChat: createSupergroupChat;
  readonly createSecretChat: createSecretChat;
  readonly createNewBasicGroupChat: createNewBasicGroupChat;
  readonly createNewSupergroupChat: createNewSupergroupChat;
  readonly createNewSecretChat: createNewSecretChat;
  readonly upgradeBasicGroupChatToSupergroupChat: upgradeBasicGroupChatToSupergroupChat;
  readonly getChatListsToAddChat: getChatListsToAddChat;
  readonly addChatToList: addChatToList;
  readonly getChatFolder: getChatFolder;
  readonly createChatFolder: createChatFolder;
  readonly editChatFolder: editChatFolder;
  readonly deleteChatFolder: deleteChatFolder;
  readonly getChatFolderChatsToLeave: getChatFolderChatsToLeave;
  readonly getChatFolderChatCount: getChatFolderChatCount;
  readonly reorderChatFolders: reorderChatFolders;
  readonly getRecommendedChatFolders: getRecommendedChatFolders;
  readonly getChatFolderDefaultIconName: getChatFolderDefaultIconName;
  readonly getChatsForChatFolderInviteLink: getChatsForChatFolderInviteLink;
  readonly createChatFolderInviteLink: createChatFolderInviteLink;
  readonly getChatFolderInviteLinks: getChatFolderInviteLinks;
  readonly editChatFolderInviteLink: editChatFolderInviteLink;
  readonly deleteChatFolderInviteLink: deleteChatFolderInviteLink;
  readonly checkChatFolderInviteLink: checkChatFolderInviteLink;
  readonly addChatFolderByInviteLink: addChatFolderByInviteLink;
  readonly getChatFolderNewChats: getChatFolderNewChats;
  readonly processChatFolderNewChats: processChatFolderNewChats;
  readonly getArchiveChatListSettings: getArchiveChatListSettings;
  readonly setArchiveChatListSettings: setArchiveChatListSettings;
  readonly setChatTitle: setChatTitle;
  readonly setChatPhoto: setChatPhoto;
  readonly setChatAccentColor: setChatAccentColor;
  readonly setChatProfileAccentColor: setChatProfileAccentColor;
  readonly setChatMessageAutoDeleteTime: setChatMessageAutoDeleteTime;
  readonly setChatEmojiStatus: setChatEmojiStatus;
  readonly setChatPermissions: setChatPermissions;
  readonly setChatBackground: setChatBackground;
  readonly deleteChatBackground: deleteChatBackground;
  readonly setChatTheme: setChatTheme;
  readonly setChatDraftMessage: setChatDraftMessage;
  readonly setChatNotificationSettings: setChatNotificationSettings;
  readonly toggleChatHasProtectedContent: toggleChatHasProtectedContent;
  readonly toggleChatViewAsTopics: toggleChatViewAsTopics;
  readonly toggleChatIsTranslatable: toggleChatIsTranslatable;
  readonly toggleChatIsMarkedAsUnread: toggleChatIsMarkedAsUnread;
  readonly toggleChatDefaultDisableNotification: toggleChatDefaultDisableNotification;
  readonly setChatAvailableReactions: setChatAvailableReactions;
  readonly setChatClientData: setChatClientData;
  readonly setChatDescription: setChatDescription;
  readonly setChatDiscussionGroup: setChatDiscussionGroup;
  readonly setChatLocation: setChatLocation;
  readonly setChatSlowModeDelay: setChatSlowModeDelay;
  readonly pinChatMessage: pinChatMessage;
  readonly unpinChatMessage: unpinChatMessage;
  readonly unpinAllChatMessages: unpinAllChatMessages;
  readonly unpinAllMessageThreadMessages: unpinAllMessageThreadMessages;
  readonly joinChat: joinChat;
  readonly leaveChat: leaveChat;
  readonly addChatMember: addChatMember;
  readonly addChatMembers: addChatMembers;
  readonly setChatMemberStatus: setChatMemberStatus;
  readonly banChatMember: banChatMember;
  readonly canTransferOwnership: canTransferOwnership;
  readonly transferChatOwnership: transferChatOwnership;
  readonly getChatMember: getChatMember;
  readonly searchChatMembers: searchChatMembers;
  readonly getChatAdministrators: getChatAdministrators;
  readonly clearAllDraftMessages: clearAllDraftMessages;
  readonly getSavedNotificationSound: getSavedNotificationSound;
  readonly getSavedNotificationSounds: getSavedNotificationSounds;
  readonly addSavedNotificationSound: addSavedNotificationSound;
  readonly removeSavedNotificationSound: removeSavedNotificationSound;
  readonly getChatNotificationSettingsExceptions: getChatNotificationSettingsExceptions;
  readonly getScopeNotificationSettings: getScopeNotificationSettings;
  readonly setScopeNotificationSettings: setScopeNotificationSettings;
  readonly resetAllNotificationSettings: resetAllNotificationSettings;
  readonly toggleChatIsPinned: toggleChatIsPinned;
  readonly setPinnedChats: setPinnedChats;
  readonly readChatList: readChatList;
  readonly getStory: getStory;
  readonly getChatsToSendStories: getChatsToSendStories;
  readonly canSendStory: canSendStory;
  readonly sendStory: sendStory;
  readonly editStory: editStory;
  readonly setStoryPrivacySettings: setStoryPrivacySettings;
  readonly toggleStoryIsPinned: toggleStoryIsPinned;
  readonly deleteStory: deleteStory;
  readonly getStoryNotificationSettingsExceptions: getStoryNotificationSettingsExceptions;
  readonly loadActiveStories: loadActiveStories;
  readonly setChatActiveStoriesList: setChatActiveStoriesList;
  readonly getChatActiveStories: getChatActiveStories;
  readonly getChatPinnedStories: getChatPinnedStories;
  readonly getChatArchivedStories: getChatArchivedStories;
  readonly openStory: openStory;
  readonly closeStory: closeStory;
  readonly getStoryAvailableReactions: getStoryAvailableReactions;
  readonly setStoryReaction: setStoryReaction;
  readonly getStoryInteractions: getStoryInteractions;
  readonly getChatStoryInteractions: getChatStoryInteractions;
  readonly reportStory: reportStory;
  readonly activateStoryStealthMode: activateStoryStealthMode;
  readonly getStoryPublicForwards: getStoryPublicForwards;
  readonly getChatBoostLevelFeatures: getChatBoostLevelFeatures;
  readonly getChatBoostFeatures: getChatBoostFeatures;
  readonly getAvailableChatBoostSlots: getAvailableChatBoostSlots;
  readonly getChatBoostStatus: getChatBoostStatus;
  readonly boostChat: boostChat;
  readonly getChatBoostLink: getChatBoostLink;
  readonly getChatBoostLinkInfo: getChatBoostLinkInfo;
  readonly getChatBoosts: getChatBoosts;
  readonly getUserChatBoosts: getUserChatBoosts;
  readonly getAttachmentMenuBot: getAttachmentMenuBot;
  readonly toggleBotIsAddedToAttachmentMenu: toggleBotIsAddedToAttachmentMenu;
  readonly getThemedEmojiStatuses: getThemedEmojiStatuses;
  readonly getRecentEmojiStatuses: getRecentEmojiStatuses;
  readonly getDefaultEmojiStatuses: getDefaultEmojiStatuses;
  readonly clearRecentEmojiStatuses: clearRecentEmojiStatuses;
  readonly getThemedChatEmojiStatuses: getThemedChatEmojiStatuses;
  readonly getDefaultChatEmojiStatuses: getDefaultChatEmojiStatuses;
  readonly getDisallowedChatEmojiStatuses: getDisallowedChatEmojiStatuses;
  readonly downloadFile: downloadFile;
  readonly getFileDownloadedPrefixSize: getFileDownloadedPrefixSize;
  readonly cancelDownloadFile: cancelDownloadFile;
  readonly getSuggestedFileName: getSuggestedFileName;
  readonly preliminaryUploadFile: preliminaryUploadFile;
  readonly cancelPreliminaryUploadFile: cancelPreliminaryUploadFile;
  readonly writeGeneratedFilePart: writeGeneratedFilePart;
  readonly setFileGenerationProgress: setFileGenerationProgress;
  readonly finishFileGeneration: finishFileGeneration;
  readonly readFilePart: readFilePart;
  readonly deleteFile: deleteFile;
  readonly addFileToDownloads: addFileToDownloads;
  readonly toggleDownloadIsPaused: toggleDownloadIsPaused;
  readonly toggleAllDownloadsArePaused: toggleAllDownloadsArePaused;
  readonly removeFileFromDownloads: removeFileFromDownloads;
  readonly removeAllFilesFromDownloads: removeAllFilesFromDownloads;
  readonly searchFileDownloads: searchFileDownloads;
  readonly getMessageFileType: getMessageFileType;
  readonly getMessageImportConfirmationText: getMessageImportConfirmationText;
  readonly importMessages: importMessages;
  readonly replacePrimaryChatInviteLink: replacePrimaryChatInviteLink;
  readonly createChatInviteLink: createChatInviteLink;
  readonly editChatInviteLink: editChatInviteLink;
  readonly getChatInviteLink: getChatInviteLink;
  readonly getChatInviteLinkCounts: getChatInviteLinkCounts;
  readonly getChatInviteLinks: getChatInviteLinks;
  readonly getChatInviteLinkMembers: getChatInviteLinkMembers;
  readonly revokeChatInviteLink: revokeChatInviteLink;
  readonly deleteRevokedChatInviteLink: deleteRevokedChatInviteLink;
  readonly deleteAllRevokedChatInviteLinks: deleteAllRevokedChatInviteLinks;
  readonly checkChatInviteLink: checkChatInviteLink;
  readonly joinChatByInviteLink: joinChatByInviteLink;
  readonly getChatJoinRequests: getChatJoinRequests;
  readonly processChatJoinRequest: processChatJoinRequest;
  readonly processChatJoinRequests: processChatJoinRequests;
  readonly createCall: createCall;
  readonly acceptCall: acceptCall;
  readonly sendCallSignalingData: sendCallSignalingData;
  readonly discardCall: discardCall;
  readonly sendCallRating: sendCallRating;
  readonly sendCallDebugInformation: sendCallDebugInformation;
  readonly sendCallLog: sendCallLog;
  readonly getVideoChatAvailableParticipants: getVideoChatAvailableParticipants;
  readonly setVideoChatDefaultParticipant: setVideoChatDefaultParticipant;
  readonly createVideoChat: createVideoChat;
  readonly getVideoChatRtmpUrl: getVideoChatRtmpUrl;
  readonly replaceVideoChatRtmpUrl: replaceVideoChatRtmpUrl;
  readonly getGroupCall: getGroupCall;
  readonly startScheduledGroupCall: startScheduledGroupCall;
  readonly toggleGroupCallEnabledStartNotification: toggleGroupCallEnabledStartNotification;
  readonly joinGroupCall: joinGroupCall;
  readonly startGroupCallScreenSharing: startGroupCallScreenSharing;
  readonly toggleGroupCallScreenSharingIsPaused: toggleGroupCallScreenSharingIsPaused;
  readonly endGroupCallScreenSharing: endGroupCallScreenSharing;
  readonly setGroupCallTitle: setGroupCallTitle;
  readonly toggleGroupCallMuteNewParticipants: toggleGroupCallMuteNewParticipants;
  readonly inviteGroupCallParticipants: inviteGroupCallParticipants;
  readonly getGroupCallInviteLink: getGroupCallInviteLink;
  readonly revokeGroupCallInviteLink: revokeGroupCallInviteLink;
  readonly startGroupCallRecording: startGroupCallRecording;
  readonly endGroupCallRecording: endGroupCallRecording;
  readonly toggleGroupCallIsMyVideoPaused: toggleGroupCallIsMyVideoPaused;
  readonly toggleGroupCallIsMyVideoEnabled: toggleGroupCallIsMyVideoEnabled;
  readonly setGroupCallParticipantIsSpeaking: setGroupCallParticipantIsSpeaking;
  readonly toggleGroupCallParticipantIsMuted: toggleGroupCallParticipantIsMuted;
  readonly setGroupCallParticipantVolumeLevel: setGroupCallParticipantVolumeLevel;
  readonly toggleGroupCallParticipantIsHandRaised: toggleGroupCallParticipantIsHandRaised;
  readonly loadGroupCallParticipants: loadGroupCallParticipants;
  readonly leaveGroupCall: leaveGroupCall;
  readonly endGroupCall: endGroupCall;
  readonly getGroupCallStreams: getGroupCallStreams;
  readonly getGroupCallStreamSegment: getGroupCallStreamSegment;
  readonly setMessageSenderBlockList: setMessageSenderBlockList;
  readonly blockMessageSenderFromReplies: blockMessageSenderFromReplies;
  readonly getBlockedMessageSenders: getBlockedMessageSenders;
  readonly addContact: addContact;
  readonly importContacts: importContacts;
  readonly getContacts: getContacts;
  readonly searchContacts: searchContacts;
  readonly removeContacts: removeContacts;
  readonly getImportedContactCount: getImportedContactCount;
  readonly changeImportedContacts: changeImportedContacts;
  readonly clearImportedContacts: clearImportedContacts;
  readonly setCloseFriends: setCloseFriends;
  readonly getCloseFriends: getCloseFriends;
  readonly setUserPersonalProfilePhoto: setUserPersonalProfilePhoto;
  readonly suggestUserProfilePhoto: suggestUserProfilePhoto;
  readonly searchUserByPhoneNumber: searchUserByPhoneNumber;
  readonly sharePhoneNumber: sharePhoneNumber;
  readonly getUserProfilePhotos: getUserProfilePhotos;
  readonly getStickers: getStickers;
  readonly getAllStickerEmojis: getAllStickerEmojis;
  readonly searchStickers: searchStickers;
  readonly getPremiumStickers: getPremiumStickers;
  readonly getInstalledStickerSets: getInstalledStickerSets;
  readonly getArchivedStickerSets: getArchivedStickerSets;
  readonly getTrendingStickerSets: getTrendingStickerSets;
  readonly getAttachedStickerSets: getAttachedStickerSets;
  readonly getStickerSet: getStickerSet;
  readonly searchStickerSet: searchStickerSet;
  readonly searchInstalledStickerSets: searchInstalledStickerSets;
  readonly searchStickerSets: searchStickerSets;
  readonly changeStickerSet: changeStickerSet;
  readonly viewTrendingStickerSets: viewTrendingStickerSets;
  readonly reorderInstalledStickerSets: reorderInstalledStickerSets;
  readonly getRecentStickers: getRecentStickers;
  readonly addRecentSticker: addRecentSticker;
  readonly removeRecentSticker: removeRecentSticker;
  readonly clearRecentStickers: clearRecentStickers;
  readonly getFavoriteStickers: getFavoriteStickers;
  readonly addFavoriteSticker: addFavoriteSticker;
  readonly removeFavoriteSticker: removeFavoriteSticker;
  readonly getStickerEmojis: getStickerEmojis;
  readonly searchEmojis: searchEmojis;
  readonly getEmojiCategories: getEmojiCategories;
  readonly getAnimatedEmoji: getAnimatedEmoji;
  readonly getEmojiSuggestionsUrl: getEmojiSuggestionsUrl;
  readonly getCustomEmojiStickers: getCustomEmojiStickers;
  readonly getDefaultChatPhotoCustomEmojiStickers: getDefaultChatPhotoCustomEmojiStickers;
  readonly getDefaultProfilePhotoCustomEmojiStickers: getDefaultProfilePhotoCustomEmojiStickers;
  readonly getDefaultBackgroundCustomEmojiStickers: getDefaultBackgroundCustomEmojiStickers;
  readonly getSavedAnimations: getSavedAnimations;
  readonly addSavedAnimation: addSavedAnimation;
  readonly removeSavedAnimation: removeSavedAnimation;
  readonly getRecentInlineBots: getRecentInlineBots;
  readonly searchHashtags: searchHashtags;
  readonly removeRecentHashtag: removeRecentHashtag;
  readonly getWebPagePreview: getWebPagePreview;
  readonly getWebPageInstantView: getWebPageInstantView;
  readonly setProfilePhoto: setProfilePhoto;
  readonly deleteProfilePhoto: deleteProfilePhoto;
  readonly setAccentColor: setAccentColor;
  readonly setProfileAccentColor: setProfileAccentColor;
  readonly setName: setName;
  readonly setBio: setBio;
  readonly setUsername: setUsername;
  readonly toggleUsernameIsActive: toggleUsernameIsActive;
  readonly reorderActiveUsernames: reorderActiveUsernames;
  readonly setEmojiStatus: setEmojiStatus;
  readonly setLocation: setLocation;
  readonly changePhoneNumber: changePhoneNumber;
  readonly resendChangePhoneNumberCode: resendChangePhoneNumberCode;
  readonly checkChangePhoneNumberCode: checkChangePhoneNumberCode;
  readonly getUserLink: getUserLink;
  readonly searchUserByToken: searchUserByToken;
  readonly setCommands: setCommands;
  readonly deleteCommands: deleteCommands;
  readonly getCommands: getCommands;
  readonly setMenuButton: setMenuButton;
  readonly getMenuButton: getMenuButton;
  readonly setDefaultGroupAdministratorRights: setDefaultGroupAdministratorRights;
  readonly setDefaultChannelAdministratorRights: setDefaultChannelAdministratorRights;
  readonly canBotSendMessages: canBotSendMessages;
  readonly allowBotToSendMessages: allowBotToSendMessages;
  readonly sendWebAppCustomRequest: sendWebAppCustomRequest;
  readonly setBotName: setBotName;
  readonly getBotName: getBotName;
  readonly setBotProfilePhoto: setBotProfilePhoto;
  readonly toggleBotUsernameIsActive: toggleBotUsernameIsActive;
  readonly reorderBotActiveUsernames: reorderBotActiveUsernames;
  readonly setBotInfoDescription: setBotInfoDescription;
  readonly getBotInfoDescription: getBotInfoDescription;
  readonly setBotInfoShortDescription: setBotInfoShortDescription;
  readonly getBotInfoShortDescription: getBotInfoShortDescription;
  readonly getActiveSessions: getActiveSessions;
  readonly terminateSession: terminateSession;
  readonly terminateAllOtherSessions: terminateAllOtherSessions;
  readonly confirmSession: confirmSession;
  readonly toggleSessionCanAcceptCalls: toggleSessionCanAcceptCalls;
  readonly toggleSessionCanAcceptSecretChats: toggleSessionCanAcceptSecretChats;
  readonly setInactiveSessionTtl: setInactiveSessionTtl;
  readonly getConnectedWebsites: getConnectedWebsites;
  readonly disconnectWebsite: disconnectWebsite;
  readonly disconnectAllWebsites: disconnectAllWebsites;
  readonly setSupergroupUsername: setSupergroupUsername;
  readonly toggleSupergroupUsernameIsActive: toggleSupergroupUsernameIsActive;
  readonly disableAllSupergroupUsernames: disableAllSupergroupUsernames;
  readonly reorderSupergroupActiveUsernames: reorderSupergroupActiveUsernames;
  readonly setSupergroupStickerSet: setSupergroupStickerSet;
  readonly toggleSupergroupSignMessages: toggleSupergroupSignMessages;
  readonly toggleSupergroupJoinToSendMessages: toggleSupergroupJoinToSendMessages;
  readonly toggleSupergroupJoinByRequest: toggleSupergroupJoinByRequest;
  readonly toggleSupergroupIsAllHistoryAvailable: toggleSupergroupIsAllHistoryAvailable;
  readonly toggleSupergroupHasHiddenMembers: toggleSupergroupHasHiddenMembers;
  readonly toggleSupergroupHasAggressiveAntiSpamEnabled: toggleSupergroupHasAggressiveAntiSpamEnabled;
  readonly toggleSupergroupIsForum: toggleSupergroupIsForum;
  readonly toggleSupergroupIsBroadcastGroup: toggleSupergroupIsBroadcastGroup;
  readonly reportSupergroupSpam: reportSupergroupSpam;
  readonly reportSupergroupAntiSpamFalsePositive: reportSupergroupAntiSpamFalsePositive;
  readonly getSupergroupMembers: getSupergroupMembers;
  readonly closeSecretChat: closeSecretChat;
  readonly getChatEventLog: getChatEventLog;
  readonly getPaymentForm: getPaymentForm;
  readonly validateOrderInfo: validateOrderInfo;
  readonly sendPaymentForm: sendPaymentForm;
  readonly getPaymentReceipt: getPaymentReceipt;
  readonly getSavedOrderInfo: getSavedOrderInfo;
  readonly deleteSavedOrderInfo: deleteSavedOrderInfo;
  readonly deleteSavedCredentials: deleteSavedCredentials;
  readonly createInvoiceLink: createInvoiceLink;
  readonly getSupportUser: getSupportUser;
  readonly getBackgroundUrl: getBackgroundUrl;
  readonly searchBackground: searchBackground;
  readonly setDefaultBackground: setDefaultBackground;
  readonly deleteDefaultBackground: deleteDefaultBackground;
  readonly getInstalledBackgrounds: getInstalledBackgrounds;
  readonly removeInstalledBackground: removeInstalledBackground;
  readonly resetInstalledBackgrounds: resetInstalledBackgrounds;
  readonly getLocalizationTargetInfo: getLocalizationTargetInfo;
  readonly getLanguagePackInfo: getLanguagePackInfo;
  readonly getLanguagePackStrings: getLanguagePackStrings;
  readonly synchronizeLanguagePack: synchronizeLanguagePack;
  readonly addCustomServerLanguagePack: addCustomServerLanguagePack;
  readonly setCustomLanguagePack: setCustomLanguagePack;
  readonly editCustomLanguagePackInfo: editCustomLanguagePackInfo;
  readonly setCustomLanguagePackString: setCustomLanguagePackString;
  readonly deleteLanguagePack: deleteLanguagePack;
  readonly registerDevice: registerDevice;
  readonly processPushNotification: processPushNotification;
  readonly getPushReceiverId: getPushReceiverId;
  readonly getRecentlyVisitedTMeUrls: getRecentlyVisitedTMeUrls;
  readonly setUserPrivacySettingRules: setUserPrivacySettingRules;
  readonly getUserPrivacySettingRules: getUserPrivacySettingRules;
  readonly getOption: getOption;
  readonly setOption: setOption;
  readonly setAccountTtl: setAccountTtl;
  readonly getAccountTtl: getAccountTtl;
  readonly deleteAccount: deleteAccount;
  readonly setDefaultMessageAutoDeleteTime: setDefaultMessageAutoDeleteTime;
  readonly getDefaultMessageAutoDeleteTime: getDefaultMessageAutoDeleteTime;
  readonly removeChatActionBar: removeChatActionBar;
  readonly reportChat: reportChat;
  readonly reportChatPhoto: reportChatPhoto;
  readonly reportMessageReactions: reportMessageReactions;
  readonly getChatStatistics: getChatStatistics;
  readonly getMessageStatistics: getMessageStatistics;
  readonly getMessagePublicForwards: getMessagePublicForwards;
  readonly getStoryStatistics: getStoryStatistics;
  readonly getStatisticalGraph: getStatisticalGraph;
  readonly getStorageStatistics: getStorageStatistics;
  readonly getStorageStatisticsFast: getStorageStatisticsFast;
  readonly getDatabaseStatistics: getDatabaseStatistics;
  readonly optimizeStorage: optimizeStorage;
  readonly setNetworkType: setNetworkType;
  readonly getNetworkStatistics: getNetworkStatistics;
  readonly addNetworkStatistics: addNetworkStatistics;
  readonly resetNetworkStatistics: resetNetworkStatistics;
  readonly getAutoDownloadSettingsPresets: getAutoDownloadSettingsPresets;
  readonly setAutoDownloadSettings: setAutoDownloadSettings;
  readonly getAutosaveSettings: getAutosaveSettings;
  readonly setAutosaveSettings: setAutosaveSettings;
  readonly clearAutosaveSettingsExceptions: clearAutosaveSettingsExceptions;
  readonly getBankCardInfo: getBankCardInfo;
  readonly getPassportElement: getPassportElement;
  readonly getAllPassportElements: getAllPassportElements;
  readonly setPassportElement: setPassportElement;
  readonly deletePassportElement: deletePassportElement;
  readonly setPassportElementErrors: setPassportElementErrors;
  readonly getPreferredCountryLanguage: getPreferredCountryLanguage;
  readonly sendPhoneNumberVerificationCode: sendPhoneNumberVerificationCode;
  readonly resendPhoneNumberVerificationCode: resendPhoneNumberVerificationCode;
  readonly checkPhoneNumberVerificationCode: checkPhoneNumberVerificationCode;
  readonly sendEmailAddressVerificationCode: sendEmailAddressVerificationCode;
  readonly resendEmailAddressVerificationCode: resendEmailAddressVerificationCode;
  readonly checkEmailAddressVerificationCode: checkEmailAddressVerificationCode;
  readonly getPassportAuthorizationForm: getPassportAuthorizationForm;
  readonly getPassportAuthorizationFormAvailableElements: getPassportAuthorizationFormAvailableElements;
  readonly sendPassportAuthorizationForm: sendPassportAuthorizationForm;
  readonly sendPhoneNumberConfirmationCode: sendPhoneNumberConfirmationCode;
  readonly resendPhoneNumberConfirmationCode: resendPhoneNumberConfirmationCode;
  readonly checkPhoneNumberConfirmationCode: checkPhoneNumberConfirmationCode;
  readonly setBotUpdatesStatus: setBotUpdatesStatus;
  readonly uploadStickerFile: uploadStickerFile;
  readonly getSuggestedStickerSetName: getSuggestedStickerSetName;
  readonly checkStickerSetName: checkStickerSetName;
  readonly createNewStickerSet: createNewStickerSet;
  readonly addStickerToSet: addStickerToSet;
  readonly setStickerSetThumbnail: setStickerSetThumbnail;
  readonly setCustomEmojiStickerSetThumbnail: setCustomEmojiStickerSetThumbnail;
  readonly setStickerSetTitle: setStickerSetTitle;
  readonly deleteStickerSet: deleteStickerSet;
  readonly setStickerPositionInSet: setStickerPositionInSet;
  readonly removeStickerFromSet: removeStickerFromSet;
  readonly setStickerEmojis: setStickerEmojis;
  readonly setStickerKeywords: setStickerKeywords;
  readonly setStickerMaskPosition: setStickerMaskPosition;
  readonly getMapThumbnailFile: getMapThumbnailFile;
  readonly getPremiumLimit: getPremiumLimit;
  readonly getPremiumFeatures: getPremiumFeatures;
  readonly getPremiumStickerExamples: getPremiumStickerExamples;
  readonly viewPremiumFeature: viewPremiumFeature;
  readonly clickPremiumSubscriptionButton: clickPremiumSubscriptionButton;
  readonly getPremiumState: getPremiumState;
  readonly getPremiumGiftCodePaymentOptions: getPremiumGiftCodePaymentOptions;
  readonly checkPremiumGiftCode: checkPremiumGiftCode;
  readonly applyPremiumGiftCode: applyPremiumGiftCode;
  readonly launchPrepaidPremiumGiveaway: launchPrepaidPremiumGiveaway;
  readonly getPremiumGiveawayInfo: getPremiumGiveawayInfo;
  readonly canPurchasePremium: canPurchasePremium;
  readonly assignAppStoreTransaction: assignAppStoreTransaction;
  readonly assignGooglePlayTransaction: assignGooglePlayTransaction;
  readonly acceptTermsOfService: acceptTermsOfService;
  readonly searchStringsByPrefix: searchStringsByPrefix;
  readonly sendCustomRequest: sendCustomRequest;
  readonly answerCustomQuery: answerCustomQuery;
  readonly setAlarm: setAlarm;
  readonly getCountries: getCountries;
  readonly getCountryCode: getCountryCode;
  readonly getPhoneNumberInfo: getPhoneNumberInfo;
  readonly getPhoneNumberInfoSync: getPhoneNumberInfoSync;
  readonly getDeepLinkInfo: getDeepLinkInfo;
  readonly getApplicationConfig: getApplicationConfig;
  readonly saveApplicationLogEvent: saveApplicationLogEvent;
  readonly getApplicationDownloadLink: getApplicationDownloadLink;
  readonly addProxy: addProxy;
  readonly editProxy: editProxy;
  readonly enableProxy: enableProxy;
  readonly disableProxy: disableProxy;
  readonly removeProxy: removeProxy;
  readonly getProxies: getProxies;
  readonly getProxyLink: getProxyLink;
  readonly pingProxy: pingProxy;
  readonly setLogStream: setLogStream;
  readonly getLogStream: getLogStream;
  readonly setLogVerbosityLevel: setLogVerbosityLevel;
  readonly getLogVerbosityLevel: getLogVerbosityLevel;
  readonly getLogTags: getLogTags;
  readonly setLogTagVerbosityLevel: setLogTagVerbosityLevel;
  readonly getLogTagVerbosityLevel: getLogTagVerbosityLevel;
  readonly addLogMessage: addLogMessage;
  readonly getUserSupportInfo: getUserSupportInfo;
  readonly setUserSupportInfo: setUserSupportInfo;
  readonly getSupportName: getSupportName;
  readonly testCallEmpty: testCallEmpty;
  readonly testCallString: testCallString;
  readonly testCallBytes: testCallBytes;
  readonly testCallVectorInt: testCallVectorInt;
  readonly testCallVectorIntObject: testCallVectorIntObject;
  readonly testCallVectorString: testCallVectorString;
  readonly testCallVectorStringObject: testCallVectorStringObject;
  readonly testSquareInt: testSquareInt;
  readonly testNetwork: testNetwork;
  readonly testProxy: testProxy;
  readonly testGetDifference: testGetDifference;
  readonly testUseUpdate: testUseUpdate;
  readonly testReturnError: testReturnError;
};

export type $SyncMethodsDict = {
  readonly searchQuote: searchQuote;
  readonly getTextEntities: getTextEntities;
  readonly parseTextEntities: parseTextEntities;
  readonly parseMarkdown: parseMarkdown;
  readonly getMarkdownText: getMarkdownText;
  readonly getFileMimeType: getFileMimeType;
  readonly getFileExtension: getFileExtension;
  readonly cleanFileName: cleanFileName;
  readonly getLanguagePackString: getLanguagePackString;
  readonly getJsonValue: getJsonValue;
  readonly getJsonString: getJsonString;
  readonly getThemeParametersJsonString: getThemeParametersJsonString;
  readonly getChatFolderDefaultIconName: getChatFolderDefaultIconName;
  readonly getPushReceiverId: getPushReceiverId;
  readonly getOption: getOption;
  readonly searchStringsByPrefix: searchStringsByPrefix;
  readonly getPhoneNumberInfoSync: getPhoneNumberInfoSync;
  readonly setLogStream: setLogStream;
  readonly getLogStream: getLogStream;
  readonly setLogVerbosityLevel: setLogVerbosityLevel;
  readonly getLogVerbosityLevel: getLogVerbosityLevel;
  readonly getLogTags: getLogTags;
  readonly setLogTagVerbosityLevel: setLogTagVerbosityLevel;
  readonly getLogTagVerbosityLevel: getLogTagVerbosityLevel;
  readonly addLogMessage: addLogMessage;
  readonly testReturnError: testReturnError;
};

/**
 * Convenience class for API calls
 *
 * @class
 */
export class $AsyncApi {
  /**
   * Constructs {@link $AsyncApi}
   *
   * @param {object} client
   */
  constructor(
    private readonly client: {
      invoke(method: string, parameters: unknown): Promise<unknown>;
    }
  ) {
    Object.freeze(this);
  }

  /**
   * Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
   *
   * @param {getAuthorizationState$DirectInput} parameters {@link getAuthorizationState$Input}
   * @return {Promise<AuthorizationState>} Promise<{@link AuthorizationState}>
   */
  async getAuthorizationState(
    parameters: getAuthorizationState$DirectInput
  ): Promise<AuthorizationState> {
    const result = await this.client.invoke("getAuthorizationState", parameters);
    return result as AuthorizationState;
  }

  /**
   * Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
   *
   * @param {setTdlibParameters$DirectInput} parameters {@link setTdlibParameters$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setTdlibParameters(parameters: setTdlibParameters$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setTdlibParameters", parameters);
    return result as Ok;
  }

  /**
   * Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
   *
   * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
   *
   * @param {setAuthenticationPhoneNumber$DirectInput} parameters {@link setAuthenticationPhoneNumber$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAuthenticationPhoneNumber(
    parameters: setAuthenticationPhoneNumber$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setAuthenticationPhoneNumber",
      parameters
    );
    return result as Ok;
  }

  /**
   * Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress
   *
   * @param {setAuthenticationEmailAddress$DirectInput} parameters {@link setAuthenticationEmailAddress$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAuthenticationEmailAddress(
    parameters: setAuthenticationEmailAddress$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setAuthenticationEmailAddress",
      parameters
    );
    return result as Ok;
  }

  /**
   * Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed,
   *
   * - or when the current authorization state is authorizationStateWaitEmailCode
   *
   * @param {resendAuthenticationCode$DirectInput} parameters {@link resendAuthenticationCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async resendAuthenticationCode(
    parameters: resendAuthenticationCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("resendAuthenticationCode", parameters);
    return result as Ok;
  }

  /**
   * Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode
   *
   * @param {checkAuthenticationEmailCode$DirectInput} parameters {@link checkAuthenticationEmailCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkAuthenticationEmailCode(
    parameters: checkAuthenticationEmailCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkAuthenticationEmailCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
   *
   * @param {checkAuthenticationCode$DirectInput} parameters {@link checkAuthenticationCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkAuthenticationCode(
    parameters: checkAuthenticationCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("checkAuthenticationCode", parameters);
    return result as Ok;
  }

  /**
   * Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
   *
   * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
   *
   * @param {requestQrCodeAuthentication$DirectInput} parameters {@link requestQrCodeAuthentication$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async requestQrCodeAuthentication(
    parameters: requestQrCodeAuthentication$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "requestQrCodeAuthentication",
      parameters
    );
    return result as Ok;
  }

  /**
   * Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
   *
   * @param {registerUser$DirectInput} parameters {@link registerUser$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async registerUser(parameters: registerUser$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("registerUser", parameters);
    return result as Ok;
  }

  /**
   * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS" if reset is still pending.
   *
   * - Works only when the current authorization state is authorizationStateWaitEmailCode and authorization_state.can_reset_email_address == true
   *
   * @param {resetAuthenticationEmailAddress$DirectInput} parameters {@link resetAuthenticationEmailAddress$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async resetAuthenticationEmailAddress(
    parameters: resetAuthenticationEmailAddress$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "resetAuthenticationEmailAddress",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
   *
   * @param {checkAuthenticationPassword$DirectInput} parameters {@link checkAuthenticationPassword$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkAuthenticationPassword(
    parameters: checkAuthenticationPassword$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkAuthenticationPassword",
      parameters
    );
    return result as Ok;
  }

  /**
   * Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
   *
   * @param {requestAuthenticationPasswordRecovery$DirectInput} parameters {@link requestAuthenticationPasswordRecovery$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async requestAuthenticationPasswordRecovery(
    parameters: requestAuthenticationPasswordRecovery$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "requestAuthenticationPasswordRecovery",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
   *
   * @param {checkAuthenticationPasswordRecoveryCode$DirectInput} parameters {@link checkAuthenticationPasswordRecoveryCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkAuthenticationPasswordRecoveryCode(
    parameters: checkAuthenticationPasswordRecoveryCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkAuthenticationPasswordRecoveryCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
   *
   * @param {recoverAuthenticationPassword$DirectInput} parameters {@link recoverAuthenticationPassword$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async recoverAuthenticationPassword(
    parameters: recoverAuthenticationPassword$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "recoverAuthenticationPassword",
      parameters
    );
    return result as Ok;
  }

  /**
   * Sends Firebase Authentication SMS to the phone number of the user. Works only when the current authorization state is authorizationStateWaitCode and the server returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
   *
   * @param {sendAuthenticationFirebaseSms$DirectInput} parameters {@link sendAuthenticationFirebaseSms$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendAuthenticationFirebaseSms(
    parameters: sendAuthenticationFirebaseSms$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "sendAuthenticationFirebaseSms",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
   *
   * @param {checkAuthenticationBotToken$DirectInput} parameters {@link checkAuthenticationBotToken$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkAuthenticationBotToken(
    parameters: checkAuthenticationBotToken$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkAuthenticationBotToken",
      parameters
    );
    return result as Ok;
  }

  /**
   * Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
   *
   * @param {logOut$DirectInput} parameters {@link logOut$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async logOut(parameters: logOut$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("logOut", parameters);
    return result as Ok;
  }

  /**
   * Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
   *
   * @param {close$DirectInput} parameters {@link close$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async close(parameters: close$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("close", parameters);
    return result as Ok;
  }

  /**
   * Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed.
   *
   * - After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
   *
   * @param {destroy$DirectInput} parameters {@link destroy$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async destroy(parameters: destroy$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("destroy", parameters);
    return result as Ok;
  }

  /**
   * Confirms QR code authentication on another device. Returns created session on success
   *
   * @param {confirmQrCodeAuthentication$DirectInput} parameters {@link confirmQrCodeAuthentication$Input}
   * @return {Promise<Session>} Promise<{@link Session}>
   */
  async confirmQrCodeAuthentication(
    parameters: confirmQrCodeAuthentication$DirectInput
  ): Promise<Session> {
    const result = await this.client.invoke(
      "confirmQrCodeAuthentication",
      parameters
    );
    return result as Session;
  }

  /**
   * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
   *
   * @param {getCurrentState$DirectInput} parameters {@link getCurrentState$Input}
   * @return {Promise<Updates>} Promise<{@link Updates}>
   */
  async getCurrentState(parameters: getCurrentState$DirectInput): Promise<Updates> {
    const result = await this.client.invoke("getCurrentState", parameters);
    return result as Updates;
  }

  /**
   * Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
   *
   * @param {setDatabaseEncryptionKey$DirectInput} parameters {@link setDatabaseEncryptionKey$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setDatabaseEncryptionKey(
    parameters: setDatabaseEncryptionKey$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setDatabaseEncryptionKey", parameters);
    return result as Ok;
  }

  /**
   * Returns the current state of 2-step verification
   *
   * @param {getPasswordState$DirectInput} parameters {@link getPasswordState$Input}
   * @return {Promise<PasswordState>} Promise<{@link PasswordState}>
   */
  async getPasswordState(
    parameters: getPasswordState$DirectInput
  ): Promise<PasswordState> {
    const result = await this.client.invoke("getPasswordState", parameters);
    return result as PasswordState;
  }

  /**
   * Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
   *
   * @param {setPassword$DirectInput} parameters {@link setPassword$Input}
   * @return {Promise<PasswordState>} Promise<{@link PasswordState}>
   */
  async setPassword(parameters: setPassword$DirectInput): Promise<PasswordState> {
    const result = await this.client.invoke("setPassword", parameters);
    return result as PasswordState;
  }

  /**
   * Changes the login email address of the user. The email address can be changed only if the current user already has login email and passwordState.login_email_address_pattern is non-empty.
   *
   * - The change will not be applied until the new login email address is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead of a email address, call checkLoginEmailAddressCode directly
   *
   * @param {setLoginEmailAddress$DirectInput} parameters {@link setLoginEmailAddress$Input}
   * @return {Promise<EmailAddressAuthenticationCodeInfo>} Promise<{@link EmailAddressAuthenticationCodeInfo}>
   */
  async setLoginEmailAddress(
    parameters: setLoginEmailAddress$DirectInput
  ): Promise<EmailAddressAuthenticationCodeInfo> {
    const result = await this.client.invoke("setLoginEmailAddress", parameters);
    return result as EmailAddressAuthenticationCodeInfo;
  }

  /**
   * Resends the login email address verification code
   *
   * @param {resendLoginEmailAddressCode$DirectInput} parameters {@link resendLoginEmailAddressCode$Input}
   * @return {Promise<EmailAddressAuthenticationCodeInfo>} Promise<{@link EmailAddressAuthenticationCodeInfo}>
   */
  async resendLoginEmailAddressCode(
    parameters: resendLoginEmailAddressCode$DirectInput
  ): Promise<EmailAddressAuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "resendLoginEmailAddressCode",
      parameters
    );
    return result as EmailAddressAuthenticationCodeInfo;
  }

  /**
   * Checks the login email address authentication
   *
   * @param {checkLoginEmailAddressCode$DirectInput} parameters {@link checkLoginEmailAddressCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkLoginEmailAddressCode(
    parameters: checkLoginEmailAddressCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkLoginEmailAddressCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
   *
   * @param {getRecoveryEmailAddress$DirectInput} parameters {@link getRecoveryEmailAddress$Input}
   * @return {Promise<RecoveryEmailAddress>} Promise<{@link RecoveryEmailAddress}>
   */
  async getRecoveryEmailAddress(
    parameters: getRecoveryEmailAddress$DirectInput
  ): Promise<RecoveryEmailAddress> {
    const result = await this.client.invoke("getRecoveryEmailAddress", parameters);
    return result as RecoveryEmailAddress;
  }

  /**
   * Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
   *
   * - If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
   *
   * @param {setRecoveryEmailAddress$DirectInput} parameters {@link setRecoveryEmailAddress$Input}
   * @return {Promise<PasswordState>} Promise<{@link PasswordState}>
   */
  async setRecoveryEmailAddress(
    parameters: setRecoveryEmailAddress$DirectInput
  ): Promise<PasswordState> {
    const result = await this.client.invoke("setRecoveryEmailAddress", parameters);
    return result as PasswordState;
  }

  /**
   * Checks the 2-step verification recovery email address verification code
   *
   * @param {checkRecoveryEmailAddressCode$DirectInput} parameters {@link checkRecoveryEmailAddressCode$Input}
   * @return {Promise<PasswordState>} Promise<{@link PasswordState}>
   */
  async checkRecoveryEmailAddressCode(
    parameters: checkRecoveryEmailAddressCode$DirectInput
  ): Promise<PasswordState> {
    const result = await this.client.invoke(
      "checkRecoveryEmailAddressCode",
      parameters
    );
    return result as PasswordState;
  }

  /**
   * Resends the 2-step verification recovery email address verification code
   *
   * @param {resendRecoveryEmailAddressCode$DirectInput} parameters {@link resendRecoveryEmailAddressCode$Input}
   * @return {Promise<PasswordState>} Promise<{@link PasswordState}>
   */
  async resendRecoveryEmailAddressCode(
    parameters: resendRecoveryEmailAddressCode$DirectInput
  ): Promise<PasswordState> {
    const result = await this.client.invoke(
      "resendRecoveryEmailAddressCode",
      parameters
    );
    return result as PasswordState;
  }

  /**
   * Requests to send a 2-step verification password recovery code to an email address that was previously set up
   *
   * @param {requestPasswordRecovery$DirectInput} parameters {@link requestPasswordRecovery$Input}
   * @return {Promise<EmailAddressAuthenticationCodeInfo>} Promise<{@link EmailAddressAuthenticationCodeInfo}>
   */
  async requestPasswordRecovery(
    parameters: requestPasswordRecovery$DirectInput
  ): Promise<EmailAddressAuthenticationCodeInfo> {
    const result = await this.client.invoke("requestPasswordRecovery", parameters);
    return result as EmailAddressAuthenticationCodeInfo;
  }

  /**
   * Checks whether a 2-step verification password recovery code sent to an email address is valid
   *
   * @param {checkPasswordRecoveryCode$DirectInput} parameters {@link checkPasswordRecoveryCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkPasswordRecoveryCode(
    parameters: checkPasswordRecoveryCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("checkPasswordRecoveryCode", parameters);
    return result as Ok;
  }

  /**
   * Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
   *
   * @param {recoverPassword$DirectInput} parameters {@link recoverPassword$Input}
   * @return {Promise<PasswordState>} Promise<{@link PasswordState}>
   */
  async recoverPassword(
    parameters: recoverPassword$DirectInput
  ): Promise<PasswordState> {
    const result = await this.client.invoke("recoverPassword", parameters);
    return result as PasswordState;
  }

  /**
   * Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
   *
   * @param {resetPassword$DirectInput} parameters {@link resetPassword$Input}
   * @return {Promise<ResetPasswordResult>} Promise<{@link ResetPasswordResult}>
   */
  async resetPassword(
    parameters: resetPassword$DirectInput
  ): Promise<ResetPasswordResult> {
    const result = await this.client.invoke("resetPassword", parameters);
    return result as ResetPasswordResult;
  }

  /**
   * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
   *
   * @param {cancelPasswordReset$DirectInput} parameters {@link cancelPasswordReset$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async cancelPasswordReset(
    parameters: cancelPasswordReset$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("cancelPasswordReset", parameters);
    return result as Ok;
  }

  /**
   * Creates a new temporary password for processing payments
   *
   * @param {createTemporaryPassword$DirectInput} parameters {@link createTemporaryPassword$Input}
   * @return {Promise<TemporaryPasswordState>} Promise<{@link TemporaryPasswordState}>
   */
  async createTemporaryPassword(
    parameters: createTemporaryPassword$DirectInput
  ): Promise<TemporaryPasswordState> {
    const result = await this.client.invoke("createTemporaryPassword", parameters);
    return result as TemporaryPasswordState;
  }

  /**
   * Returns information about the current temporary password
   *
   * @param {getTemporaryPasswordState$DirectInput} parameters {@link getTemporaryPasswordState$Input}
   * @return {Promise<TemporaryPasswordState>} Promise<{@link TemporaryPasswordState}>
   */
  async getTemporaryPasswordState(
    parameters: getTemporaryPasswordState$DirectInput
  ): Promise<TemporaryPasswordState> {
    const result = await this.client.invoke("getTemporaryPasswordState", parameters);
    return result as TemporaryPasswordState;
  }

  /**
   * Returns the current user
   *
   * @param {getMe$DirectInput} parameters {@link getMe$Input}
   * @return {Promise<User>} Promise<{@link User}>
   */
  async getMe(parameters: getMe$DirectInput): Promise<User> {
    const result = await this.client.invoke("getMe", parameters);
    return result as User;
  }

  /**
   * Returns information about a user by their identifier. This is an offline request if the current user is not a bot
   *
   * @param {getUser$DirectInput} parameters {@link getUser$Input}
   * @return {Promise<User>} Promise<{@link User}>
   */
  async getUser(parameters: getUser$DirectInput): Promise<User> {
    const result = await this.client.invoke("getUser", parameters);
    return result as User;
  }

  /**
   * Returns full information about a user by their identifier
   *
   * @param {getUserFullInfo$DirectInput} parameters {@link getUserFullInfo$Input}
   * @return {Promise<UserFullInfo>} Promise<{@link UserFullInfo}>
   */
  async getUserFullInfo(
    parameters: getUserFullInfo$DirectInput
  ): Promise<UserFullInfo> {
    const result = await this.client.invoke("getUserFullInfo", parameters);
    return result as UserFullInfo;
  }

  /**
   * Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
   *
   * @param {getBasicGroup$DirectInput} parameters {@link getBasicGroup$Input}
   * @return {Promise<BasicGroup>} Promise<{@link BasicGroup}>
   */
  async getBasicGroup(parameters: getBasicGroup$DirectInput): Promise<BasicGroup> {
    const result = await this.client.invoke("getBasicGroup", parameters);
    return result as BasicGroup;
  }

  /**
   * Returns full information about a basic group by its identifier
   *
   * @param {getBasicGroupFullInfo$DirectInput} parameters {@link getBasicGroupFullInfo$Input}
   * @return {Promise<BasicGroupFullInfo>} Promise<{@link BasicGroupFullInfo}>
   */
  async getBasicGroupFullInfo(
    parameters: getBasicGroupFullInfo$DirectInput
  ): Promise<BasicGroupFullInfo> {
    const result = await this.client.invoke("getBasicGroupFullInfo", parameters);
    return result as BasicGroupFullInfo;
  }

  /**
   * Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
   *
   * @param {getSupergroup$DirectInput} parameters {@link getSupergroup$Input}
   * @return {Promise<Supergroup>} Promise<{@link Supergroup}>
   */
  async getSupergroup(parameters: getSupergroup$DirectInput): Promise<Supergroup> {
    const result = await this.client.invoke("getSupergroup", parameters);
    return result as Supergroup;
  }

  /**
   * Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
   *
   * @param {getSupergroupFullInfo$DirectInput} parameters {@link getSupergroupFullInfo$Input}
   * @return {Promise<SupergroupFullInfo>} Promise<{@link SupergroupFullInfo}>
   */
  async getSupergroupFullInfo(
    parameters: getSupergroupFullInfo$DirectInput
  ): Promise<SupergroupFullInfo> {
    const result = await this.client.invoke("getSupergroupFullInfo", parameters);
    return result as SupergroupFullInfo;
  }

  /**
   * Returns information about a secret chat by its identifier. This is an offline request
   *
   * @param {getSecretChat$DirectInput} parameters {@link getSecretChat$Input}
   * @return {Promise<SecretChat>} Promise<{@link SecretChat}>
   */
  async getSecretChat(parameters: getSecretChat$DirectInput): Promise<SecretChat> {
    const result = await this.client.invoke("getSecretChat", parameters);
    return result as SecretChat;
  }

  /**
   * Returns information about a chat by its identifier; this is an offline request if the current user is not a bot
   *
   * @param {getChat$DirectInput} parameters {@link getChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async getChat(parameters: getChat$DirectInput): Promise<Chat> {
    const result = await this.client.invoke("getChat", parameters);
    return result as Chat;
  }

  /**
   * Returns information about a message
   *
   * @param {getMessage$DirectInput} parameters {@link getMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async getMessage(parameters: getMessage$DirectInput): Promise<Message> {
    const result = await this.client.invoke("getMessage", parameters);
    return result as Message;
  }

  /**
   * Returns information about a message, if it is available without sending network request. This is an offline request
   *
   * @param {getMessageLocally$DirectInput} parameters {@link getMessageLocally$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async getMessageLocally(
    parameters: getMessageLocally$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("getMessageLocally", parameters);
    return result as Message;
  }

  /**
   * Returns information about a non-bundled message that is replied by a given message. Also, returns the pinned message, the game message, the invoice message,
   *
   * - the message with a previously set same background, the giveaway message, and the topic creation message for messages of the types
   *
   * - messagePinMessage, messageGameScore, messagePaymentSuccessful, messageChatSetBackground, messagePremiumGiveawayCompleted and topic messages without non-bundled replied message respectively
   *
   * @param {getRepliedMessage$DirectInput} parameters {@link getRepliedMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async getRepliedMessage(
    parameters: getRepliedMessage$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("getRepliedMessage", parameters);
    return result as Message;
  }

  /**
   * Returns information about a newest pinned message in the chat
   *
   * @param {getChatPinnedMessage$DirectInput} parameters {@link getChatPinnedMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async getChatPinnedMessage(
    parameters: getChatPinnedMessage$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("getChatPinnedMessage", parameters);
    return result as Message;
  }

  /**
   * Returns information about a message with the callback button that originated a callback query; for bots only
   *
   * @param {getCallbackQueryMessage$DirectInput} parameters {@link getCallbackQueryMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async getCallbackQueryMessage(
    parameters: getCallbackQueryMessage$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("getCallbackQueryMessage", parameters);
    return result as Message;
  }

  /**
   * Returns information about messages. If a message is not found, returns null on the corresponding position of the result
   *
   * @param {getMessages$DirectInput} parameters {@link getMessages$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async getMessages(parameters: getMessages$DirectInput): Promise<Messages> {
    const result = await this.client.invoke("getMessages", parameters);
    return result as Messages;
  }

  /**
   * Returns information about a message thread. Can be used only if message.can_get_message_thread == true
   *
   * @param {getMessageThread$DirectInput} parameters {@link getMessageThread$Input}
   * @return {Promise<MessageThreadInfo>} Promise<{@link MessageThreadInfo}>
   */
  async getMessageThread(
    parameters: getMessageThread$DirectInput
  ): Promise<MessageThreadInfo> {
    const result = await this.client.invoke("getMessageThread", parameters);
    return result as MessageThreadInfo;
  }

  /**
   * Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
   *
   * @param {getMessageViewers$DirectInput} parameters {@link getMessageViewers$Input}
   * @return {Promise<MessageViewers>} Promise<{@link MessageViewers}>
   */
  async getMessageViewers(
    parameters: getMessageViewers$DirectInput
  ): Promise<MessageViewers> {
    const result = await this.client.invoke("getMessageViewers", parameters);
    return result as MessageViewers;
  }

  /**
   * Returns information about a file; this is an offline request
   *
   * @param {getFile$DirectInput} parameters {@link getFile$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async getFile(parameters: getFile$DirectInput): Promise<File> {
    const result = await this.client.invoke("getFile", parameters);
    return result as File;
  }

  /**
   * Returns information about a file by its remote identifier; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
   *
   * - For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
   *
   * @param {getRemoteFile$DirectInput} parameters {@link getRemoteFile$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async getRemoteFile(parameters: getRemoteFile$DirectInput): Promise<File> {
    const result = await this.client.invoke("getRemoteFile", parameters);
    return result as File;
  }

  /**
   * Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
   *
   * @param {loadChats$DirectInput} parameters {@link loadChats$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async loadChats(parameters: loadChats$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("loadChats", parameters);
    return result as Ok;
  }

  /**
   * Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
   *
   * @param {getChats$DirectInput} parameters {@link getChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChats(parameters: getChats$DirectInput): Promise<Chats> {
    const result = await this.client.invoke("getChats", parameters);
    return result as Chats;
  }

  /**
   * Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise, an error is returned
   *
   * @param {searchPublicChat$DirectInput} parameters {@link searchPublicChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async searchPublicChat(parameters: searchPublicChat$DirectInput): Promise<Chat> {
    const result = await this.client.invoke("searchPublicChat", parameters);
    return result as Chat;
  }

  /**
   * Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
   *
   * - Excludes private chats with contacts and chats from the chat list from the results
   *
   * @param {searchPublicChats$DirectInput} parameters {@link searchPublicChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async searchPublicChats(
    parameters: searchPublicChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("searchPublicChats", parameters);
    return result as Chats;
  }

  /**
   * Searches for the specified query in the title and username of already known chats; this is an offline request. Returns chats in the order seen in the main chat list
   *
   * @param {searchChats$DirectInput} parameters {@link searchChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async searchChats(parameters: searchChats$DirectInput): Promise<Chats> {
    const result = await this.client.invoke("searchChats", parameters);
    return result as Chats;
  }

  /**
   * Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
   *
   * @param {searchChatsOnServer$DirectInput} parameters {@link searchChatsOnServer$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async searchChatsOnServer(
    parameters: searchChatsOnServer$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("searchChatsOnServer", parameters);
    return result as Chats;
  }

  /**
   * Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
   *
   * - The request must be sent again every 25 seconds with adjusted location to not miss new chats
   *
   * @param {searchChatsNearby$DirectInput} parameters {@link searchChatsNearby$Input}
   * @return {Promise<ChatsNearby>} Promise<{@link ChatsNearby}>
   */
  async searchChatsNearby(
    parameters: searchChatsNearby$DirectInput
  ): Promise<ChatsNearby> {
    const result = await this.client.invoke("searchChatsNearby", parameters);
    return result as ChatsNearby;
  }

  /**
   * Returns a list of chats similar to the given chat
   *
   * @param {getChatSimilarChats$DirectInput} parameters {@link getChatSimilarChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChatSimilarChats(
    parameters: getChatSimilarChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getChatSimilarChats", parameters);
    return result as Chats;
  }

  /**
   * Returns approximate number of chats similar to the given chat
   *
   * @param {getChatSimilarChatCount$DirectInput} parameters {@link getChatSimilarChatCount$Input}
   * @return {Promise<Count>} Promise<{@link Count}>
   */
  async getChatSimilarChatCount(
    parameters: getChatSimilarChatCount$DirectInput
  ): Promise<Count> {
    const result = await this.client.invoke("getChatSimilarChatCount", parameters);
    return result as Count;
  }

  /**
   * Informs TDLib that a chat was opened from the list of similar chats. The method is independent from openChat and closeChat methods
   *
   * @param {openChatSimilarChat$DirectInput} parameters {@link openChatSimilarChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async openChatSimilarChat(
    parameters: openChatSimilarChat$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("openChatSimilarChat", parameters);
    return result as Ok;
  }

  /**
   * Returns a list of frequently used chats
   *
   * @param {getTopChats$DirectInput} parameters {@link getTopChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getTopChats(parameters: getTopChats$DirectInput): Promise<Chats> {
    const result = await this.client.invoke("getTopChats", parameters);
    return result as Chats;
  }

  /**
   * Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
   *
   * @param {removeTopChat$DirectInput} parameters {@link removeTopChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeTopChat(parameters: removeTopChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("removeTopChat", parameters);
    return result as Ok;
  }

  /**
   * Searches for the specified query in the title and username of up to 50 recently found chats; this is an offline request
   *
   * @param {searchRecentlyFoundChats$DirectInput} parameters {@link searchRecentlyFoundChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async searchRecentlyFoundChats(
    parameters: searchRecentlyFoundChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("searchRecentlyFoundChats", parameters);
    return result as Chats;
  }

  /**
   * Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
   *
   * @param {addRecentlyFoundChat$DirectInput} parameters {@link addRecentlyFoundChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addRecentlyFoundChat(
    parameters: addRecentlyFoundChat$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("addRecentlyFoundChat", parameters);
    return result as Ok;
  }

  /**
   * Removes a chat from the list of recently found chats
   *
   * @param {removeRecentlyFoundChat$DirectInput} parameters {@link removeRecentlyFoundChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeRecentlyFoundChat(
    parameters: removeRecentlyFoundChat$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeRecentlyFoundChat", parameters);
    return result as Ok;
  }

  /**
   * Clears the list of recently found chats
   *
   * @param {clearRecentlyFoundChats$DirectInput} parameters {@link clearRecentlyFoundChats$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearRecentlyFoundChats(
    parameters: clearRecentlyFoundChats$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clearRecentlyFoundChats", parameters);
    return result as Ok;
  }

  /**
   * Returns recently opened chats; this is an offline request. Returns chats in the order of last opening
   *
   * @param {getRecentlyOpenedChats$DirectInput} parameters {@link getRecentlyOpenedChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getRecentlyOpenedChats(
    parameters: getRecentlyOpenedChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getRecentlyOpenedChats", parameters);
    return result as Chats;
  }

  /**
   * Checks whether a username can be set for a chat
   *
   * @param {checkChatUsername$DirectInput} parameters {@link checkChatUsername$Input}
   * @return {Promise<CheckChatUsernameResult>} Promise<{@link CheckChatUsernameResult}>
   */
  async checkChatUsername(
    parameters: checkChatUsername$DirectInput
  ): Promise<CheckChatUsernameResult> {
    const result = await this.client.invoke("checkChatUsername", parameters);
    return result as CheckChatUsernameResult;
  }

  /**
   * Returns a list of public chats of the specified type, owned by the user
   *
   * @param {getCreatedPublicChats$DirectInput} parameters {@link getCreatedPublicChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getCreatedPublicChats(
    parameters: getCreatedPublicChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getCreatedPublicChats", parameters);
    return result as Chats;
  }

  /**
   * Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium
   *
   * @param {checkCreatedPublicChatsLimit$DirectInput} parameters {@link checkCreatedPublicChatsLimit$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkCreatedPublicChatsLimit(
    parameters: checkCreatedPublicChatsLimit$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkCreatedPublicChatsLimit",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group.
   *
   * - To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
   *
   * @param {getSuitableDiscussionChats$DirectInput} parameters {@link getSuitableDiscussionChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getSuitableDiscussionChats(
    parameters: getSuitableDiscussionChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke(
      "getSuitableDiscussionChats",
      parameters
    );
    return result as Chats;
  }

  /**
   * Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
   *
   * @param {getInactiveSupergroupChats$DirectInput} parameters {@link getInactiveSupergroupChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getInactiveSupergroupChats(
    parameters: getInactiveSupergroupChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke(
      "getInactiveSupergroupChats",
      parameters
    );
    return result as Chats;
  }

  /**
   * Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
   *
   * @param {getGroupsInCommon$DirectInput} parameters {@link getGroupsInCommon$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getGroupsInCommon(
    parameters: getGroupsInCommon$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getGroupsInCommon", parameters);
    return result as Chats;
  }

  /**
   * Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
   *
   * @param {getChatHistory$DirectInput} parameters {@link getChatHistory$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async getChatHistory(parameters: getChatHistory$DirectInput): Promise<Messages> {
    const result = await this.client.invoke("getChatHistory", parameters);
    return result as Messages;
  }

  /**
   * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
   *
   * - The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
   *
   * @param {getMessageThreadHistory$DirectInput} parameters {@link getMessageThreadHistory$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async getMessageThreadHistory(
    parameters: getMessageThreadHistory$DirectInput
  ): Promise<Messages> {
    const result = await this.client.invoke("getMessageThreadHistory", parameters);
    return result as Messages;
  }

  /**
   * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
   *
   * @param {deleteChatHistory$DirectInput} parameters {@link deleteChatHistory$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatHistory(parameters: deleteChatHistory$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteChatHistory", parameters);
    return result as Ok;
  }

  /**
   * Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members.
   *
   * - Use the field chat.can_be_deleted_for_all_users to find whether the method can be applied to the chat
   *
   * @param {deleteChat$DirectInput} parameters {@link deleteChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChat(parameters: deleteChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteChat", parameters);
    return result as Ok;
  }

  /**
   * Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
   *
   * - (searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
   *
   * - A combination of query, sender_id, filter and message_thread_id search criteria is expected to be supported, only if it is required for Telegram official application implementation
   *
   * @param {searchChatMessages$DirectInput} parameters {@link searchChatMessages$Input}
   * @return {Promise<FoundChatMessages>} Promise<{@link FoundChatMessages}>
   */
  async searchChatMessages(
    parameters: searchChatMessages$DirectInput
  ): Promise<FoundChatMessages> {
    const result = await this.client.invoke("searchChatMessages", parameters);
    return result as FoundChatMessages;
  }

  /**
   * Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   *
   * @param {searchMessages$DirectInput} parameters {@link searchMessages$Input}
   * @return {Promise<FoundMessages>} Promise<{@link FoundMessages}>
   */
  async searchMessages(
    parameters: searchMessages$DirectInput
  ): Promise<FoundMessages> {
    const result = await this.client.invoke("searchMessages", parameters);
    return result as FoundMessages;
  }

  /**
   * Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
   *
   * @param {searchSecretMessages$DirectInput} parameters {@link searchSecretMessages$Input}
   * @return {Promise<FoundMessages>} Promise<{@link FoundMessages}>
   */
  async searchSecretMessages(
    parameters: searchSecretMessages$DirectInput
  ): Promise<FoundMessages> {
    const result = await this.client.invoke("searchSecretMessages", parameters);
    return result as FoundMessages;
  }

  /**
   * Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
   *
   * @param {searchCallMessages$DirectInput} parameters {@link searchCallMessages$Input}
   * @return {Promise<FoundMessages>} Promise<{@link FoundMessages}>
   */
  async searchCallMessages(
    parameters: searchCallMessages$DirectInput
  ): Promise<FoundMessages> {
    const result = await this.client.invoke("searchCallMessages", parameters);
    return result as FoundMessages;
  }

  /**
   * Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order
   *
   * @param {searchOutgoingDocumentMessages$DirectInput} parameters {@link searchOutgoingDocumentMessages$Input}
   * @return {Promise<FoundMessages>} Promise<{@link FoundMessages}>
   */
  async searchOutgoingDocumentMessages(
    parameters: searchOutgoingDocumentMessages$DirectInput
  ): Promise<FoundMessages> {
    const result = await this.client.invoke(
      "searchOutgoingDocumentMessages",
      parameters
    );
    return result as FoundMessages;
  }

  /**
   * Deletes all call messages
   *
   * @param {deleteAllCallMessages$DirectInput} parameters {@link deleteAllCallMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteAllCallMessages(
    parameters: deleteAllCallMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteAllCallMessages", parameters);
    return result as Ok;
  }

  /**
   * Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
   *
   * @param {searchChatRecentLocationMessages$DirectInput} parameters {@link searchChatRecentLocationMessages$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async searchChatRecentLocationMessages(
    parameters: searchChatRecentLocationMessages$DirectInput
  ): Promise<Messages> {
    const result = await this.client.invoke(
      "searchChatRecentLocationMessages",
      parameters
    );
    return result as Messages;
  }

  /**
   * Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
   *
   * @param {getActiveLiveLocationMessages$DirectInput} parameters {@link getActiveLiveLocationMessages$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async getActiveLiveLocationMessages(
    parameters: getActiveLiveLocationMessages$DirectInput
  ): Promise<Messages> {
    const result = await this.client.invoke(
      "getActiveLiveLocationMessages",
      parameters
    );
    return result as Messages;
  }

  /**
   * Returns the last message sent in a chat no later than the specified date
   *
   * @param {getChatMessageByDate$DirectInput} parameters {@link getChatMessageByDate$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async getChatMessageByDate(
    parameters: getChatMessageByDate$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("getChatMessageByDate", parameters);
    return result as Message;
  }

  /**
   * Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
   *
   * - Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
   *
   * @param {getChatSparseMessagePositions$DirectInput} parameters {@link getChatSparseMessagePositions$Input}
   * @return {Promise<MessagePositions>} Promise<{@link MessagePositions}>
   */
  async getChatSparseMessagePositions(
    parameters: getChatSparseMessagePositions$DirectInput
  ): Promise<MessagePositions> {
    const result = await this.client.invoke(
      "getChatSparseMessagePositions",
      parameters
    );
    return result as MessagePositions;
  }

  /**
   * Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
   *
   * @param {getChatMessageCalendar$DirectInput} parameters {@link getChatMessageCalendar$Input}
   * @return {Promise<MessageCalendar>} Promise<{@link MessageCalendar}>
   */
  async getChatMessageCalendar(
    parameters: getChatMessageCalendar$DirectInput
  ): Promise<MessageCalendar> {
    const result = await this.client.invoke("getChatMessageCalendar", parameters);
    return result as MessageCalendar;
  }

  /**
   * Returns approximate number of messages of the specified type in the chat
   *
   * @param {getChatMessageCount$DirectInput} parameters {@link getChatMessageCount$Input}
   * @return {Promise<Count>} Promise<{@link Count}>
   */
  async getChatMessageCount(
    parameters: getChatMessageCount$DirectInput
  ): Promise<Count> {
    const result = await this.client.invoke("getChatMessageCount", parameters);
    return result as Count;
  }

  /**
   * Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats
   *
   * @param {getChatMessagePosition$DirectInput} parameters {@link getChatMessagePosition$Input}
   * @return {Promise<Count>} Promise<{@link Count}>
   */
  async getChatMessagePosition(
    parameters: getChatMessagePosition$DirectInput
  ): Promise<Count> {
    const result = await this.client.invoke("getChatMessagePosition", parameters);
    return result as Count;
  }

  /**
   * Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
   *
   * @param {getChatScheduledMessages$DirectInput} parameters {@link getChatScheduledMessages$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async getChatScheduledMessages(
    parameters: getChatScheduledMessages$DirectInput
  ): Promise<Messages> {
    const result = await this.client.invoke("getChatScheduledMessages", parameters);
    return result as Messages;
  }

  /**
   * Returns sponsored messages to be shown in a chat; for channel chats only
   *
   * @param {getChatSponsoredMessages$DirectInput} parameters {@link getChatSponsoredMessages$Input}
   * @return {Promise<SponsoredMessages>} Promise<{@link SponsoredMessages}>
   */
  async getChatSponsoredMessages(
    parameters: getChatSponsoredMessages$DirectInput
  ): Promise<SponsoredMessages> {
    const result = await this.client.invoke("getChatSponsoredMessages", parameters);
    return result as SponsoredMessages;
  }

  /**
   * Informs TDLib that the user opened the sponsored chat via the button, the name, the photo, or a mention in the sponsored message
   *
   * @param {clickChatSponsoredMessage$DirectInput} parameters {@link clickChatSponsoredMessage$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clickChatSponsoredMessage(
    parameters: clickChatSponsoredMessage$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clickChatSponsoredMessage", parameters);
    return result as Ok;
  }

  /**
   * Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
   *
   * @param {removeNotification$DirectInput} parameters {@link removeNotification$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeNotification(parameters: removeNotification$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("removeNotification", parameters);
    return result as Ok;
  }

  /**
   * Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
   *
   * @param {removeNotificationGroup$DirectInput} parameters {@link removeNotificationGroup$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeNotificationGroup(
    parameters: removeNotificationGroup$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeNotificationGroup", parameters);
    return result as Ok;
  }

  /**
   * Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
   *
   * @param {getMessageLink$DirectInput} parameters {@link getMessageLink$Input}
   * @return {Promise<MessageLink>} Promise<{@link MessageLink}>
   */
  async getMessageLink(
    parameters: getMessageLink$DirectInput
  ): Promise<MessageLink> {
    const result = await this.client.invoke("getMessageLink", parameters);
    return result as MessageLink;
  }

  /**
   * Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
   *
   * @param {getMessageEmbeddingCode$DirectInput} parameters {@link getMessageEmbeddingCode$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getMessageEmbeddingCode(
    parameters: getMessageEmbeddingCode$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke("getMessageEmbeddingCode", parameters);
    return result as Text;
  }

  /**
   * Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
   *
   * @param {getMessageLinkInfo$DirectInput} parameters {@link getMessageLinkInfo$Input}
   * @return {Promise<MessageLinkInfo>} Promise<{@link MessageLinkInfo}>
   */
  async getMessageLinkInfo(
    parameters: getMessageLinkInfo$DirectInput
  ): Promise<MessageLinkInfo> {
    const result = await this.client.invoke("getMessageLinkInfo", parameters);
    return result as MessageLinkInfo;
  }

  /**
   * Translates a text to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
   *
   * @param {translateText$DirectInput} parameters {@link translateText$Input}
   * @return {Promise<FormattedText>} Promise<{@link FormattedText}>
   */
  async translateText(
    parameters: translateText$DirectInput
  ): Promise<FormattedText> {
    const result = await this.client.invoke("translateText", parameters);
    return result as FormattedText;
  }

  /**
   * Extracts text or caption of the given message and translates it to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
   *
   * @param {translateMessageText$DirectInput} parameters {@link translateMessageText$Input}
   * @return {Promise<FormattedText>} Promise<{@link FormattedText}>
   */
  async translateMessageText(
    parameters: translateMessageText$DirectInput
  ): Promise<FormattedText> {
    const result = await this.client.invoke("translateMessageText", parameters);
    return result as FormattedText;
  }

  /**
   * Recognizes speech in a video note or a voice note message. The message must be successfully sent, must not be scheduled, and must be from a non-secret chat
   *
   * @param {recognizeSpeech$DirectInput} parameters {@link recognizeSpeech$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async recognizeSpeech(parameters: recognizeSpeech$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("recognizeSpeech", parameters);
    return result as Ok;
  }

  /**
   * Rates recognized speech in a video note or a voice note message
   *
   * @param {rateSpeechRecognition$DirectInput} parameters {@link rateSpeechRecognition$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async rateSpeechRecognition(
    parameters: rateSpeechRecognition$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("rateSpeechRecognition", parameters);
    return result as Ok;
  }

  /**
   * Returns list of message sender identifiers, which can be used to send messages in a chat
   *
   * @param {getChatAvailableMessageSenders$DirectInput} parameters {@link getChatAvailableMessageSenders$Input}
   * @return {Promise<ChatMessageSenders>} Promise<{@link ChatMessageSenders}>
   */
  async getChatAvailableMessageSenders(
    parameters: getChatAvailableMessageSenders$DirectInput
  ): Promise<ChatMessageSenders> {
    const result = await this.client.invoke(
      "getChatAvailableMessageSenders",
      parameters
    );
    return result as ChatMessageSenders;
  }

  /**
   * Selects a message sender to send messages in a chat
   *
   * @param {setChatMessageSender$DirectInput} parameters {@link setChatMessageSender$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatMessageSender(
    parameters: setChatMessageSender$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatMessageSender", parameters);
    return result as Ok;
  }

  /**
   * Sends a message. Returns the sent message
   *
   * @param {sendMessage$DirectInput} parameters {@link sendMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async sendMessage(parameters: sendMessage$DirectInput): Promise<Message> {
    const result = await this.client.invoke("sendMessage", parameters);
    return result as Message;
  }

  /**
   * Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
   *
   * @param {sendMessageAlbum$DirectInput} parameters {@link sendMessageAlbum$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async sendMessageAlbum(
    parameters: sendMessageAlbum$DirectInput
  ): Promise<Messages> {
    const result = await this.client.invoke("sendMessageAlbum", parameters);
    return result as Messages;
  }

  /**
   * Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
   *
   * @param {sendBotStartMessage$DirectInput} parameters {@link sendBotStartMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async sendBotStartMessage(
    parameters: sendBotStartMessage$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("sendBotStartMessage", parameters);
    return result as Message;
  }

  /**
   * Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
   *
   * @param {sendInlineQueryResultMessage$DirectInput} parameters {@link sendInlineQueryResultMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async sendInlineQueryResultMessage(
    parameters: sendInlineQueryResultMessage$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke(
      "sendInlineQueryResultMessage",
      parameters
    );
    return result as Message;
  }

  /**
   * Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
   *
   * @param {forwardMessages$DirectInput} parameters {@link forwardMessages$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async forwardMessages(parameters: forwardMessages$DirectInput): Promise<Messages> {
    const result = await this.client.invoke("forwardMessages", parameters);
    return result as Messages;
  }

  /**
   * Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
   *
   * - If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
   *
   * @param {resendMessages$DirectInput} parameters {@link resendMessages$Input}
   * @return {Promise<Messages>} Promise<{@link Messages}>
   */
  async resendMessages(parameters: resendMessages$DirectInput): Promise<Messages> {
    const result = await this.client.invoke("resendMessages", parameters);
    return result as Messages;
  }

  /**
   * Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
   *
   * @param {addLocalMessage$DirectInput} parameters {@link addLocalMessage$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async addLocalMessage(parameters: addLocalMessage$DirectInput): Promise<Message> {
    const result = await this.client.invoke("addLocalMessage", parameters);
    return result as Message;
  }

  /**
   * Deletes messages
   *
   * @param {deleteMessages$DirectInput} parameters {@link deleteMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteMessages(parameters: deleteMessages$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteMessages", parameters);
    return result as Ok;
  }

  /**
   * Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
   *
   * @param {deleteChatMessagesBySender$DirectInput} parameters {@link deleteChatMessagesBySender$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatMessagesBySender(
    parameters: deleteChatMessagesBySender$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "deleteChatMessagesBySender",
      parameters
    );
    return result as Ok;
  }

  /**
   * Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
   *
   * @param {deleteChatMessagesByDate$DirectInput} parameters {@link deleteChatMessagesByDate$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatMessagesByDate(
    parameters: deleteChatMessagesByDate$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteChatMessagesByDate", parameters);
    return result as Ok;
  }

  /**
   * Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
   *
   * @param {editMessageText$DirectInput} parameters {@link editMessageText$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async editMessageText(parameters: editMessageText$DirectInput): Promise<Message> {
    const result = await this.client.invoke("editMessageText", parameters);
    return result as Message;
  }

  /**
   * Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
   *
   * @param {editMessageLiveLocation$DirectInput} parameters {@link editMessageLiveLocation$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async editMessageLiveLocation(
    parameters: editMessageLiveLocation$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("editMessageLiveLocation", parameters);
    return result as Message;
  }

  /**
   * Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
   *
   * - The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
   *
   * @param {editMessageMedia$DirectInput} parameters {@link editMessageMedia$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async editMessageMedia(
    parameters: editMessageMedia$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("editMessageMedia", parameters);
    return result as Message;
  }

  /**
   * Edits the message content caption. Returns the edited message after the edit is completed on the server side
   *
   * @param {editMessageCaption$DirectInput} parameters {@link editMessageCaption$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async editMessageCaption(
    parameters: editMessageCaption$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("editMessageCaption", parameters);
    return result as Message;
  }

  /**
   * Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
   *
   * @param {editMessageReplyMarkup$DirectInput} parameters {@link editMessageReplyMarkup$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async editMessageReplyMarkup(
    parameters: editMessageReplyMarkup$DirectInput
  ): Promise<Message> {
    const result = await this.client.invoke("editMessageReplyMarkup", parameters);
    return result as Message;
  }

  /**
   * Edits the text of an inline text or game message sent via a bot; for bots only
   *
   * @param {editInlineMessageText$DirectInput} parameters {@link editInlineMessageText$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editInlineMessageText(
    parameters: editInlineMessageText$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("editInlineMessageText", parameters);
    return result as Ok;
  }

  /**
   * Edits the content of a live location in an inline message sent via a bot; for bots only
   *
   * @param {editInlineMessageLiveLocation$DirectInput} parameters {@link editInlineMessageLiveLocation$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editInlineMessageLiveLocation(
    parameters: editInlineMessageLiveLocation$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "editInlineMessageLiveLocation",
      parameters
    );
    return result as Ok;
  }

  /**
   * Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
   *
   * @param {editInlineMessageMedia$DirectInput} parameters {@link editInlineMessageMedia$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editInlineMessageMedia(
    parameters: editInlineMessageMedia$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("editInlineMessageMedia", parameters);
    return result as Ok;
  }

  /**
   * Edits the caption of an inline message sent via a bot; for bots only
   *
   * @param {editInlineMessageCaption$DirectInput} parameters {@link editInlineMessageCaption$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editInlineMessageCaption(
    parameters: editInlineMessageCaption$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("editInlineMessageCaption", parameters);
    return result as Ok;
  }

  /**
   * Edits the reply markup of an inline message sent via a bot; for bots only
   *
   * @param {editInlineMessageReplyMarkup$DirectInput} parameters {@link editInlineMessageReplyMarkup$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editInlineMessageReplyMarkup(
    parameters: editInlineMessageReplyMarkup$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "editInlineMessageReplyMarkup",
      parameters
    );
    return result as Ok;
  }

  /**
   * Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
   *
   * @param {editMessageSchedulingState$DirectInput} parameters {@link editMessageSchedulingState$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editMessageSchedulingState(
    parameters: editMessageSchedulingState$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "editMessageSchedulingState",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns list of custom emojis, which can be used as forum topic icon by all users
   *
   * @param {getForumTopicDefaultIcons$DirectInput} parameters {@link getForumTopicDefaultIcons$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getForumTopicDefaultIcons(
    parameters: getForumTopicDefaultIcons$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("getForumTopicDefaultIcons", parameters);
    return result as Stickers;
  }

  /**
   * Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup
   *
   * @param {createForumTopic$DirectInput} parameters {@link createForumTopic$Input}
   * @return {Promise<ForumTopicInfo>} Promise<{@link ForumTopicInfo}>
   */
  async createForumTopic(
    parameters: createForumTopic$DirectInput
  ): Promise<ForumTopicInfo> {
    const result = await this.client.invoke("createForumTopic", parameters);
    return result as ForumTopicInfo;
  }

  /**
   * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
   *
   * @param {editForumTopic$DirectInput} parameters {@link editForumTopic$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editForumTopic(parameters: editForumTopic$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("editForumTopic", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a forum topic
   *
   * @param {getForumTopic$DirectInput} parameters {@link getForumTopic$Input}
   * @return {Promise<ForumTopic>} Promise<{@link ForumTopic}>
   */
  async getForumTopic(parameters: getForumTopic$DirectInput): Promise<ForumTopic> {
    const result = await this.client.invoke("getForumTopic", parameters);
    return result as ForumTopic;
  }

  /**
   * Returns an HTTPS link to a topic in a forum chat. This is an offline request
   *
   * @param {getForumTopicLink$DirectInput} parameters {@link getForumTopicLink$Input}
   * @return {Promise<MessageLink>} Promise<{@link MessageLink}>
   */
  async getForumTopicLink(
    parameters: getForumTopicLink$DirectInput
  ): Promise<MessageLink> {
    const result = await this.client.invoke("getForumTopicLink", parameters);
    return result as MessageLink;
  }

  /**
   * Returns found forum topics in a forum chat. This is a temporary method for getting information about topic list from the server
   *
   * @param {getForumTopics$DirectInput} parameters {@link getForumTopics$Input}
   * @return {Promise<ForumTopics>} Promise<{@link ForumTopics}>
   */
  async getForumTopics(
    parameters: getForumTopics$DirectInput
  ): Promise<ForumTopics> {
    const result = await this.client.invoke("getForumTopics", parameters);
    return result as ForumTopics;
  }

  /**
   * Changes the notification settings of a forum topic
   *
   * @param {setForumTopicNotificationSettings$DirectInput} parameters {@link setForumTopicNotificationSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setForumTopicNotificationSettings(
    parameters: setForumTopicNotificationSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setForumTopicNotificationSettings",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
   *
   * @param {toggleForumTopicIsClosed$DirectInput} parameters {@link toggleForumTopicIsClosed$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleForumTopicIsClosed(
    parameters: toggleForumTopicIsClosed$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleForumTopicIsClosed", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether a General topic is hidden in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup
   *
   * @param {toggleGeneralForumTopicIsHidden$DirectInput} parameters {@link toggleGeneralForumTopicIsHidden$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGeneralForumTopicIsHidden(
    parameters: toggleGeneralForumTopicIsHidden$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGeneralForumTopicIsHidden",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the pinned state of a forum topic; requires can_manage_topics administrator right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max") pinned forum topics
   *
   * @param {toggleForumTopicIsPinned$DirectInput} parameters {@link toggleForumTopicIsPinned$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleForumTopicIsPinned(
    parameters: toggleForumTopicIsPinned$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleForumTopicIsPinned", parameters);
    return result as Ok;
  }

  /**
   * Changes the order of pinned forum topics
   *
   * @param {setPinnedForumTopics$DirectInput} parameters {@link setPinnedForumTopics$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setPinnedForumTopics(
    parameters: setPinnedForumTopics$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setPinnedForumTopics", parameters);
    return result as Ok;
  }

  /**
   * Deletes all messages in a forum topic; requires can_delete_messages administrator right in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages
   *
   * @param {deleteForumTopic$DirectInput} parameters {@link deleteForumTopic$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteForumTopic(parameters: deleteForumTopic$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteForumTopic", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a emoji reaction. Returns a 404 error if the reaction is not found
   *
   * @param {getEmojiReaction$DirectInput} parameters {@link getEmojiReaction$Input}
   * @return {Promise<EmojiReaction>} Promise<{@link EmojiReaction}>
   */
  async getEmojiReaction(
    parameters: getEmojiReaction$DirectInput
  ): Promise<EmojiReaction> {
    const result = await this.client.invoke("getEmojiReaction", parameters);
    return result as EmojiReaction;
  }

  /**
   * Returns TGS stickers with generic animations for custom emoji reactions
   *
   * @param {getCustomEmojiReactionAnimations$DirectInput} parameters {@link getCustomEmojiReactionAnimations$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getCustomEmojiReactionAnimations(
    parameters: getCustomEmojiReactionAnimations$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke(
      "getCustomEmojiReactionAnimations",
      parameters
    );
    return result as Stickers;
  }

  /**
   * Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message
   *
   * @param {getMessageAvailableReactions$DirectInput} parameters {@link getMessageAvailableReactions$Input}
   * @return {Promise<AvailableReactions>} Promise<{@link AvailableReactions}>
   */
  async getMessageAvailableReactions(
    parameters: getMessageAvailableReactions$DirectInput
  ): Promise<AvailableReactions> {
    const result = await this.client.invoke(
      "getMessageAvailableReactions",
      parameters
    );
    return result as AvailableReactions;
  }

  /**
   * Clears the list of recently used reactions
   *
   * @param {clearRecentReactions$DirectInput} parameters {@link clearRecentReactions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearRecentReactions(
    parameters: clearRecentReactions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clearRecentReactions", parameters);
    return result as Ok;
  }

  /**
   * Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message
   *
   * @param {addMessageReaction$DirectInput} parameters {@link addMessageReaction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addMessageReaction(parameters: addMessageReaction$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addMessageReaction", parameters);
    return result as Ok;
  }

  /**
   * Removes a reaction from a message. A chosen reaction can always be removed
   *
   * @param {removeMessageReaction$DirectInput} parameters {@link removeMessageReaction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeMessageReaction(
    parameters: removeMessageReaction$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeMessageReaction", parameters);
    return result as Ok;
  }

  /**
   * Sets reactions on a message; for bots only
   *
   * @param {setMessageReactions$DirectInput} parameters {@link setMessageReactions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setMessageReactions(
    parameters: setMessageReactions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setMessageReactions", parameters);
    return result as Ok;
  }

  /**
   * Returns reactions added for a message, along with their sender
   *
   * @param {getMessageAddedReactions$DirectInput} parameters {@link getMessageAddedReactions$Input}
   * @return {Promise<AddedReactions>} Promise<{@link AddedReactions}>
   */
  async getMessageAddedReactions(
    parameters: getMessageAddedReactions$DirectInput
  ): Promise<AddedReactions> {
    const result = await this.client.invoke("getMessageAddedReactions", parameters);
    return result as AddedReactions;
  }

  /**
   * Changes type of default reaction for the current user
   *
   * @param {setDefaultReactionType$DirectInput} parameters {@link setDefaultReactionType$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setDefaultReactionType(
    parameters: setDefaultReactionType$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setDefaultReactionType", parameters);
    return result as Ok;
  }

  /**
   * Searches for a given quote in a text. Returns found quote start position in UTF-16 code units. Returns a 404 error if the quote is not found. Can be called synchronously
   *
   * @param {searchQuote$DirectInput} parameters {@link searchQuote$Input}
   * @return {Promise<FoundPosition>} Promise<{@link FoundPosition}>
   */
  async searchQuote(parameters: searchQuote$DirectInput): Promise<FoundPosition> {
    const result = await this.client.invoke("searchQuote", parameters);
    return result as FoundPosition;
  }

  /**
   * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
   *
   * @param {getTextEntities$DirectInput} parameters {@link getTextEntities$Input}
   * @return {Promise<TextEntities>} Promise<{@link TextEntities}>
   */
  async getTextEntities(
    parameters: getTextEntities$DirectInput
  ): Promise<TextEntities> {
    const result = await this.client.invoke("getTextEntities", parameters);
    return result as TextEntities;
  }

  /**
   * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
   *
   * @param {parseTextEntities$DirectInput} parameters {@link parseTextEntities$Input}
   * @return {Promise<FormattedText>} Promise<{@link FormattedText}>
   */
  async parseTextEntities(
    parameters: parseTextEntities$DirectInput
  ): Promise<FormattedText> {
    const result = await this.client.invoke("parseTextEntities", parameters);
    return result as FormattedText;
  }

  /**
   * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
   *
   * @param {parseMarkdown$DirectInput} parameters {@link parseMarkdown$Input}
   * @return {Promise<FormattedText>} Promise<{@link FormattedText}>
   */
  async parseMarkdown(
    parameters: parseMarkdown$DirectInput
  ): Promise<FormattedText> {
    const result = await this.client.invoke("parseMarkdown", parameters);
    return result as FormattedText;
  }

  /**
   * Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
   *
   * @param {getMarkdownText$DirectInput} parameters {@link getMarkdownText$Input}
   * @return {Promise<FormattedText>} Promise<{@link FormattedText}>
   */
  async getMarkdownText(
    parameters: getMarkdownText$DirectInput
  ): Promise<FormattedText> {
    const result = await this.client.invoke("getMarkdownText", parameters);
    return result as FormattedText;
  }

  /**
   * Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
   *
   * @param {getFileMimeType$DirectInput} parameters {@link getFileMimeType$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getFileMimeType(parameters: getFileMimeType$DirectInput): Promise<Text> {
    const result = await this.client.invoke("getFileMimeType", parameters);
    return result as Text;
  }

  /**
   * Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
   *
   * @param {getFileExtension$DirectInput} parameters {@link getFileExtension$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getFileExtension(parameters: getFileExtension$DirectInput): Promise<Text> {
    const result = await this.client.invoke("getFileExtension", parameters);
    return result as Text;
  }

  /**
   * Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
   *
   * @param {cleanFileName$DirectInput} parameters {@link cleanFileName$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async cleanFileName(parameters: cleanFileName$DirectInput): Promise<Text> {
    const result = await this.client.invoke("cleanFileName", parameters);
    return result as Text;
  }

  /**
   * Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
   *
   * @param {getLanguagePackString$DirectInput} parameters {@link getLanguagePackString$Input}
   * @return {Promise<LanguagePackStringValue>} Promise<{@link LanguagePackStringValue}>
   */
  async getLanguagePackString(
    parameters: getLanguagePackString$DirectInput
  ): Promise<LanguagePackStringValue> {
    const result = await this.client.invoke("getLanguagePackString", parameters);
    return result as LanguagePackStringValue;
  }

  /**
   * Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
   *
   * @param {getJsonValue$DirectInput} parameters {@link getJsonValue$Input}
   * @return {Promise<JsonValue>} Promise<{@link JsonValue}>
   */
  async getJsonValue(parameters: getJsonValue$DirectInput): Promise<JsonValue> {
    const result = await this.client.invoke("getJsonValue", parameters);
    return result as JsonValue;
  }

  /**
   * Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
   *
   * @param {getJsonString$DirectInput} parameters {@link getJsonString$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getJsonString(parameters: getJsonString$DirectInput): Promise<Text> {
    const result = await this.client.invoke("getJsonString", parameters);
    return result as Text;
  }

  /**
   * Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
   *
   * @param {getThemeParametersJsonString$DirectInput} parameters {@link getThemeParametersJsonString$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getThemeParametersJsonString(
    parameters: getThemeParametersJsonString$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke(
      "getThemeParametersJsonString",
      parameters
    );
    return result as Text;
  }

  /**
   * Changes the user answer to a poll. A poll in quiz mode can be answered only once
   *
   * @param {setPollAnswer$DirectInput} parameters {@link setPollAnswer$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setPollAnswer(parameters: setPollAnswer$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setPollAnswer", parameters);
    return result as Ok;
  }

  /**
   * Returns message senders voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
   *
   * @param {getPollVoters$DirectInput} parameters {@link getPollVoters$Input}
   * @return {Promise<MessageSenders>} Promise<{@link MessageSenders}>
   */
  async getPollVoters(
    parameters: getPollVoters$DirectInput
  ): Promise<MessageSenders> {
    const result = await this.client.invoke("getPollVoters", parameters);
    return result as MessageSenders;
  }

  /**
   * Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag is set
   *
   * @param {stopPoll$DirectInput} parameters {@link stopPoll$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async stopPoll(parameters: stopPoll$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("stopPoll", parameters);
    return result as Ok;
  }

  /**
   * Hides a suggested action
   *
   * @param {hideSuggestedAction$DirectInput} parameters {@link hideSuggestedAction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async hideSuggestedAction(
    parameters: hideSuggestedAction$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("hideSuggestedAction", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
   *
   * @param {getLoginUrlInfo$DirectInput} parameters {@link getLoginUrlInfo$Input}
   * @return {Promise<LoginUrlInfo>} Promise<{@link LoginUrlInfo}>
   */
  async getLoginUrlInfo(
    parameters: getLoginUrlInfo$DirectInput
  ): Promise<LoginUrlInfo> {
    const result = await this.client.invoke("getLoginUrlInfo", parameters);
    return result as LoginUrlInfo;
  }

  /**
   * Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
   *
   * - Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
   *
   * @param {getLoginUrl$DirectInput} parameters {@link getLoginUrl$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getLoginUrl(parameters: getLoginUrl$DirectInput): Promise<HttpUrl> {
    const result = await this.client.invoke("getLoginUrl", parameters);
    return result as HttpUrl;
  }

  /**
   * Shares users after pressing a keyboardButtonTypeRequestUsers button with the bot
   *
   * @param {shareUsersWithBot$DirectInput} parameters {@link shareUsersWithBot$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async shareUsersWithBot(parameters: shareUsersWithBot$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("shareUsersWithBot", parameters);
    return result as Ok;
  }

  /**
   * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the bot
   *
   * @param {shareChatWithBot$DirectInput} parameters {@link shareChatWithBot$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async shareChatWithBot(parameters: shareChatWithBot$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("shareChatWithBot", parameters);
    return result as Ok;
  }

  /**
   * Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
   *
   * @param {getInlineQueryResults$DirectInput} parameters {@link getInlineQueryResults$Input}
   * @return {Promise<InlineQueryResults>} Promise<{@link InlineQueryResults}>
   */
  async getInlineQueryResults(
    parameters: getInlineQueryResults$DirectInput
  ): Promise<InlineQueryResults> {
    const result = await this.client.invoke("getInlineQueryResults", parameters);
    return result as InlineQueryResults;
  }

  /**
   * Sets the result of an inline query; for bots only
   *
   * @param {answerInlineQuery$DirectInput} parameters {@link answerInlineQuery$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async answerInlineQuery(parameters: answerInlineQuery$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("answerInlineQuery", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a Web App by its short name. Returns a 404 error if the Web App is not found
   *
   * @param {searchWebApp$DirectInput} parameters {@link searchWebApp$Input}
   * @return {Promise<FoundWebApp>} Promise<{@link FoundWebApp}>
   */
  async searchWebApp(parameters: searchWebApp$DirectInput): Promise<FoundWebApp> {
    const result = await this.client.invoke("searchWebApp", parameters);
    return result as FoundWebApp;
  }

  /**
   * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp is clicked
   *
   * @param {getWebAppLinkUrl$DirectInput} parameters {@link getWebAppLinkUrl$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getWebAppLinkUrl(
    parameters: getWebAppLinkUrl$DirectInput
  ): Promise<HttpUrl> {
    const result = await this.client.invoke("getWebAppLinkUrl", parameters);
    return result as HttpUrl;
  }

  /**
   * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot link
   *
   * @param {getWebAppUrl$DirectInput} parameters {@link getWebAppUrl$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getWebAppUrl(parameters: getWebAppUrl$DirectInput): Promise<HttpUrl> {
    const result = await this.client.invoke("getWebAppUrl", parameters);
    return result as HttpUrl;
  }

  /**
   * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
   *
   * @param {sendWebAppData$DirectInput} parameters {@link sendWebAppData$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendWebAppData(parameters: sendWebAppData$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("sendWebAppData", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
   *
   * - For each bot, a confirmation alert about data sent to the bot must be shown once
   *
   * @param {openWebApp$DirectInput} parameters {@link openWebApp$Input}
   * @return {Promise<WebAppInfo>} Promise<{@link WebAppInfo}>
   */
  async openWebApp(parameters: openWebApp$DirectInput): Promise<WebAppInfo> {
    const result = await this.client.invoke("openWebApp", parameters);
    return result as WebAppInfo;
  }

  /**
   * Informs TDLib that a previously opened Web App was closed
   *
   * @param {closeWebApp$DirectInput} parameters {@link closeWebApp$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async closeWebApp(parameters: closeWebApp$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("closeWebApp", parameters);
    return result as Ok;
  }

  /**
   * Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only
   *
   * @param {answerWebAppQuery$DirectInput} parameters {@link answerWebAppQuery$Input}
   * @return {Promise<SentWebAppMessage>} Promise<{@link SentWebAppMessage}>
   */
  async answerWebAppQuery(
    parameters: answerWebAppQuery$DirectInput
  ): Promise<SentWebAppMessage> {
    const result = await this.client.invoke("answerWebAppQuery", parameters);
    return result as SentWebAppMessage;
  }

  /**
   * Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
   *
   * @param {getCallbackQueryAnswer$DirectInput} parameters {@link getCallbackQueryAnswer$Input}
   * @return {Promise<CallbackQueryAnswer>} Promise<{@link CallbackQueryAnswer}>
   */
  async getCallbackQueryAnswer(
    parameters: getCallbackQueryAnswer$DirectInput
  ): Promise<CallbackQueryAnswer> {
    const result = await this.client.invoke("getCallbackQueryAnswer", parameters);
    return result as CallbackQueryAnswer;
  }

  /**
   * Sets the result of a callback query; for bots only
   *
   * @param {answerCallbackQuery$DirectInput} parameters {@link answerCallbackQuery$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async answerCallbackQuery(
    parameters: answerCallbackQuery$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("answerCallbackQuery", parameters);
    return result as Ok;
  }

  /**
   * Sets the result of a shipping query; for bots only
   *
   * @param {answerShippingQuery$DirectInput} parameters {@link answerShippingQuery$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async answerShippingQuery(
    parameters: answerShippingQuery$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("answerShippingQuery", parameters);
    return result as Ok;
  }

  /**
   * Sets the result of a pre-checkout query; for bots only
   *
   * @param {answerPreCheckoutQuery$DirectInput} parameters {@link answerPreCheckoutQuery$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async answerPreCheckoutQuery(
    parameters: answerPreCheckoutQuery$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("answerPreCheckoutQuery", parameters);
    return result as Ok;
  }

  /**
   * Updates the game score of the specified user in the game; for bots only
   *
   * @param {setGameScore$DirectInput} parameters {@link setGameScore$Input}
   * @return {Promise<Message>} Promise<{@link Message}>
   */
  async setGameScore(parameters: setGameScore$DirectInput): Promise<Message> {
    const result = await this.client.invoke("setGameScore", parameters);
    return result as Message;
  }

  /**
   * Updates the game score of the specified user in a game; for bots only
   *
   * @param {setInlineGameScore$DirectInput} parameters {@link setInlineGameScore$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setInlineGameScore(parameters: setInlineGameScore$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setInlineGameScore", parameters);
    return result as Ok;
  }

  /**
   * Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
   *
   * @param {getGameHighScores$DirectInput} parameters {@link getGameHighScores$Input}
   * @return {Promise<GameHighScores>} Promise<{@link GameHighScores}>
   */
  async getGameHighScores(
    parameters: getGameHighScores$DirectInput
  ): Promise<GameHighScores> {
    const result = await this.client.invoke("getGameHighScores", parameters);
    return result as GameHighScores;
  }

  /**
   * Returns game high scores and some part of the high score table in the range of the specified user; for bots only
   *
   * @param {getInlineGameHighScores$DirectInput} parameters {@link getInlineGameHighScores$Input}
   * @return {Promise<GameHighScores>} Promise<{@link GameHighScores}>
   */
  async getInlineGameHighScores(
    parameters: getInlineGameHighScores$DirectInput
  ): Promise<GameHighScores> {
    const result = await this.client.invoke("getInlineGameHighScores", parameters);
    return result as GameHighScores;
  }

  /**
   * Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup update will be sent if the reply markup is changed
   *
   * @param {deleteChatReplyMarkup$DirectInput} parameters {@link deleteChatReplyMarkup$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatReplyMarkup(
    parameters: deleteChatReplyMarkup$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteChatReplyMarkup", parameters);
    return result as Ok;
  }

  /**
   * Sends a notification about user activity in a chat
   *
   * @param {sendChatAction$DirectInput} parameters {@link sendChatAction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendChatAction(parameters: sendChatAction$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("sendChatAction", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
   *
   * @param {openChat$DirectInput} parameters {@link openChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async openChat(parameters: openChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("openChat", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
   *
   * @param {closeChat$DirectInput} parameters {@link closeChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async closeChat(parameters: closeChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("closeChat", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button).
   *
   * - Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
   *
   * @param {viewMessages$DirectInput} parameters {@link viewMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async viewMessages(parameters: viewMessages$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("viewMessages", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message).
   *
   * - An updateMessageContentOpened update will be generated if something has changed
   *
   * @param {openMessageContent$DirectInput} parameters {@link openMessageContent$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async openMessageContent(parameters: openMessageContent$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("openMessageContent", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
   *
   * @param {clickAnimatedEmojiMessage$DirectInput} parameters {@link clickAnimatedEmojiMessage$Input}
   * @return {Promise<Sticker>} Promise<{@link Sticker}>
   */
  async clickAnimatedEmojiMessage(
    parameters: clickAnimatedEmojiMessage$DirectInput
  ): Promise<Sticker> {
    const result = await this.client.invoke("clickAnimatedEmojiMessage", parameters);
    return result as Sticker;
  }

  /**
   * Returns an HTTPS or a tg: link with the given type. Can be called before authorization
   *
   * @param {getInternalLink$DirectInput} parameters {@link getInternalLink$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getInternalLink(parameters: getInternalLink$DirectInput): Promise<HttpUrl> {
    const result = await this.client.invoke("getInternalLink", parameters);
    return result as HttpUrl;
  }

  /**
   * Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
   *
   * @param {getInternalLinkType$DirectInput} parameters {@link getInternalLinkType$Input}
   * @return {Promise<InternalLinkType>} Promise<{@link InternalLinkType}>
   */
  async getInternalLinkType(
    parameters: getInternalLinkType$DirectInput
  ): Promise<InternalLinkType> {
    const result = await this.client.invoke("getInternalLinkType", parameters);
    return result as InternalLinkType;
  }

  /**
   * Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
   *
   * @param {getExternalLinkInfo$DirectInput} parameters {@link getExternalLinkInfo$Input}
   * @return {Promise<LoginUrlInfo>} Promise<{@link LoginUrlInfo}>
   */
  async getExternalLinkInfo(
    parameters: getExternalLinkInfo$DirectInput
  ): Promise<LoginUrlInfo> {
    const result = await this.client.invoke("getExternalLinkInfo", parameters);
    return result as LoginUrlInfo;
  }

  /**
   * Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
   *
   * @param {getExternalLink$DirectInput} parameters {@link getExternalLink$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getExternalLink(parameters: getExternalLink$DirectInput): Promise<HttpUrl> {
    const result = await this.client.invoke("getExternalLink", parameters);
    return result as HttpUrl;
  }

  /**
   * Marks all mentions in a chat as read
   *
   * @param {readAllChatMentions$DirectInput} parameters {@link readAllChatMentions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async readAllChatMentions(
    parameters: readAllChatMentions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("readAllChatMentions", parameters);
    return result as Ok;
  }

  /**
   * Marks all mentions in a forum topic as read
   *
   * @param {readAllMessageThreadMentions$DirectInput} parameters {@link readAllMessageThreadMentions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async readAllMessageThreadMentions(
    parameters: readAllMessageThreadMentions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "readAllMessageThreadMentions",
      parameters
    );
    return result as Ok;
  }

  /**
   * Marks all reactions in a chat or a forum topic as read
   *
   * @param {readAllChatReactions$DirectInput} parameters {@link readAllChatReactions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async readAllChatReactions(
    parameters: readAllChatReactions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("readAllChatReactions", parameters);
    return result as Ok;
  }

  /**
   * Marks all reactions in a forum topic as read
   *
   * @param {readAllMessageThreadReactions$DirectInput} parameters {@link readAllMessageThreadReactions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async readAllMessageThreadReactions(
    parameters: readAllMessageThreadReactions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "readAllMessageThreadReactions",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns an existing chat corresponding to a given user
   *
   * @param {createPrivateChat$DirectInput} parameters {@link createPrivateChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createPrivateChat(parameters: createPrivateChat$DirectInput): Promise<Chat> {
    const result = await this.client.invoke("createPrivateChat", parameters);
    return result as Chat;
  }

  /**
   * Returns an existing chat corresponding to a known basic group
   *
   * @param {createBasicGroupChat$DirectInput} parameters {@link createBasicGroupChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createBasicGroupChat(
    parameters: createBasicGroupChat$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke("createBasicGroupChat", parameters);
    return result as Chat;
  }

  /**
   * Returns an existing chat corresponding to a known supergroup or channel
   *
   * @param {createSupergroupChat$DirectInput} parameters {@link createSupergroupChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createSupergroupChat(
    parameters: createSupergroupChat$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke("createSupergroupChat", parameters);
    return result as Chat;
  }

  /**
   * Returns an existing chat corresponding to a known secret chat
   *
   * @param {createSecretChat$DirectInput} parameters {@link createSecretChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createSecretChat(parameters: createSecretChat$DirectInput): Promise<Chat> {
    const result = await this.client.invoke("createSecretChat", parameters);
    return result as Chat;
  }

  /**
   * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
   *
   * @param {createNewBasicGroupChat$DirectInput} parameters {@link createNewBasicGroupChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createNewBasicGroupChat(
    parameters: createNewBasicGroupChat$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke("createNewBasicGroupChat", parameters);
    return result as Chat;
  }

  /**
   * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
   *
   * @param {createNewSupergroupChat$DirectInput} parameters {@link createNewSupergroupChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createNewSupergroupChat(
    parameters: createNewSupergroupChat$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke("createNewSupergroupChat", parameters);
    return result as Chat;
  }

  /**
   * Creates a new secret chat. Returns the newly created chat
   *
   * @param {createNewSecretChat$DirectInput} parameters {@link createNewSecretChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async createNewSecretChat(
    parameters: createNewSecretChat$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke("createNewSecretChat", parameters);
    return result as Chat;
  }

  /**
   * Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
   *
   * @param {upgradeBasicGroupChatToSupergroupChat$DirectInput} parameters {@link upgradeBasicGroupChatToSupergroupChat$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async upgradeBasicGroupChatToSupergroupChat(
    parameters: upgradeBasicGroupChatToSupergroupChat$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke(
      "upgradeBasicGroupChatToSupergroupChat",
      parameters
    );
    return result as Chat;
  }

  /**
   * Returns chat lists to which the chat can be added. This is an offline request
   *
   * @param {getChatListsToAddChat$DirectInput} parameters {@link getChatListsToAddChat$Input}
   * @return {Promise<ChatLists>} Promise<{@link ChatLists}>
   */
  async getChatListsToAddChat(
    parameters: getChatListsToAddChat$DirectInput
  ): Promise<ChatLists> {
    const result = await this.client.invoke("getChatListsToAddChat", parameters);
    return result as ChatLists;
  }

  /**
   * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
   *
   * @param {addChatToList$DirectInput} parameters {@link addChatToList$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addChatToList(parameters: addChatToList$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addChatToList", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a chat folder by its identifier
   *
   * @param {getChatFolder$DirectInput} parameters {@link getChatFolder$Input}
   * @return {Promise<ChatFolder>} Promise<{@link ChatFolder}>
   */
  async getChatFolder(parameters: getChatFolder$DirectInput): Promise<ChatFolder> {
    const result = await this.client.invoke("getChatFolder", parameters);
    return result as ChatFolder;
  }

  /**
   * Creates new chat folder. Returns information about the created chat folder. There can be up to getOption("chat_folder_count_max") chat folders, but the limit can be increased with Telegram Premium
   *
   * @param {createChatFolder$DirectInput} parameters {@link createChatFolder$Input}
   * @return {Promise<ChatFolderInfo>} Promise<{@link ChatFolderInfo}>
   */
  async createChatFolder(
    parameters: createChatFolder$DirectInput
  ): Promise<ChatFolderInfo> {
    const result = await this.client.invoke("createChatFolder", parameters);
    return result as ChatFolderInfo;
  }

  /**
   * Edits existing chat folder. Returns information about the edited chat folder
   *
   * @param {editChatFolder$DirectInput} parameters {@link editChatFolder$Input}
   * @return {Promise<ChatFolderInfo>} Promise<{@link ChatFolderInfo}>
   */
  async editChatFolder(
    parameters: editChatFolder$DirectInput
  ): Promise<ChatFolderInfo> {
    const result = await this.client.invoke("editChatFolder", parameters);
    return result as ChatFolderInfo;
  }

  /**
   * Deletes existing chat folder
   *
   * @param {deleteChatFolder$DirectInput} parameters {@link deleteChatFolder$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatFolder(parameters: deleteChatFolder$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteChatFolder", parameters);
    return result as Ok;
  }

  /**
   * Returns identifiers of pinned or always included chats from a chat folder, which are suggested to be left when the chat folder is deleted
   *
   * @param {getChatFolderChatsToLeave$DirectInput} parameters {@link getChatFolderChatsToLeave$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChatFolderChatsToLeave(
    parameters: getChatFolderChatsToLeave$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getChatFolderChatsToLeave", parameters);
    return result as Chats;
  }

  /**
   * Returns approximate number of chats in a being created chat folder. Main and archive chat lists must be fully preloaded for this function to work correctly
   *
   * @param {getChatFolderChatCount$DirectInput} parameters {@link getChatFolderChatCount$Input}
   * @return {Promise<Count>} Promise<{@link Count}>
   */
  async getChatFolderChatCount(
    parameters: getChatFolderChatCount$DirectInput
  ): Promise<Count> {
    const result = await this.client.invoke("getChatFolderChatCount", parameters);
    return result as Count;
  }

  /**
   * Changes the order of chat folders
   *
   * @param {reorderChatFolders$DirectInput} parameters {@link reorderChatFolders$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reorderChatFolders(parameters: reorderChatFolders$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("reorderChatFolders", parameters);
    return result as Ok;
  }

  /**
   * Returns recommended chat folders for the current user
   *
   * @param {getRecommendedChatFolders$DirectInput} parameters {@link getRecommendedChatFolders$Input}
   * @return {Promise<RecommendedChatFolders>} Promise<{@link RecommendedChatFolders}>
   */
  async getRecommendedChatFolders(
    parameters: getRecommendedChatFolders$DirectInput
  ): Promise<RecommendedChatFolders> {
    const result = await this.client.invoke("getRecommendedChatFolders", parameters);
    return result as RecommendedChatFolders;
  }

  /**
   * Returns default icon name for a folder. Can be called synchronously
   *
   * @param {getChatFolderDefaultIconName$DirectInput} parameters {@link getChatFolderDefaultIconName$Input}
   * @return {Promise<ChatFolderIcon>} Promise<{@link ChatFolderIcon}>
   */
  async getChatFolderDefaultIconName(
    parameters: getChatFolderDefaultIconName$DirectInput
  ): Promise<ChatFolderIcon> {
    const result = await this.client.invoke(
      "getChatFolderDefaultIconName",
      parameters
    );
    return result as ChatFolderIcon;
  }

  /**
   * Returns identifiers of chats from a chat folder, suitable for adding to a chat folder invite link
   *
   * @param {getChatsForChatFolderInviteLink$DirectInput} parameters {@link getChatsForChatFolderInviteLink$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChatsForChatFolderInviteLink(
    parameters: getChatsForChatFolderInviteLink$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke(
      "getChatsForChatFolderInviteLink",
      parameters
    );
    return result as Chats;
  }

  /**
   * Creates a new invite link for a chat folder. A link can be created for a chat folder if it has only pinned and included chats
   *
   * @param {createChatFolderInviteLink$DirectInput} parameters {@link createChatFolderInviteLink$Input}
   * @return {Promise<ChatFolderInviteLink>} Promise<{@link ChatFolderInviteLink}>
   */
  async createChatFolderInviteLink(
    parameters: createChatFolderInviteLink$DirectInput
  ): Promise<ChatFolderInviteLink> {
    const result = await this.client.invoke(
      "createChatFolderInviteLink",
      parameters
    );
    return result as ChatFolderInviteLink;
  }

  /**
   * Returns invite links created by the current user for a shareable chat folder
   *
   * @param {getChatFolderInviteLinks$DirectInput} parameters {@link getChatFolderInviteLinks$Input}
   * @return {Promise<ChatFolderInviteLinks>} Promise<{@link ChatFolderInviteLinks}>
   */
  async getChatFolderInviteLinks(
    parameters: getChatFolderInviteLinks$DirectInput
  ): Promise<ChatFolderInviteLinks> {
    const result = await this.client.invoke("getChatFolderInviteLinks", parameters);
    return result as ChatFolderInviteLinks;
  }

  /**
   * Edits an invite link for a chat folder
   *
   * @param {editChatFolderInviteLink$DirectInput} parameters {@link editChatFolderInviteLink$Input}
   * @return {Promise<ChatFolderInviteLink>} Promise<{@link ChatFolderInviteLink}>
   */
  async editChatFolderInviteLink(
    parameters: editChatFolderInviteLink$DirectInput
  ): Promise<ChatFolderInviteLink> {
    const result = await this.client.invoke("editChatFolderInviteLink", parameters);
    return result as ChatFolderInviteLink;
  }

  /**
   * Deletes an invite link for a chat folder
   *
   * @param {deleteChatFolderInviteLink$DirectInput} parameters {@link deleteChatFolderInviteLink$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatFolderInviteLink(
    parameters: deleteChatFolderInviteLink$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "deleteChatFolderInviteLink",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks the validity of an invite link for a chat folder and returns information about the corresponding chat folder
   *
   * @param {checkChatFolderInviteLink$DirectInput} parameters {@link checkChatFolderInviteLink$Input}
   * @return {Promise<ChatFolderInviteLinkInfo>} Promise<{@link ChatFolderInviteLinkInfo}>
   */
  async checkChatFolderInviteLink(
    parameters: checkChatFolderInviteLink$DirectInput
  ): Promise<ChatFolderInviteLinkInfo> {
    const result = await this.client.invoke("checkChatFolderInviteLink", parameters);
    return result as ChatFolderInviteLinkInfo;
  }

  /**
   * Adds a chat folder by an invite link
   *
   * @param {addChatFolderByInviteLink$DirectInput} parameters {@link addChatFolderByInviteLink$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addChatFolderByInviteLink(
    parameters: addChatFolderByInviteLink$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("addChatFolderByInviteLink", parameters);
    return result as Ok;
  }

  /**
   * Returns new chats added to a shareable chat folder by its owner. The method must be called at most once in getOption("chat_folder_new_chats_update_period") for the given chat folder
   *
   * @param {getChatFolderNewChats$DirectInput} parameters {@link getChatFolderNewChats$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChatFolderNewChats(
    parameters: getChatFolderNewChats$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getChatFolderNewChats", parameters);
    return result as Chats;
  }

  /**
   * Process new chats added to a shareable chat folder by its owner
   *
   * @param {processChatFolderNewChats$DirectInput} parameters {@link processChatFolderNewChats$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async processChatFolderNewChats(
    parameters: processChatFolderNewChats$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("processChatFolderNewChats", parameters);
    return result as Ok;
  }

  /**
   * Returns settings for automatic moving of chats to and from the Archive chat lists
   *
   * @param {getArchiveChatListSettings$DirectInput} parameters {@link getArchiveChatListSettings$Input}
   * @return {Promise<ArchiveChatListSettings>} Promise<{@link ArchiveChatListSettings}>
   */
  async getArchiveChatListSettings(
    parameters: getArchiveChatListSettings$DirectInput
  ): Promise<ArchiveChatListSettings> {
    const result = await this.client.invoke(
      "getArchiveChatListSettings",
      parameters
    );
    return result as ArchiveChatListSettings;
  }

  /**
   * Changes settings for automatic moving of chats to and from the Archive chat lists
   *
   * @param {setArchiveChatListSettings$DirectInput} parameters {@link setArchiveChatListSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setArchiveChatListSettings(
    parameters: setArchiveChatListSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setArchiveChatListSettings",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
   *
   * @param {setChatTitle$DirectInput} parameters {@link setChatTitle$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatTitle(parameters: setChatTitle$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatTitle", parameters);
    return result as Ok;
  }

  /**
   * Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
   *
   * @param {setChatPhoto$DirectInput} parameters {@link setChatPhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatPhoto(parameters: setChatPhoto$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatPhoto", parameters);
    return result as Ok;
  }

  /**
   * Changes accent color and background custom emoji of a chat. Requires can_change_info administrator right
   *
   * @param {setChatAccentColor$DirectInput} parameters {@link setChatAccentColor$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatAccentColor(parameters: setChatAccentColor$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatAccentColor", parameters);
    return result as Ok;
  }

  /**
   * Changes accent color and background custom emoji for profile of a chat. Requires can_change_info administrator right
   *
   * @param {setChatProfileAccentColor$DirectInput} parameters {@link setChatProfileAccentColor$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatProfileAccentColor(
    parameters: setChatProfileAccentColor$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatProfileAccentColor", parameters);
    return result as Ok;
  }

  /**
   * Changes the message auto-delete or self-destruct (for secret chats) time in a chat. Requires change_info administrator right in basic groups, supergroups and channels
   *
   * - Message auto-delete time can't be changed in a chat with the current user (Saved Messages) and the chat 777000 (Telegram).
   *
   * @param {setChatMessageAutoDeleteTime$DirectInput} parameters {@link setChatMessageAutoDeleteTime$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatMessageAutoDeleteTime(
    parameters: setChatMessageAutoDeleteTime$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setChatMessageAutoDeleteTime",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the emoji status of a chat. Use chatBoostLevelFeatures.can_set_emoji_status to check whether an emoji status can be set. Requires can_change_info administrator right
   *
   * @param {setChatEmojiStatus$DirectInput} parameters {@link setChatEmojiStatus$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatEmojiStatus(parameters: setChatEmojiStatus$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatEmojiStatus", parameters);
    return result as Ok;
  }

  /**
   * Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
   *
   * @param {setChatPermissions$DirectInput} parameters {@link setChatPermissions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatPermissions(parameters: setChatPermissions$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatPermissions", parameters);
    return result as Ok;
  }

  /**
   * Sets the background in a specific chat. Supported only in private and secret chats with non-deleted users, and in chats with sufficient boost level and can_change_info administrator right
   *
   * @param {setChatBackground$DirectInput} parameters {@link setChatBackground$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatBackground(parameters: setChatBackground$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatBackground", parameters);
    return result as Ok;
  }

  /**
   * Deletes background in a specific chat
   *
   * @param {deleteChatBackground$DirectInput} parameters {@link deleteChatBackground$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteChatBackground(
    parameters: deleteChatBackground$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteChatBackground", parameters);
    return result as Ok;
  }

  /**
   * Changes the chat theme. Supported only in private and secret chats
   *
   * @param {setChatTheme$DirectInput} parameters {@link setChatTheme$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatTheme(parameters: setChatTheme$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatTheme", parameters);
    return result as Ok;
  }

  /**
   * Changes the draft message in a chat
   *
   * @param {setChatDraftMessage$DirectInput} parameters {@link setChatDraftMessage$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatDraftMessage(
    parameters: setChatDraftMessage$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatDraftMessage", parameters);
    return result as Ok;
  }

  /**
   * Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
   *
   * @param {setChatNotificationSettings$DirectInput} parameters {@link setChatNotificationSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatNotificationSettings(
    parameters: setChatNotificationSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setChatNotificationSettings",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges
   *
   * @param {toggleChatHasProtectedContent$DirectInput} parameters {@link toggleChatHasProtectedContent$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleChatHasProtectedContent(
    parameters: toggleChatHasProtectedContent$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleChatHasProtectedContent",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the view_as_topics setting of a forum chat
   *
   * @param {toggleChatViewAsTopics$DirectInput} parameters {@link toggleChatViewAsTopics$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleChatViewAsTopics(
    parameters: toggleChatViewAsTopics$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleChatViewAsTopics", parameters);
    return result as Ok;
  }

  /**
   * Changes the translatable state of a chat
   *
   * @param {toggleChatIsTranslatable$DirectInput} parameters {@link toggleChatIsTranslatable$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleChatIsTranslatable(
    parameters: toggleChatIsTranslatable$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleChatIsTranslatable", parameters);
    return result as Ok;
  }

  /**
   * Changes the marked as unread state of a chat
   *
   * @param {toggleChatIsMarkedAsUnread$DirectInput} parameters {@link toggleChatIsMarkedAsUnread$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleChatIsMarkedAsUnread(
    parameters: toggleChatIsMarkedAsUnread$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleChatIsMarkedAsUnread",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the value of the default disable_notification parameter, used when a message is sent to a chat
   *
   * @param {toggleChatDefaultDisableNotification$DirectInput} parameters {@link toggleChatDefaultDisableNotification$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleChatDefaultDisableNotification(
    parameters: toggleChatDefaultDisableNotification$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleChatDefaultDisableNotification",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
   *
   * @param {setChatAvailableReactions$DirectInput} parameters {@link setChatAvailableReactions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatAvailableReactions(
    parameters: setChatAvailableReactions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatAvailableReactions", parameters);
    return result as Ok;
  }

  /**
   * Changes application-specific data associated with a chat
   *
   * @param {setChatClientData$DirectInput} parameters {@link setChatClientData$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatClientData(parameters: setChatClientData$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatClientData", parameters);
    return result as Ok;
  }

  /**
   * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
   *
   * @param {setChatDescription$DirectInput} parameters {@link setChatDescription$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatDescription(parameters: setChatDescription$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatDescription", parameters);
    return result as Ok;
  }

  /**
   * Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
   *
   * @param {setChatDiscussionGroup$DirectInput} parameters {@link setChatDiscussionGroup$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatDiscussionGroup(
    parameters: setChatDiscussionGroup$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatDiscussionGroup", parameters);
    return result as Ok;
  }

  /**
   * Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
   *
   * @param {setChatLocation$DirectInput} parameters {@link setChatLocation$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatLocation(parameters: setChatLocation$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setChatLocation", parameters);
    return result as Ok;
  }

  /**
   * Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
   *
   * @param {setChatSlowModeDelay$DirectInput} parameters {@link setChatSlowModeDelay$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatSlowModeDelay(
    parameters: setChatSlowModeDelay$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatSlowModeDelay", parameters);
    return result as Ok;
  }

  /**
   * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
   *
   * @param {pinChatMessage$DirectInput} parameters {@link pinChatMessage$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async pinChatMessage(parameters: pinChatMessage$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("pinChatMessage", parameters);
    return result as Ok;
  }

  /**
   * Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
   *
   * @param {unpinChatMessage$DirectInput} parameters {@link unpinChatMessage$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async unpinChatMessage(parameters: unpinChatMessage$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("unpinChatMessage", parameters);
    return result as Ok;
  }

  /**
   * Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
   *
   * @param {unpinAllChatMessages$DirectInput} parameters {@link unpinAllChatMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async unpinAllChatMessages(
    parameters: unpinAllChatMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("unpinAllChatMessages", parameters);
    return result as Ok;
  }

  /**
   * Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup
   *
   * @param {unpinAllMessageThreadMessages$DirectInput} parameters {@link unpinAllMessageThreadMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async unpinAllMessageThreadMessages(
    parameters: unpinAllMessageThreadMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "unpinAllMessageThreadMessages",
      parameters
    );
    return result as Ok;
  }

  /**
   * Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
   *
   * @param {joinChat$DirectInput} parameters {@link joinChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async joinChat(parameters: joinChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("joinChat", parameters);
    return result as Ok;
  }

  /**
   * Removes the current user from chat members. Private and secret chats can't be left using this method
   *
   * @param {leaveChat$DirectInput} parameters {@link leaveChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async leaveChat(parameters: leaveChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("leaveChat", parameters);
    return result as Ok;
  }

  /**
   * Adds a new member to a chat. Members can't be added to private or secret chats
   *
   * @param {addChatMember$DirectInput} parameters {@link addChatMember$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addChatMember(parameters: addChatMember$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addChatMember", parameters);
    return result as Ok;
  }

  /**
   * Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
   *
   * @param {addChatMembers$DirectInput} parameters {@link addChatMembers$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addChatMembers(parameters: addChatMembers$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addChatMembers", parameters);
    return result as Ok;
  }

  /**
   * Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
   *
   * @param {setChatMemberStatus$DirectInput} parameters {@link setChatMemberStatus$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatMemberStatus(
    parameters: setChatMemberStatus$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatMemberStatus", parameters);
    return result as Ok;
  }

  /**
   * Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
   *
   * @param {banChatMember$DirectInput} parameters {@link banChatMember$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async banChatMember(parameters: banChatMember$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("banChatMember", parameters);
    return result as Ok;
  }

  /**
   * Checks whether the current session can be used to transfer a chat ownership to another user
   *
   * @param {canTransferOwnership$DirectInput} parameters {@link canTransferOwnership$Input}
   * @return {Promise<CanTransferOwnershipResult>} Promise<{@link CanTransferOwnershipResult}>
   */
  async canTransferOwnership(
    parameters: canTransferOwnership$DirectInput
  ): Promise<CanTransferOwnershipResult> {
    const result = await this.client.invoke("canTransferOwnership", parameters);
    return result as CanTransferOwnershipResult;
  }

  /**
   * Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
   *
   * @param {transferChatOwnership$DirectInput} parameters {@link transferChatOwnership$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async transferChatOwnership(
    parameters: transferChatOwnership$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("transferChatOwnership", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a single member of a chat
   *
   * @param {getChatMember$DirectInput} parameters {@link getChatMember$Input}
   * @return {Promise<ChatMember>} Promise<{@link ChatMember}>
   */
  async getChatMember(parameters: getChatMember$DirectInput): Promise<ChatMember> {
    const result = await this.client.invoke("getChatMember", parameters);
    return result as ChatMember;
  }

  /**
   * Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels
   *
   * @param {searchChatMembers$DirectInput} parameters {@link searchChatMembers$Input}
   * @return {Promise<ChatMembers>} Promise<{@link ChatMembers}>
   */
  async searchChatMembers(
    parameters: searchChatMembers$DirectInput
  ): Promise<ChatMembers> {
    const result = await this.client.invoke("searchChatMembers", parameters);
    return result as ChatMembers;
  }

  /**
   * Returns a list of administrators of the chat with their custom titles
   *
   * @param {getChatAdministrators$DirectInput} parameters {@link getChatAdministrators$Input}
   * @return {Promise<ChatAdministrators>} Promise<{@link ChatAdministrators}>
   */
  async getChatAdministrators(
    parameters: getChatAdministrators$DirectInput
  ): Promise<ChatAdministrators> {
    const result = await this.client.invoke("getChatAdministrators", parameters);
    return result as ChatAdministrators;
  }

  /**
   * Clears message drafts in all chats
   *
   * @param {clearAllDraftMessages$DirectInput} parameters {@link clearAllDraftMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearAllDraftMessages(
    parameters: clearAllDraftMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clearAllDraftMessages", parameters);
    return result as Ok;
  }

  /**
   * Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier
   *
   * @param {getSavedNotificationSound$DirectInput} parameters {@link getSavedNotificationSound$Input}
   * @return {Promise<NotificationSounds>} Promise<{@link NotificationSounds}>
   */
  async getSavedNotificationSound(
    parameters: getSavedNotificationSound$DirectInput
  ): Promise<NotificationSounds> {
    const result = await this.client.invoke("getSavedNotificationSound", parameters);
    return result as NotificationSounds;
  }

  /**
   * Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used
   *
   * @param {getSavedNotificationSounds$DirectInput} parameters {@link getSavedNotificationSounds$Input}
   * @return {Promise<NotificationSounds>} Promise<{@link NotificationSounds}>
   */
  async getSavedNotificationSounds(
    parameters: getSavedNotificationSounds$DirectInput
  ): Promise<NotificationSounds> {
    const result = await this.client.invoke(
      "getSavedNotificationSounds",
      parameters
    );
    return result as NotificationSounds;
  }

  /**
   * Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed
   *
   * @param {addSavedNotificationSound$DirectInput} parameters {@link addSavedNotificationSound$Input}
   * @return {Promise<NotificationSound>} Promise<{@link NotificationSound}>
   */
  async addSavedNotificationSound(
    parameters: addSavedNotificationSound$DirectInput
  ): Promise<NotificationSound> {
    const result = await this.client.invoke("addSavedNotificationSound", parameters);
    return result as NotificationSound;
  }

  /**
   * Removes a notification sound from the list of saved notification sounds
   *
   * @param {removeSavedNotificationSound$DirectInput} parameters {@link removeSavedNotificationSound$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeSavedNotificationSound(
    parameters: removeSavedNotificationSound$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "removeSavedNotificationSound",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns list of chats with non-default notification settings for new messages
   *
   * @param {getChatNotificationSettingsExceptions$DirectInput} parameters {@link getChatNotificationSettingsExceptions$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChatNotificationSettingsExceptions(
    parameters: getChatNotificationSettingsExceptions$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke(
      "getChatNotificationSettingsExceptions",
      parameters
    );
    return result as Chats;
  }

  /**
   * Returns the notification settings for chats of a given type
   *
   * @param {getScopeNotificationSettings$DirectInput} parameters {@link getScopeNotificationSettings$Input}
   * @return {Promise<ScopeNotificationSettings>} Promise<{@link ScopeNotificationSettings}>
   */
  async getScopeNotificationSettings(
    parameters: getScopeNotificationSettings$DirectInput
  ): Promise<ScopeNotificationSettings> {
    const result = await this.client.invoke(
      "getScopeNotificationSettings",
      parameters
    );
    return result as ScopeNotificationSettings;
  }

  /**
   * Changes notification settings for chats of a given type
   *
   * @param {setScopeNotificationSettings$DirectInput} parameters {@link setScopeNotificationSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setScopeNotificationSettings(
    parameters: setScopeNotificationSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setScopeNotificationSettings",
      parameters
    );
    return result as Ok;
  }

  /**
   * Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown
   *
   * @param {resetAllNotificationSettings$DirectInput} parameters {@link resetAllNotificationSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async resetAllNotificationSettings(
    parameters: resetAllNotificationSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "resetAllNotificationSettings",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium
   *
   * @param {toggleChatIsPinned$DirectInput} parameters {@link toggleChatIsPinned$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleChatIsPinned(parameters: toggleChatIsPinned$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("toggleChatIsPinned", parameters);
    return result as Ok;
  }

  /**
   * Changes the order of pinned chats
   *
   * @param {setPinnedChats$DirectInput} parameters {@link setPinnedChats$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setPinnedChats(parameters: setPinnedChats$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setPinnedChats", parameters);
    return result as Ok;
  }

  /**
   * Traverse all chats in a chat list and marks all messages in the chats as read
   *
   * @param {readChatList$DirectInput} parameters {@link readChatList$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async readChatList(parameters: readChatList$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("readChatList", parameters);
    return result as Ok;
  }

  /**
   * Returns a story
   *
   * @param {getStory$DirectInput} parameters {@link getStory$Input}
   * @return {Promise<Story>} Promise<{@link Story}>
   */
  async getStory(parameters: getStory$DirectInput): Promise<Story> {
    const result = await this.client.invoke("getStory", parameters);
    return result as Story;
  }

  /**
   * Returns channel chats in which the current user has the right to post stories. The chats must be rechecked with canSendStory before actually trying to post a story there
   *
   * @param {getChatsToSendStories$DirectInput} parameters {@link getChatsToSendStories$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getChatsToSendStories(
    parameters: getChatsToSendStories$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke("getChatsToSendStories", parameters);
    return result as Chats;
  }

  /**
   * Checks whether the current user can send a story on behalf of a chat; requires can_post_stories rights for channel chats
   *
   * @param {canSendStory$DirectInput} parameters {@link canSendStory$Input}
   * @return {Promise<CanSendStoryResult>} Promise<{@link CanSendStoryResult}>
   */
  async canSendStory(
    parameters: canSendStory$DirectInput
  ): Promise<CanSendStoryResult> {
    const result = await this.client.invoke("canSendStory", parameters);
    return result as CanSendStoryResult;
  }

  /**
   * Sends a new story to a chat; requires can_post_stories rights for channel chats. Returns a temporary story
   *
   * @param {sendStory$DirectInput} parameters {@link sendStory$Input}
   * @return {Promise<Story>} Promise<{@link Story}>
   */
  async sendStory(parameters: sendStory$DirectInput): Promise<Story> {
    const result = await this.client.invoke("sendStory", parameters);
    return result as Story;
  }

  /**
   * Changes content and caption of a story. Can be called only if story.can_be_edited == true
   *
   * @param {editStory$DirectInput} parameters {@link editStory$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editStory(parameters: editStory$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("editStory", parameters);
    return result as Ok;
  }

  /**
   * Changes privacy settings of a story. Can be called only if story.can_be_edited == true
   *
   * @param {setStoryPrivacySettings$DirectInput} parameters {@link setStoryPrivacySettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStoryPrivacySettings(
    parameters: setStoryPrivacySettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setStoryPrivacySettings", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether a story is accessible after expiration. Can be called only if story.can_toggle_is_pinned == true
   *
   * @param {toggleStoryIsPinned$DirectInput} parameters {@link toggleStoryIsPinned$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleStoryIsPinned(
    parameters: toggleStoryIsPinned$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleStoryIsPinned", parameters);
    return result as Ok;
  }

  /**
   * Deletes a previously sent story. Can be called only if story.can_be_deleted == true
   *
   * @param {deleteStory$DirectInput} parameters {@link deleteStory$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteStory(parameters: deleteStory$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteStory", parameters);
    return result as Ok;
  }

  /**
   * Returns list of chats with non-default notification settings for stories
   *
   * @param {getStoryNotificationSettingsExceptions$DirectInput} parameters {@link getStoryNotificationSettingsExceptions$Input}
   * @return {Promise<Chats>} Promise<{@link Chats}>
   */
  async getStoryNotificationSettingsExceptions(
    parameters: getStoryNotificationSettingsExceptions$DirectInput
  ): Promise<Chats> {
    const result = await this.client.invoke(
      "getStoryNotificationSettingsExceptions",
      parameters
    );
    return result as Chats;
  }

  /**
   * Loads more active stories from a story list. The loaded stories will be sent through updates. Active stories are sorted by
   *
   * - the pair (active_stories.order, active_stories.story_sender_chat_id) in descending order. Returns a 404 error if all active stories have been loaded
   *
   * @param {loadActiveStories$DirectInput} parameters {@link loadActiveStories$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async loadActiveStories(parameters: loadActiveStories$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("loadActiveStories", parameters);
    return result as Ok;
  }

  /**
   * Changes story list in which stories from the chat are shown
   *
   * @param {setChatActiveStoriesList$DirectInput} parameters {@link setChatActiveStoriesList$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setChatActiveStoriesList(
    parameters: setChatActiveStoriesList$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setChatActiveStoriesList", parameters);
    return result as Ok;
  }

  /**
   * Returns the list of active stories posted by the given chat
   *
   * @param {getChatActiveStories$DirectInput} parameters {@link getChatActiveStories$Input}
   * @return {Promise<ChatActiveStories>} Promise<{@link ChatActiveStories}>
   */
  async getChatActiveStories(
    parameters: getChatActiveStories$DirectInput
  ): Promise<ChatActiveStories> {
    const result = await this.client.invoke("getChatActiveStories", parameters);
    return result as ChatActiveStories;
  }

  /**
   * Returns the list of pinned stories posted by the given chat. The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id).
   *
   * - For optimal performance, the number of returned stories is chosen by TDLib
   *
   * @param {getChatPinnedStories$DirectInput} parameters {@link getChatPinnedStories$Input}
   * @return {Promise<Stories>} Promise<{@link Stories}>
   */
  async getChatPinnedStories(
    parameters: getChatPinnedStories$DirectInput
  ): Promise<Stories> {
    const result = await this.client.invoke("getChatPinnedStories", parameters);
    return result as Stories;
  }

  /**
   * Returns the list of all stories posted by the given chat; requires can_edit_stories rights for channel chats.
   *
   * - The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id). For optimal performance, the number of returned stories is chosen by TDLib
   *
   * @param {getChatArchivedStories$DirectInput} parameters {@link getChatArchivedStories$Input}
   * @return {Promise<Stories>} Promise<{@link Stories}>
   */
  async getChatArchivedStories(
    parameters: getChatArchivedStories$DirectInput
  ): Promise<Stories> {
    const result = await this.client.invoke("getChatArchivedStories", parameters);
    return result as Stories;
  }

  /**
   * Informs TDLib that a story is opened and is being viewed by the user
   *
   * @param {openStory$DirectInput} parameters {@link openStory$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async openStory(parameters: openStory$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("openStory", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that a story is closed by the user
   *
   * @param {closeStory$DirectInput} parameters {@link closeStory$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async closeStory(parameters: closeStory$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("closeStory", parameters);
    return result as Ok;
  }

  /**
   * Returns reactions, which can be chosen for a story
   *
   * @param {getStoryAvailableReactions$DirectInput} parameters {@link getStoryAvailableReactions$Input}
   * @return {Promise<AvailableReactions>} Promise<{@link AvailableReactions}>
   */
  async getStoryAvailableReactions(
    parameters: getStoryAvailableReactions$DirectInput
  ): Promise<AvailableReactions> {
    const result = await this.client.invoke(
      "getStoryAvailableReactions",
      parameters
    );
    return result as AvailableReactions;
  }

  /**
   * Changes chosen reaction on a story
   *
   * @param {setStoryReaction$DirectInput} parameters {@link setStoryReaction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStoryReaction(parameters: setStoryReaction$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setStoryReaction", parameters);
    return result as Ok;
  }

  /**
   * Returns interactions with a story. The method can be called only for stories posted on behalf of the current user
   *
   * @param {getStoryInteractions$DirectInput} parameters {@link getStoryInteractions$Input}
   * @return {Promise<StoryInteractions>} Promise<{@link StoryInteractions}>
   */
  async getStoryInteractions(
    parameters: getStoryInteractions$DirectInput
  ): Promise<StoryInteractions> {
    const result = await this.client.invoke("getStoryInteractions", parameters);
    return result as StoryInteractions;
  }

  /**
   * Returns interactions with a story posted in a chat. Can be used only if story is posted on behalf of a chat and the user is an administrator in the chat
   *
   * @param {getChatStoryInteractions$DirectInput} parameters {@link getChatStoryInteractions$Input}
   * @return {Promise<StoryInteractions>} Promise<{@link StoryInteractions}>
   */
  async getChatStoryInteractions(
    parameters: getChatStoryInteractions$DirectInput
  ): Promise<StoryInteractions> {
    const result = await this.client.invoke("getChatStoryInteractions", parameters);
    return result as StoryInteractions;
  }

  /**
   * Reports a story to the Telegram moderators
   *
   * @param {reportStory$DirectInput} parameters {@link reportStory$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reportStory(parameters: reportStory$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("reportStory", parameters);
    return result as Ok;
  }

  /**
   * Activates stealth mode for stories, which hides all views of stories from the current user in the last "story_stealth_mode_past_period" seconds
   *
   * - and for the next "story_stealth_mode_future_period" seconds; for Telegram Premium users only
   *
   * @param {activateStoryStealthMode$DirectInput} parameters {@link activateStoryStealthMode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async activateStoryStealthMode(
    parameters: activateStoryStealthMode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("activateStoryStealthMode", parameters);
    return result as Ok;
  }

  /**
   * Returns forwards of a story as a message to public chats and reposts by public channels. Can be used only if the story is posted on behalf of the current user or story.can_get_statistics == true.
   *
   * - For optimal performance, the number of returned messages and stories is chosen by TDLib
   *
   * @param {getStoryPublicForwards$DirectInput} parameters {@link getStoryPublicForwards$Input}
   * @return {Promise<PublicForwards>} Promise<{@link PublicForwards}>
   */
  async getStoryPublicForwards(
    parameters: getStoryPublicForwards$DirectInput
  ): Promise<PublicForwards> {
    const result = await this.client.invoke("getStoryPublicForwards", parameters);
    return result as PublicForwards;
  }

  /**
   * Returns list of features available on the specific chat boost level; this is an offline request
   *
   * @param {getChatBoostLevelFeatures$DirectInput} parameters {@link getChatBoostLevelFeatures$Input}
   * @return {Promise<ChatBoostLevelFeatures>} Promise<{@link ChatBoostLevelFeatures}>
   */
  async getChatBoostLevelFeatures(
    parameters: getChatBoostLevelFeatures$DirectInput
  ): Promise<ChatBoostLevelFeatures> {
    const result = await this.client.invoke("getChatBoostLevelFeatures", parameters);
    return result as ChatBoostLevelFeatures;
  }

  /**
   * Returns list of features available on the first 10 chat boost levels; this is an offline request
   *
   * @param {getChatBoostFeatures$DirectInput} parameters {@link getChatBoostFeatures$Input}
   * @return {Promise<ChatBoostFeatures>} Promise<{@link ChatBoostFeatures}>
   */
  async getChatBoostFeatures(
    parameters: getChatBoostFeatures$DirectInput
  ): Promise<ChatBoostFeatures> {
    const result = await this.client.invoke("getChatBoostFeatures", parameters);
    return result as ChatBoostFeatures;
  }

  /**
   * Returns the list of available chat boost slots for the current user
   *
   * @param {getAvailableChatBoostSlots$DirectInput} parameters {@link getAvailableChatBoostSlots$Input}
   * @return {Promise<ChatBoostSlots>} Promise<{@link ChatBoostSlots}>
   */
  async getAvailableChatBoostSlots(
    parameters: getAvailableChatBoostSlots$DirectInput
  ): Promise<ChatBoostSlots> {
    const result = await this.client.invoke(
      "getAvailableChatBoostSlots",
      parameters
    );
    return result as ChatBoostSlots;
  }

  /**
   * Returns the current boost status for a channel chat
   *
   * @param {getChatBoostStatus$DirectInput} parameters {@link getChatBoostStatus$Input}
   * @return {Promise<ChatBoostStatus>} Promise<{@link ChatBoostStatus}>
   */
  async getChatBoostStatus(
    parameters: getChatBoostStatus$DirectInput
  ): Promise<ChatBoostStatus> {
    const result = await this.client.invoke("getChatBoostStatus", parameters);
    return result as ChatBoostStatus;
  }

  /**
   * Boosts a chat and returns the list of available chat boost slots for the current user after the boost
   *
   * @param {boostChat$DirectInput} parameters {@link boostChat$Input}
   * @return {Promise<ChatBoostSlots>} Promise<{@link ChatBoostSlots}>
   */
  async boostChat(parameters: boostChat$DirectInput): Promise<ChatBoostSlots> {
    const result = await this.client.invoke("boostChat", parameters);
    return result as ChatBoostSlots;
  }

  /**
   * Returns an HTTPS link to boost the specified channel chat
   *
   * @param {getChatBoostLink$DirectInput} parameters {@link getChatBoostLink$Input}
   * @return {Promise<ChatBoostLink>} Promise<{@link ChatBoostLink}>
   */
  async getChatBoostLink(
    parameters: getChatBoostLink$DirectInput
  ): Promise<ChatBoostLink> {
    const result = await this.client.invoke("getChatBoostLink", parameters);
    return result as ChatBoostLink;
  }

  /**
   * Returns information about a link to boost a chat. Can be called for any internal link of the type internalLinkTypeChatBoost
   *
   * @param {getChatBoostLinkInfo$DirectInput} parameters {@link getChatBoostLinkInfo$Input}
   * @return {Promise<ChatBoostLinkInfo>} Promise<{@link ChatBoostLinkInfo}>
   */
  async getChatBoostLinkInfo(
    parameters: getChatBoostLinkInfo$DirectInput
  ): Promise<ChatBoostLinkInfo> {
    const result = await this.client.invoke("getChatBoostLinkInfo", parameters);
    return result as ChatBoostLinkInfo;
  }

  /**
   * Returns list of boosts applied to a chat; requires administrator rights in the channel chat
   *
   * @param {getChatBoosts$DirectInput} parameters {@link getChatBoosts$Input}
   * @return {Promise<FoundChatBoosts>} Promise<{@link FoundChatBoosts}>
   */
  async getChatBoosts(
    parameters: getChatBoosts$DirectInput
  ): Promise<FoundChatBoosts> {
    const result = await this.client.invoke("getChatBoosts", parameters);
    return result as FoundChatBoosts;
  }

  /**
   * Returns list of boosts applied to a chat by a given user; requires administrator rights in the channel chat; for bots only
   *
   * @param {getUserChatBoosts$DirectInput} parameters {@link getUserChatBoosts$Input}
   * @return {Promise<FoundChatBoosts>} Promise<{@link FoundChatBoosts}>
   */
  async getUserChatBoosts(
    parameters: getUserChatBoosts$DirectInput
  ): Promise<FoundChatBoosts> {
    const result = await this.client.invoke("getUserChatBoosts", parameters);
    return result as FoundChatBoosts;
  }

  /**
   * Returns information about a bot that can be added to attachment or side menu
   *
   * @param {getAttachmentMenuBot$DirectInput} parameters {@link getAttachmentMenuBot$Input}
   * @return {Promise<AttachmentMenuBot>} Promise<{@link AttachmentMenuBot}>
   */
  async getAttachmentMenuBot(
    parameters: getAttachmentMenuBot$DirectInput
  ): Promise<AttachmentMenuBot> {
    const result = await this.client.invoke("getAttachmentMenuBot", parameters);
    return result as AttachmentMenuBot;
  }

  /**
   * Adds or removes a bot to attachment and side menu. Bot can be added to the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
   *
   * @param {toggleBotIsAddedToAttachmentMenu$DirectInput} parameters {@link toggleBotIsAddedToAttachmentMenu$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleBotIsAddedToAttachmentMenu(
    parameters: toggleBotIsAddedToAttachmentMenu$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleBotIsAddedToAttachmentMenu",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns up to 8 emoji statuses, which must be shown right after the default Premium Badge in the emoji status list for self status
   *
   * @param {getThemedEmojiStatuses$DirectInput} parameters {@link getThemedEmojiStatuses$Input}
   * @return {Promise<EmojiStatuses>} Promise<{@link EmojiStatuses}>
   */
  async getThemedEmojiStatuses(
    parameters: getThemedEmojiStatuses$DirectInput
  ): Promise<EmojiStatuses> {
    const result = await this.client.invoke("getThemedEmojiStatuses", parameters);
    return result as EmojiStatuses;
  }

  /**
   * Returns recent emoji statuses for self status
   *
   * @param {getRecentEmojiStatuses$DirectInput} parameters {@link getRecentEmojiStatuses$Input}
   * @return {Promise<EmojiStatuses>} Promise<{@link EmojiStatuses}>
   */
  async getRecentEmojiStatuses(
    parameters: getRecentEmojiStatuses$DirectInput
  ): Promise<EmojiStatuses> {
    const result = await this.client.invoke("getRecentEmojiStatuses", parameters);
    return result as EmojiStatuses;
  }

  /**
   * Returns default emoji statuses for self status
   *
   * @param {getDefaultEmojiStatuses$DirectInput} parameters {@link getDefaultEmojiStatuses$Input}
   * @return {Promise<EmojiStatuses>} Promise<{@link EmojiStatuses}>
   */
  async getDefaultEmojiStatuses(
    parameters: getDefaultEmojiStatuses$DirectInput
  ): Promise<EmojiStatuses> {
    const result = await this.client.invoke("getDefaultEmojiStatuses", parameters);
    return result as EmojiStatuses;
  }

  /**
   * Clears the list of recently used emoji statuses for self status
   *
   * @param {clearRecentEmojiStatuses$DirectInput} parameters {@link clearRecentEmojiStatuses$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearRecentEmojiStatuses(
    parameters: clearRecentEmojiStatuses$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clearRecentEmojiStatuses", parameters);
    return result as Ok;
  }

  /**
   * Returns up to 8 emoji statuses, which must be shown in the emoji status list for chats
   *
   * @param {getThemedChatEmojiStatuses$DirectInput} parameters {@link getThemedChatEmojiStatuses$Input}
   * @return {Promise<EmojiStatuses>} Promise<{@link EmojiStatuses}>
   */
  async getThemedChatEmojiStatuses(
    parameters: getThemedChatEmojiStatuses$DirectInput
  ): Promise<EmojiStatuses> {
    const result = await this.client.invoke(
      "getThemedChatEmojiStatuses",
      parameters
    );
    return result as EmojiStatuses;
  }

  /**
   * Returns default emoji statuses for chats
   *
   * @param {getDefaultChatEmojiStatuses$DirectInput} parameters {@link getDefaultChatEmojiStatuses$Input}
   * @return {Promise<EmojiStatuses>} Promise<{@link EmojiStatuses}>
   */
  async getDefaultChatEmojiStatuses(
    parameters: getDefaultChatEmojiStatuses$DirectInput
  ): Promise<EmojiStatuses> {
    const result = await this.client.invoke(
      "getDefaultChatEmojiStatuses",
      parameters
    );
    return result as EmojiStatuses;
  }

  /**
   * Returns the list of emoji statuses, which can't be used as chat emoji status, even they are from a sticker set with is_allowed_as_chat_emoji_status == true
   *
   * @param {getDisallowedChatEmojiStatuses$DirectInput} parameters {@link getDisallowedChatEmojiStatuses$Input}
   * @return {Promise<EmojiStatuses>} Promise<{@link EmojiStatuses}>
   */
  async getDisallowedChatEmojiStatuses(
    parameters: getDisallowedChatEmojiStatuses$DirectInput
  ): Promise<EmojiStatuses> {
    const result = await this.client.invoke(
      "getDisallowedChatEmojiStatuses",
      parameters
    );
    return result as EmojiStatuses;
  }

  /**
   * Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
   *
   * @param {downloadFile$DirectInput} parameters {@link downloadFile$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async downloadFile(parameters: downloadFile$DirectInput): Promise<File> {
    const result = await this.client.invoke("downloadFile", parameters);
    return result as File;
  }

  /**
   * Returns file downloaded prefix size from a given offset, in bytes
   *
   * @param {getFileDownloadedPrefixSize$DirectInput} parameters {@link getFileDownloadedPrefixSize$Input}
   * @return {Promise<FileDownloadedPrefixSize>} Promise<{@link FileDownloadedPrefixSize}>
   */
  async getFileDownloadedPrefixSize(
    parameters: getFileDownloadedPrefixSize$DirectInput
  ): Promise<FileDownloadedPrefixSize> {
    const result = await this.client.invoke(
      "getFileDownloadedPrefixSize",
      parameters
    );
    return result as FileDownloadedPrefixSize;
  }

  /**
   * Stops the downloading of a file. If a file has already been downloaded, does nothing
   *
   * @param {cancelDownloadFile$DirectInput} parameters {@link cancelDownloadFile$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async cancelDownloadFile(parameters: cancelDownloadFile$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("cancelDownloadFile", parameters);
    return result as Ok;
  }

  /**
   * Returns suggested name for saving a file in a given directory
   *
   * @param {getSuggestedFileName$DirectInput} parameters {@link getSuggestedFileName$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getSuggestedFileName(
    parameters: getSuggestedFileName$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke("getSuggestedFileName", parameters);
    return result as Text;
  }

  /**
   * Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used
   *
   * - to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it is sent in a message
   *
   * @param {preliminaryUploadFile$DirectInput} parameters {@link preliminaryUploadFile$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async preliminaryUploadFile(
    parameters: preliminaryUploadFile$DirectInput
  ): Promise<File> {
    const result = await this.client.invoke("preliminaryUploadFile", parameters);
    return result as File;
  }

  /**
   * Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined
   *
   * @param {cancelPreliminaryUploadFile$DirectInput} parameters {@link cancelPreliminaryUploadFile$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async cancelPreliminaryUploadFile(
    parameters: cancelPreliminaryUploadFile$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "cancelPreliminaryUploadFile",
      parameters
    );
    return result as Ok;
  }

  /**
   * Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
   *
   * @param {writeGeneratedFilePart$DirectInput} parameters {@link writeGeneratedFilePart$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async writeGeneratedFilePart(
    parameters: writeGeneratedFilePart$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("writeGeneratedFilePart", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib on a file generation progress
   *
   * @param {setFileGenerationProgress$DirectInput} parameters {@link setFileGenerationProgress$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setFileGenerationProgress(
    parameters: setFileGenerationProgress$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setFileGenerationProgress", parameters);
    return result as Ok;
  }

  /**
   * Finishes the file generation
   *
   * @param {finishFileGeneration$DirectInput} parameters {@link finishFileGeneration$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async finishFileGeneration(
    parameters: finishFileGeneration$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("finishFileGeneration", parameters);
    return result as Ok;
  }

  /**
   * Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
   *
   * @param {readFilePart$DirectInput} parameters {@link readFilePart$Input}
   * @return {Promise<FilePart>} Promise<{@link FilePart}>
   */
  async readFilePart(parameters: readFilePart$DirectInput): Promise<FilePart> {
    const result = await this.client.invoke("readFilePart", parameters);
    return result as FilePart;
  }

  /**
   * Deletes a file from the TDLib file cache
   *
   * @param {deleteFile$DirectInput} parameters {@link deleteFile$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteFile(parameters: deleteFile$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteFile", parameters);
    return result as Ok;
  }

  /**
   * Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
   *
   * - If message database is used, the list of file downloads is persistent across application restarts. The downloading is independent from download using downloadFile, i.e. it continues if downloadFile is canceled or is used to download a part of the file
   *
   * @param {addFileToDownloads$DirectInput} parameters {@link addFileToDownloads$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async addFileToDownloads(
    parameters: addFileToDownloads$DirectInput
  ): Promise<File> {
    const result = await this.client.invoke("addFileToDownloads", parameters);
    return result as File;
  }

  /**
   * Changes pause state of a file in the file download list
   *
   * @param {toggleDownloadIsPaused$DirectInput} parameters {@link toggleDownloadIsPaused$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleDownloadIsPaused(
    parameters: toggleDownloadIsPaused$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleDownloadIsPaused", parameters);
    return result as Ok;
  }

  /**
   * Changes pause state of all files in the file download list
   *
   * @param {toggleAllDownloadsArePaused$DirectInput} parameters {@link toggleAllDownloadsArePaused$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleAllDownloadsArePaused(
    parameters: toggleAllDownloadsArePaused$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleAllDownloadsArePaused",
      parameters
    );
    return result as Ok;
  }

  /**
   * Removes a file from the file download list
   *
   * @param {removeFileFromDownloads$DirectInput} parameters {@link removeFileFromDownloads$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeFileFromDownloads(
    parameters: removeFileFromDownloads$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeFileFromDownloads", parameters);
    return result as Ok;
  }

  /**
   * Removes all files from the file download list
   *
   * @param {removeAllFilesFromDownloads$DirectInput} parameters {@link removeAllFilesFromDownloads$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeAllFilesFromDownloads(
    parameters: removeAllFilesFromDownloads$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "removeAllFilesFromDownloads",
      parameters
    );
    return result as Ok;
  }

  /**
   * Searches for files in the file download list or recently downloaded files from the list
   *
   * @param {searchFileDownloads$DirectInput} parameters {@link searchFileDownloads$Input}
   * @return {Promise<FoundFileDownloads>} Promise<{@link FoundFileDownloads}>
   */
  async searchFileDownloads(
    parameters: searchFileDownloads$DirectInput
  ): Promise<FoundFileDownloads> {
    const result = await this.client.invoke("searchFileDownloads", parameters);
    return result as FoundFileDownloads;
  }

  /**
   * Returns information about a file with messages exported from another application
   *
   * @param {getMessageFileType$DirectInput} parameters {@link getMessageFileType$Input}
   * @return {Promise<MessageFileType>} Promise<{@link MessageFileType}>
   */
  async getMessageFileType(
    parameters: getMessageFileType$DirectInput
  ): Promise<MessageFileType> {
    const result = await this.client.invoke("getMessageFileType", parameters);
    return result as MessageFileType;
  }

  /**
   * Returns a confirmation text to be shown to the user before starting message import
   *
   * @param {getMessageImportConfirmationText$DirectInput} parameters {@link getMessageImportConfirmationText$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getMessageImportConfirmationText(
    parameters: getMessageImportConfirmationText$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke(
      "getMessageImportConfirmationText",
      parameters
    );
    return result as Text;
  }

  /**
   * Imports messages exported from another app
   *
   * @param {importMessages$DirectInput} parameters {@link importMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async importMessages(parameters: importMessages$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("importMessages", parameters);
    return result as Ok;
  }

  /**
   * Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
   *
   * @param {replacePrimaryChatInviteLink$DirectInput} parameters {@link replacePrimaryChatInviteLink$Input}
   * @return {Promise<ChatInviteLink>} Promise<{@link ChatInviteLink}>
   */
  async replacePrimaryChatInviteLink(
    parameters: replacePrimaryChatInviteLink$DirectInput
  ): Promise<ChatInviteLink> {
    const result = await this.client.invoke(
      "replacePrimaryChatInviteLink",
      parameters
    );
    return result as ChatInviteLink;
  }

  /**
   * Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
   *
   * @param {createChatInviteLink$DirectInput} parameters {@link createChatInviteLink$Input}
   * @return {Promise<ChatInviteLink>} Promise<{@link ChatInviteLink}>
   */
  async createChatInviteLink(
    parameters: createChatInviteLink$DirectInput
  ): Promise<ChatInviteLink> {
    const result = await this.client.invoke("createChatInviteLink", parameters);
    return result as ChatInviteLink;
  }

  /**
   * Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   *
   * @param {editChatInviteLink$DirectInput} parameters {@link editChatInviteLink$Input}
   * @return {Promise<ChatInviteLink>} Promise<{@link ChatInviteLink}>
   */
  async editChatInviteLink(
    parameters: editChatInviteLink$DirectInput
  ): Promise<ChatInviteLink> {
    const result = await this.client.invoke("editChatInviteLink", parameters);
    return result as ChatInviteLink;
  }

  /**
   * Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
   *
   * @param {getChatInviteLink$DirectInput} parameters {@link getChatInviteLink$Input}
   * @return {Promise<ChatInviteLink>} Promise<{@link ChatInviteLink}>
   */
  async getChatInviteLink(
    parameters: getChatInviteLink$DirectInput
  ): Promise<ChatInviteLink> {
    const result = await this.client.invoke("getChatInviteLink", parameters);
    return result as ChatInviteLink;
  }

  /**
   * Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
   *
   * @param {getChatInviteLinkCounts$DirectInput} parameters {@link getChatInviteLinkCounts$Input}
   * @return {Promise<ChatInviteLinkCounts>} Promise<{@link ChatInviteLinkCounts}>
   */
  async getChatInviteLinkCounts(
    parameters: getChatInviteLinkCounts$DirectInput
  ): Promise<ChatInviteLinkCounts> {
    const result = await this.client.invoke("getChatInviteLinkCounts", parameters);
    return result as ChatInviteLinkCounts;
  }

  /**
   * Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
   *
   * @param {getChatInviteLinks$DirectInput} parameters {@link getChatInviteLinks$Input}
   * @return {Promise<ChatInviteLinks>} Promise<{@link ChatInviteLinks}>
   */
  async getChatInviteLinks(
    parameters: getChatInviteLinks$DirectInput
  ): Promise<ChatInviteLinks> {
    const result = await this.client.invoke("getChatInviteLinks", parameters);
    return result as ChatInviteLinks;
  }

  /**
   * Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   *
   * @param {getChatInviteLinkMembers$DirectInput} parameters {@link getChatInviteLinkMembers$Input}
   * @return {Promise<ChatInviteLinkMembers>} Promise<{@link ChatInviteLinkMembers}>
   */
  async getChatInviteLinkMembers(
    parameters: getChatInviteLinkMembers$DirectInput
  ): Promise<ChatInviteLinkMembers> {
    const result = await this.client.invoke("getChatInviteLinkMembers", parameters);
    return result as ChatInviteLinkMembers;
  }

  /**
   * Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
   *
   * - If a primary link is revoked, then additionally to the revoked link returns new primary link
   *
   * @param {revokeChatInviteLink$DirectInput} parameters {@link revokeChatInviteLink$Input}
   * @return {Promise<ChatInviteLinks>} Promise<{@link ChatInviteLinks}>
   */
  async revokeChatInviteLink(
    parameters: revokeChatInviteLink$DirectInput
  ): Promise<ChatInviteLinks> {
    const result = await this.client.invoke("revokeChatInviteLink", parameters);
    return result as ChatInviteLinks;
  }

  /**
   * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   *
   * @param {deleteRevokedChatInviteLink$DirectInput} parameters {@link deleteRevokedChatInviteLink$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteRevokedChatInviteLink(
    parameters: deleteRevokedChatInviteLink$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "deleteRevokedChatInviteLink",
      parameters
    );
    return result as Ok;
  }

  /**
   * Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   *
   * @param {deleteAllRevokedChatInviteLinks$DirectInput} parameters {@link deleteAllRevokedChatInviteLinks$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteAllRevokedChatInviteLinks(
    parameters: deleteAllRevokedChatInviteLinks$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "deleteAllRevokedChatInviteLinks",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks the validity of an invite link for a chat and returns information about the corresponding chat
   *
   * @param {checkChatInviteLink$DirectInput} parameters {@link checkChatInviteLink$Input}
   * @return {Promise<ChatInviteLinkInfo>} Promise<{@link ChatInviteLinkInfo}>
   */
  async checkChatInviteLink(
    parameters: checkChatInviteLink$DirectInput
  ): Promise<ChatInviteLinkInfo> {
    const result = await this.client.invoke("checkChatInviteLink", parameters);
    return result as ChatInviteLinkInfo;
  }

  /**
   * Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
   *
   * @param {joinChatByInviteLink$DirectInput} parameters {@link joinChatByInviteLink$Input}
   * @return {Promise<Chat>} Promise<{@link Chat}>
   */
  async joinChatByInviteLink(
    parameters: joinChatByInviteLink$DirectInput
  ): Promise<Chat> {
    const result = await this.client.invoke("joinChatByInviteLink", parameters);
    return result as Chat;
  }

  /**
   * Returns pending join requests in a chat
   *
   * @param {getChatJoinRequests$DirectInput} parameters {@link getChatJoinRequests$Input}
   * @return {Promise<ChatJoinRequests>} Promise<{@link ChatJoinRequests}>
   */
  async getChatJoinRequests(
    parameters: getChatJoinRequests$DirectInput
  ): Promise<ChatJoinRequests> {
    const result = await this.client.invoke("getChatJoinRequests", parameters);
    return result as ChatJoinRequests;
  }

  /**
   * Handles a pending join request in a chat
   *
   * @param {processChatJoinRequest$DirectInput} parameters {@link processChatJoinRequest$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async processChatJoinRequest(
    parameters: processChatJoinRequest$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("processChatJoinRequest", parameters);
    return result as Ok;
  }

  /**
   * Handles all pending join requests for a given link in a chat
   *
   * @param {processChatJoinRequests$DirectInput} parameters {@link processChatJoinRequests$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async processChatJoinRequests(
    parameters: processChatJoinRequests$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("processChatJoinRequests", parameters);
    return result as Ok;
  }

  /**
   * Creates a new call
   *
   * @param {createCall$DirectInput} parameters {@link createCall$Input}
   * @return {Promise<CallId>} Promise<{@link CallId}>
   */
  async createCall(parameters: createCall$DirectInput): Promise<CallId> {
    const result = await this.client.invoke("createCall", parameters);
    return result as CallId;
  }

  /**
   * Accepts an incoming call
   *
   * @param {acceptCall$DirectInput} parameters {@link acceptCall$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async acceptCall(parameters: acceptCall$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("acceptCall", parameters);
    return result as Ok;
  }

  /**
   * Sends call signaling data
   *
   * @param {sendCallSignalingData$DirectInput} parameters {@link sendCallSignalingData$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendCallSignalingData(
    parameters: sendCallSignalingData$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("sendCallSignalingData", parameters);
    return result as Ok;
  }

  /**
   * Discards a call
   *
   * @param {discardCall$DirectInput} parameters {@link discardCall$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async discardCall(parameters: discardCall$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("discardCall", parameters);
    return result as Ok;
  }

  /**
   * Sends a call rating
   *
   * @param {sendCallRating$DirectInput} parameters {@link sendCallRating$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendCallRating(parameters: sendCallRating$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("sendCallRating", parameters);
    return result as Ok;
  }

  /**
   * Sends debug information for a call to Telegram servers
   *
   * @param {sendCallDebugInformation$DirectInput} parameters {@link sendCallDebugInformation$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendCallDebugInformation(
    parameters: sendCallDebugInformation$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("sendCallDebugInformation", parameters);
    return result as Ok;
  }

  /**
   * Sends log file for a call to Telegram servers
   *
   * @param {sendCallLog$DirectInput} parameters {@link sendCallLog$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendCallLog(parameters: sendCallLog$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("sendCallLog", parameters);
    return result as Ok;
  }

  /**
   * Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined
   *
   * @param {getVideoChatAvailableParticipants$DirectInput} parameters {@link getVideoChatAvailableParticipants$Input}
   * @return {Promise<MessageSenders>} Promise<{@link MessageSenders}>
   */
  async getVideoChatAvailableParticipants(
    parameters: getVideoChatAvailableParticipants$DirectInput
  ): Promise<MessageSenders> {
    const result = await this.client.invoke(
      "getVideoChatAvailableParticipants",
      parameters
    );
    return result as MessageSenders;
  }

  /**
   * Changes default participant identifier, on whose behalf a video chat in the chat will be joined
   *
   * @param {setVideoChatDefaultParticipant$DirectInput} parameters {@link setVideoChatDefaultParticipant$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setVideoChatDefaultParticipant(
    parameters: setVideoChatDefaultParticipant$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setVideoChatDefaultParticipant",
      parameters
    );
    return result as Ok;
  }

  /**
   * Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
   *
   * @param {createVideoChat$DirectInput} parameters {@link createVideoChat$Input}
   * @return {Promise<GroupCallId>} Promise<{@link GroupCallId}>
   */
  async createVideoChat(
    parameters: createVideoChat$DirectInput
  ): Promise<GroupCallId> {
    const result = await this.client.invoke("createVideoChat", parameters);
    return result as GroupCallId;
  }

  /**
   * Returns RTMP URL for streaming to the chat; requires creator privileges
   *
   * @param {getVideoChatRtmpUrl$DirectInput} parameters {@link getVideoChatRtmpUrl$Input}
   * @return {Promise<RtmpUrl>} Promise<{@link RtmpUrl}>
   */
  async getVideoChatRtmpUrl(
    parameters: getVideoChatRtmpUrl$DirectInput
  ): Promise<RtmpUrl> {
    const result = await this.client.invoke("getVideoChatRtmpUrl", parameters);
    return result as RtmpUrl;
  }

  /**
   * Replaces the current RTMP URL for streaming to the chat; requires creator privileges
   *
   * @param {replaceVideoChatRtmpUrl$DirectInput} parameters {@link replaceVideoChatRtmpUrl$Input}
   * @return {Promise<RtmpUrl>} Promise<{@link RtmpUrl}>
   */
  async replaceVideoChatRtmpUrl(
    parameters: replaceVideoChatRtmpUrl$DirectInput
  ): Promise<RtmpUrl> {
    const result = await this.client.invoke("replaceVideoChatRtmpUrl", parameters);
    return result as RtmpUrl;
  }

  /**
   * Returns information about a group call
   *
   * @param {getGroupCall$DirectInput} parameters {@link getGroupCall$Input}
   * @return {Promise<GroupCall>} Promise<{@link GroupCall}>
   */
  async getGroupCall(parameters: getGroupCall$DirectInput): Promise<GroupCall> {
    const result = await this.client.invoke("getGroupCall", parameters);
    return result as GroupCall;
  }

  /**
   * Starts a scheduled group call
   *
   * @param {startScheduledGroupCall$DirectInput} parameters {@link startScheduledGroupCall$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async startScheduledGroupCall(
    parameters: startScheduledGroupCall$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("startScheduledGroupCall", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether the current user will receive a notification when the group call starts; scheduled group calls only
   *
   * @param {toggleGroupCallEnabledStartNotification$DirectInput} parameters {@link toggleGroupCallEnabledStartNotification$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallEnabledStartNotification(
    parameters: toggleGroupCallEnabledStartNotification$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallEnabledStartNotification",
      parameters
    );
    return result as Ok;
  }

  /**
   * Joins an active group call. Returns join response payload for tgcalls
   *
   * @param {joinGroupCall$DirectInput} parameters {@link joinGroupCall$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async joinGroupCall(parameters: joinGroupCall$DirectInput): Promise<Text> {
    const result = await this.client.invoke("joinGroupCall", parameters);
    return result as Text;
  }

  /**
   * Starts screen sharing in a joined group call. Returns join response payload for tgcalls
   *
   * @param {startGroupCallScreenSharing$DirectInput} parameters {@link startGroupCallScreenSharing$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async startGroupCallScreenSharing(
    parameters: startGroupCallScreenSharing$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke(
      "startGroupCallScreenSharing",
      parameters
    );
    return result as Text;
  }

  /**
   * Pauses or unpauses screen sharing in a joined group call
   *
   * @param {toggleGroupCallScreenSharingIsPaused$DirectInput} parameters {@link toggleGroupCallScreenSharingIsPaused$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallScreenSharingIsPaused(
    parameters: toggleGroupCallScreenSharingIsPaused$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallScreenSharingIsPaused",
      parameters
    );
    return result as Ok;
  }

  /**
   * Ends screen sharing in a joined group call
   *
   * @param {endGroupCallScreenSharing$DirectInput} parameters {@link endGroupCallScreenSharing$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async endGroupCallScreenSharing(
    parameters: endGroupCallScreenSharing$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("endGroupCallScreenSharing", parameters);
    return result as Ok;
  }

  /**
   * Sets group call title. Requires groupCall.can_be_managed group call flag
   *
   * @param {setGroupCallTitle$DirectInput} parameters {@link setGroupCallTitle$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setGroupCallTitle(parameters: setGroupCallTitle$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setGroupCallTitle", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
   *
   * @param {toggleGroupCallMuteNewParticipants$DirectInput} parameters {@link toggleGroupCallMuteNewParticipants$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallMuteNewParticipants(
    parameters: toggleGroupCallMuteNewParticipants$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallMuteNewParticipants",
      parameters
    );
    return result as Ok;
  }

  /**
   * Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants for video chats
   *
   * @param {inviteGroupCallParticipants$DirectInput} parameters {@link inviteGroupCallParticipants$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async inviteGroupCallParticipants(
    parameters: inviteGroupCallParticipants$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "inviteGroupCallParticipants",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns invite link to a video chat in a public chat
   *
   * @param {getGroupCallInviteLink$DirectInput} parameters {@link getGroupCallInviteLink$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getGroupCallInviteLink(
    parameters: getGroupCallInviteLink$DirectInput
  ): Promise<HttpUrl> {
    const result = await this.client.invoke("getGroupCallInviteLink", parameters);
    return result as HttpUrl;
  }

  /**
   * Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
   *
   * @param {revokeGroupCallInviteLink$DirectInput} parameters {@link revokeGroupCallInviteLink$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async revokeGroupCallInviteLink(
    parameters: revokeGroupCallInviteLink$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("revokeGroupCallInviteLink", parameters);
    return result as Ok;
  }

  /**
   * Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
   *
   * @param {startGroupCallRecording$DirectInput} parameters {@link startGroupCallRecording$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async startGroupCallRecording(
    parameters: startGroupCallRecording$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("startGroupCallRecording", parameters);
    return result as Ok;
  }

  /**
   * Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
   *
   * @param {endGroupCallRecording$DirectInput} parameters {@link endGroupCallRecording$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async endGroupCallRecording(
    parameters: endGroupCallRecording$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("endGroupCallRecording", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether current user's video is paused
   *
   * @param {toggleGroupCallIsMyVideoPaused$DirectInput} parameters {@link toggleGroupCallIsMyVideoPaused$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallIsMyVideoPaused(
    parameters: toggleGroupCallIsMyVideoPaused$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallIsMyVideoPaused",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether current user's video is enabled
   *
   * @param {toggleGroupCallIsMyVideoEnabled$DirectInput} parameters {@link toggleGroupCallIsMyVideoEnabled$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallIsMyVideoEnabled(
    parameters: toggleGroupCallIsMyVideoEnabled$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallIsMyVideoEnabled",
      parameters
    );
    return result as Ok;
  }

  /**
   * Informs TDLib that speaking state of a participant of an active group has changed
   *
   * @param {setGroupCallParticipantIsSpeaking$DirectInput} parameters {@link setGroupCallParticipantIsSpeaking$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setGroupCallParticipantIsSpeaking(
    parameters: setGroupCallParticipantIsSpeaking$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setGroupCallParticipantIsSpeaking",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
   *
   * @param {toggleGroupCallParticipantIsMuted$DirectInput} parameters {@link toggleGroupCallParticipantIsMuted$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallParticipantIsMuted(
    parameters: toggleGroupCallParticipantIsMuted$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallParticipantIsMuted",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
   *
   * @param {setGroupCallParticipantVolumeLevel$DirectInput} parameters {@link setGroupCallParticipantVolumeLevel$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setGroupCallParticipantVolumeLevel(
    parameters: setGroupCallParticipantVolumeLevel$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setGroupCallParticipantVolumeLevel",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether a group call participant hand is rased
   *
   * @param {toggleGroupCallParticipantIsHandRaised$DirectInput} parameters {@link toggleGroupCallParticipantIsHandRaised$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleGroupCallParticipantIsHandRaised(
    parameters: toggleGroupCallParticipantIsHandRaised$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleGroupCallParticipantIsHandRaised",
      parameters
    );
    return result as Ok;
  }

  /**
   * Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
   *
   * @param {loadGroupCallParticipants$DirectInput} parameters {@link loadGroupCallParticipants$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async loadGroupCallParticipants(
    parameters: loadGroupCallParticipants$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("loadGroupCallParticipants", parameters);
    return result as Ok;
  }

  /**
   * Leaves a group call
   *
   * @param {leaveGroupCall$DirectInput} parameters {@link leaveGroupCall$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async leaveGroupCall(parameters: leaveGroupCall$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("leaveGroupCall", parameters);
    return result as Ok;
  }

  /**
   * Ends a group call. Requires groupCall.can_be_managed
   *
   * @param {endGroupCall$DirectInput} parameters {@link endGroupCall$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async endGroupCall(parameters: endGroupCall$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("endGroupCall", parameters);
    return result as Ok;
  }

  /**
   * Returns information about available group call streams
   *
   * @param {getGroupCallStreams$DirectInput} parameters {@link getGroupCallStreams$Input}
   * @return {Promise<GroupCallStreams>} Promise<{@link GroupCallStreams}>
   */
  async getGroupCallStreams(
    parameters: getGroupCallStreams$DirectInput
  ): Promise<GroupCallStreams> {
    const result = await this.client.invoke("getGroupCallStreams", parameters);
    return result as GroupCallStreams;
  }

  /**
   * Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
   *
   * @param {getGroupCallStreamSegment$DirectInput} parameters {@link getGroupCallStreamSegment$Input}
   * @return {Promise<FilePart>} Promise<{@link FilePart}>
   */
  async getGroupCallStreamSegment(
    parameters: getGroupCallStreamSegment$DirectInput
  ): Promise<FilePart> {
    const result = await this.client.invoke("getGroupCallStreamSegment", parameters);
    return result as FilePart;
  }

  /**
   * Changes the block list of a message sender. Currently, only users and supergroup chats can be blocked
   *
   * @param {setMessageSenderBlockList$DirectInput} parameters {@link setMessageSenderBlockList$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setMessageSenderBlockList(
    parameters: setMessageSenderBlockList$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setMessageSenderBlockList", parameters);
    return result as Ok;
  }

  /**
   * Blocks an original sender of a message in the Replies chat
   *
   * @param {blockMessageSenderFromReplies$DirectInput} parameters {@link blockMessageSenderFromReplies$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async blockMessageSenderFromReplies(
    parameters: blockMessageSenderFromReplies$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "blockMessageSenderFromReplies",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns users and chats that were blocked by the current user
   *
   * @param {getBlockedMessageSenders$DirectInput} parameters {@link getBlockedMessageSenders$Input}
   * @return {Promise<MessageSenders>} Promise<{@link MessageSenders}>
   */
  async getBlockedMessageSenders(
    parameters: getBlockedMessageSenders$DirectInput
  ): Promise<MessageSenders> {
    const result = await this.client.invoke("getBlockedMessageSenders", parameters);
    return result as MessageSenders;
  }

  /**
   * Adds a user to the contact list or edits an existing contact by their user identifier
   *
   * @param {addContact$DirectInput} parameters {@link addContact$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addContact(parameters: addContact$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addContact", parameters);
    return result as Ok;
  }

  /**
   * Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
   *
   * @param {importContacts$DirectInput} parameters {@link importContacts$Input}
   * @return {Promise<ImportedContacts>} Promise<{@link ImportedContacts}>
   */
  async importContacts(
    parameters: importContacts$DirectInput
  ): Promise<ImportedContacts> {
    const result = await this.client.invoke("importContacts", parameters);
    return result as ImportedContacts;
  }

  /**
   * Returns all contacts of the user
   *
   * @param {getContacts$DirectInput} parameters {@link getContacts$Input}
   * @return {Promise<Users>} Promise<{@link Users}>
   */
  async getContacts(parameters: getContacts$DirectInput): Promise<Users> {
    const result = await this.client.invoke("getContacts", parameters);
    return result as Users;
  }

  /**
   * Searches for the specified query in the first names, last names and usernames of the known user contacts
   *
   * @param {searchContacts$DirectInput} parameters {@link searchContacts$Input}
   * @return {Promise<Users>} Promise<{@link Users}>
   */
  async searchContacts(parameters: searchContacts$DirectInput): Promise<Users> {
    const result = await this.client.invoke("searchContacts", parameters);
    return result as Users;
  }

  /**
   * Removes users from the contact list
   *
   * @param {removeContacts$DirectInput} parameters {@link removeContacts$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeContacts(parameters: removeContacts$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("removeContacts", parameters);
    return result as Ok;
  }

  /**
   * Returns the total number of imported contacts
   *
   * @param {getImportedContactCount$DirectInput} parameters {@link getImportedContactCount$Input}
   * @return {Promise<Count>} Promise<{@link Count}>
   */
  async getImportedContactCount(
    parameters: getImportedContactCount$DirectInput
  ): Promise<Count> {
    const result = await this.client.invoke("getImportedContactCount", parameters);
    return result as Count;
  }

  /**
   * Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
   *
   * - Query result depends on the result of the previous query, so only one query is possible at the same time
   *
   * @param {changeImportedContacts$DirectInput} parameters {@link changeImportedContacts$Input}
   * @return {Promise<ImportedContacts>} Promise<{@link ImportedContacts}>
   */
  async changeImportedContacts(
    parameters: changeImportedContacts$DirectInput
  ): Promise<ImportedContacts> {
    const result = await this.client.invoke("changeImportedContacts", parameters);
    return result as ImportedContacts;
  }

  /**
   * Clears all imported contacts, contact list remains unchanged
   *
   * @param {clearImportedContacts$DirectInput} parameters {@link clearImportedContacts$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearImportedContacts(
    parameters: clearImportedContacts$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clearImportedContacts", parameters);
    return result as Ok;
  }

  /**
   * Changes the list of close friends of the current user
   *
   * @param {setCloseFriends$DirectInput} parameters {@link setCloseFriends$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setCloseFriends(parameters: setCloseFriends$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setCloseFriends", parameters);
    return result as Ok;
  }

  /**
   * Returns all close friends of the current user
   *
   * @param {getCloseFriends$DirectInput} parameters {@link getCloseFriends$Input}
   * @return {Promise<Users>} Promise<{@link Users}>
   */
  async getCloseFriends(parameters: getCloseFriends$DirectInput): Promise<Users> {
    const result = await this.client.invoke("getCloseFriends", parameters);
    return result as Users;
  }

  /**
   * Changes a personal profile photo of a contact user
   *
   * @param {setUserPersonalProfilePhoto$DirectInput} parameters {@link setUserPersonalProfilePhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setUserPersonalProfilePhoto(
    parameters: setUserPersonalProfilePhoto$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setUserPersonalProfilePhoto",
      parameters
    );
    return result as Ok;
  }

  /**
   * Suggests a profile photo to another regular user with common messages
   *
   * @param {suggestUserProfilePhoto$DirectInput} parameters {@link suggestUserProfilePhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async suggestUserProfilePhoto(
    parameters: suggestUserProfilePhoto$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("suggestUserProfilePhoto", parameters);
    return result as Ok;
  }

  /**
   * Searches a user by their phone number. Returns a 404 error if the user can't be found
   *
   * @param {searchUserByPhoneNumber$DirectInput} parameters {@link searchUserByPhoneNumber$Input}
   * @return {Promise<User>} Promise<{@link User}>
   */
  async searchUserByPhoneNumber(
    parameters: searchUserByPhoneNumber$DirectInput
  ): Promise<User> {
    const result = await this.client.invoke("searchUserByPhoneNumber", parameters);
    return result as User;
  }

  /**
   * Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
   *
   * @param {sharePhoneNumber$DirectInput} parameters {@link sharePhoneNumber$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sharePhoneNumber(parameters: sharePhoneNumber$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("sharePhoneNumber", parameters);
    return result as Ok;
  }

  /**
   * Returns the profile photos of a user. Personal and public photo aren't returned
   *
   * @param {getUserProfilePhotos$DirectInput} parameters {@link getUserProfilePhotos$Input}
   * @return {Promise<ChatPhotos>} Promise<{@link ChatPhotos}>
   */
  async getUserProfilePhotos(
    parameters: getUserProfilePhotos$DirectInput
  ): Promise<ChatPhotos> {
    const result = await this.client.invoke("getUserProfilePhotos", parameters);
    return result as ChatPhotos;
  }

  /**
   * Returns stickers from the installed sticker sets that correspond to any of the given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned
   *
   * @param {getStickers$DirectInput} parameters {@link getStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getStickers(parameters: getStickers$DirectInput): Promise<Stickers> {
    const result = await this.client.invoke("getStickers", parameters);
    return result as Stickers;
  }

  /**
   * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type, query, 1000000, chat_id)
   *
   * @param {getAllStickerEmojis$DirectInput} parameters {@link getAllStickerEmojis$Input}
   * @return {Promise<Emojis>} Promise<{@link Emojis}>
   */
  async getAllStickerEmojis(
    parameters: getAllStickerEmojis$DirectInput
  ): Promise<Emojis> {
    const result = await this.client.invoke("getAllStickerEmojis", parameters);
    return result as Emojis;
  }

  /**
   * Searches for stickers from public sticker sets that correspond to any of the given emoji
   *
   * @param {searchStickers$DirectInput} parameters {@link searchStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async searchStickers(parameters: searchStickers$DirectInput): Promise<Stickers> {
    const result = await this.client.invoke("searchStickers", parameters);
    return result as Stickers;
  }

  /**
   * Returns premium stickers from regular sticker sets
   *
   * @param {getPremiumStickers$DirectInput} parameters {@link getPremiumStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getPremiumStickers(
    parameters: getPremiumStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("getPremiumStickers", parameters);
    return result as Stickers;
  }

  /**
   * Returns a list of installed sticker sets
   *
   * @param {getInstalledStickerSets$DirectInput} parameters {@link getInstalledStickerSets$Input}
   * @return {Promise<StickerSets>} Promise<{@link StickerSets}>
   */
  async getInstalledStickerSets(
    parameters: getInstalledStickerSets$DirectInput
  ): Promise<StickerSets> {
    const result = await this.client.invoke("getInstalledStickerSets", parameters);
    return result as StickerSets;
  }

  /**
   * Returns a list of archived sticker sets
   *
   * @param {getArchivedStickerSets$DirectInput} parameters {@link getArchivedStickerSets$Input}
   * @return {Promise<StickerSets>} Promise<{@link StickerSets}>
   */
  async getArchivedStickerSets(
    parameters: getArchivedStickerSets$DirectInput
  ): Promise<StickerSets> {
    const result = await this.client.invoke("getArchivedStickerSets", parameters);
    return result as StickerSets;
  }

  /**
   * Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
   *
   * @param {getTrendingStickerSets$DirectInput} parameters {@link getTrendingStickerSets$Input}
   * @return {Promise<TrendingStickerSets>} Promise<{@link TrendingStickerSets}>
   */
  async getTrendingStickerSets(
    parameters: getTrendingStickerSets$DirectInput
  ): Promise<TrendingStickerSets> {
    const result = await this.client.invoke("getTrendingStickerSets", parameters);
    return result as TrendingStickerSets;
  }

  /**
   * Returns a list of sticker sets attached to a file, including regular, mask, and emoji sticker sets. Currently, only animations, photos, and videos can have attached sticker sets
   *
   * @param {getAttachedStickerSets$DirectInput} parameters {@link getAttachedStickerSets$Input}
   * @return {Promise<StickerSets>} Promise<{@link StickerSets}>
   */
  async getAttachedStickerSets(
    parameters: getAttachedStickerSets$DirectInput
  ): Promise<StickerSets> {
    const result = await this.client.invoke("getAttachedStickerSets", parameters);
    return result as StickerSets;
  }

  /**
   * Returns information about a sticker set by its identifier
   *
   * @param {getStickerSet$DirectInput} parameters {@link getStickerSet$Input}
   * @return {Promise<StickerSet>} Promise<{@link StickerSet}>
   */
  async getStickerSet(parameters: getStickerSet$DirectInput): Promise<StickerSet> {
    const result = await this.client.invoke("getStickerSet", parameters);
    return result as StickerSet;
  }

  /**
   * Searches for a sticker set by its name
   *
   * @param {searchStickerSet$DirectInput} parameters {@link searchStickerSet$Input}
   * @return {Promise<StickerSet>} Promise<{@link StickerSet}>
   */
  async searchStickerSet(
    parameters: searchStickerSet$DirectInput
  ): Promise<StickerSet> {
    const result = await this.client.invoke("searchStickerSet", parameters);
    return result as StickerSet;
  }

  /**
   * Searches for installed sticker sets by looking for specified query in their title and name
   *
   * @param {searchInstalledStickerSets$DirectInput} parameters {@link searchInstalledStickerSets$Input}
   * @return {Promise<StickerSets>} Promise<{@link StickerSets}>
   */
  async searchInstalledStickerSets(
    parameters: searchInstalledStickerSets$DirectInput
  ): Promise<StickerSets> {
    const result = await this.client.invoke(
      "searchInstalledStickerSets",
      parameters
    );
    return result as StickerSets;
  }

  /**
   * Searches for sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
   *
   * @param {searchStickerSets$DirectInput} parameters {@link searchStickerSets$Input}
   * @return {Promise<StickerSets>} Promise<{@link StickerSets}>
   */
  async searchStickerSets(
    parameters: searchStickerSets$DirectInput
  ): Promise<StickerSets> {
    const result = await this.client.invoke("searchStickerSets", parameters);
    return result as StickerSets;
  }

  /**
   * Installs/uninstalls or activates/archives a sticker set
   *
   * @param {changeStickerSet$DirectInput} parameters {@link changeStickerSet$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async changeStickerSet(parameters: changeStickerSet$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("changeStickerSet", parameters);
    return result as Ok;
  }

  /**
   * Informs the server that some trending sticker sets have been viewed by the user
   *
   * @param {viewTrendingStickerSets$DirectInput} parameters {@link viewTrendingStickerSets$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async viewTrendingStickerSets(
    parameters: viewTrendingStickerSets$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("viewTrendingStickerSets", parameters);
    return result as Ok;
  }

  /**
   * Changes the order of installed sticker sets
   *
   * @param {reorderInstalledStickerSets$DirectInput} parameters {@link reorderInstalledStickerSets$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reorderInstalledStickerSets(
    parameters: reorderInstalledStickerSets$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "reorderInstalledStickerSets",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns a list of recently used stickers
   *
   * @param {getRecentStickers$DirectInput} parameters {@link getRecentStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getRecentStickers(
    parameters: getRecentStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("getRecentStickers", parameters);
    return result as Stickers;
  }

  /**
   * Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
   *
   * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to recent stickers
   *
   * @param {addRecentSticker$DirectInput} parameters {@link addRecentSticker$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async addRecentSticker(
    parameters: addRecentSticker$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("addRecentSticker", parameters);
    return result as Stickers;
  }

  /**
   * Removes a sticker from the list of recently used stickers
   *
   * @param {removeRecentSticker$DirectInput} parameters {@link removeRecentSticker$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeRecentSticker(
    parameters: removeRecentSticker$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeRecentSticker", parameters);
    return result as Ok;
  }

  /**
   * Clears the list of recently used stickers
   *
   * @param {clearRecentStickers$DirectInput} parameters {@link clearRecentStickers$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearRecentStickers(
    parameters: clearRecentStickers$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("clearRecentStickers", parameters);
    return result as Ok;
  }

  /**
   * Returns favorite stickers
   *
   * @param {getFavoriteStickers$DirectInput} parameters {@link getFavoriteStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getFavoriteStickers(
    parameters: getFavoriteStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("getFavoriteStickers", parameters);
    return result as Stickers;
  }

  /**
   * Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
   *
   * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to favorite stickers
   *
   * @param {addFavoriteSticker$DirectInput} parameters {@link addFavoriteSticker$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addFavoriteSticker(parameters: addFavoriteSticker$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addFavoriteSticker", parameters);
    return result as Ok;
  }

  /**
   * Removes a sticker from the list of favorite stickers
   *
   * @param {removeFavoriteSticker$DirectInput} parameters {@link removeFavoriteSticker$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeFavoriteSticker(
    parameters: removeFavoriteSticker$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeFavoriteSticker", parameters);
    return result as Ok;
  }

  /**
   * Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
   *
   * @param {getStickerEmojis$DirectInput} parameters {@link getStickerEmojis$Input}
   * @return {Promise<Emojis>} Promise<{@link Emojis}>
   */
  async getStickerEmojis(parameters: getStickerEmojis$DirectInput): Promise<Emojis> {
    const result = await this.client.invoke("getStickerEmojis", parameters);
    return result as Emojis;
  }

  /**
   * Searches for emojis by keywords. Supported only if the file database is enabled
   *
   * @param {searchEmojis$DirectInput} parameters {@link searchEmojis$Input}
   * @return {Promise<Emojis>} Promise<{@link Emojis}>
   */
  async searchEmojis(parameters: searchEmojis$DirectInput): Promise<Emojis> {
    const result = await this.client.invoke("searchEmojis", parameters);
    return result as Emojis;
  }

  /**
   * Returns available emojis categories
   *
   * @param {getEmojiCategories$DirectInput} parameters {@link getEmojiCategories$Input}
   * @return {Promise<EmojiCategories>} Promise<{@link EmojiCategories}>
   */
  async getEmojiCategories(
    parameters: getEmojiCategories$DirectInput
  ): Promise<EmojiCategories> {
    const result = await this.client.invoke("getEmojiCategories", parameters);
    return result as EmojiCategories;
  }

  /**
   * Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
   *
   * @param {getAnimatedEmoji$DirectInput} parameters {@link getAnimatedEmoji$Input}
   * @return {Promise<AnimatedEmoji>} Promise<{@link AnimatedEmoji}>
   */
  async getAnimatedEmoji(
    parameters: getAnimatedEmoji$DirectInput
  ): Promise<AnimatedEmoji> {
    const result = await this.client.invoke("getAnimatedEmoji", parameters);
    return result as AnimatedEmoji;
  }

  /**
   * Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
   *
   * @param {getEmojiSuggestionsUrl$DirectInput} parameters {@link getEmojiSuggestionsUrl$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getEmojiSuggestionsUrl(
    parameters: getEmojiSuggestionsUrl$DirectInput
  ): Promise<HttpUrl> {
    const result = await this.client.invoke("getEmojiSuggestionsUrl", parameters);
    return result as HttpUrl;
  }

  /**
   * Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned
   *
   * @param {getCustomEmojiStickers$DirectInput} parameters {@link getCustomEmojiStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getCustomEmojiStickers(
    parameters: getCustomEmojiStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("getCustomEmojiStickers", parameters);
    return result as Stickers;
  }

  /**
   * Returns default list of custom emoji stickers for placing on a chat photo
   *
   * @param {getDefaultChatPhotoCustomEmojiStickers$DirectInput} parameters {@link getDefaultChatPhotoCustomEmojiStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getDefaultChatPhotoCustomEmojiStickers(
    parameters: getDefaultChatPhotoCustomEmojiStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke(
      "getDefaultChatPhotoCustomEmojiStickers",
      parameters
    );
    return result as Stickers;
  }

  /**
   * Returns default list of custom emoji stickers for placing on a profile photo
   *
   * @param {getDefaultProfilePhotoCustomEmojiStickers$DirectInput} parameters {@link getDefaultProfilePhotoCustomEmojiStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getDefaultProfilePhotoCustomEmojiStickers(
    parameters: getDefaultProfilePhotoCustomEmojiStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke(
      "getDefaultProfilePhotoCustomEmojiStickers",
      parameters
    );
    return result as Stickers;
  }

  /**
   * Returns default list of custom emoji stickers for reply background
   *
   * @param {getDefaultBackgroundCustomEmojiStickers$DirectInput} parameters {@link getDefaultBackgroundCustomEmojiStickers$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getDefaultBackgroundCustomEmojiStickers(
    parameters: getDefaultBackgroundCustomEmojiStickers$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke(
      "getDefaultBackgroundCustomEmojiStickers",
      parameters
    );
    return result as Stickers;
  }

  /**
   * Returns saved animations
   *
   * @param {getSavedAnimations$DirectInput} parameters {@link getSavedAnimations$Input}
   * @return {Promise<Animations>} Promise<{@link Animations}>
   */
  async getSavedAnimations(
    parameters: getSavedAnimations$DirectInput
  ): Promise<Animations> {
    const result = await this.client.invoke("getSavedAnimations", parameters);
    return result as Animations;
  }

  /**
   * Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
   *
   * @param {addSavedAnimation$DirectInput} parameters {@link addSavedAnimation$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addSavedAnimation(parameters: addSavedAnimation$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addSavedAnimation", parameters);
    return result as Ok;
  }

  /**
   * Removes an animation from the list of saved animations
   *
   * @param {removeSavedAnimation$DirectInput} parameters {@link removeSavedAnimation$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeSavedAnimation(
    parameters: removeSavedAnimation$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeSavedAnimation", parameters);
    return result as Ok;
  }

  /**
   * Returns up to 20 recently used inline bots in the order of their last usage
   *
   * @param {getRecentInlineBots$DirectInput} parameters {@link getRecentInlineBots$Input}
   * @return {Promise<Users>} Promise<{@link Users}>
   */
  async getRecentInlineBots(
    parameters: getRecentInlineBots$DirectInput
  ): Promise<Users> {
    const result = await this.client.invoke("getRecentInlineBots", parameters);
    return result as Users;
  }

  /**
   * Searches for recently used hashtags by their prefix
   *
   * @param {searchHashtags$DirectInput} parameters {@link searchHashtags$Input}
   * @return {Promise<Hashtags>} Promise<{@link Hashtags}>
   */
  async searchHashtags(parameters: searchHashtags$DirectInput): Promise<Hashtags> {
    const result = await this.client.invoke("searchHashtags", parameters);
    return result as Hashtags;
  }

  /**
   * Removes a hashtag from the list of recently used hashtags
   *
   * @param {removeRecentHashtag$DirectInput} parameters {@link removeRecentHashtag$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeRecentHashtag(
    parameters: removeRecentHashtag$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeRecentHashtag", parameters);
    return result as Ok;
  }

  /**
   * Returns a link preview by the text of a message. Do not call this function too often. Returns a 404 error if the text has no link preview
   *
   * @param {getWebPagePreview$DirectInput} parameters {@link getWebPagePreview$Input}
   * @return {Promise<WebPage>} Promise<{@link WebPage}>
   */
  async getWebPagePreview(
    parameters: getWebPagePreview$DirectInput
  ): Promise<WebPage> {
    const result = await this.client.invoke("getWebPagePreview", parameters);
    return result as WebPage;
  }

  /**
   * Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
   *
   * @param {getWebPageInstantView$DirectInput} parameters {@link getWebPageInstantView$Input}
   * @return {Promise<WebPageInstantView>} Promise<{@link WebPageInstantView}>
   */
  async getWebPageInstantView(
    parameters: getWebPageInstantView$DirectInput
  ): Promise<WebPageInstantView> {
    const result = await this.client.invoke("getWebPageInstantView", parameters);
    return result as WebPageInstantView;
  }

  /**
   * Changes a profile photo for the current user
   *
   * @param {setProfilePhoto$DirectInput} parameters {@link setProfilePhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setProfilePhoto(parameters: setProfilePhoto$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setProfilePhoto", parameters);
    return result as Ok;
  }

  /**
   * Deletes a profile photo
   *
   * @param {deleteProfilePhoto$DirectInput} parameters {@link deleteProfilePhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteProfilePhoto(parameters: deleteProfilePhoto$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteProfilePhoto", parameters);
    return result as Ok;
  }

  /**
   * Changes accent color and background custom emoji for the current user; for Telegram Premium users only
   *
   * @param {setAccentColor$DirectInput} parameters {@link setAccentColor$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAccentColor(parameters: setAccentColor$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setAccentColor", parameters);
    return result as Ok;
  }

  /**
   * Changes accent color and background custom emoji for profile of the current user; for Telegram Premium users only
   *
   * @param {setProfileAccentColor$DirectInput} parameters {@link setProfileAccentColor$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setProfileAccentColor(
    parameters: setProfileAccentColor$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setProfileAccentColor", parameters);
    return result as Ok;
  }

  /**
   * Changes the first and last name of the current user
   *
   * @param {setName$DirectInput} parameters {@link setName$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setName(parameters: setName$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setName", parameters);
    return result as Ok;
  }

  /**
   * Changes the bio of the current user
   *
   * @param {setBio$DirectInput} parameters {@link setBio$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setBio(parameters: setBio$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setBio", parameters);
    return result as Ok;
  }

  /**
   * Changes the editable username of the current user
   *
   * @param {setUsername$DirectInput} parameters {@link setUsername$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setUsername(parameters: setUsername$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setUsername", parameters);
    return result as Ok;
  }

  /**
   * Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
   *
   * @param {toggleUsernameIsActive$DirectInput} parameters {@link toggleUsernameIsActive$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleUsernameIsActive(
    parameters: toggleUsernameIsActive$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleUsernameIsActive", parameters);
    return result as Ok;
  }

  /**
   * Changes order of active usernames of the current user
   *
   * @param {reorderActiveUsernames$DirectInput} parameters {@link reorderActiveUsernames$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reorderActiveUsernames(
    parameters: reorderActiveUsernames$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("reorderActiveUsernames", parameters);
    return result as Ok;
  }

  /**
   * Changes the emoji status of the current user; for Telegram Premium users only
   *
   * @param {setEmojiStatus$DirectInput} parameters {@link setEmojiStatus$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setEmojiStatus(parameters: setEmojiStatus$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setEmojiStatus", parameters);
    return result as Ok;
  }

  /**
   * Changes the location of the current user. Needs to be called if getOption("is_location_visible") is true and location changes for more than 1 kilometer
   *
   * @param {setLocation$DirectInput} parameters {@link setLocation$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setLocation(parameters: setLocation$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setLocation", parameters);
    return result as Ok;
  }

  /**
   * Changes the phone number of the user and sends an authentication code to the user's new phone number; for official Android and iOS applications only. On success, returns information about the sent code
   *
   * @param {changePhoneNumber$DirectInput} parameters {@link changePhoneNumber$Input}
   * @return {Promise<AuthenticationCodeInfo>} Promise<{@link AuthenticationCodeInfo}>
   */
  async changePhoneNumber(
    parameters: changePhoneNumber$DirectInput
  ): Promise<AuthenticationCodeInfo> {
    const result = await this.client.invoke("changePhoneNumber", parameters);
    return result as AuthenticationCodeInfo;
  }

  /**
   * Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
   *
   * @param {resendChangePhoneNumberCode$DirectInput} parameters {@link resendChangePhoneNumberCode$Input}
   * @return {Promise<AuthenticationCodeInfo>} Promise<{@link AuthenticationCodeInfo}>
   */
  async resendChangePhoneNumberCode(
    parameters: resendChangePhoneNumberCode$DirectInput
  ): Promise<AuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "resendChangePhoneNumberCode",
      parameters
    );
    return result as AuthenticationCodeInfo;
  }

  /**
   * Checks the authentication code sent to confirm a new phone number of the user
   *
   * @param {checkChangePhoneNumberCode$DirectInput} parameters {@link checkChangePhoneNumberCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkChangePhoneNumberCode(
    parameters: checkChangePhoneNumberCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkChangePhoneNumberCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns an HTTPS link, which can be used to get information about the current user
   *
   * @param {getUserLink$DirectInput} parameters {@link getUserLink$Input}
   * @return {Promise<UserLink>} Promise<{@link UserLink}>
   */
  async getUserLink(parameters: getUserLink$DirectInput): Promise<UserLink> {
    const result = await this.client.invoke("getUserLink", parameters);
    return result as UserLink;
  }

  /**
   * Searches a user by a token from the user's link
   *
   * @param {searchUserByToken$DirectInput} parameters {@link searchUserByToken$Input}
   * @return {Promise<User>} Promise<{@link User}>
   */
  async searchUserByToken(parameters: searchUserByToken$DirectInput): Promise<User> {
    const result = await this.client.invoke("searchUserByToken", parameters);
    return result as User;
  }

  /**
   * Sets the list of commands supported by the bot for the given user scope and language; for bots only
   *
   * @param {setCommands$DirectInput} parameters {@link setCommands$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setCommands(parameters: setCommands$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setCommands", parameters);
    return result as Ok;
  }

  /**
   * Deletes commands supported by the bot for the given user scope and language; for bots only
   *
   * @param {deleteCommands$DirectInput} parameters {@link deleteCommands$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteCommands(parameters: deleteCommands$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteCommands", parameters);
    return result as Ok;
  }

  /**
   * Returns list of commands supported by the bot for the given user scope and language; for bots only
   *
   * @param {getCommands$DirectInput} parameters {@link getCommands$Input}
   * @return {Promise<BotCommands>} Promise<{@link BotCommands}>
   */
  async getCommands(parameters: getCommands$DirectInput): Promise<BotCommands> {
    const result = await this.client.invoke("getCommands", parameters);
    return result as BotCommands;
  }

  /**
   * Sets menu button for the given user or for all users; for bots only
   *
   * @param {setMenuButton$DirectInput} parameters {@link setMenuButton$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setMenuButton(parameters: setMenuButton$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setMenuButton", parameters);
    return result as Ok;
  }

  /**
   * Returns menu button set by the bot for the given user; for bots only
   *
   * @param {getMenuButton$DirectInput} parameters {@link getMenuButton$Input}
   * @return {Promise<BotMenuButton>} Promise<{@link BotMenuButton}>
   */
  async getMenuButton(
    parameters: getMenuButton$DirectInput
  ): Promise<BotMenuButton> {
    const result = await this.client.invoke("getMenuButton", parameters);
    return result as BotMenuButton;
  }

  /**
   * Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only
   *
   * @param {setDefaultGroupAdministratorRights$DirectInput} parameters {@link setDefaultGroupAdministratorRights$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setDefaultGroupAdministratorRights(
    parameters: setDefaultGroupAdministratorRights$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setDefaultGroupAdministratorRights",
      parameters
    );
    return result as Ok;
  }

  /**
   * Sets default administrator rights for adding the bot to channel chats; for bots only
   *
   * @param {setDefaultChannelAdministratorRights$DirectInput} parameters {@link setDefaultChannelAdministratorRights$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setDefaultChannelAdministratorRights(
    parameters: setDefaultChannelAdministratorRights$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setDefaultChannelAdministratorRights",
      parameters
    );
    return result as Ok;
  }

  /**
   * Checks whether the specified bot can send messages to the user. Returns a 404 error if can't and the access can be granted by call to allowBotToSendMessages
   *
   * @param {canBotSendMessages$DirectInput} parameters {@link canBotSendMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async canBotSendMessages(parameters: canBotSendMessages$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("canBotSendMessages", parameters);
    return result as Ok;
  }

  /**
   * Allows the specified bot to send messages to the user
   *
   * @param {allowBotToSendMessages$DirectInput} parameters {@link allowBotToSendMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async allowBotToSendMessages(
    parameters: allowBotToSendMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("allowBotToSendMessages", parameters);
    return result as Ok;
  }

  /**
   * Sends a custom request from a Web App
   *
   * @param {sendWebAppCustomRequest$DirectInput} parameters {@link sendWebAppCustomRequest$Input}
   * @return {Promise<CustomRequestResult>} Promise<{@link CustomRequestResult}>
   */
  async sendWebAppCustomRequest(
    parameters: sendWebAppCustomRequest$DirectInput
  ): Promise<CustomRequestResult> {
    const result = await this.client.invoke("sendWebAppCustomRequest", parameters);
    return result as CustomRequestResult;
  }

  /**
   * Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {setBotName$DirectInput} parameters {@link setBotName$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setBotName(parameters: setBotName$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setBotName", parameters);
    return result as Ok;
  }

  /**
   * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {getBotName$DirectInput} parameters {@link getBotName$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getBotName(parameters: getBotName$DirectInput): Promise<Text> {
    const result = await this.client.invoke("getBotName", parameters);
    return result as Text;
  }

  /**
   * Changes a profile photo for a bot
   *
   * @param {setBotProfilePhoto$DirectInput} parameters {@link setBotProfilePhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setBotProfilePhoto(parameters: setBotProfilePhoto$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setBotProfilePhoto", parameters);
    return result as Ok;
  }

  /**
   * Changes active state for a username of a bot. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {toggleBotUsernameIsActive$DirectInput} parameters {@link toggleBotUsernameIsActive$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleBotUsernameIsActive(
    parameters: toggleBotUsernameIsActive$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleBotUsernameIsActive", parameters);
    return result as Ok;
  }

  /**
   * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {reorderBotActiveUsernames$DirectInput} parameters {@link reorderBotActiveUsernames$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reorderBotActiveUsernames(
    parameters: reorderBotActiveUsernames$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("reorderBotActiveUsernames", parameters);
    return result as Ok;
  }

  /**
   * Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {setBotInfoDescription$DirectInput} parameters {@link setBotInfoDescription$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setBotInfoDescription(
    parameters: setBotInfoDescription$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setBotInfoDescription", parameters);
    return result as Ok;
  }

  /**
   * Returns the text shown in the chat with a bot if the chat is empty in the given language. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {getBotInfoDescription$DirectInput} parameters {@link getBotInfoDescription$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getBotInfoDescription(
    parameters: getBotInfoDescription$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke("getBotInfoDescription", parameters);
    return result as Text;
  }

  /**
   * Sets the text shown on a bot's profile page and sent together with the link when users share the bot. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {setBotInfoShortDescription$DirectInput} parameters {@link setBotInfoShortDescription$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setBotInfoShortDescription(
    parameters: setBotInfoShortDescription$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setBotInfoShortDescription",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns the text shown on a bot's profile page and sent together with the link when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited == true
   *
   * @param {getBotInfoShortDescription$DirectInput} parameters {@link getBotInfoShortDescription$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getBotInfoShortDescription(
    parameters: getBotInfoShortDescription$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke(
      "getBotInfoShortDescription",
      parameters
    );
    return result as Text;
  }

  /**
   * Returns all active sessions of the current user
   *
   * @param {getActiveSessions$DirectInput} parameters {@link getActiveSessions$Input}
   * @return {Promise<Sessions>} Promise<{@link Sessions}>
   */
  async getActiveSessions(
    parameters: getActiveSessions$DirectInput
  ): Promise<Sessions> {
    const result = await this.client.invoke("getActiveSessions", parameters);
    return result as Sessions;
  }

  /**
   * Terminates a session of the current user
   *
   * @param {terminateSession$DirectInput} parameters {@link terminateSession$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async terminateSession(parameters: terminateSession$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("terminateSession", parameters);
    return result as Ok;
  }

  /**
   * Terminates all other sessions of the current user
   *
   * @param {terminateAllOtherSessions$DirectInput} parameters {@link terminateAllOtherSessions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async terminateAllOtherSessions(
    parameters: terminateAllOtherSessions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("terminateAllOtherSessions", parameters);
    return result as Ok;
  }

  /**
   * Confirms an unconfirmed session of the current user from another device
   *
   * @param {confirmSession$DirectInput} parameters {@link confirmSession$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async confirmSession(parameters: confirmSession$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("confirmSession", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether a session can accept incoming calls
   *
   * @param {toggleSessionCanAcceptCalls$DirectInput} parameters {@link toggleSessionCanAcceptCalls$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSessionCanAcceptCalls(
    parameters: toggleSessionCanAcceptCalls$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSessionCanAcceptCalls",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether a session can accept incoming secret chats
   *
   * @param {toggleSessionCanAcceptSecretChats$DirectInput} parameters {@link toggleSessionCanAcceptSecretChats$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSessionCanAcceptSecretChats(
    parameters: toggleSessionCanAcceptSecretChats$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSessionCanAcceptSecretChats",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the period of inactivity after which sessions will automatically be terminated
   *
   * @param {setInactiveSessionTtl$DirectInput} parameters {@link setInactiveSessionTtl$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setInactiveSessionTtl(
    parameters: setInactiveSessionTtl$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setInactiveSessionTtl", parameters);
    return result as Ok;
  }

  /**
   * Returns all website where the current user used Telegram to log in
   *
   * @param {getConnectedWebsites$DirectInput} parameters {@link getConnectedWebsites$Input}
   * @return {Promise<ConnectedWebsites>} Promise<{@link ConnectedWebsites}>
   */
  async getConnectedWebsites(
    parameters: getConnectedWebsites$DirectInput
  ): Promise<ConnectedWebsites> {
    const result = await this.client.invoke("getConnectedWebsites", parameters);
    return result as ConnectedWebsites;
  }

  /**
   * Disconnects website from the current user's Telegram account
   *
   * @param {disconnectWebsite$DirectInput} parameters {@link disconnectWebsite$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async disconnectWebsite(parameters: disconnectWebsite$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("disconnectWebsite", parameters);
    return result as Ok;
  }

  /**
   * Disconnects all websites from the current user's Telegram account
   *
   * @param {disconnectAllWebsites$DirectInput} parameters {@link disconnectAllWebsites$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async disconnectAllWebsites(
    parameters: disconnectAllWebsites$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("disconnectAllWebsites", parameters);
    return result as Ok;
  }

  /**
   * Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel
   *
   * @param {setSupergroupUsername$DirectInput} parameters {@link setSupergroupUsername$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setSupergroupUsername(
    parameters: setSupergroupUsername$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setSupergroupUsername", parameters);
    return result as Ok;
  }

  /**
   * Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled.
   *
   * - May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
   *
   * @param {toggleSupergroupUsernameIsActive$DirectInput} parameters {@link toggleSupergroupUsernameIsActive$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupUsernameIsActive(
    parameters: toggleSupergroupUsernameIsActive$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupUsernameIsActive",
      parameters
    );
    return result as Ok;
  }

  /**
   * Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
   *
   * @param {disableAllSupergroupUsernames$DirectInput} parameters {@link disableAllSupergroupUsernames$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async disableAllSupergroupUsernames(
    parameters: disableAllSupergroupUsernames$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "disableAllSupergroupUsernames",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
   *
   * @param {reorderSupergroupActiveUsernames$DirectInput} parameters {@link reorderSupergroupActiveUsernames$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reorderSupergroupActiveUsernames(
    parameters: reorderSupergroupActiveUsernames$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "reorderSupergroupActiveUsernames",
      parameters
    );
    return result as Ok;
  }

  /**
   * Changes the sticker set of a supergroup; requires can_change_info administrator right
   *
   * @param {setSupergroupStickerSet$DirectInput} parameters {@link setSupergroupStickerSet$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setSupergroupStickerSet(
    parameters: setSupergroupStickerSet$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setSupergroupStickerSet", parameters);
    return result as Ok;
  }

  /**
   * Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right
   *
   * @param {toggleSupergroupSignMessages$DirectInput} parameters {@link toggleSupergroupSignMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupSignMessages(
    parameters: toggleSupergroupSignMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupSignMessages",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right
   *
   * @param {toggleSupergroupJoinToSendMessages$DirectInput} parameters {@link toggleSupergroupJoinToSendMessages$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupJoinToSendMessages(
    parameters: toggleSupergroupJoinToSendMessages$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupJoinToSendMessages",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right
   *
   * @param {toggleSupergroupJoinByRequest$DirectInput} parameters {@link toggleSupergroupJoinByRequest$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupJoinByRequest(
    parameters: toggleSupergroupJoinByRequest$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupJoinByRequest",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
   *
   * @param {toggleSupergroupIsAllHistoryAvailable$DirectInput} parameters {@link toggleSupergroupIsAllHistoryAvailable$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupIsAllHistoryAvailable(
    parameters: toggleSupergroupIsAllHistoryAvailable$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupIsAllHistoryAvailable",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members == true
   *
   * @param {toggleSupergroupHasHiddenMembers$DirectInput} parameters {@link toggleSupergroupHasHiddenMembers$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupHasHiddenMembers(
    parameters: toggleSupergroupHasHiddenMembers$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupHasHiddenMembers",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
   *
   * @param {toggleSupergroupHasAggressiveAntiSpamEnabled$DirectInput} parameters {@link toggleSupergroupHasAggressiveAntiSpamEnabled$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupHasAggressiveAntiSpamEnabled(
    parameters: toggleSupergroupHasAggressiveAntiSpamEnabled$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupHasAggressiveAntiSpamEnabled",
      parameters
    );
    return result as Ok;
  }

  /**
   * Toggles whether the supergroup is a forum; requires owner privileges in the supergroup. Discussion supergroups can't be converted to forums
   *
   * @param {toggleSupergroupIsForum$DirectInput} parameters {@link toggleSupergroupIsForum$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupIsForum(
    parameters: toggleSupergroupIsForum$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("toggleSupergroupIsForum", parameters);
    return result as Ok;
  }

  /**
   * Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
   *
   * @param {toggleSupergroupIsBroadcastGroup$DirectInput} parameters {@link toggleSupergroupIsBroadcastGroup$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async toggleSupergroupIsBroadcastGroup(
    parameters: toggleSupergroupIsBroadcastGroup$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "toggleSupergroupIsBroadcastGroup",
      parameters
    );
    return result as Ok;
  }

  /**
   * Reports messages in a supergroup as spam; requires administrator rights in the supergroup
   *
   * @param {reportSupergroupSpam$DirectInput} parameters {@link reportSupergroupSpam$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reportSupergroupSpam(
    parameters: reportSupergroupSpam$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("reportSupergroupSpam", parameters);
    return result as Ok;
  }

  /**
   * Reports a false deletion of a message by aggressive anti-spam checks; requires administrator rights in the supergroup. Can be called only for messages from chatEventMessageDeleted with can_report_anti_spam_false_positive == true
   *
   * @param {reportSupergroupAntiSpamFalsePositive$DirectInput} parameters {@link reportSupergroupAntiSpamFalsePositive$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reportSupergroupAntiSpamFalsePositive(
    parameters: reportSupergroupAntiSpamFalsePositive$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "reportSupergroupAntiSpamFalsePositive",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
   *
   * @param {getSupergroupMembers$DirectInput} parameters {@link getSupergroupMembers$Input}
   * @return {Promise<ChatMembers>} Promise<{@link ChatMembers}>
   */
  async getSupergroupMembers(
    parameters: getSupergroupMembers$DirectInput
  ): Promise<ChatMembers> {
    const result = await this.client.invoke("getSupergroupMembers", parameters);
    return result as ChatMembers;
  }

  /**
   * Closes a secret chat, effectively transferring its state to secretChatStateClosed
   *
   * @param {closeSecretChat$DirectInput} parameters {@link closeSecretChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async closeSecretChat(parameters: closeSecretChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("closeSecretChat", parameters);
    return result as Ok;
  }

  /**
   * Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id)
   *
   * @param {getChatEventLog$DirectInput} parameters {@link getChatEventLog$Input}
   * @return {Promise<ChatEvents>} Promise<{@link ChatEvents}>
   */
  async getChatEventLog(
    parameters: getChatEventLog$DirectInput
  ): Promise<ChatEvents> {
    const result = await this.client.invoke("getChatEventLog", parameters);
    return result as ChatEvents;
  }

  /**
   * Returns an invoice payment form. This method must be called when the user presses inline button of the type inlineKeyboardButtonTypeBuy
   *
   * @param {getPaymentForm$DirectInput} parameters {@link getPaymentForm$Input}
   * @return {Promise<PaymentForm>} Promise<{@link PaymentForm}>
   */
  async getPaymentForm(
    parameters: getPaymentForm$DirectInput
  ): Promise<PaymentForm> {
    const result = await this.client.invoke("getPaymentForm", parameters);
    return result as PaymentForm;
  }

  /**
   * Validates the order information provided by a user and returns the available shipping options for a flexible invoice
   *
   * @param {validateOrderInfo$DirectInput} parameters {@link validateOrderInfo$Input}
   * @return {Promise<ValidatedOrderInfo>} Promise<{@link ValidatedOrderInfo}>
   */
  async validateOrderInfo(
    parameters: validateOrderInfo$DirectInput
  ): Promise<ValidatedOrderInfo> {
    const result = await this.client.invoke("validateOrderInfo", parameters);
    return result as ValidatedOrderInfo;
  }

  /**
   * Sends a filled-out payment form to the bot for final verification
   *
   * @param {sendPaymentForm$DirectInput} parameters {@link sendPaymentForm$Input}
   * @return {Promise<PaymentResult>} Promise<{@link PaymentResult}>
   */
  async sendPaymentForm(
    parameters: sendPaymentForm$DirectInput
  ): Promise<PaymentResult> {
    const result = await this.client.invoke("sendPaymentForm", parameters);
    return result as PaymentResult;
  }

  /**
   * Returns information about a successful payment
   *
   * @param {getPaymentReceipt$DirectInput} parameters {@link getPaymentReceipt$Input}
   * @return {Promise<PaymentReceipt>} Promise<{@link PaymentReceipt}>
   */
  async getPaymentReceipt(
    parameters: getPaymentReceipt$DirectInput
  ): Promise<PaymentReceipt> {
    const result = await this.client.invoke("getPaymentReceipt", parameters);
    return result as PaymentReceipt;
  }

  /**
   * Returns saved order information. Returns a 404 error if there is no saved order information
   *
   * @param {getSavedOrderInfo$DirectInput} parameters {@link getSavedOrderInfo$Input}
   * @return {Promise<OrderInfo>} Promise<{@link OrderInfo}>
   */
  async getSavedOrderInfo(
    parameters: getSavedOrderInfo$DirectInput
  ): Promise<OrderInfo> {
    const result = await this.client.invoke("getSavedOrderInfo", parameters);
    return result as OrderInfo;
  }

  /**
   * Deletes saved order information
   *
   * @param {deleteSavedOrderInfo$DirectInput} parameters {@link deleteSavedOrderInfo$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteSavedOrderInfo(
    parameters: deleteSavedOrderInfo$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteSavedOrderInfo", parameters);
    return result as Ok;
  }

  /**
   * Deletes saved credentials for all payment provider bots
   *
   * @param {deleteSavedCredentials$DirectInput} parameters {@link deleteSavedCredentials$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteSavedCredentials(
    parameters: deleteSavedCredentials$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteSavedCredentials", parameters);
    return result as Ok;
  }

  /**
   * Creates a link for the given invoice; for bots only
   *
   * @param {createInvoiceLink$DirectInput} parameters {@link createInvoiceLink$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async createInvoiceLink(
    parameters: createInvoiceLink$DirectInput
  ): Promise<HttpUrl> {
    const result = await this.client.invoke("createInvoiceLink", parameters);
    return result as HttpUrl;
  }

  /**
   * Returns a user that can be contacted to get support
   *
   * @param {getSupportUser$DirectInput} parameters {@link getSupportUser$Input}
   * @return {Promise<User>} Promise<{@link User}>
   */
  async getSupportUser(parameters: getSupportUser$DirectInput): Promise<User> {
    const result = await this.client.invoke("getSupportUser", parameters);
    return result as User;
  }

  /**
   * Constructs a persistent HTTP URL for a background
   *
   * @param {getBackgroundUrl$DirectInput} parameters {@link getBackgroundUrl$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getBackgroundUrl(
    parameters: getBackgroundUrl$DirectInput
  ): Promise<HttpUrl> {
    const result = await this.client.invoke("getBackgroundUrl", parameters);
    return result as HttpUrl;
  }

  /**
   * Searches for a background by its name
   *
   * @param {searchBackground$DirectInput} parameters {@link searchBackground$Input}
   * @return {Promise<Background>} Promise<{@link Background}>
   */
  async searchBackground(
    parameters: searchBackground$DirectInput
  ): Promise<Background> {
    const result = await this.client.invoke("searchBackground", parameters);
    return result as Background;
  }

  /**
   * Sets default background for chats; adds the background to the list of installed backgrounds
   *
   * @param {setDefaultBackground$DirectInput} parameters {@link setDefaultBackground$Input}
   * @return {Promise<Background>} Promise<{@link Background}>
   */
  async setDefaultBackground(
    parameters: setDefaultBackground$DirectInput
  ): Promise<Background> {
    const result = await this.client.invoke("setDefaultBackground", parameters);
    return result as Background;
  }

  /**
   * Deletes default background for chats
   *
   * @param {deleteDefaultBackground$DirectInput} parameters {@link deleteDefaultBackground$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteDefaultBackground(
    parameters: deleteDefaultBackground$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deleteDefaultBackground", parameters);
    return result as Ok;
  }

  /**
   * Returns backgrounds installed by the user
   *
   * @param {getInstalledBackgrounds$DirectInput} parameters {@link getInstalledBackgrounds$Input}
   * @return {Promise<Backgrounds>} Promise<{@link Backgrounds}>
   */
  async getInstalledBackgrounds(
    parameters: getInstalledBackgrounds$DirectInput
  ): Promise<Backgrounds> {
    const result = await this.client.invoke("getInstalledBackgrounds", parameters);
    return result as Backgrounds;
  }

  /**
   * Removes background from the list of installed backgrounds
   *
   * @param {removeInstalledBackground$DirectInput} parameters {@link removeInstalledBackground$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeInstalledBackground(
    parameters: removeInstalledBackground$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeInstalledBackground", parameters);
    return result as Ok;
  }

  /**
   * Resets list of installed backgrounds to its default value
   *
   * @param {resetInstalledBackgrounds$DirectInput} parameters {@link resetInstalledBackgrounds$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async resetInstalledBackgrounds(
    parameters: resetInstalledBackgrounds$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("resetInstalledBackgrounds", parameters);
    return result as Ok;
  }

  /**
   * Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
   *
   * @param {getLocalizationTargetInfo$DirectInput} parameters {@link getLocalizationTargetInfo$Input}
   * @return {Promise<LocalizationTargetInfo>} Promise<{@link LocalizationTargetInfo}>
   */
  async getLocalizationTargetInfo(
    parameters: getLocalizationTargetInfo$DirectInput
  ): Promise<LocalizationTargetInfo> {
    const result = await this.client.invoke("getLocalizationTargetInfo", parameters);
    return result as LocalizationTargetInfo;
  }

  /**
   * Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
   *
   * @param {getLanguagePackInfo$DirectInput} parameters {@link getLanguagePackInfo$Input}
   * @return {Promise<LanguagePackInfo>} Promise<{@link LanguagePackInfo}>
   */
  async getLanguagePackInfo(
    parameters: getLanguagePackInfo$DirectInput
  ): Promise<LanguagePackInfo> {
    const result = await this.client.invoke("getLanguagePackInfo", parameters);
    return result as LanguagePackInfo;
  }

  /**
   * Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
   *
   * @param {getLanguagePackStrings$DirectInput} parameters {@link getLanguagePackStrings$Input}
   * @return {Promise<LanguagePackStrings>} Promise<{@link LanguagePackStrings}>
   */
  async getLanguagePackStrings(
    parameters: getLanguagePackStrings$DirectInput
  ): Promise<LanguagePackStrings> {
    const result = await this.client.invoke("getLanguagePackStrings", parameters);
    return result as LanguagePackStrings;
  }

  /**
   * Fetches the latest versions of all strings from a language pack in the current localization target from the server.
   *
   * - This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
   *
   * @param {synchronizeLanguagePack$DirectInput} parameters {@link synchronizeLanguagePack$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async synchronizeLanguagePack(
    parameters: synchronizeLanguagePack$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("synchronizeLanguagePack", parameters);
    return result as Ok;
  }

  /**
   * Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
   *
   * @param {addCustomServerLanguagePack$DirectInput} parameters {@link addCustomServerLanguagePack$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addCustomServerLanguagePack(
    parameters: addCustomServerLanguagePack$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "addCustomServerLanguagePack",
      parameters
    );
    return result as Ok;
  }

  /**
   * Adds or changes a custom local language pack to the current localization target
   *
   * @param {setCustomLanguagePack$DirectInput} parameters {@link setCustomLanguagePack$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setCustomLanguagePack(
    parameters: setCustomLanguagePack$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setCustomLanguagePack", parameters);
    return result as Ok;
  }

  /**
   * Edits information about a custom local language pack in the current localization target. Can be called before authorization
   *
   * @param {editCustomLanguagePackInfo$DirectInput} parameters {@link editCustomLanguagePackInfo$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async editCustomLanguagePackInfo(
    parameters: editCustomLanguagePackInfo$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "editCustomLanguagePackInfo",
      parameters
    );
    return result as Ok;
  }

  /**
   * Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
   *
   * @param {setCustomLanguagePackString$DirectInput} parameters {@link setCustomLanguagePackString$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setCustomLanguagePackString(
    parameters: setCustomLanguagePackString$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setCustomLanguagePackString",
      parameters
    );
    return result as Ok;
  }

  /**
   * Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted.
   *
   * - Can be called before authorization
   *
   * @param {deleteLanguagePack$DirectInput} parameters {@link deleteLanguagePack$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteLanguagePack(parameters: deleteLanguagePack$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteLanguagePack", parameters);
    return result as Ok;
  }

  /**
   * Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
   *
   * @param {registerDevice$DirectInput} parameters {@link registerDevice$Input}
   * @return {Promise<PushReceiverId>} Promise<{@link PushReceiverId}>
   */
  async registerDevice(
    parameters: registerDevice$DirectInput
  ): Promise<PushReceiverId> {
    const result = await this.client.invoke("registerDevice", parameters);
    return result as PushReceiverId;
  }

  /**
   * Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
   *
   * @param {processPushNotification$DirectInput} parameters {@link processPushNotification$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async processPushNotification(
    parameters: processPushNotification$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("processPushNotification", parameters);
    return result as Ok;
  }

  /**
   * Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
   *
   * @param {getPushReceiverId$DirectInput} parameters {@link getPushReceiverId$Input}
   * @return {Promise<PushReceiverId>} Promise<{@link PushReceiverId}>
   */
  async getPushReceiverId(
    parameters: getPushReceiverId$DirectInput
  ): Promise<PushReceiverId> {
    const result = await this.client.invoke("getPushReceiverId", parameters);
    return result as PushReceiverId;
  }

  /**
   * Returns t.me URLs recently visited by a newly registered user
   *
   * @param {getRecentlyVisitedTMeUrls$DirectInput} parameters {@link getRecentlyVisitedTMeUrls$Input}
   * @return {Promise<TMeUrls>} Promise<{@link TMeUrls}>
   */
  async getRecentlyVisitedTMeUrls(
    parameters: getRecentlyVisitedTMeUrls$DirectInput
  ): Promise<TMeUrls> {
    const result = await this.client.invoke("getRecentlyVisitedTMeUrls", parameters);
    return result as TMeUrls;
  }

  /**
   * Changes user privacy settings
   *
   * @param {setUserPrivacySettingRules$DirectInput} parameters {@link setUserPrivacySettingRules$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setUserPrivacySettingRules(
    parameters: setUserPrivacySettingRules$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setUserPrivacySettingRules",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns the current privacy settings
   *
   * @param {getUserPrivacySettingRules$DirectInput} parameters {@link getUserPrivacySettingRules$Input}
   * @return {Promise<UserPrivacySettingRules>} Promise<{@link UserPrivacySettingRules}>
   */
  async getUserPrivacySettingRules(
    parameters: getUserPrivacySettingRules$DirectInput
  ): Promise<UserPrivacySettingRules> {
    const result = await this.client.invoke(
      "getUserPrivacySettingRules",
      parameters
    );
    return result as UserPrivacySettingRules;
  }

  /**
   * Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
   *
   * @param {getOption$DirectInput} parameters {@link getOption$Input}
   * @return {Promise<OptionValue>} Promise<{@link OptionValue}>
   */
  async getOption(parameters: getOption$DirectInput): Promise<OptionValue> {
    const result = await this.client.invoke("getOption", parameters);
    return result as OptionValue;
  }

  /**
   * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
   *
   * @param {setOption$DirectInput} parameters {@link setOption$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setOption(parameters: setOption$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setOption", parameters);
    return result as Ok;
  }

  /**
   * Changes the period of inactivity after which the account of the current user will automatically be deleted
   *
   * @param {setAccountTtl$DirectInput} parameters {@link setAccountTtl$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAccountTtl(parameters: setAccountTtl$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setAccountTtl", parameters);
    return result as Ok;
  }

  /**
   * Returns the period of inactivity after which the account of the current user will automatically be deleted
   *
   * @param {getAccountTtl$DirectInput} parameters {@link getAccountTtl$Input}
   * @return {Promise<AccountTtl>} Promise<{@link AccountTtl}>
   */
  async getAccountTtl(parameters: getAccountTtl$DirectInput): Promise<AccountTtl> {
    const result = await this.client.invoke("getAccountTtl", parameters);
    return result as AccountTtl;
  }

  /**
   * Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account.
   *
   * - Can be called before authorization when the current authorization state is authorizationStateWaitPassword
   *
   * @param {deleteAccount$DirectInput} parameters {@link deleteAccount$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteAccount(parameters: deleteAccount$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteAccount", parameters);
    return result as Ok;
  }

  /**
   * Changes the default message auto-delete time for new chats
   *
   * @param {setDefaultMessageAutoDeleteTime$DirectInput} parameters {@link setDefaultMessageAutoDeleteTime$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setDefaultMessageAutoDeleteTime(
    parameters: setDefaultMessageAutoDeleteTime$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setDefaultMessageAutoDeleteTime",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns default message auto-delete time setting for new chats
   *
   * @param {getDefaultMessageAutoDeleteTime$DirectInput} parameters {@link getDefaultMessageAutoDeleteTime$Input}
   * @return {Promise<MessageAutoDeleteTime>} Promise<{@link MessageAutoDeleteTime}>
   */
  async getDefaultMessageAutoDeleteTime(
    parameters: getDefaultMessageAutoDeleteTime$DirectInput
  ): Promise<MessageAutoDeleteTime> {
    const result = await this.client.invoke(
      "getDefaultMessageAutoDeleteTime",
      parameters
    );
    return result as MessageAutoDeleteTime;
  }

  /**
   * Removes a chat action bar without any other action
   *
   * @param {removeChatActionBar$DirectInput} parameters {@link removeChatActionBar$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeChatActionBar(
    parameters: removeChatActionBar$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeChatActionBar", parameters);
    return result as Ok;
  }

  /**
   * Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported
   *
   * @param {reportChat$DirectInput} parameters {@link reportChat$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reportChat(parameters: reportChat$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("reportChat", parameters);
    return result as Ok;
  }

  /**
   * Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported
   *
   * @param {reportChatPhoto$DirectInput} parameters {@link reportChatPhoto$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reportChatPhoto(parameters: reportChatPhoto$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("reportChatPhoto", parameters);
    return result as Ok;
  }

  /**
   * Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions
   *
   * @param {reportMessageReactions$DirectInput} parameters {@link reportMessageReactions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async reportMessageReactions(
    parameters: reportMessageReactions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("reportMessageReactions", parameters);
    return result as Ok;
  }

  /**
   * Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
   *
   * @param {getChatStatistics$DirectInput} parameters {@link getChatStatistics$Input}
   * @return {Promise<ChatStatistics>} Promise<{@link ChatStatistics}>
   */
  async getChatStatistics(
    parameters: getChatStatistics$DirectInput
  ): Promise<ChatStatistics> {
    const result = await this.client.invoke("getChatStatistics", parameters);
    return result as ChatStatistics;
  }

  /**
   * Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
   *
   * @param {getMessageStatistics$DirectInput} parameters {@link getMessageStatistics$Input}
   * @return {Promise<MessageStatistics>} Promise<{@link MessageStatistics}>
   */
  async getMessageStatistics(
    parameters: getMessageStatistics$DirectInput
  ): Promise<MessageStatistics> {
    const result = await this.client.invoke("getMessageStatistics", parameters);
    return result as MessageStatistics;
  }

  /**
   * Returns forwarded copies of a channel message to different public channels and public reposts as a story. Can be used only if message.can_get_statistics == true. For optimal performance, the number of returned messages and stories is chosen by TDLib
   *
   * @param {getMessagePublicForwards$DirectInput} parameters {@link getMessagePublicForwards$Input}
   * @return {Promise<PublicForwards>} Promise<{@link PublicForwards}>
   */
  async getMessagePublicForwards(
    parameters: getMessagePublicForwards$DirectInput
  ): Promise<PublicForwards> {
    const result = await this.client.invoke("getMessagePublicForwards", parameters);
    return result as PublicForwards;
  }

  /**
   * Returns detailed statistics about a story. Can be used only if story.can_get_statistics == true
   *
   * @param {getStoryStatistics$DirectInput} parameters {@link getStoryStatistics$Input}
   * @return {Promise<StoryStatistics>} Promise<{@link StoryStatistics}>
   */
  async getStoryStatistics(
    parameters: getStoryStatistics$DirectInput
  ): Promise<StoryStatistics> {
    const result = await this.client.invoke("getStoryStatistics", parameters);
    return result as StoryStatistics;
  }

  /**
   * Loads an asynchronous or a zoomed in statistical graph
   *
   * @param {getStatisticalGraph$DirectInput} parameters {@link getStatisticalGraph$Input}
   * @return {Promise<StatisticalGraph>} Promise<{@link StatisticalGraph}>
   */
  async getStatisticalGraph(
    parameters: getStatisticalGraph$DirectInput
  ): Promise<StatisticalGraph> {
    const result = await this.client.invoke("getStatisticalGraph", parameters);
    return result as StatisticalGraph;
  }

  /**
   * Returns storage usage statistics. Can be called before authorization
   *
   * @param {getStorageStatistics$DirectInput} parameters {@link getStorageStatistics$Input}
   * @return {Promise<StorageStatistics>} Promise<{@link StorageStatistics}>
   */
  async getStorageStatistics(
    parameters: getStorageStatistics$DirectInput
  ): Promise<StorageStatistics> {
    const result = await this.client.invoke("getStorageStatistics", parameters);
    return result as StorageStatistics;
  }

  /**
   * Quickly returns approximate storage usage statistics. Can be called before authorization
   *
   * @param {getStorageStatisticsFast$DirectInput} parameters {@link getStorageStatisticsFast$Input}
   * @return {Promise<StorageStatisticsFast>} Promise<{@link StorageStatisticsFast}>
   */
  async getStorageStatisticsFast(
    parameters: getStorageStatisticsFast$DirectInput
  ): Promise<StorageStatisticsFast> {
    const result = await this.client.invoke("getStorageStatisticsFast", parameters);
    return result as StorageStatisticsFast;
  }

  /**
   * Returns database statistics
   *
   * @param {getDatabaseStatistics$DirectInput} parameters {@link getDatabaseStatistics$Input}
   * @return {Promise<DatabaseStatistics>} Promise<{@link DatabaseStatistics}>
   */
  async getDatabaseStatistics(
    parameters: getDatabaseStatistics$DirectInput
  ): Promise<DatabaseStatistics> {
    const result = await this.client.invoke("getDatabaseStatistics", parameters);
    return result as DatabaseStatistics;
  }

  /**
   * Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
   *
   * @param {optimizeStorage$DirectInput} parameters {@link optimizeStorage$Input}
   * @return {Promise<StorageStatistics>} Promise<{@link StorageStatistics}>
   */
  async optimizeStorage(
    parameters: optimizeStorage$DirectInput
  ): Promise<StorageStatistics> {
    const result = await this.client.invoke("optimizeStorage", parameters);
    return result as StorageStatistics;
  }

  /**
   * Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks,
   *
   * - so it must be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
   *
   * @param {setNetworkType$DirectInput} parameters {@link setNetworkType$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setNetworkType(parameters: setNetworkType$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setNetworkType", parameters);
    return result as Ok;
  }

  /**
   * Returns network data usage statistics. Can be called before authorization
   *
   * @param {getNetworkStatistics$DirectInput} parameters {@link getNetworkStatistics$Input}
   * @return {Promise<NetworkStatistics>} Promise<{@link NetworkStatistics}>
   */
  async getNetworkStatistics(
    parameters: getNetworkStatistics$DirectInput
  ): Promise<NetworkStatistics> {
    const result = await this.client.invoke("getNetworkStatistics", parameters);
    return result as NetworkStatistics;
  }

  /**
   * Adds the specified data to data usage statistics. Can be called before authorization
   *
   * @param {addNetworkStatistics$DirectInput} parameters {@link addNetworkStatistics$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addNetworkStatistics(
    parameters: addNetworkStatistics$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("addNetworkStatistics", parameters);
    return result as Ok;
  }

  /**
   * Resets all network data usage statistics to zero. Can be called before authorization
   *
   * @param {resetNetworkStatistics$DirectInput} parameters {@link resetNetworkStatistics$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async resetNetworkStatistics(
    parameters: resetNetworkStatistics$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("resetNetworkStatistics", parameters);
    return result as Ok;
  }

  /**
   * Returns auto-download settings presets for the current user
   *
   * @param {getAutoDownloadSettingsPresets$DirectInput} parameters {@link getAutoDownloadSettingsPresets$Input}
   * @return {Promise<AutoDownloadSettingsPresets>} Promise<{@link AutoDownloadSettingsPresets}>
   */
  async getAutoDownloadSettingsPresets(
    parameters: getAutoDownloadSettingsPresets$DirectInput
  ): Promise<AutoDownloadSettingsPresets> {
    const result = await this.client.invoke(
      "getAutoDownloadSettingsPresets",
      parameters
    );
    return result as AutoDownloadSettingsPresets;
  }

  /**
   * Sets auto-download settings
   *
   * @param {setAutoDownloadSettings$DirectInput} parameters {@link setAutoDownloadSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAutoDownloadSettings(
    parameters: setAutoDownloadSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setAutoDownloadSettings", parameters);
    return result as Ok;
  }

  /**
   * Returns autosave settings for the current user
   *
   * @param {getAutosaveSettings$DirectInput} parameters {@link getAutosaveSettings$Input}
   * @return {Promise<AutosaveSettings>} Promise<{@link AutosaveSettings}>
   */
  async getAutosaveSettings(
    parameters: getAutosaveSettings$DirectInput
  ): Promise<AutosaveSettings> {
    const result = await this.client.invoke("getAutosaveSettings", parameters);
    return result as AutosaveSettings;
  }

  /**
   * Sets autosave settings for the given scope. The method is guaranteed to work only after at least one call to getAutosaveSettings
   *
   * @param {setAutosaveSettings$DirectInput} parameters {@link setAutosaveSettings$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAutosaveSettings(
    parameters: setAutosaveSettings$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setAutosaveSettings", parameters);
    return result as Ok;
  }

  /**
   * Clears the list of all autosave settings exceptions. The method is guaranteed to work only after at least one call to getAutosaveSettings
   *
   * @param {clearAutosaveSettingsExceptions$DirectInput} parameters {@link clearAutosaveSettingsExceptions$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clearAutosaveSettingsExceptions(
    parameters: clearAutosaveSettingsExceptions$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "clearAutosaveSettingsExceptions",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns information about a bank card
   *
   * @param {getBankCardInfo$DirectInput} parameters {@link getBankCardInfo$Input}
   * @return {Promise<BankCardInfo>} Promise<{@link BankCardInfo}>
   */
  async getBankCardInfo(
    parameters: getBankCardInfo$DirectInput
  ): Promise<BankCardInfo> {
    const result = await this.client.invoke("getBankCardInfo", parameters);
    return result as BankCardInfo;
  }

  /**
   * Returns one of the available Telegram Passport elements
   *
   * @param {getPassportElement$DirectInput} parameters {@link getPassportElement$Input}
   * @return {Promise<PassportElement>} Promise<{@link PassportElement}>
   */
  async getPassportElement(
    parameters: getPassportElement$DirectInput
  ): Promise<PassportElement> {
    const result = await this.client.invoke("getPassportElement", parameters);
    return result as PassportElement;
  }

  /**
   * Returns all available Telegram Passport elements
   *
   * @param {getAllPassportElements$DirectInput} parameters {@link getAllPassportElements$Input}
   * @return {Promise<PassportElements>} Promise<{@link PassportElements}>
   */
  async getAllPassportElements(
    parameters: getAllPassportElements$DirectInput
  ): Promise<PassportElements> {
    const result = await this.client.invoke("getAllPassportElements", parameters);
    return result as PassportElements;
  }

  /**
   * Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
   *
   * @param {setPassportElement$DirectInput} parameters {@link setPassportElement$Input}
   * @return {Promise<PassportElement>} Promise<{@link PassportElement}>
   */
  async setPassportElement(
    parameters: setPassportElement$DirectInput
  ): Promise<PassportElement> {
    const result = await this.client.invoke("setPassportElement", parameters);
    return result as PassportElement;
  }

  /**
   * Deletes a Telegram Passport element
   *
   * @param {deletePassportElement$DirectInput} parameters {@link deletePassportElement$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deletePassportElement(
    parameters: deletePassportElement$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("deletePassportElement", parameters);
    return result as Ok;
  }

  /**
   * Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
   *
   * @param {setPassportElementErrors$DirectInput} parameters {@link setPassportElementErrors$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setPassportElementErrors(
    parameters: setPassportElementErrors$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setPassportElementErrors", parameters);
    return result as Ok;
  }

  /**
   * Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
   *
   * @param {getPreferredCountryLanguage$DirectInput} parameters {@link getPreferredCountryLanguage$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getPreferredCountryLanguage(
    parameters: getPreferredCountryLanguage$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke(
      "getPreferredCountryLanguage",
      parameters
    );
    return result as Text;
  }

  /**
   * Sends a code to verify a phone number to be added to a user's Telegram Passport
   *
   * @param {sendPhoneNumberVerificationCode$DirectInput} parameters {@link sendPhoneNumberVerificationCode$Input}
   * @return {Promise<AuthenticationCodeInfo>} Promise<{@link AuthenticationCodeInfo}>
   */
  async sendPhoneNumberVerificationCode(
    parameters: sendPhoneNumberVerificationCode$DirectInput
  ): Promise<AuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "sendPhoneNumberVerificationCode",
      parameters
    );
    return result as AuthenticationCodeInfo;
  }

  /**
   * Resends the code to verify a phone number to be added to a user's Telegram Passport
   *
   * @param {resendPhoneNumberVerificationCode$DirectInput} parameters {@link resendPhoneNumberVerificationCode$Input}
   * @return {Promise<AuthenticationCodeInfo>} Promise<{@link AuthenticationCodeInfo}>
   */
  async resendPhoneNumberVerificationCode(
    parameters: resendPhoneNumberVerificationCode$DirectInput
  ): Promise<AuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "resendPhoneNumberVerificationCode",
      parameters
    );
    return result as AuthenticationCodeInfo;
  }

  /**
   * Checks the phone number verification code for Telegram Passport
   *
   * @param {checkPhoneNumberVerificationCode$DirectInput} parameters {@link checkPhoneNumberVerificationCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkPhoneNumberVerificationCode(
    parameters: checkPhoneNumberVerificationCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkPhoneNumberVerificationCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Sends a code to verify an email address to be added to a user's Telegram Passport
   *
   * @param {sendEmailAddressVerificationCode$DirectInput} parameters {@link sendEmailAddressVerificationCode$Input}
   * @return {Promise<EmailAddressAuthenticationCodeInfo>} Promise<{@link EmailAddressAuthenticationCodeInfo}>
   */
  async sendEmailAddressVerificationCode(
    parameters: sendEmailAddressVerificationCode$DirectInput
  ): Promise<EmailAddressAuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "sendEmailAddressVerificationCode",
      parameters
    );
    return result as EmailAddressAuthenticationCodeInfo;
  }

  /**
   * Resends the code to verify an email address to be added to a user's Telegram Passport
   *
   * @param {resendEmailAddressVerificationCode$DirectInput} parameters {@link resendEmailAddressVerificationCode$Input}
   * @return {Promise<EmailAddressAuthenticationCodeInfo>} Promise<{@link EmailAddressAuthenticationCodeInfo}>
   */
  async resendEmailAddressVerificationCode(
    parameters: resendEmailAddressVerificationCode$DirectInput
  ): Promise<EmailAddressAuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "resendEmailAddressVerificationCode",
      parameters
    );
    return result as EmailAddressAuthenticationCodeInfo;
  }

  /**
   * Checks the email address verification code for Telegram Passport
   *
   * @param {checkEmailAddressVerificationCode$DirectInput} parameters {@link checkEmailAddressVerificationCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkEmailAddressVerificationCode(
    parameters: checkEmailAddressVerificationCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkEmailAddressVerificationCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns a Telegram Passport authorization form for sharing data with a service
   *
   * @param {getPassportAuthorizationForm$DirectInput} parameters {@link getPassportAuthorizationForm$Input}
   * @return {Promise<PassportAuthorizationForm>} Promise<{@link PassportAuthorizationForm}>
   */
  async getPassportAuthorizationForm(
    parameters: getPassportAuthorizationForm$DirectInput
  ): Promise<PassportAuthorizationForm> {
    const result = await this.client.invoke(
      "getPassportAuthorizationForm",
      parameters
    );
    return result as PassportAuthorizationForm;
  }

  /**
   * Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
   *
   * @param {getPassportAuthorizationFormAvailableElements$DirectInput} parameters {@link getPassportAuthorizationFormAvailableElements$Input}
   * @return {Promise<PassportElementsWithErrors>} Promise<{@link PassportElementsWithErrors}>
   */
  async getPassportAuthorizationFormAvailableElements(
    parameters: getPassportAuthorizationFormAvailableElements$DirectInput
  ): Promise<PassportElementsWithErrors> {
    const result = await this.client.invoke(
      "getPassportAuthorizationFormAvailableElements",
      parameters
    );
    return result as PassportElementsWithErrors;
  }

  /**
   * Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
   *
   * @param {sendPassportAuthorizationForm$DirectInput} parameters {@link sendPassportAuthorizationForm$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async sendPassportAuthorizationForm(
    parameters: sendPassportAuthorizationForm$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "sendPassportAuthorizationForm",
      parameters
    );
    return result as Ok;
  }

  /**
   * Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
   *
   * @param {sendPhoneNumberConfirmationCode$DirectInput} parameters {@link sendPhoneNumberConfirmationCode$Input}
   * @return {Promise<AuthenticationCodeInfo>} Promise<{@link AuthenticationCodeInfo}>
   */
  async sendPhoneNumberConfirmationCode(
    parameters: sendPhoneNumberConfirmationCode$DirectInput
  ): Promise<AuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "sendPhoneNumberConfirmationCode",
      parameters
    );
    return result as AuthenticationCodeInfo;
  }

  /**
   * Resends phone number confirmation code
   *
   * @param {resendPhoneNumberConfirmationCode$DirectInput} parameters {@link resendPhoneNumberConfirmationCode$Input}
   * @return {Promise<AuthenticationCodeInfo>} Promise<{@link AuthenticationCodeInfo}>
   */
  async resendPhoneNumberConfirmationCode(
    parameters: resendPhoneNumberConfirmationCode$DirectInput
  ): Promise<AuthenticationCodeInfo> {
    const result = await this.client.invoke(
      "resendPhoneNumberConfirmationCode",
      parameters
    );
    return result as AuthenticationCodeInfo;
  }

  /**
   * Checks phone number confirmation code
   *
   * @param {checkPhoneNumberConfirmationCode$DirectInput} parameters {@link checkPhoneNumberConfirmationCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async checkPhoneNumberConfirmationCode(
    parameters: checkPhoneNumberConfirmationCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "checkPhoneNumberConfirmationCode",
      parameters
    );
    return result as Ok;
  }

  /**
   * Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
   *
   * @param {setBotUpdatesStatus$DirectInput} parameters {@link setBotUpdatesStatus$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setBotUpdatesStatus(
    parameters: setBotUpdatesStatus$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setBotUpdatesStatus", parameters);
    return result as Ok;
  }

  /**
   * Uploads a file with a sticker; returns the uploaded file
   *
   * @param {uploadStickerFile$DirectInput} parameters {@link uploadStickerFile$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async uploadStickerFile(parameters: uploadStickerFile$DirectInput): Promise<File> {
    const result = await this.client.invoke("uploadStickerFile", parameters);
    return result as File;
  }

  /**
   * Returns a suggested name for a new sticker set with a given title
   *
   * @param {getSuggestedStickerSetName$DirectInput} parameters {@link getSuggestedStickerSetName$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getSuggestedStickerSetName(
    parameters: getSuggestedStickerSetName$DirectInput
  ): Promise<Text> {
    const result = await this.client.invoke(
      "getSuggestedStickerSetName",
      parameters
    );
    return result as Text;
  }

  /**
   * Checks whether a name can be used for a new sticker set
   *
   * @param {checkStickerSetName$DirectInput} parameters {@link checkStickerSetName$Input}
   * @return {Promise<CheckStickerSetNameResult>} Promise<{@link CheckStickerSetNameResult}>
   */
  async checkStickerSetName(
    parameters: checkStickerSetName$DirectInput
  ): Promise<CheckStickerSetNameResult> {
    const result = await this.client.invoke("checkStickerSetName", parameters);
    return result as CheckStickerSetNameResult;
  }

  /**
   * Creates a new sticker set. Returns the newly created sticker set
   *
   * @param {createNewStickerSet$DirectInput} parameters {@link createNewStickerSet$Input}
   * @return {Promise<StickerSet>} Promise<{@link StickerSet}>
   */
  async createNewStickerSet(
    parameters: createNewStickerSet$DirectInput
  ): Promise<StickerSet> {
    const result = await this.client.invoke("createNewStickerSet", parameters);
    return result as StickerSet;
  }

  /**
   * Adds a new sticker to a set; for bots only
   *
   * @param {addStickerToSet$DirectInput} parameters {@link addStickerToSet$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addStickerToSet(parameters: addStickerToSet$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addStickerToSet", parameters);
    return result as Ok;
  }

  /**
   * Sets a sticker set thumbnail; for bots only
   *
   * @param {setStickerSetThumbnail$DirectInput} parameters {@link setStickerSetThumbnail$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStickerSetThumbnail(
    parameters: setStickerSetThumbnail$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setStickerSetThumbnail", parameters);
    return result as Ok;
  }

  /**
   * Sets a custom emoji sticker set thumbnail; for bots only
   *
   * @param {setCustomEmojiStickerSetThumbnail$DirectInput} parameters {@link setCustomEmojiStickerSetThumbnail$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setCustomEmojiStickerSetThumbnail(
    parameters: setCustomEmojiStickerSetThumbnail$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "setCustomEmojiStickerSetThumbnail",
      parameters
    );
    return result as Ok;
  }

  /**
   * Sets a sticker set title; for bots only
   *
   * @param {setStickerSetTitle$DirectInput} parameters {@link setStickerSetTitle$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStickerSetTitle(parameters: setStickerSetTitle$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setStickerSetTitle", parameters);
    return result as Ok;
  }

  /**
   * Deleted a sticker set; for bots only
   *
   * @param {deleteStickerSet$DirectInput} parameters {@link deleteStickerSet$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async deleteStickerSet(parameters: deleteStickerSet$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("deleteStickerSet", parameters);
    return result as Ok;
  }

  /**
   * Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
   *
   * @param {setStickerPositionInSet$DirectInput} parameters {@link setStickerPositionInSet$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStickerPositionInSet(
    parameters: setStickerPositionInSet$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setStickerPositionInSet", parameters);
    return result as Ok;
  }

  /**
   * Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
   *
   * @param {removeStickerFromSet$DirectInput} parameters {@link removeStickerFromSet$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeStickerFromSet(
    parameters: removeStickerFromSet$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("removeStickerFromSet", parameters);
    return result as Ok;
  }

  /**
   * Changes the list of emoji corresponding to a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
   *
   * @param {setStickerEmojis$DirectInput} parameters {@link setStickerEmojis$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStickerEmojis(parameters: setStickerEmojis$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setStickerEmojis", parameters);
    return result as Ok;
  }

  /**
   * Changes the list of keywords of a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
   *
   * @param {setStickerKeywords$DirectInput} parameters {@link setStickerKeywords$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStickerKeywords(parameters: setStickerKeywords$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setStickerKeywords", parameters);
    return result as Ok;
  }

  /**
   * Changes the mask position of a mask sticker; for bots only. The sticker must belong to a mask sticker set created by the bot
   *
   * @param {setStickerMaskPosition$DirectInput} parameters {@link setStickerMaskPosition$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setStickerMaskPosition(
    parameters: setStickerMaskPosition$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setStickerMaskPosition", parameters);
    return result as Ok;
  }

  /**
   * Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
   *
   * @param {getMapThumbnailFile$DirectInput} parameters {@link getMapThumbnailFile$Input}
   * @return {Promise<File>} Promise<{@link File}>
   */
  async getMapThumbnailFile(
    parameters: getMapThumbnailFile$DirectInput
  ): Promise<File> {
    const result = await this.client.invoke("getMapThumbnailFile", parameters);
    return result as File;
  }

  /**
   * Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown
   *
   * @param {getPremiumLimit$DirectInput} parameters {@link getPremiumLimit$Input}
   * @return {Promise<PremiumLimit>} Promise<{@link PremiumLimit}>
   */
  async getPremiumLimit(
    parameters: getPremiumLimit$DirectInput
  ): Promise<PremiumLimit> {
    const result = await this.client.invoke("getPremiumLimit", parameters);
    return result as PremiumLimit;
  }

  /**
   * Returns information about features, available to Premium users
   *
   * @param {getPremiumFeatures$DirectInput} parameters {@link getPremiumFeatures$Input}
   * @return {Promise<PremiumFeatures>} Promise<{@link PremiumFeatures}>
   */
  async getPremiumFeatures(
    parameters: getPremiumFeatures$DirectInput
  ): Promise<PremiumFeatures> {
    const result = await this.client.invoke("getPremiumFeatures", parameters);
    return result as PremiumFeatures;
  }

  /**
   * Returns examples of premium stickers for demonstration purposes
   *
   * @param {getPremiumStickerExamples$DirectInput} parameters {@link getPremiumStickerExamples$Input}
   * @return {Promise<Stickers>} Promise<{@link Stickers}>
   */
  async getPremiumStickerExamples(
    parameters: getPremiumStickerExamples$DirectInput
  ): Promise<Stickers> {
    const result = await this.client.invoke("getPremiumStickerExamples", parameters);
    return result as Stickers;
  }

  /**
   * Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen
   *
   * @param {viewPremiumFeature$DirectInput} parameters {@link viewPremiumFeature$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async viewPremiumFeature(parameters: viewPremiumFeature$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("viewPremiumFeature", parameters);
    return result as Ok;
  }

  /**
   * Informs TDLib that the user clicked Premium subscription button on the Premium features screen
   *
   * @param {clickPremiumSubscriptionButton$DirectInput} parameters {@link clickPremiumSubscriptionButton$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async clickPremiumSubscriptionButton(
    parameters: clickPremiumSubscriptionButton$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "clickPremiumSubscriptionButton",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns state of Telegram Premium subscription and promotion videos for Premium features
   *
   * @param {getPremiumState$DirectInput} parameters {@link getPremiumState$Input}
   * @return {Promise<PremiumState>} Promise<{@link PremiumState}>
   */
  async getPremiumState(
    parameters: getPremiumState$DirectInput
  ): Promise<PremiumState> {
    const result = await this.client.invoke("getPremiumState", parameters);
    return result as PremiumState;
  }

  /**
   * Returns available options for Telegram Premium gift code or giveaway creation
   *
   * @param {getPremiumGiftCodePaymentOptions$DirectInput} parameters {@link getPremiumGiftCodePaymentOptions$Input}
   * @return {Promise<PremiumGiftCodePaymentOptions>} Promise<{@link PremiumGiftCodePaymentOptions}>
   */
  async getPremiumGiftCodePaymentOptions(
    parameters: getPremiumGiftCodePaymentOptions$DirectInput
  ): Promise<PremiumGiftCodePaymentOptions> {
    const result = await this.client.invoke(
      "getPremiumGiftCodePaymentOptions",
      parameters
    );
    return result as PremiumGiftCodePaymentOptions;
  }

  /**
   * Return information about a Telegram Premium gift code
   *
   * @param {checkPremiumGiftCode$DirectInput} parameters {@link checkPremiumGiftCode$Input}
   * @return {Promise<PremiumGiftCodeInfo>} Promise<{@link PremiumGiftCodeInfo}>
   */
  async checkPremiumGiftCode(
    parameters: checkPremiumGiftCode$DirectInput
  ): Promise<PremiumGiftCodeInfo> {
    const result = await this.client.invoke("checkPremiumGiftCode", parameters);
    return result as PremiumGiftCodeInfo;
  }

  /**
   * Applies a Telegram Premium gift code
   *
   * @param {applyPremiumGiftCode$DirectInput} parameters {@link applyPremiumGiftCode$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async applyPremiumGiftCode(
    parameters: applyPremiumGiftCode$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("applyPremiumGiftCode", parameters);
    return result as Ok;
  }

  /**
   * Launches a prepaid Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
   *
   * @param {launchPrepaidPremiumGiveaway$DirectInput} parameters {@link launchPrepaidPremiumGiveaway$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async launchPrepaidPremiumGiveaway(
    parameters: launchPrepaidPremiumGiveaway$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "launchPrepaidPremiumGiveaway",
      parameters
    );
    return result as Ok;
  }

  /**
   * Returns information about a Telegram Premium giveaway
   *
   * @param {getPremiumGiveawayInfo$DirectInput} parameters {@link getPremiumGiveawayInfo$Input}
   * @return {Promise<PremiumGiveawayInfo>} Promise<{@link PremiumGiveawayInfo}>
   */
  async getPremiumGiveawayInfo(
    parameters: getPremiumGiveawayInfo$DirectInput
  ): Promise<PremiumGiveawayInfo> {
    const result = await this.client.invoke("getPremiumGiveawayInfo", parameters);
    return result as PremiumGiveawayInfo;
  }

  /**
   * Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase
   *
   * @param {canPurchasePremium$DirectInput} parameters {@link canPurchasePremium$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async canPurchasePremium(parameters: canPurchasePremium$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("canPurchasePremium", parameters);
    return result as Ok;
  }

  /**
   * Informs server about a purchase through App Store. For official applications only
   *
   * @param {assignAppStoreTransaction$DirectInput} parameters {@link assignAppStoreTransaction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async assignAppStoreTransaction(
    parameters: assignAppStoreTransaction$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("assignAppStoreTransaction", parameters);
    return result as Ok;
  }

  /**
   * Informs server about a purchase through Google Play. For official applications only
   *
   * @param {assignGooglePlayTransaction$DirectInput} parameters {@link assignGooglePlayTransaction$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async assignGooglePlayTransaction(
    parameters: assignGooglePlayTransaction$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke(
      "assignGooglePlayTransaction",
      parameters
    );
    return result as Ok;
  }

  /**
   * Accepts Telegram terms of services
   *
   * @param {acceptTermsOfService$DirectInput} parameters {@link acceptTermsOfService$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async acceptTermsOfService(
    parameters: acceptTermsOfService$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("acceptTermsOfService", parameters);
    return result as Ok;
  }

  /**
   * Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously
   *
   * @param {searchStringsByPrefix$DirectInput} parameters {@link searchStringsByPrefix$Input}
   * @return {Promise<FoundPositions>} Promise<{@link FoundPositions}>
   */
  async searchStringsByPrefix(
    parameters: searchStringsByPrefix$DirectInput
  ): Promise<FoundPositions> {
    const result = await this.client.invoke("searchStringsByPrefix", parameters);
    return result as FoundPositions;
  }

  /**
   * Sends a custom request; for bots only
   *
   * @param {sendCustomRequest$DirectInput} parameters {@link sendCustomRequest$Input}
   * @return {Promise<CustomRequestResult>} Promise<{@link CustomRequestResult}>
   */
  async sendCustomRequest(
    parameters: sendCustomRequest$DirectInput
  ): Promise<CustomRequestResult> {
    const result = await this.client.invoke("sendCustomRequest", parameters);
    return result as CustomRequestResult;
  }

  /**
   * Answers a custom query; for bots only
   *
   * @param {answerCustomQuery$DirectInput} parameters {@link answerCustomQuery$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async answerCustomQuery(parameters: answerCustomQuery$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("answerCustomQuery", parameters);
    return result as Ok;
  }

  /**
   * Succeeds after a specified amount of time has passed. Can be called before initialization
   *
   * @param {setAlarm$DirectInput} parameters {@link setAlarm$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setAlarm(parameters: setAlarm$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setAlarm", parameters);
    return result as Ok;
  }

  /**
   * Returns information about existing countries. Can be called before authorization
   *
   * @param {getCountries$DirectInput} parameters {@link getCountries$Input}
   * @return {Promise<Countries>} Promise<{@link Countries}>
   */
  async getCountries(parameters: getCountries$DirectInput): Promise<Countries> {
    const result = await this.client.invoke("getCountries", parameters);
    return result as Countries;
  }

  /**
   * Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
   *
   * @param {getCountryCode$DirectInput} parameters {@link getCountryCode$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getCountryCode(parameters: getCountryCode$DirectInput): Promise<Text> {
    const result = await this.client.invoke("getCountryCode", parameters);
    return result as Text;
  }

  /**
   * Returns information about a phone number by its prefix. Can be called before authorization
   *
   * @param {getPhoneNumberInfo$DirectInput} parameters {@link getPhoneNumberInfo$Input}
   * @return {Promise<PhoneNumberInfo>} Promise<{@link PhoneNumberInfo}>
   */
  async getPhoneNumberInfo(
    parameters: getPhoneNumberInfo$DirectInput
  ): Promise<PhoneNumberInfo> {
    const result = await this.client.invoke("getPhoneNumberInfo", parameters);
    return result as PhoneNumberInfo;
  }

  /**
   * Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
   *
   * @param {getPhoneNumberInfoSync$DirectInput} parameters {@link getPhoneNumberInfoSync$Input}
   * @return {Promise<PhoneNumberInfo>} Promise<{@link PhoneNumberInfo}>
   */
  async getPhoneNumberInfoSync(
    parameters: getPhoneNumberInfoSync$DirectInput
  ): Promise<PhoneNumberInfo> {
    const result = await this.client.invoke("getPhoneNumberInfoSync", parameters);
    return result as PhoneNumberInfo;
  }

  /**
   * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
   *
   * @param {getDeepLinkInfo$DirectInput} parameters {@link getDeepLinkInfo$Input}
   * @return {Promise<DeepLinkInfo>} Promise<{@link DeepLinkInfo}>
   */
  async getDeepLinkInfo(
    parameters: getDeepLinkInfo$DirectInput
  ): Promise<DeepLinkInfo> {
    const result = await this.client.invoke("getDeepLinkInfo", parameters);
    return result as DeepLinkInfo;
  }

  /**
   * Returns application config, provided by the server. Can be called before authorization
   *
   * @param {getApplicationConfig$DirectInput} parameters {@link getApplicationConfig$Input}
   * @return {Promise<JsonValue>} Promise<{@link JsonValue}>
   */
  async getApplicationConfig(
    parameters: getApplicationConfig$DirectInput
  ): Promise<JsonValue> {
    const result = await this.client.invoke("getApplicationConfig", parameters);
    return result as JsonValue;
  }

  /**
   * Saves application log event on the server. Can be called before authorization
   *
   * @param {saveApplicationLogEvent$DirectInput} parameters {@link saveApplicationLogEvent$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async saveApplicationLogEvent(
    parameters: saveApplicationLogEvent$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("saveApplicationLogEvent", parameters);
    return result as Ok;
  }

  /**
   * Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
   *
   * @param {getApplicationDownloadLink$DirectInput} parameters {@link getApplicationDownloadLink$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getApplicationDownloadLink(
    parameters: getApplicationDownloadLink$DirectInput
  ): Promise<HttpUrl> {
    const result = await this.client.invoke(
      "getApplicationDownloadLink",
      parameters
    );
    return result as HttpUrl;
  }

  /**
   * Adds a proxy server for network requests. Can be called before authorization
   *
   * @param {addProxy$DirectInput} parameters {@link addProxy$Input}
   * @return {Promise<Proxy>} Promise<{@link Proxy}>
   */
  async addProxy(parameters: addProxy$DirectInput): Promise<Proxy> {
    const result = await this.client.invoke("addProxy", parameters);
    return result as Proxy;
  }

  /**
   * Edits an existing proxy server for network requests. Can be called before authorization
   *
   * @param {editProxy$DirectInput} parameters {@link editProxy$Input}
   * @return {Promise<Proxy>} Promise<{@link Proxy}>
   */
  async editProxy(parameters: editProxy$DirectInput): Promise<Proxy> {
    const result = await this.client.invoke("editProxy", parameters);
    return result as Proxy;
  }

  /**
   * Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
   *
   * @param {enableProxy$DirectInput} parameters {@link enableProxy$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async enableProxy(parameters: enableProxy$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("enableProxy", parameters);
    return result as Ok;
  }

  /**
   * Disables the currently enabled proxy. Can be called before authorization
   *
   * @param {disableProxy$DirectInput} parameters {@link disableProxy$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async disableProxy(parameters: disableProxy$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("disableProxy", parameters);
    return result as Ok;
  }

  /**
   * Removes a proxy server. Can be called before authorization
   *
   * @param {removeProxy$DirectInput} parameters {@link removeProxy$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async removeProxy(parameters: removeProxy$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("removeProxy", parameters);
    return result as Ok;
  }

  /**
   * Returns list of proxies that are currently set up. Can be called before authorization
   *
   * @param {getProxies$DirectInput} parameters {@link getProxies$Input}
   * @return {Promise<Proxies>} Promise<{@link Proxies}>
   */
  async getProxies(parameters: getProxies$DirectInput): Promise<Proxies> {
    const result = await this.client.invoke("getProxies", parameters);
    return result as Proxies;
  }

  /**
   * Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
   *
   * @param {getProxyLink$DirectInput} parameters {@link getProxyLink$Input}
   * @return {Promise<HttpUrl>} Promise<{@link HttpUrl}>
   */
  async getProxyLink(parameters: getProxyLink$DirectInput): Promise<HttpUrl> {
    const result = await this.client.invoke("getProxyLink", parameters);
    return result as HttpUrl;
  }

  /**
   * Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
   *
   * @param {pingProxy$DirectInput} parameters {@link pingProxy$Input}
   * @return {Promise<Seconds>} Promise<{@link Seconds}>
   */
  async pingProxy(parameters: pingProxy$DirectInput): Promise<Seconds> {
    const result = await this.client.invoke("pingProxy", parameters);
    return result as Seconds;
  }

  /**
   * Sets new log stream for internal logging of TDLib. Can be called synchronously
   *
   * @param {setLogStream$DirectInput} parameters {@link setLogStream$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setLogStream(parameters: setLogStream$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("setLogStream", parameters);
    return result as Ok;
  }

  /**
   * Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
   *
   * @param {getLogStream$DirectInput} parameters {@link getLogStream$Input}
   * @return {Promise<LogStream>} Promise<{@link LogStream}>
   */
  async getLogStream(parameters: getLogStream$DirectInput): Promise<LogStream> {
    const result = await this.client.invoke("getLogStream", parameters);
    return result as LogStream;
  }

  /**
   * Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
   *
   * @param {setLogVerbosityLevel$DirectInput} parameters {@link setLogVerbosityLevel$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setLogVerbosityLevel(
    parameters: setLogVerbosityLevel$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setLogVerbosityLevel", parameters);
    return result as Ok;
  }

  /**
   * Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
   *
   * @param {getLogVerbosityLevel$DirectInput} parameters {@link getLogVerbosityLevel$Input}
   * @return {Promise<LogVerbosityLevel>} Promise<{@link LogVerbosityLevel}>
   */
  async getLogVerbosityLevel(
    parameters: getLogVerbosityLevel$DirectInput
  ): Promise<LogVerbosityLevel> {
    const result = await this.client.invoke("getLogVerbosityLevel", parameters);
    return result as LogVerbosityLevel;
  }

  /**
   * Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
   *
   * @param {getLogTags$DirectInput} parameters {@link getLogTags$Input}
   * @return {Promise<LogTags>} Promise<{@link LogTags}>
   */
  async getLogTags(parameters: getLogTags$DirectInput): Promise<LogTags> {
    const result = await this.client.invoke("getLogTags", parameters);
    return result as LogTags;
  }

  /**
   * Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
   *
   * @param {setLogTagVerbosityLevel$DirectInput} parameters {@link setLogTagVerbosityLevel$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async setLogTagVerbosityLevel(
    parameters: setLogTagVerbosityLevel$DirectInput
  ): Promise<Ok> {
    const result = await this.client.invoke("setLogTagVerbosityLevel", parameters);
    return result as Ok;
  }

  /**
   * Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
   *
   * @param {getLogTagVerbosityLevel$DirectInput} parameters {@link getLogTagVerbosityLevel$Input}
   * @return {Promise<LogVerbosityLevel>} Promise<{@link LogVerbosityLevel}>
   */
  async getLogTagVerbosityLevel(
    parameters: getLogTagVerbosityLevel$DirectInput
  ): Promise<LogVerbosityLevel> {
    const result = await this.client.invoke("getLogTagVerbosityLevel", parameters);
    return result as LogVerbosityLevel;
  }

  /**
   * Adds a message to TDLib internal log. Can be called synchronously
   *
   * @param {addLogMessage$DirectInput} parameters {@link addLogMessage$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async addLogMessage(parameters: addLogMessage$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("addLogMessage", parameters);
    return result as Ok;
  }

  /**
   * Returns support information for the given user; for Telegram support only
   *
   * @param {getUserSupportInfo$DirectInput} parameters {@link getUserSupportInfo$Input}
   * @return {Promise<UserSupportInfo>} Promise<{@link UserSupportInfo}>
   */
  async getUserSupportInfo(
    parameters: getUserSupportInfo$DirectInput
  ): Promise<UserSupportInfo> {
    const result = await this.client.invoke("getUserSupportInfo", parameters);
    return result as UserSupportInfo;
  }

  /**
   * Sets support information for the given user; for Telegram support only
   *
   * @param {setUserSupportInfo$DirectInput} parameters {@link setUserSupportInfo$Input}
   * @return {Promise<UserSupportInfo>} Promise<{@link UserSupportInfo}>
   */
  async setUserSupportInfo(
    parameters: setUserSupportInfo$DirectInput
  ): Promise<UserSupportInfo> {
    const result = await this.client.invoke("setUserSupportInfo", parameters);
    return result as UserSupportInfo;
  }

  /**
   * Returns localized name of the Telegram support user; for Telegram support only
   *
   * @param {getSupportName$DirectInput} parameters {@link getSupportName$Input}
   * @return {Promise<Text>} Promise<{@link Text}>
   */
  async getSupportName(parameters: getSupportName$DirectInput): Promise<Text> {
    const result = await this.client.invoke("getSupportName", parameters);
    return result as Text;
  }

  /**
   * Does nothing; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallEmpty$DirectInput} parameters {@link testCallEmpty$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async testCallEmpty(parameters: testCallEmpty$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("testCallEmpty", parameters);
    return result as Ok;
  }

  /**
   * Returns the received string; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallString$DirectInput} parameters {@link testCallString$Input}
   * @return {Promise<TestString>} Promise<{@link TestString}>
   */
  async testCallString(parameters: testCallString$DirectInput): Promise<TestString> {
    const result = await this.client.invoke("testCallString", parameters);
    return result as TestString;
  }

  /**
   * Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallBytes$DirectInput} parameters {@link testCallBytes$Input}
   * @return {Promise<TestBytes>} Promise<{@link TestBytes}>
   */
  async testCallBytes(parameters: testCallBytes$DirectInput): Promise<TestBytes> {
    const result = await this.client.invoke("testCallBytes", parameters);
    return result as TestBytes;
  }

  /**
   * Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallVectorInt$DirectInput} parameters {@link testCallVectorInt$Input}
   * @return {Promise<TestVectorInt>} Promise<{@link TestVectorInt}>
   */
  async testCallVectorInt(
    parameters: testCallVectorInt$DirectInput
  ): Promise<TestVectorInt> {
    const result = await this.client.invoke("testCallVectorInt", parameters);
    return result as TestVectorInt;
  }

  /**
   * Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallVectorIntObject$DirectInput} parameters {@link testCallVectorIntObject$Input}
   * @return {Promise<TestVectorIntObject>} Promise<{@link TestVectorIntObject}>
   */
  async testCallVectorIntObject(
    parameters: testCallVectorIntObject$DirectInput
  ): Promise<TestVectorIntObject> {
    const result = await this.client.invoke("testCallVectorIntObject", parameters);
    return result as TestVectorIntObject;
  }

  /**
   * Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallVectorString$DirectInput} parameters {@link testCallVectorString$Input}
   * @return {Promise<TestVectorString>} Promise<{@link TestVectorString}>
   */
  async testCallVectorString(
    parameters: testCallVectorString$DirectInput
  ): Promise<TestVectorString> {
    const result = await this.client.invoke("testCallVectorString", parameters);
    return result as TestVectorString;
  }

  /**
   * Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testCallVectorStringObject$DirectInput} parameters {@link testCallVectorStringObject$Input}
   * @return {Promise<TestVectorStringObject>} Promise<{@link TestVectorStringObject}>
   */
  async testCallVectorStringObject(
    parameters: testCallVectorStringObject$DirectInput
  ): Promise<TestVectorStringObject> {
    const result = await this.client.invoke(
      "testCallVectorStringObject",
      parameters
    );
    return result as TestVectorStringObject;
  }

  /**
   * Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testSquareInt$DirectInput} parameters {@link testSquareInt$Input}
   * @return {Promise<TestInt>} Promise<{@link TestInt}>
   */
  async testSquareInt(parameters: testSquareInt$DirectInput): Promise<TestInt> {
    const result = await this.client.invoke("testSquareInt", parameters);
    return result as TestInt;
  }

  /**
   * Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
   *
   * @param {testNetwork$DirectInput} parameters {@link testNetwork$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async testNetwork(parameters: testNetwork$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("testNetwork", parameters);
    return result as Ok;
  }

  /**
   * Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
   *
   * @param {testProxy$DirectInput} parameters {@link testProxy$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async testProxy(parameters: testProxy$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("testProxy", parameters);
    return result as Ok;
  }

  /**
   * Forces an updates.getDifference call to the Telegram servers; for testing only
   *
   * @param {testGetDifference$DirectInput} parameters {@link testGetDifference$Input}
   * @return {Promise<Ok>} Promise<{@link Ok}>
   */
  async testGetDifference(parameters: testGetDifference$DirectInput): Promise<Ok> {
    const result = await this.client.invoke("testGetDifference", parameters);
    return result as Ok;
  }

  /**
   * Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
   *
   * @param {testUseUpdate$DirectInput} parameters {@link testUseUpdate$Input}
   * @return {Promise<Update>} Promise<{@link Update}>
   */
  async testUseUpdate(parameters: testUseUpdate$DirectInput): Promise<Update> {
    const result = await this.client.invoke("testUseUpdate", parameters);
    return result as Update;
  }

  /**
   * Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
   *
   * @param {testReturnError$DirectInput} parameters {@link testReturnError$Input}
   * @return {Promise<Error>} Promise<{@link Error}>
   */
  async testReturnError(parameters: testReturnError$DirectInput): Promise<Error> {
    const result = await this.client.invoke("testReturnError", parameters);
    return result as Error;
  }
}

Object.freeze($AsyncApi);
Object.freeze($AsyncApi.prototype);

/**
 * Convenience class for sync API calls
 *
 * @class
 */
export class $SyncApi {
  /**
   * Constructs {@link $SyncApi}
   *
   * @param {object} client
   */
  constructor(
    private readonly client: {
      execute(method: string, parameters: unknown): unknown;
    }
  ) {
    Object.freeze(this);
  }

  /**
   * Searches for a given quote in a text. Returns found quote start position in UTF-16 code units. Returns a 404 error if the quote is not found. Can be called synchronously
   *
   * @param {searchQuote$DirectInput} parameters - {@link searchQuote$Input}
   * @return {FoundPosition} {@link FoundPosition}
   */
  searchQuote(parameters: searchQuote$DirectInput): FoundPosition {
    return this.client.execute("searchQuote", parameters) as FoundPosition;
  }

  /**
   * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
   *
   * @param {getTextEntities$DirectInput} parameters - {@link getTextEntities$Input}
   * @return {TextEntities} {@link TextEntities}
   */
  getTextEntities(parameters: getTextEntities$DirectInput): TextEntities {
    return this.client.execute("getTextEntities", parameters) as TextEntities;
  }

  /**
   * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
   *
   * @param {parseTextEntities$DirectInput} parameters - {@link parseTextEntities$Input}
   * @return {FormattedText} {@link FormattedText}
   */
  parseTextEntities(parameters: parseTextEntities$DirectInput): FormattedText {
    return this.client.execute("parseTextEntities", parameters) as FormattedText;
  }

  /**
   * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
   *
   * @param {parseMarkdown$DirectInput} parameters - {@link parseMarkdown$Input}
   * @return {FormattedText} {@link FormattedText}
   */
  parseMarkdown(parameters: parseMarkdown$DirectInput): FormattedText {
    return this.client.execute("parseMarkdown", parameters) as FormattedText;
  }

  /**
   * Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
   *
   * @param {getMarkdownText$DirectInput} parameters - {@link getMarkdownText$Input}
   * @return {FormattedText} {@link FormattedText}
   */
  getMarkdownText(parameters: getMarkdownText$DirectInput): FormattedText {
    return this.client.execute("getMarkdownText", parameters) as FormattedText;
  }

  /**
   * Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
   *
   * @param {getFileMimeType$DirectInput} parameters - {@link getFileMimeType$Input}
   * @return {Text} {@link Text}
   */
  getFileMimeType(parameters: getFileMimeType$DirectInput): Text {
    return this.client.execute("getFileMimeType", parameters) as Text;
  }

  /**
   * Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
   *
   * @param {getFileExtension$DirectInput} parameters - {@link getFileExtension$Input}
   * @return {Text} {@link Text}
   */
  getFileExtension(parameters: getFileExtension$DirectInput): Text {
    return this.client.execute("getFileExtension", parameters) as Text;
  }

  /**
   * Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
   *
   * @param {cleanFileName$DirectInput} parameters - {@link cleanFileName$Input}
   * @return {Text} {@link Text}
   */
  cleanFileName(parameters: cleanFileName$DirectInput): Text {
    return this.client.execute("cleanFileName", parameters) as Text;
  }

  /**
   * Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
   *
   * @param {getLanguagePackString$DirectInput} parameters - {@link getLanguagePackString$Input}
   * @return {LanguagePackStringValue} {@link LanguagePackStringValue}
   */
  getLanguagePackString(
    parameters: getLanguagePackString$DirectInput
  ): LanguagePackStringValue {
    return this.client.execute(
      "getLanguagePackString",
      parameters
    ) as LanguagePackStringValue;
  }

  /**
   * Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
   *
   * @param {getJsonValue$DirectInput} parameters - {@link getJsonValue$Input}
   * @return {JsonValue} {@link JsonValue}
   */
  getJsonValue(parameters: getJsonValue$DirectInput): JsonValue {
    return this.client.execute("getJsonValue", parameters) as JsonValue;
  }

  /**
   * Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
   *
   * @param {getJsonString$DirectInput} parameters - {@link getJsonString$Input}
   * @return {Text} {@link Text}
   */
  getJsonString(parameters: getJsonString$DirectInput): Text {
    return this.client.execute("getJsonString", parameters) as Text;
  }

  /**
   * Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
   *
   * @param {getThemeParametersJsonString$DirectInput} parameters - {@link getThemeParametersJsonString$Input}
   * @return {Text} {@link Text}
   */
  getThemeParametersJsonString(
    parameters: getThemeParametersJsonString$DirectInput
  ): Text {
    return this.client.execute("getThemeParametersJsonString", parameters) as Text;
  }

  /**
   * Returns default icon name for a folder. Can be called synchronously
   *
   * @param {getChatFolderDefaultIconName$DirectInput} parameters - {@link getChatFolderDefaultIconName$Input}
   * @return {ChatFolderIcon} {@link ChatFolderIcon}
   */
  getChatFolderDefaultIconName(
    parameters: getChatFolderDefaultIconName$DirectInput
  ): ChatFolderIcon {
    return this.client.execute(
      "getChatFolderDefaultIconName",
      parameters
    ) as ChatFolderIcon;
  }

  /**
   * Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
   *
   * @param {getPushReceiverId$DirectInput} parameters - {@link getPushReceiverId$Input}
   * @return {PushReceiverId} {@link PushReceiverId}
   */
  getPushReceiverId(parameters: getPushReceiverId$DirectInput): PushReceiverId {
    return this.client.execute("getPushReceiverId", parameters) as PushReceiverId;
  }

  /**
   * Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
   *
   * @param {getOption$DirectInput} parameters - {@link getOption$Input}
   * @return {OptionValue} {@link OptionValue}
   */
  getOption(parameters: getOption$DirectInput): OptionValue {
    return this.client.execute("getOption", parameters) as OptionValue;
  }

  /**
   * Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously
   *
   * @param {searchStringsByPrefix$DirectInput} parameters - {@link searchStringsByPrefix$Input}
   * @return {FoundPositions} {@link FoundPositions}
   */
  searchStringsByPrefix(
    parameters: searchStringsByPrefix$DirectInput
  ): FoundPositions {
    return this.client.execute(
      "searchStringsByPrefix",
      parameters
    ) as FoundPositions;
  }

  /**
   * Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
   *
   * @param {getPhoneNumberInfoSync$DirectInput} parameters - {@link getPhoneNumberInfoSync$Input}
   * @return {PhoneNumberInfo} {@link PhoneNumberInfo}
   */
  getPhoneNumberInfoSync(
    parameters: getPhoneNumberInfoSync$DirectInput
  ): PhoneNumberInfo {
    return this.client.execute(
      "getPhoneNumberInfoSync",
      parameters
    ) as PhoneNumberInfo;
  }

  /**
   * Sets new log stream for internal logging of TDLib. Can be called synchronously
   *
   * @param {setLogStream$DirectInput} parameters - {@link setLogStream$Input}
   * @return {Ok} {@link Ok}
   */
  setLogStream(parameters: setLogStream$DirectInput): Ok {
    return this.client.execute("setLogStream", parameters) as Ok;
  }

  /**
   * Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
   *
   * @param {getLogStream$DirectInput} parameters - {@link getLogStream$Input}
   * @return {LogStream} {@link LogStream}
   */
  getLogStream(parameters: getLogStream$DirectInput): LogStream {
    return this.client.execute("getLogStream", parameters) as LogStream;
  }

  /**
   * Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
   *
   * @param {setLogVerbosityLevel$DirectInput} parameters - {@link setLogVerbosityLevel$Input}
   * @return {Ok} {@link Ok}
   */
  setLogVerbosityLevel(parameters: setLogVerbosityLevel$DirectInput): Ok {
    return this.client.execute("setLogVerbosityLevel", parameters) as Ok;
  }

  /**
   * Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
   *
   * @param {getLogVerbosityLevel$DirectInput} parameters - {@link getLogVerbosityLevel$Input}
   * @return {LogVerbosityLevel} {@link LogVerbosityLevel}
   */
  getLogVerbosityLevel(
    parameters: getLogVerbosityLevel$DirectInput
  ): LogVerbosityLevel {
    return this.client.execute(
      "getLogVerbosityLevel",
      parameters
    ) as LogVerbosityLevel;
  }

  /**
   * Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
   *
   * @param {getLogTags$DirectInput} parameters - {@link getLogTags$Input}
   * @return {LogTags} {@link LogTags}
   */
  getLogTags(parameters: getLogTags$DirectInput): LogTags {
    return this.client.execute("getLogTags", parameters) as LogTags;
  }

  /**
   * Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
   *
   * @param {setLogTagVerbosityLevel$DirectInput} parameters - {@link setLogTagVerbosityLevel$Input}
   * @return {Ok} {@link Ok}
   */
  setLogTagVerbosityLevel(parameters: setLogTagVerbosityLevel$DirectInput): Ok {
    return this.client.execute("setLogTagVerbosityLevel", parameters) as Ok;
  }

  /**
   * Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
   *
   * @param {getLogTagVerbosityLevel$DirectInput} parameters - {@link getLogTagVerbosityLevel$Input}
   * @return {LogVerbosityLevel} {@link LogVerbosityLevel}
   */
  getLogTagVerbosityLevel(
    parameters: getLogTagVerbosityLevel$DirectInput
  ): LogVerbosityLevel {
    return this.client.execute(
      "getLogTagVerbosityLevel",
      parameters
    ) as LogVerbosityLevel;
  }

  /**
   * Adds a message to TDLib internal log. Can be called synchronously
   *
   * @param {addLogMessage$DirectInput} parameters - {@link addLogMessage$Input}
   * @return {Ok} {@link Ok}
   */
  addLogMessage(parameters: addLogMessage$DirectInput): Ok {
    return this.client.execute("addLogMessage", parameters) as Ok;
  }

  /**
   * Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
   *
   * @param {testReturnError$DirectInput} parameters - {@link testReturnError$Input}
   * @return {Error} {@link Error}
   */
  testReturnError(parameters: testReturnError$DirectInput): Error {
    return this.client.execute("testReturnError", parameters) as Error;
  }
}

Object.freeze($SyncApi);
Object.freeze($SyncApi.prototype);

/**
 * Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
 */
export type getAuthorizationState$Input = {
  readonly _: "getAuthorizationState";
};

/**
 * Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
 */
export type getAuthorizationState$DirectInput = {};

/**
 * Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
 *
 * @param {getAuthorizationState$Input} parameters {@link getAuthorizationState$Input}
 * @return {AuthorizationState} {@link AuthorizationState}
 */
export type getAuthorizationState = (
  parameters: getAuthorizationState$Input
) => AuthorizationState;

/**
 * Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
 */
export type setTdlibParameters$Input = {
  readonly _: "setTdlibParameters";

  /**
   * Pass true to use Telegram test environment instead of the production environment
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_test_dc?: Bool$Input;

  /**
   * The path to the directory for the persistent database; if empty, the current working directory will be used
   * @type {string} {@link string}
   */
  readonly database_directory?: string;

  /**
   * The path to the directory for storing files; if empty, database_directory will be used
   * @type {string} {@link string}
   */
  readonly files_directory?: string;

  /**
   * Encryption key for the database. If the encryption key is invalid, then an error with code 401 will be returned
   * @type {bytes$Input} {@link bytes}
   */
  readonly database_encryption_key?: bytes$Input;

  /**
   * Pass true to keep information about downloaded and uploaded files between application restarts
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_file_database?: Bool$Input;

  /**
   * Pass true to keep cache of users, basic groups, supergroups, channels and secret chats between restarts. Implies use_file_database
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_chat_info_database?: Bool$Input;

  /**
   * Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_message_database?: Bool$Input;

  /**
   * Pass true to enable support for secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_secret_chats?: Bool$Input;

  /**
   * Application identifier for Telegram API access, which can be obtained at https://my.telegram.org
   * @type {int32} {@link int32}
   */
  readonly api_id?: int32;

  /**
   * Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org
   * @type {string} {@link string}
   */
  readonly api_hash?: string;

  /**
   * IETF language tag of the user's operating system language; must be non-empty
   * @type {string} {@link string}
   */
  readonly system_language_code?: string;

  /**
   * Model of the device the application is being run on; must be non-empty
   * @type {string} {@link string}
   */
  readonly device_model?: string;

  /**
   * Version of the operating system the application is being run on. If empty, the version is automatically detected by TDLib
   * @type {string} {@link string}
   */
  readonly system_version?: string;

  /**
   * Application version; must be non-empty
   * @type {string} {@link string}
   */
  readonly application_version?: string;

  /**
   * Pass true to automatically delete old files in background
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable_storage_optimizer?: Bool$Input;

  /**
   * Pass true to ignore original file names for downloaded files. Otherwise, downloaded files are saved under names as close as possible to the original name
   * @type {Bool$Input} {@link Bool}
   */
  readonly ignore_file_names?: Bool$Input;
};

/**
 * Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
 */
export type setTdlibParameters$DirectInput = {
  /**
   * Pass true to use Telegram test environment instead of the production environment
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_test_dc?: Bool$Input;

  /**
   * The path to the directory for the persistent database; if empty, the current working directory will be used
   * @type {string} {@link string}
   */
  readonly database_directory?: string;

  /**
   * The path to the directory for storing files; if empty, database_directory will be used
   * @type {string} {@link string}
   */
  readonly files_directory?: string;

  /**
   * Encryption key for the database. If the encryption key is invalid, then an error with code 401 will be returned
   * @type {bytes$Input} {@link bytes}
   */
  readonly database_encryption_key?: bytes$Input;

  /**
   * Pass true to keep information about downloaded and uploaded files between application restarts
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_file_database?: Bool$Input;

  /**
   * Pass true to keep cache of users, basic groups, supergroups, channels and secret chats between restarts. Implies use_file_database
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_chat_info_database?: Bool$Input;

  /**
   * Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_message_database?: Bool$Input;

  /**
   * Pass true to enable support for secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_secret_chats?: Bool$Input;

  /**
   * Application identifier for Telegram API access, which can be obtained at https://my.telegram.org
   * @type {int32} {@link int32}
   */
  readonly api_id?: int32;

  /**
   * Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org
   * @type {string} {@link string}
   */
  readonly api_hash?: string;

  /**
   * IETF language tag of the user's operating system language; must be non-empty
   * @type {string} {@link string}
   */
  readonly system_language_code?: string;

  /**
   * Model of the device the application is being run on; must be non-empty
   * @type {string} {@link string}
   */
  readonly device_model?: string;

  /**
   * Version of the operating system the application is being run on. If empty, the version is automatically detected by TDLib
   * @type {string} {@link string}
   */
  readonly system_version?: string;

  /**
   * Application version; must be non-empty
   * @type {string} {@link string}
   */
  readonly application_version?: string;

  /**
   * Pass true to automatically delete old files in background
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable_storage_optimizer?: Bool$Input;

  /**
   * Pass true to ignore original file names for downloaded files. Otherwise, downloaded files are saved under names as close as possible to the original name
   * @type {Bool$Input} {@link Bool}
   */
  readonly ignore_file_names?: Bool$Input;
};

/**
 * Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
 *
 * @param {setTdlibParameters$Input} parameters {@link setTdlibParameters$Input}
 * @return {Ok} {@link Ok}
 */
export type setTdlibParameters = (parameters: setTdlibParameters$Input) => Ok;

/**
 * Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 *
 * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 */
export type setAuthenticationPhoneNumber$Input = {
  readonly _: "setAuthenticationPhoneNumber";

  /**
   * The phone number of the user, in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 *
 * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 */
export type setAuthenticationPhoneNumber$DirectInput = {
  /**
   * The phone number of the user, in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 *
 * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 *
 * @param {setAuthenticationPhoneNumber$Input} parameters {@link setAuthenticationPhoneNumber$Input}
 * @return {Ok} {@link Ok}
 */
export type setAuthenticationPhoneNumber = (
  parameters: setAuthenticationPhoneNumber$Input
) => Ok;

/**
 * Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress
 */
export type setAuthenticationEmailAddress$Input = {
  readonly _: "setAuthenticationEmailAddress";

  /**
   * The email address of the user
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress
 */
export type setAuthenticationEmailAddress$DirectInput = {
  /**
   * The email address of the user
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress
 *
 * @param {setAuthenticationEmailAddress$Input} parameters {@link setAuthenticationEmailAddress$Input}
 * @return {Ok} {@link Ok}
 */
export type setAuthenticationEmailAddress = (
  parameters: setAuthenticationEmailAddress$Input
) => Ok;

/**
 * Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed,
 *
 * - or when the current authorization state is authorizationStateWaitEmailCode
 */
export type resendAuthenticationCode$Input = {
  readonly _: "resendAuthenticationCode";
};

/**
 * Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed,
 *
 * - or when the current authorization state is authorizationStateWaitEmailCode
 */
export type resendAuthenticationCode$DirectInput = {};

/**
 * Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed,
 *
 * - or when the current authorization state is authorizationStateWaitEmailCode
 *
 * @param {resendAuthenticationCode$Input} parameters {@link resendAuthenticationCode$Input}
 * @return {Ok} {@link Ok}
 */
export type resendAuthenticationCode = (
  parameters: resendAuthenticationCode$Input
) => Ok;

/**
 * Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode
 */
export type checkAuthenticationEmailCode$Input = {
  readonly _: "checkAuthenticationEmailCode";

  /**
   * Email address authentication to check
   * @type {EmailAddressAuthentication$Input} {@link EmailAddressAuthentication}
   */
  readonly code?: EmailAddressAuthentication$Input;
};

/**
 * Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode
 */
export type checkAuthenticationEmailCode$DirectInput = {
  /**
   * Email address authentication to check
   * @type {EmailAddressAuthentication$Input} {@link EmailAddressAuthentication}
   */
  readonly code?: EmailAddressAuthentication$Input;
};

/**
 * Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode
 *
 * @param {checkAuthenticationEmailCode$Input} parameters {@link checkAuthenticationEmailCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationEmailCode = (
  parameters: checkAuthenticationEmailCode$Input
) => Ok;

/**
 * Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
 */
export type checkAuthenticationCode$Input = {
  readonly _: "checkAuthenticationCode";

  /**
   * Authentication code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
 */
export type checkAuthenticationCode$DirectInput = {
  /**
   * Authentication code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
 *
 * @param {checkAuthenticationCode$Input} parameters {@link checkAuthenticationCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationCode = (
  parameters: checkAuthenticationCode$Input
) => Ok;

/**
 * Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 *
 * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 */
export type requestQrCodeAuthentication$Input = {
  readonly _: "requestQrCodeAuthentication";

  /**
   * List of user identifiers of other users currently using the application
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly other_user_ids?: vector$Input<int53>;
};

/**
 * Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 *
 * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 */
export type requestQrCodeAuthentication$DirectInput = {
  /**
   * List of user identifiers of other users currently using the application
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly other_user_ids?: vector$Input<int53>;
};

/**
 * Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
 *
 * - or if there is no pending authentication query and the current authorization state is authorizationStateWaitEmailAddress, authorizationStateWaitEmailCode, authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 *
 * @param {requestQrCodeAuthentication$Input} parameters {@link requestQrCodeAuthentication$Input}
 * @return {Ok} {@link Ok}
 */
export type requestQrCodeAuthentication = (
  parameters: requestQrCodeAuthentication$Input
) => Ok;

/**
 * Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
 */
export type registerUser$Input = {
  readonly _: "registerUser";

  /**
   * The first name of the user; 1-64 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * The last name of the user; 0-64 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;
};

/**
 * Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
 */
export type registerUser$DirectInput = {
  /**
   * The first name of the user; 1-64 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * The last name of the user; 0-64 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;
};

/**
 * Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
 *
 * @param {registerUser$Input} parameters {@link registerUser$Input}
 * @return {Ok} {@link Ok}
 */
export type registerUser = (parameters: registerUser$Input) => Ok;

/**
 * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS" if reset is still pending.
 *
 * - Works only when the current authorization state is authorizationStateWaitEmailCode and authorization_state.can_reset_email_address == true
 */
export type resetAuthenticationEmailAddress$Input = {
  readonly _: "resetAuthenticationEmailAddress";
};

/**
 * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS" if reset is still pending.
 *
 * - Works only when the current authorization state is authorizationStateWaitEmailCode and authorization_state.can_reset_email_address == true
 */
export type resetAuthenticationEmailAddress$DirectInput = {};

/**
 * Resets the login email address. May return an error with a message "TASK_ALREADY_EXISTS" if reset is still pending.
 *
 * - Works only when the current authorization state is authorizationStateWaitEmailCode and authorization_state.can_reset_email_address == true
 *
 * @param {resetAuthenticationEmailAddress$Input} parameters {@link resetAuthenticationEmailAddress$Input}
 * @return {Ok} {@link Ok}
 */
export type resetAuthenticationEmailAddress = (
  parameters: resetAuthenticationEmailAddress$Input
) => Ok;

/**
 * Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type checkAuthenticationPassword$Input = {
  readonly _: "checkAuthenticationPassword";

  /**
   * The 2-step verification password to check
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type checkAuthenticationPassword$DirectInput = {
  /**
   * The 2-step verification password to check
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {checkAuthenticationPassword$Input} parameters {@link checkAuthenticationPassword$Input}
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationPassword = (
  parameters: checkAuthenticationPassword$Input
) => Ok;

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type requestAuthenticationPasswordRecovery$Input = {
  readonly _: "requestAuthenticationPasswordRecovery";
};

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type requestAuthenticationPasswordRecovery$DirectInput = {};

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {requestAuthenticationPasswordRecovery$Input} parameters {@link requestAuthenticationPasswordRecovery$Input}
 * @return {Ok} {@link Ok}
 */
export type requestAuthenticationPasswordRecovery = (
  parameters: requestAuthenticationPasswordRecovery$Input
) => Ok;

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type checkAuthenticationPasswordRecoveryCode$Input = {
  readonly _: "checkAuthenticationPasswordRecoveryCode";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;
};

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type checkAuthenticationPasswordRecoveryCode$DirectInput = {
  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;
};

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {checkAuthenticationPasswordRecoveryCode$Input} parameters {@link checkAuthenticationPasswordRecoveryCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationPasswordRecoveryCode = (
  parameters: checkAuthenticationPasswordRecoveryCode$Input
) => Ok;

/**
 * Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type recoverAuthenticationPassword$Input = {
  readonly _: "recoverAuthenticationPassword";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;
};

/**
 * Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 */
export type recoverAuthenticationPassword$DirectInput = {
  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;
};

/**
 * Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {recoverAuthenticationPassword$Input} parameters {@link recoverAuthenticationPassword$Input}
 * @return {Ok} {@link Ok}
 */
export type recoverAuthenticationPassword = (
  parameters: recoverAuthenticationPassword$Input
) => Ok;

/**
 * Sends Firebase Authentication SMS to the phone number of the user. Works only when the current authorization state is authorizationStateWaitCode and the server returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
 */
export type sendAuthenticationFirebaseSms$Input = {
  readonly _: "sendAuthenticationFirebaseSms";

  /**
   * SafetyNet Attestation API token for the Android application, or secret from push notification for the iOS application
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Sends Firebase Authentication SMS to the phone number of the user. Works only when the current authorization state is authorizationStateWaitCode and the server returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
 */
export type sendAuthenticationFirebaseSms$DirectInput = {
  /**
   * SafetyNet Attestation API token for the Android application, or secret from push notification for the iOS application
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Sends Firebase Authentication SMS to the phone number of the user. Works only when the current authorization state is authorizationStateWaitCode and the server returned code of the type authenticationCodeTypeFirebaseAndroid or authenticationCodeTypeFirebaseIos
 *
 * @param {sendAuthenticationFirebaseSms$Input} parameters {@link sendAuthenticationFirebaseSms$Input}
 * @return {Ok} {@link Ok}
 */
export type sendAuthenticationFirebaseSms = (
  parameters: sendAuthenticationFirebaseSms$Input
) => Ok;

/**
 * Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
 */
export type checkAuthenticationBotToken$Input = {
  readonly _: "checkAuthenticationBotToken";

  /**
   * The bot token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
 */
export type checkAuthenticationBotToken$DirectInput = {
  /**
   * The bot token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
 *
 * @param {checkAuthenticationBotToken$Input} parameters {@link checkAuthenticationBotToken$Input}
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationBotToken = (
  parameters: checkAuthenticationBotToken$Input
) => Ok;

/**
 * Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
 */
export type logOut$Input = {
  readonly _: "logOut";
};

/**
 * Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
 */
export type logOut$DirectInput = {};

/**
 * Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
 *
 * @param {logOut$Input} parameters {@link logOut$Input}
 * @return {Ok} {@link Ok}
 */
export type logOut = (parameters: logOut$Input) => Ok;

/**
 * Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
 */
export type close$Input = {
  readonly _: "close";
};

/**
 * Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
 */
export type close$DirectInput = {};

/**
 * Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
 *
 * @param {close$Input} parameters {@link close$Input}
 * @return {Ok} {@link Ok}
 */
export type close = (parameters: close$Input) => Ok;

/**
 * Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed.
 *
 * - After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
 */
export type destroy$Input = {
  readonly _: "destroy";
};

/**
 * Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed.
 *
 * - After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
 */
export type destroy$DirectInput = {};

/**
 * Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed.
 *
 * - After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
 *
 * @param {destroy$Input} parameters {@link destroy$Input}
 * @return {Ok} {@link Ok}
 */
export type destroy = (parameters: destroy$Input) => Ok;

/**
 * Confirms QR code authentication on another device. Returns created session on success
 */
export type confirmQrCodeAuthentication$Input = {
  readonly _: "confirmQrCodeAuthentication";

  /**
   * A link from a QR code. The link must be scanned by the in-app camera
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Confirms QR code authentication on another device. Returns created session on success
 */
export type confirmQrCodeAuthentication$DirectInput = {
  /**
   * A link from a QR code. The link must be scanned by the in-app camera
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Confirms QR code authentication on another device. Returns created session on success
 *
 * @param {confirmQrCodeAuthentication$Input} parameters {@link confirmQrCodeAuthentication$Input}
 * @return {Session} {@link Session}
 */
export type confirmQrCodeAuthentication = (
  parameters: confirmQrCodeAuthentication$Input
) => Session;

/**
 * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
 */
export type getCurrentState$Input = {
  readonly _: "getCurrentState";
};

/**
 * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
 */
export type getCurrentState$DirectInput = {};

/**
 * Returns all updates needed to restore current TDLib state, i.e. all actual updateAuthorizationState/updateUser/updateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
 *
 * @param {getCurrentState$Input} parameters {@link getCurrentState$Input}
 * @return {Updates} {@link Updates}
 */
export type getCurrentState = (parameters: getCurrentState$Input) => Updates;

/**
 * Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
 */
export type setDatabaseEncryptionKey$Input = {
  readonly _: "setDatabaseEncryptionKey";

  /**
   * New encryption key
   * @type {bytes$Input} {@link bytes}
   */
  readonly new_encryption_key?: bytes$Input;
};

/**
 * Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
 */
export type setDatabaseEncryptionKey$DirectInput = {
  /**
   * New encryption key
   * @type {bytes$Input} {@link bytes}
   */
  readonly new_encryption_key?: bytes$Input;
};

/**
 * Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
 *
 * @param {setDatabaseEncryptionKey$Input} parameters {@link setDatabaseEncryptionKey$Input}
 * @return {Ok} {@link Ok}
 */
export type setDatabaseEncryptionKey = (
  parameters: setDatabaseEncryptionKey$Input
) => Ok;

/**
 * Returns the current state of 2-step verification
 */
export type getPasswordState$Input = {
  readonly _: "getPasswordState";
};

/**
 * Returns the current state of 2-step verification
 */
export type getPasswordState$DirectInput = {};

/**
 * Returns the current state of 2-step verification
 *
 * @param {getPasswordState$Input} parameters {@link getPasswordState$Input}
 * @return {PasswordState} {@link PasswordState}
 */
export type getPasswordState = (parameters: getPasswordState$Input) => PasswordState;

/**
 * Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
 */
export type setPassword$Input = {
  readonly _: "setPassword";

  /**
   * Previous 2-step verification password of the user
   * @type {string} {@link string}
   */
  readonly old_password?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;

  /**
   * Pass true to change also the recovery email address
   * @type {Bool$Input} {@link Bool}
   */
  readonly set_recovery_email_address?: Bool$Input;

  /**
   * New recovery email address; may be empty
   * @type {string} {@link string}
   */
  readonly new_recovery_email_address?: string;
};

/**
 * Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
 */
export type setPassword$DirectInput = {
  /**
   * Previous 2-step verification password of the user
   * @type {string} {@link string}
   */
  readonly old_password?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;

  /**
   * Pass true to change also the recovery email address
   * @type {Bool$Input} {@link Bool}
   */
  readonly set_recovery_email_address?: Bool$Input;

  /**
   * New recovery email address; may be empty
   * @type {string} {@link string}
   */
  readonly new_recovery_email_address?: string;
};

/**
 * Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
 *
 * @param {setPassword$Input} parameters {@link setPassword$Input}
 * @return {PasswordState} {@link PasswordState}
 */
export type setPassword = (parameters: setPassword$Input) => PasswordState;

/**
 * Changes the login email address of the user. The email address can be changed only if the current user already has login email and passwordState.login_email_address_pattern is non-empty.
 *
 * - The change will not be applied until the new login email address is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead of a email address, call checkLoginEmailAddressCode directly
 */
export type setLoginEmailAddress$Input = {
  readonly _: "setLoginEmailAddress";

  /**
   * New login email address
   * @type {string} {@link string}
   */
  readonly new_login_email_address?: string;
};

/**
 * Changes the login email address of the user. The email address can be changed only if the current user already has login email and passwordState.login_email_address_pattern is non-empty.
 *
 * - The change will not be applied until the new login email address is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead of a email address, call checkLoginEmailAddressCode directly
 */
export type setLoginEmailAddress$DirectInput = {
  /**
   * New login email address
   * @type {string} {@link string}
   */
  readonly new_login_email_address?: string;
};

/**
 * Changes the login email address of the user. The email address can be changed only if the current user already has login email and passwordState.login_email_address_pattern is non-empty.
 *
 * - The change will not be applied until the new login email address is confirmed with checkLoginEmailAddressCode. To use Apple ID/Google ID instead of a email address, call checkLoginEmailAddressCode directly
 *
 * @param {setLoginEmailAddress$Input} parameters {@link setLoginEmailAddress$Input}
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type setLoginEmailAddress = (
  parameters: setLoginEmailAddress$Input
) => EmailAddressAuthenticationCodeInfo;

/**
 * Resends the login email address verification code
 */
export type resendLoginEmailAddressCode$Input = {
  readonly _: "resendLoginEmailAddressCode";
};

/**
 * Resends the login email address verification code
 */
export type resendLoginEmailAddressCode$DirectInput = {};

/**
 * Resends the login email address verification code
 *
 * @param {resendLoginEmailAddressCode$Input} parameters {@link resendLoginEmailAddressCode$Input}
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type resendLoginEmailAddressCode = (
  parameters: resendLoginEmailAddressCode$Input
) => EmailAddressAuthenticationCodeInfo;

/**
 * Checks the login email address authentication
 */
export type checkLoginEmailAddressCode$Input = {
  readonly _: "checkLoginEmailAddressCode";

  /**
   * Email address authentication to check
   * @type {EmailAddressAuthentication$Input} {@link EmailAddressAuthentication}
   */
  readonly code?: EmailAddressAuthentication$Input;
};

/**
 * Checks the login email address authentication
 */
export type checkLoginEmailAddressCode$DirectInput = {
  /**
   * Email address authentication to check
   * @type {EmailAddressAuthentication$Input} {@link EmailAddressAuthentication}
   */
  readonly code?: EmailAddressAuthentication$Input;
};

/**
 * Checks the login email address authentication
 *
 * @param {checkLoginEmailAddressCode$Input} parameters {@link checkLoginEmailAddressCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkLoginEmailAddressCode = (
  parameters: checkLoginEmailAddressCode$Input
) => Ok;

/**
 * Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
 */
export type getRecoveryEmailAddress$Input = {
  readonly _: "getRecoveryEmailAddress";

  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
 */
export type getRecoveryEmailAddress$DirectInput = {
  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
 *
 * @param {getRecoveryEmailAddress$Input} parameters {@link getRecoveryEmailAddress$Input}
 * @return {RecoveryEmailAddress} {@link RecoveryEmailAddress}
 */
export type getRecoveryEmailAddress = (
  parameters: getRecoveryEmailAddress$Input
) => RecoveryEmailAddress;

/**
 * Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
 *
 * - If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
 */
export type setRecoveryEmailAddress$Input = {
  readonly _: "setRecoveryEmailAddress";

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * New recovery email address
   * @type {string} {@link string}
   */
  readonly new_recovery_email_address?: string;
};

/**
 * Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
 *
 * - If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
 */
export type setRecoveryEmailAddress$DirectInput = {
  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * New recovery email address
   * @type {string} {@link string}
   */
  readonly new_recovery_email_address?: string;
};

/**
 * Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
 *
 * - If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
 *
 * @param {setRecoveryEmailAddress$Input} parameters {@link setRecoveryEmailAddress$Input}
 * @return {PasswordState} {@link PasswordState}
 */
export type setRecoveryEmailAddress = (
  parameters: setRecoveryEmailAddress$Input
) => PasswordState;

/**
 * Checks the 2-step verification recovery email address verification code
 */
export type checkRecoveryEmailAddressCode$Input = {
  readonly _: "checkRecoveryEmailAddressCode";

  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the 2-step verification recovery email address verification code
 */
export type checkRecoveryEmailAddressCode$DirectInput = {
  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the 2-step verification recovery email address verification code
 *
 * @param {checkRecoveryEmailAddressCode$Input} parameters {@link checkRecoveryEmailAddressCode$Input}
 * @return {PasswordState} {@link PasswordState}
 */
export type checkRecoveryEmailAddressCode = (
  parameters: checkRecoveryEmailAddressCode$Input
) => PasswordState;

/**
 * Resends the 2-step verification recovery email address verification code
 */
export type resendRecoveryEmailAddressCode$Input = {
  readonly _: "resendRecoveryEmailAddressCode";
};

/**
 * Resends the 2-step verification recovery email address verification code
 */
export type resendRecoveryEmailAddressCode$DirectInput = {};

/**
 * Resends the 2-step verification recovery email address verification code
 *
 * @param {resendRecoveryEmailAddressCode$Input} parameters {@link resendRecoveryEmailAddressCode$Input}
 * @return {PasswordState} {@link PasswordState}
 */
export type resendRecoveryEmailAddressCode = (
  parameters: resendRecoveryEmailAddressCode$Input
) => PasswordState;

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up
 */
export type requestPasswordRecovery$Input = {
  readonly _: "requestPasswordRecovery";
};

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up
 */
export type requestPasswordRecovery$DirectInput = {};

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up
 *
 * @param {requestPasswordRecovery$Input} parameters {@link requestPasswordRecovery$Input}
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type requestPasswordRecovery = (
  parameters: requestPasswordRecovery$Input
) => EmailAddressAuthenticationCodeInfo;

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid
 */
export type checkPasswordRecoveryCode$Input = {
  readonly _: "checkPasswordRecoveryCode";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;
};

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid
 */
export type checkPasswordRecoveryCode$DirectInput = {
  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;
};

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid
 *
 * @param {checkPasswordRecoveryCode$Input} parameters {@link checkPasswordRecoveryCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkPasswordRecoveryCode = (
  parameters: checkPasswordRecoveryCode$Input
) => Ok;

/**
 * Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
 */
export type recoverPassword$Input = {
  readonly _: "recoverPassword";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;
};

/**
 * Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
 */
export type recoverPassword$DirectInput = {
  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;
};

/**
 * Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
 *
 * @param {recoverPassword$Input} parameters {@link recoverPassword$Input}
 * @return {PasswordState} {@link PasswordState}
 */
export type recoverPassword = (parameters: recoverPassword$Input) => PasswordState;

/**
 * Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
 */
export type resetPassword$Input = {
  readonly _: "resetPassword";
};

/**
 * Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
 */
export type resetPassword$DirectInput = {};

/**
 * Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
 *
 * @param {resetPassword$Input} parameters {@link resetPassword$Input}
 * @return {ResetPasswordResult} {@link ResetPasswordResult}
 */
export type resetPassword = (parameters: resetPassword$Input) => ResetPasswordResult;

/**
 * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
 */
export type cancelPasswordReset$Input = {
  readonly _: "cancelPasswordReset";
};

/**
 * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
 */
export type cancelPasswordReset$DirectInput = {};

/**
 * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
 *
 * @param {cancelPasswordReset$Input} parameters {@link cancelPasswordReset$Input}
 * @return {Ok} {@link Ok}
 */
export type cancelPasswordReset = (parameters: cancelPasswordReset$Input) => Ok;

/**
 * Creates a new temporary password for processing payments
 */
export type createTemporaryPassword$Input = {
  readonly _: "createTemporaryPassword";

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Time during which the temporary password will be valid, in seconds; must be between 60 and 86400
   * @type {int32} {@link int32}
   */
  readonly valid_for?: int32;
};

/**
 * Creates a new temporary password for processing payments
 */
export type createTemporaryPassword$DirectInput = {
  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Time during which the temporary password will be valid, in seconds; must be between 60 and 86400
   * @type {int32} {@link int32}
   */
  readonly valid_for?: int32;
};

/**
 * Creates a new temporary password for processing payments
 *
 * @param {createTemporaryPassword$Input} parameters {@link createTemporaryPassword$Input}
 * @return {TemporaryPasswordState} {@link TemporaryPasswordState}
 */
export type createTemporaryPassword = (
  parameters: createTemporaryPassword$Input
) => TemporaryPasswordState;

/**
 * Returns information about the current temporary password
 */
export type getTemporaryPasswordState$Input = {
  readonly _: "getTemporaryPasswordState";
};

/**
 * Returns information about the current temporary password
 */
export type getTemporaryPasswordState$DirectInput = {};

/**
 * Returns information about the current temporary password
 *
 * @param {getTemporaryPasswordState$Input} parameters {@link getTemporaryPasswordState$Input}
 * @return {TemporaryPasswordState} {@link TemporaryPasswordState}
 */
export type getTemporaryPasswordState = (
  parameters: getTemporaryPasswordState$Input
) => TemporaryPasswordState;

/**
 * Returns the current user
 */
export type getMe$Input = {
  readonly _: "getMe";
};

/**
 * Returns the current user
 */
export type getMe$DirectInput = {};

/**
 * Returns the current user
 *
 * @param {getMe$Input} parameters {@link getMe$Input}
 * @return {User} {@link User}
 */
export type getMe = (parameters: getMe$Input) => User;

/**
 * Returns information about a user by their identifier. This is an offline request if the current user is not a bot
 */
export type getUser$Input = {
  readonly _: "getUser";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns information about a user by their identifier. This is an offline request if the current user is not a bot
 */
export type getUser$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns information about a user by their identifier. This is an offline request if the current user is not a bot
 *
 * @param {getUser$Input} parameters {@link getUser$Input}
 * @return {User} {@link User}
 */
export type getUser = (parameters: getUser$Input) => User;

/**
 * Returns full information about a user by their identifier
 */
export type getUserFullInfo$Input = {
  readonly _: "getUserFullInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns full information about a user by their identifier
 */
export type getUserFullInfo$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns full information about a user by their identifier
 *
 * @param {getUserFullInfo$Input} parameters {@link getUserFullInfo$Input}
 * @return {UserFullInfo} {@link UserFullInfo}
 */
export type getUserFullInfo = (parameters: getUserFullInfo$Input) => UserFullInfo;

/**
 * Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
 */
export type getBasicGroup$Input = {
  readonly _: "getBasicGroup";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
 */
export type getBasicGroup$DirectInput = {
  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
 *
 * @param {getBasicGroup$Input} parameters {@link getBasicGroup$Input}
 * @return {BasicGroup} {@link BasicGroup}
 */
export type getBasicGroup = (parameters: getBasicGroup$Input) => BasicGroup;

/**
 * Returns full information about a basic group by its identifier
 */
export type getBasicGroupFullInfo$Input = {
  readonly _: "getBasicGroupFullInfo";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * Returns full information about a basic group by its identifier
 */
export type getBasicGroupFullInfo$DirectInput = {
  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * Returns full information about a basic group by its identifier
 *
 * @param {getBasicGroupFullInfo$Input} parameters {@link getBasicGroupFullInfo$Input}
 * @return {BasicGroupFullInfo} {@link BasicGroupFullInfo}
 */
export type getBasicGroupFullInfo = (
  parameters: getBasicGroupFullInfo$Input
) => BasicGroupFullInfo;

/**
 * Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
 */
export type getSupergroup$Input = {
  readonly _: "getSupergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
 */
export type getSupergroup$DirectInput = {
  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
 *
 * @param {getSupergroup$Input} parameters {@link getSupergroup$Input}
 * @return {Supergroup} {@link Supergroup}
 */
export type getSupergroup = (parameters: getSupergroup$Input) => Supergroup;

/**
 * Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
 */
export type getSupergroupFullInfo$Input = {
  readonly _: "getSupergroupFullInfo";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
 */
export type getSupergroupFullInfo$DirectInput = {
  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
 *
 * @param {getSupergroupFullInfo$Input} parameters {@link getSupergroupFullInfo$Input}
 * @return {SupergroupFullInfo} {@link SupergroupFullInfo}
 */
export type getSupergroupFullInfo = (
  parameters: getSupergroupFullInfo$Input
) => SupergroupFullInfo;

/**
 * Returns information about a secret chat by its identifier. This is an offline request
 */
export type getSecretChat$Input = {
  readonly _: "getSecretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Returns information about a secret chat by its identifier. This is an offline request
 */
export type getSecretChat$DirectInput = {
  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Returns information about a secret chat by its identifier. This is an offline request
 *
 * @param {getSecretChat$Input} parameters {@link getSecretChat$Input}
 * @return {SecretChat} {@link SecretChat}
 */
export type getSecretChat = (parameters: getSecretChat$Input) => SecretChat;

/**
 * Returns information about a chat by its identifier; this is an offline request if the current user is not a bot
 */
export type getChat$Input = {
  readonly _: "getChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a chat by its identifier; this is an offline request if the current user is not a bot
 */
export type getChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a chat by its identifier; this is an offline request if the current user is not a bot
 *
 * @param {getChat$Input} parameters {@link getChat$Input}
 * @return {Chat} {@link Chat}
 */
export type getChat = (parameters: getChat$Input) => Chat;

/**
 * Returns information about a message
 */
export type getMessage$Input = {
  readonly _: "getMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message to get
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message
 */
export type getMessage$DirectInput = {
  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message to get
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message
 *
 * @param {getMessage$Input} parameters {@link getMessage$Input}
 * @return {Message} {@link Message}
 */
export type getMessage = (parameters: getMessage$Input) => Message;

/**
 * Returns information about a message, if it is available without sending network request. This is an offline request
 */
export type getMessageLocally$Input = {
  readonly _: "getMessageLocally";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message to get
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message, if it is available without sending network request. This is an offline request
 */
export type getMessageLocally$DirectInput = {
  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message to get
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message, if it is available without sending network request. This is an offline request
 *
 * @param {getMessageLocally$Input} parameters {@link getMessageLocally$Input}
 * @return {Message} {@link Message}
 */
export type getMessageLocally = (parameters: getMessageLocally$Input) => Message;

/**
 * Returns information about a non-bundled message that is replied by a given message. Also, returns the pinned message, the game message, the invoice message,
 *
 * - the message with a previously set same background, the giveaway message, and the topic creation message for messages of the types
 *
 * - messagePinMessage, messageGameScore, messagePaymentSuccessful, messageChatSetBackground, messagePremiumGiveawayCompleted and topic messages without non-bundled replied message respectively
 */
export type getRepliedMessage$Input = {
  readonly _: "getRepliedMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the reply message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a non-bundled message that is replied by a given message. Also, returns the pinned message, the game message, the invoice message,
 *
 * - the message with a previously set same background, the giveaway message, and the topic creation message for messages of the types
 *
 * - messagePinMessage, messageGameScore, messagePaymentSuccessful, messageChatSetBackground, messagePremiumGiveawayCompleted and topic messages without non-bundled replied message respectively
 */
export type getRepliedMessage$DirectInput = {
  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the reply message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a non-bundled message that is replied by a given message. Also, returns the pinned message, the game message, the invoice message,
 *
 * - the message with a previously set same background, the giveaway message, and the topic creation message for messages of the types
 *
 * - messagePinMessage, messageGameScore, messagePaymentSuccessful, messageChatSetBackground, messagePremiumGiveawayCompleted and topic messages without non-bundled replied message respectively
 *
 * @param {getRepliedMessage$Input} parameters {@link getRepliedMessage$Input}
 * @return {Message} {@link Message}
 */
export type getRepliedMessage = (parameters: getRepliedMessage$Input) => Message;

/**
 * Returns information about a newest pinned message in the chat
 */
export type getChatPinnedMessage$Input = {
  readonly _: "getChatPinnedMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a newest pinned message in the chat
 */
export type getChatPinnedMessage$DirectInput = {
  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a newest pinned message in the chat
 *
 * @param {getChatPinnedMessage$Input} parameters {@link getChatPinnedMessage$Input}
 * @return {Message} {@link Message}
 */
export type getChatPinnedMessage = (
  parameters: getChatPinnedMessage$Input
) => Message;

/**
 * Returns information about a message with the callback button that originated a callback query; for bots only
 */
export type getCallbackQueryMessage$Input = {
  readonly _: "getCallbackQueryMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the callback query
   * @type {int64$Input} {@link int64}
   */
  readonly callback_query_id?: int64$Input;
};

/**
 * Returns information about a message with the callback button that originated a callback query; for bots only
 */
export type getCallbackQueryMessage$DirectInput = {
  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the callback query
   * @type {int64$Input} {@link int64}
   */
  readonly callback_query_id?: int64$Input;
};

/**
 * Returns information about a message with the callback button that originated a callback query; for bots only
 *
 * @param {getCallbackQueryMessage$Input} parameters {@link getCallbackQueryMessage$Input}
 * @return {Message} {@link Message}
 */
export type getCallbackQueryMessage = (
  parameters: getCallbackQueryMessage$Input
) => Message;

/**
 * Returns information about messages. If a message is not found, returns null on the corresponding position of the result
 */
export type getMessages$Input = {
  readonly _: "getMessages";

  /**
   * Identifier of the chat the messages belong to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to get
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Returns information about messages. If a message is not found, returns null on the corresponding position of the result
 */
export type getMessages$DirectInput = {
  /**
   * Identifier of the chat the messages belong to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to get
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Returns information about messages. If a message is not found, returns null on the corresponding position of the result
 *
 * @param {getMessages$Input} parameters {@link getMessages$Input}
 * @return {Messages} {@link Messages}
 */
export type getMessages = (parameters: getMessages$Input) => Messages;

/**
 * Returns information about a message thread. Can be used only if message.can_get_message_thread == true
 */
export type getMessageThread$Input = {
  readonly _: "getMessageThread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message thread. Can be used only if message.can_get_message_thread == true
 */
export type getMessageThread$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message thread. Can be used only if message.can_get_message_thread == true
 *
 * @param {getMessageThread$Input} parameters {@link getMessageThread$Input}
 * @return {MessageThreadInfo} {@link MessageThreadInfo}
 */
export type getMessageThread = (
  parameters: getMessageThread$Input
) => MessageThreadInfo;

/**
 * Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
 */
export type getMessageViewers$Input = {
  readonly _: "getMessageViewers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
 */
export type getMessageViewers$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
 *
 * @param {getMessageViewers$Input} parameters {@link getMessageViewers$Input}
 * @return {MessageViewers} {@link MessageViewers}
 */
export type getMessageViewers = (
  parameters: getMessageViewers$Input
) => MessageViewers;

/**
 * Returns information about a file; this is an offline request
 */
export type getFile$Input = {
  readonly _: "getFile";

  /**
   * Identifier of the file to get
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Returns information about a file; this is an offline request
 */
export type getFile$DirectInput = {
  /**
   * Identifier of the file to get
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Returns information about a file; this is an offline request
 *
 * @param {getFile$Input} parameters {@link getFile$Input}
 * @return {File} {@link File}
 */
export type getFile = (parameters: getFile$Input) => File;

/**
 * Returns information about a file by its remote identifier; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
 *
 * - For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
 */
export type getRemoteFile$Input = {
  readonly _: "getRemoteFile";

  /**
   * Remote identifier of the file to get
   * @type {string} {@link string}
   */
  readonly remote_file_id?: string;

  /**
   * File type; pass null if unknown
   * @type {FileType$Input} {@link FileType}
   */
  readonly file_type?: FileType$Input | null;
};

/**
 * Returns information about a file by its remote identifier; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
 *
 * - For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
 */
export type getRemoteFile$DirectInput = {
  /**
   * Remote identifier of the file to get
   * @type {string} {@link string}
   */
  readonly remote_file_id?: string;

  /**
   * File type; pass null if unknown
   * @type {FileType$Input} {@link FileType}
   */
  readonly file_type?: FileType$Input | null;
};

/**
 * Returns information about a file by its remote identifier; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
 *
 * - For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
 *
 * @param {getRemoteFile$Input} parameters {@link getRemoteFile$Input}
 * @return {File} {@link File}
 */
export type getRemoteFile = (parameters: getRemoteFile$Input) => File;

/**
 * Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
 */
export type loadChats$Input = {
  readonly _: "loadChats";

  /**
   * The chat list in which to load chats; pass null to load chats from the main chat list
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input | null;

  /**
   * The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
 */
export type loadChats$DirectInput = {
  /**
   * The chat list in which to load chats; pass null to load chats from the main chat list
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input | null;

  /**
   * The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
 *
 * @param {loadChats$Input} parameters {@link loadChats$Input}
 * @return {Ok} {@link Ok}
 */
export type loadChats = (parameters: loadChats$Input) => Ok;

/**
 * Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
 */
export type getChats$Input = {
  readonly _: "getChats";

  /**
   * The chat list in which to return chats; pass null to get chats from the main chat list
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input | null;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
 */
export type getChats$DirectInput = {
  /**
   * The chat list in which to return chats; pass null to get chats from the main chat list
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input | null;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
 *
 * @param {getChats$Input} parameters {@link getChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getChats = (parameters: getChats$Input) => Chats;

/**
 * Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise, an error is returned
 */
export type searchPublicChat$Input = {
  readonly _: "searchPublicChat";

  /**
   * Username to be resolved
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise, an error is returned
 */
export type searchPublicChat$DirectInput = {
  /**
   * Username to be resolved
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise, an error is returned
 *
 * @param {searchPublicChat$Input} parameters {@link searchPublicChat$Input}
 * @return {Chat} {@link Chat}
 */
export type searchPublicChat = (parameters: searchPublicChat$Input) => Chat;

/**
 * Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
 *
 * - Excludes private chats with contacts and chats from the chat list from the results
 */
export type searchPublicChats$Input = {
  readonly _: "searchPublicChats";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
 *
 * - Excludes private chats with contacts and chats from the chat list from the results
 */
export type searchPublicChats$DirectInput = {
  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
 *
 * - Excludes private chats with contacts and chats from the chat list from the results
 *
 * @param {searchPublicChats$Input} parameters {@link searchPublicChats$Input}
 * @return {Chats} {@link Chats}
 */
export type searchPublicChats = (parameters: searchPublicChats$Input) => Chats;

/**
 * Searches for the specified query in the title and username of already known chats; this is an offline request. Returns chats in the order seen in the main chat list
 */
export type searchChats$Input = {
  readonly _: "searchChats";

  /**
   * Query to search for. If the query is empty, returns up to 50 recently found chats
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of already known chats; this is an offline request. Returns chats in the order seen in the main chat list
 */
export type searchChats$DirectInput = {
  /**
   * Query to search for. If the query is empty, returns up to 50 recently found chats
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of already known chats; this is an offline request. Returns chats in the order seen in the main chat list
 *
 * @param {searchChats$Input} parameters {@link searchChats$Input}
 * @return {Chats} {@link Chats}
 */
export type searchChats = (parameters: searchChats$Input) => Chats;

/**
 * Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
 */
export type searchChatsOnServer$Input = {
  readonly _: "searchChatsOnServer";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
 */
export type searchChatsOnServer$DirectInput = {
  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
 *
 * @param {searchChatsOnServer$Input} parameters {@link searchChatsOnServer$Input}
 * @return {Chats} {@link Chats}
 */
export type searchChatsOnServer = (parameters: searchChatsOnServer$Input) => Chats;

/**
 * Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
 *
 * - The request must be sent again every 25 seconds with adjusted location to not miss new chats
 */
export type searchChatsNearby$Input = {
  readonly _: "searchChatsNearby";

  /**
   * Current user location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
 *
 * - The request must be sent again every 25 seconds with adjusted location to not miss new chats
 */
export type searchChatsNearby$DirectInput = {
  /**
   * Current user location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby.
 *
 * - The request must be sent again every 25 seconds with adjusted location to not miss new chats
 *
 * @param {searchChatsNearby$Input} parameters {@link searchChatsNearby$Input}
 * @return {ChatsNearby} {@link ChatsNearby}
 */
export type searchChatsNearby = (parameters: searchChatsNearby$Input) => ChatsNearby;

/**
 * Returns a list of chats similar to the given chat
 */
export type getChatSimilarChats$Input = {
  readonly _: "getChatSimilarChats";

  /**
   * Identifier of the target chat; must be an identifier of a channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a list of chats similar to the given chat
 */
export type getChatSimilarChats$DirectInput = {
  /**
   * Identifier of the target chat; must be an identifier of a channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a list of chats similar to the given chat
 *
 * @param {getChatSimilarChats$Input} parameters {@link getChatSimilarChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getChatSimilarChats = (parameters: getChatSimilarChats$Input) => Chats;

/**
 * Returns approximate number of chats similar to the given chat
 */
export type getChatSimilarChatCount$Input = {
  readonly _: "getChatSimilarChatCount";

  /**
   * Identifier of the target chat; must be an identifier of a channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to get the number of chats without sending network requests, or -1 if the number of chats is unknown locally
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_local?: Bool$Input;
};

/**
 * Returns approximate number of chats similar to the given chat
 */
export type getChatSimilarChatCount$DirectInput = {
  /**
   * Identifier of the target chat; must be an identifier of a channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to get the number of chats without sending network requests, or -1 if the number of chats is unknown locally
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_local?: Bool$Input;
};

/**
 * Returns approximate number of chats similar to the given chat
 *
 * @param {getChatSimilarChatCount$Input} parameters {@link getChatSimilarChatCount$Input}
 * @return {Count} {@link Count}
 */
export type getChatSimilarChatCount = (
  parameters: getChatSimilarChatCount$Input
) => Count;

/**
 * Informs TDLib that a chat was opened from the list of similar chats. The method is independent from openChat and closeChat methods
 */
export type openChatSimilarChat$Input = {
  readonly _: "openChatSimilarChat";

  /**
   * Identifier of the original chat, which similar chats were requested
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the opened chat
   * @type {int53} {@link int53}
   */
  readonly opened_chat_id?: int53;
};

/**
 * Informs TDLib that a chat was opened from the list of similar chats. The method is independent from openChat and closeChat methods
 */
export type openChatSimilarChat$DirectInput = {
  /**
   * Identifier of the original chat, which similar chats were requested
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the opened chat
   * @type {int53} {@link int53}
   */
  readonly opened_chat_id?: int53;
};

/**
 * Informs TDLib that a chat was opened from the list of similar chats. The method is independent from openChat and closeChat methods
 *
 * @param {openChatSimilarChat$Input} parameters {@link openChatSimilarChat$Input}
 * @return {Ok} {@link Ok}
 */
export type openChatSimilarChat = (parameters: openChatSimilarChat$Input) => Ok;

/**
 * Returns a list of frequently used chats
 */
export type getTopChats$Input = {
  readonly _: "getTopChats";

  /**
   * Category of chats to be returned
   * @type {TopChatCategory$Input} {@link TopChatCategory}
   */
  readonly category?: TopChatCategory$Input;

  /**
   * The maximum number of chats to be returned; up to 30
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of frequently used chats
 */
export type getTopChats$DirectInput = {
  /**
   * Category of chats to be returned
   * @type {TopChatCategory$Input} {@link TopChatCategory}
   */
  readonly category?: TopChatCategory$Input;

  /**
   * The maximum number of chats to be returned; up to 30
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of frequently used chats
 *
 * @param {getTopChats$Input} parameters {@link getTopChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getTopChats = (parameters: getTopChats$Input) => Chats;

/**
 * Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
 */
export type removeTopChat$Input = {
  readonly _: "removeTopChat";

  /**
   * Category of frequently used chats
   * @type {TopChatCategory$Input} {@link TopChatCategory}
   */
  readonly category?: TopChatCategory$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
 */
export type removeTopChat$DirectInput = {
  /**
   * Category of frequently used chats
   * @type {TopChatCategory$Input} {@link TopChatCategory}
   */
  readonly category?: TopChatCategory$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
 *
 * @param {removeTopChat$Input} parameters {@link removeTopChat$Input}
 * @return {Ok} {@link Ok}
 */
export type removeTopChat = (parameters: removeTopChat$Input) => Ok;

/**
 * Searches for the specified query in the title and username of up to 50 recently found chats; this is an offline request
 */
export type searchRecentlyFoundChats$Input = {
  readonly _: "searchRecentlyFoundChats";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of up to 50 recently found chats; this is an offline request
 */
export type searchRecentlyFoundChats$DirectInput = {
  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of up to 50 recently found chats; this is an offline request
 *
 * @param {searchRecentlyFoundChats$Input} parameters {@link searchRecentlyFoundChats$Input}
 * @return {Chats} {@link Chats}
 */
export type searchRecentlyFoundChats = (
  parameters: searchRecentlyFoundChats$Input
) => Chats;

/**
 * Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
 */
export type addRecentlyFoundChat$Input = {
  readonly _: "addRecentlyFoundChat";

  /**
   * Identifier of the chat to add
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
 */
export type addRecentlyFoundChat$DirectInput = {
  /**
   * Identifier of the chat to add
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
 *
 * @param {addRecentlyFoundChat$Input} parameters {@link addRecentlyFoundChat$Input}
 * @return {Ok} {@link Ok}
 */
export type addRecentlyFoundChat = (parameters: addRecentlyFoundChat$Input) => Ok;

/**
 * Removes a chat from the list of recently found chats
 */
export type removeRecentlyFoundChat$Input = {
  readonly _: "removeRecentlyFoundChat";

  /**
   * Identifier of the chat to be removed
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat from the list of recently found chats
 */
export type removeRecentlyFoundChat$DirectInput = {
  /**
   * Identifier of the chat to be removed
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat from the list of recently found chats
 *
 * @param {removeRecentlyFoundChat$Input} parameters {@link removeRecentlyFoundChat$Input}
 * @return {Ok} {@link Ok}
 */
export type removeRecentlyFoundChat = (
  parameters: removeRecentlyFoundChat$Input
) => Ok;

/**
 * Clears the list of recently found chats
 */
export type clearRecentlyFoundChats$Input = {
  readonly _: "clearRecentlyFoundChats";
};

/**
 * Clears the list of recently found chats
 */
export type clearRecentlyFoundChats$DirectInput = {};

/**
 * Clears the list of recently found chats
 *
 * @param {clearRecentlyFoundChats$Input} parameters {@link clearRecentlyFoundChats$Input}
 * @return {Ok} {@link Ok}
 */
export type clearRecentlyFoundChats = (
  parameters: clearRecentlyFoundChats$Input
) => Ok;

/**
 * Returns recently opened chats; this is an offline request. Returns chats in the order of last opening
 */
export type getRecentlyOpenedChats$Input = {
  readonly _: "getRecentlyOpenedChats";

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns recently opened chats; this is an offline request. Returns chats in the order of last opening
 */
export type getRecentlyOpenedChats$DirectInput = {
  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns recently opened chats; this is an offline request. Returns chats in the order of last opening
 *
 * @param {getRecentlyOpenedChats$Input} parameters {@link getRecentlyOpenedChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getRecentlyOpenedChats = (
  parameters: getRecentlyOpenedChats$Input
) => Chats;

/**
 * Checks whether a username can be set for a chat
 */
export type checkChatUsername$Input = {
  readonly _: "checkChatUsername";

  /**
   * Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a private chat with self, or 0 if the chat is being created
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Username to be checked
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Checks whether a username can be set for a chat
 */
export type checkChatUsername$DirectInput = {
  /**
   * Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a private chat with self, or 0 if the chat is being created
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Username to be checked
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Checks whether a username can be set for a chat
 *
 * @param {checkChatUsername$Input} parameters {@link checkChatUsername$Input}
 * @return {CheckChatUsernameResult} {@link CheckChatUsernameResult}
 */
export type checkChatUsername = (
  parameters: checkChatUsername$Input
) => CheckChatUsernameResult;

/**
 * Returns a list of public chats of the specified type, owned by the user
 */
export type getCreatedPublicChats$Input = {
  readonly _: "getCreatedPublicChats";

  /**
   * Type of the public chats to return
   * @type {PublicChatType$Input} {@link PublicChatType}
   */
  readonly type?: PublicChatType$Input;
};

/**
 * Returns a list of public chats of the specified type, owned by the user
 */
export type getCreatedPublicChats$DirectInput = {
  /**
   * Type of the public chats to return
   * @type {PublicChatType$Input} {@link PublicChatType}
   */
  readonly type?: PublicChatType$Input;
};

/**
 * Returns a list of public chats of the specified type, owned by the user
 *
 * @param {getCreatedPublicChats$Input} parameters {@link getCreatedPublicChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getCreatedPublicChats = (
  parameters: getCreatedPublicChats$Input
) => Chats;

/**
 * Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium
 */
export type checkCreatedPublicChatsLimit$Input = {
  readonly _: "checkCreatedPublicChatsLimit";

  /**
   * Type of the public chats, for which to check the limit
   * @type {PublicChatType$Input} {@link PublicChatType}
   */
  readonly type?: PublicChatType$Input;
};

/**
 * Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium
 */
export type checkCreatedPublicChatsLimit$DirectInput = {
  /**
   * Type of the public chats, for which to check the limit
   * @type {PublicChatType$Input} {@link PublicChatType}
   */
  readonly type?: PublicChatType$Input;
};

/**
 * Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium
 *
 * @param {checkCreatedPublicChatsLimit$Input} parameters {@link checkCreatedPublicChatsLimit$Input}
 * @return {Ok} {@link Ok}
 */
export type checkCreatedPublicChatsLimit = (
  parameters: checkCreatedPublicChatsLimit$Input
) => Ok;

/**
 * Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group.
 *
 * - To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
 */
export type getSuitableDiscussionChats$Input = {
  readonly _: "getSuitableDiscussionChats";
};

/**
 * Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group.
 *
 * - To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
 */
export type getSuitableDiscussionChats$DirectInput = {};

/**
 * Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group.
 *
 * - To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
 *
 * @param {getSuitableDiscussionChats$Input} parameters {@link getSuitableDiscussionChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getSuitableDiscussionChats = (
  parameters: getSuitableDiscussionChats$Input
) => Chats;

/**
 * Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
 */
export type getInactiveSupergroupChats$Input = {
  readonly _: "getInactiveSupergroupChats";
};

/**
 * Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
 */
export type getInactiveSupergroupChats$DirectInput = {};

/**
 * Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
 *
 * @param {getInactiveSupergroupChats$Input} parameters {@link getInactiveSupergroupChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getInactiveSupergroupChats = (
  parameters: getInactiveSupergroupChats$Input
) => Chats;

/**
 * Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
 */
export type getGroupsInCommon$Input = {
  readonly _: "getGroupsInCommon";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Chat identifier starting from which to return chats; use 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_chat_id?: int53;

  /**
   * The maximum number of chats to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
 */
export type getGroupsInCommon$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Chat identifier starting from which to return chats; use 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_chat_id?: int53;

  /**
   * The maximum number of chats to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
 *
 * @param {getGroupsInCommon$Input} parameters {@link getGroupsInCommon$Input}
 * @return {Chats} {@link Chats}
 */
export type getGroupsInCommon = (parameters: getGroupsInCommon$Input) => Chats;

/**
 * Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
 *
 * - For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
 */
export type getChatHistory$Input = {
  readonly _: "getChatHistory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset.
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to get only messages that are available without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
 *
 * - For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
 */
export type getChatHistory$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset.
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to get only messages that are available without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
 *
 * - For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
 *
 * @param {getChatHistory$Input} parameters {@link getChatHistory$Input}
 * @return {Messages} {@link Messages}
 */
export type getChatHistory = (parameters: getChatHistory$Input) => Messages;

/**
 * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
 *
 * - The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 */
export type getMessageThreadHistory$Input = {
  readonly _: "getMessageThreadHistory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier, which thread history needs to be returned
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset.
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
 *
 * - The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 */
export type getMessageThreadHistory$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier, which thread history needs to be returned
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset.
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
 *
 * - The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 *
 * @param {getMessageThreadHistory$Input} parameters {@link getMessageThreadHistory$Input}
 * @return {Messages} {@link Messages}
 */
export type getMessageThreadHistory = (
  parameters: getMessageThreadHistory$Input
) => Messages;

/**
 * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
 */
export type deleteChatHistory$Input = {
  readonly _: "deleteChatHistory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to remove the chat from all chat lists
   * @type {Bool$Input} {@link Bool}
   */
  readonly remove_from_chat_list?: Bool$Input;

  /**
   * Pass true to delete chat history for all users
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
 */
export type deleteChatHistory$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to remove the chat from all chat lists
   * @type {Bool$Input} {@link Bool}
   */
  readonly remove_from_chat_list?: Bool$Input;

  /**
   * Pass true to delete chat history for all users
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
 *
 * @param {deleteChatHistory$Input} parameters {@link deleteChatHistory$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatHistory = (parameters: deleteChatHistory$Input) => Ok;

/**
 * Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members.
 *
 * - Use the field chat.can_be_deleted_for_all_users to find whether the method can be applied to the chat
 */
export type deleteChat$Input = {
  readonly _: "deleteChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members.
 *
 * - Use the field chat.can_be_deleted_for_all_users to find whether the method can be applied to the chat
 */
export type deleteChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members.
 *
 * - Use the field chat.can_be_deleted_for_all_users to find whether the method can be applied to the chat
 *
 * @param {deleteChat$Input} parameters {@link deleteChat$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChat = (parameters: deleteChat$Input) => Ok;

/**
 * Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
 *
 * - (searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
 *
 * - A combination of query, sender_id, filter and message_thread_id search criteria is expected to be supported, only if it is required for Telegram official application implementation
 */
export type searchChatMessages$Input = {
  readonly _: "searchChatMessages";

  /**
   * Identifier of the chat in which to search messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of the sender of messages to search for; pass null to search for messages from any sender. Not supported in secret chats
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input | null;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset.
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input | null;

  /**
   * If not 0, only messages in the specified thread will be returned; supergroups only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
 *
 * - (searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
 *
 * - A combination of query, sender_id, filter and message_thread_id search criteria is expected to be supported, only if it is required for Telegram official application implementation
 */
export type searchChatMessages$DirectInput = {
  /**
   * Identifier of the chat in which to search messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of the sender of messages to search for; pass null to search for messages from any sender. Not supported in secret chats
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input | null;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset.
   *
   * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input | null;

  /**
   * If not 0, only messages in the specified thread will be returned; supergroups only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
 *
 * - (searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
 *
 * - A combination of query, sender_id, filter and message_thread_id search criteria is expected to be supported, only if it is required for Telegram official application implementation
 *
 * @param {searchChatMessages$Input} parameters {@link searchChatMessages$Input}
 * @return {FoundChatMessages} {@link FoundChatMessages}
 */
export type searchChatMessages = (
  parameters: searchChatMessages$Input
) => FoundChatMessages;

/**
 * Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
 *
 * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
 */
export type searchMessages$Input = {
  readonly _: "searchMessages";

  /**
   * Chat list in which to search messages; pass null to search in all chats regardless of their chat list. Only Main and Archive chat lists are supported
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input | null;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages. Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input | null;

  /**
   * If not 0, the minimum date of the messages to return
   * @type {int32} {@link int32}
   */
  readonly min_date?: int32;

  /**
   * If not 0, the maximum date of the messages to return
   * @type {int32} {@link int32}
   */
  readonly max_date?: int32;
};

/**
 * Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
 *
 * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
 */
export type searchMessages$DirectInput = {
  /**
   * Chat list in which to search messages; pass null to search in all chats regardless of their chat list. Only Main and Archive chat lists are supported
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input | null;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages. Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input | null;

  /**
   * If not 0, the minimum date of the messages to return
   * @type {int32} {@link int32}
   */
  readonly min_date?: int32;

  /**
   * If not 0, the maximum date of the messages to return
   * @type {int32} {@link int32}
   */
  readonly max_date?: int32;
};

/**
 * Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
 *
 * - For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
 *
 * @param {searchMessages$Input} parameters {@link searchMessages$Input}
 * @return {FoundMessages} {@link FoundMessages}
 */
export type searchMessages = (parameters: searchMessages$Input) => FoundMessages;

/**
 * Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
 */
export type searchSecretMessages$Input = {
  readonly _: "searchSecretMessages";

  /**
   * Identifier of the chat in which to search. Specify 0 to search in all secret chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for. If empty, searchChatMessages must be used instead
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input | null;
};

/**
 * Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
 */
export type searchSecretMessages$DirectInput = {
  /**
   * Identifier of the chat in which to search. Specify 0 to search in all secret chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for. If empty, searchChatMessages must be used instead
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input | null;
};

/**
 * Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
 *
 * @param {searchSecretMessages$Input} parameters {@link searchSecretMessages$Input}
 * @return {FoundMessages} {@link FoundMessages}
 */
export type searchSecretMessages = (
  parameters: searchSecretMessages$Input
) => FoundMessages;

/**
 * Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 */
export type searchCallMessages$Input = {
  readonly _: "searchCallMessages";

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to search only for messages with missed/declined calls
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_missed?: Bool$Input;
};

/**
 * Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 */
export type searchCallMessages$DirectInput = {
  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to search only for messages with missed/declined calls
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_missed?: Bool$Input;
};

/**
 * Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 *
 * @param {searchCallMessages$Input} parameters {@link searchCallMessages$Input}
 * @return {FoundMessages} {@link FoundMessages}
 */
export type searchCallMessages = (
  parameters: searchCallMessages$Input
) => FoundMessages;

/**
 * Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order
 */
export type searchOutgoingDocumentMessages$Input = {
  readonly _: "searchOutgoingDocumentMessages";

  /**
   * Query to search for in document file name and message caption
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of messages to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order
 */
export type searchOutgoingDocumentMessages$DirectInput = {
  /**
   * Query to search for in document file name and message caption
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of messages to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order
 *
 * @param {searchOutgoingDocumentMessages$Input} parameters {@link searchOutgoingDocumentMessages$Input}
 * @return {FoundMessages} {@link FoundMessages}
 */
export type searchOutgoingDocumentMessages = (
  parameters: searchOutgoingDocumentMessages$Input
) => FoundMessages;

/**
 * Deletes all call messages
 */
export type deleteAllCallMessages$Input = {
  readonly _: "deleteAllCallMessages";

  /**
   * Pass true to delete the messages for all users
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all call messages
 */
export type deleteAllCallMessages$DirectInput = {
  /**
   * Pass true to delete the messages for all users
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all call messages
 *
 * @param {deleteAllCallMessages$Input} parameters {@link deleteAllCallMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteAllCallMessages = (parameters: deleteAllCallMessages$Input) => Ok;

/**
 * Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
 */
export type searchChatRecentLocationMessages$Input = {
  readonly _: "searchChatRecentLocationMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The maximum number of messages to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
 */
export type searchChatRecentLocationMessages$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The maximum number of messages to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
 *
 * @param {searchChatRecentLocationMessages$Input} parameters {@link searchChatRecentLocationMessages$Input}
 * @return {Messages} {@link Messages}
 */
export type searchChatRecentLocationMessages = (
  parameters: searchChatRecentLocationMessages$Input
) => Messages;

/**
 * Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
 */
export type getActiveLiveLocationMessages$Input = {
  readonly _: "getActiveLiveLocationMessages";
};

/**
 * Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
 */
export type getActiveLiveLocationMessages$DirectInput = {};

/**
 * Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
 *
 * @param {getActiveLiveLocationMessages$Input} parameters {@link getActiveLiveLocationMessages$Input}
 * @return {Messages} {@link Messages}
 */
export type getActiveLiveLocationMessages = (
  parameters: getActiveLiveLocationMessages$Input
) => Messages;

/**
 * Returns the last message sent in a chat no later than the specified date
 */
export type getChatMessageByDate$Input = {
  readonly _: "getChatMessageByDate";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Point in time (Unix timestamp) relative to which to search for messages
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * Returns the last message sent in a chat no later than the specified date
 */
export type getChatMessageByDate$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Point in time (Unix timestamp) relative to which to search for messages
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * Returns the last message sent in a chat no later than the specified date
 *
 * @param {getChatMessageByDate$Input} parameters {@link getChatMessageByDate$Input}
 * @return {Message} {@link Message}
 */
export type getChatMessageByDate = (
  parameters: getChatMessageByDate$Input
) => Message;

/**
 * Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
 *
 * - Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
 */
export type getChatSparseMessagePositions$Input = {
  readonly _: "getChatSparseMessagePositions";

  /**
   * Identifier of the chat in which to return information about message positions
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * The message identifier from which to return information about message positions
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * The expected number of message positions to be returned; 50-2000. A smaller number of positions can be returned, if there are not enough appropriate messages
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
 *
 * - Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
 */
export type getChatSparseMessagePositions$DirectInput = {
  /**
   * Identifier of the chat in which to return information about message positions
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * The message identifier from which to return information about message positions
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * The expected number of message positions to be returned; 50-2000. A smaller number of positions can be returned, if there are not enough appropriate messages
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
 *
 * - Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
 *
 * @param {getChatSparseMessagePositions$Input} parameters {@link getChatSparseMessagePositions$Input}
 * @return {MessagePositions} {@link MessagePositions}
 */
export type getChatSparseMessagePositions = (
  parameters: getChatSparseMessagePositions$Input
) => MessagePositions;

/**
 * Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
 */
export type getChatMessageCalendar$Input = {
  readonly _: "getChatMessageCalendar";

  /**
   * Identifier of the chat in which to return information about messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * The message identifier from which to return information about messages; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;
};

/**
 * Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
 */
export type getChatMessageCalendar$DirectInput = {
  /**
   * Identifier of the chat in which to return information about messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * The message identifier from which to return information about messages; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;
};

/**
 * Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
 *
 * @param {getChatMessageCalendar$Input} parameters {@link getChatMessageCalendar$Input}
 * @return {MessageCalendar} {@link MessageCalendar}
 */
export type getChatMessageCalendar = (
  parameters: getChatMessageCalendar$Input
) => MessageCalendar;

/**
 * Returns approximate number of messages of the specified type in the chat
 */
export type getChatMessageCount$Input = {
  readonly _: "getChatMessageCount";

  /**
   * Identifier of the chat in which to count messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content; searchMessagesFilterEmpty is unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * Pass true to get the number of messages without sending network requests, or -1 if the number of messages is unknown locally
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_local?: Bool$Input;
};

/**
 * Returns approximate number of messages of the specified type in the chat
 */
export type getChatMessageCount$DirectInput = {
  /**
   * Identifier of the chat in which to count messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content; searchMessagesFilterEmpty is unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * Pass true to get the number of messages without sending network requests, or -1 if the number of messages is unknown locally
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_local?: Bool$Input;
};

/**
 * Returns approximate number of messages of the specified type in the chat
 *
 * @param {getChatMessageCount$Input} parameters {@link getChatMessageCount$Input}
 * @return {Count} {@link Count}
 */
export type getChatMessageCount = (parameters: getChatMessageCount$Input) => Count;

/**
 * Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats
 */
export type getChatMessagePosition$Input = {
  readonly _: "getChatMessagePosition";

  /**
   * Identifier of the chat in which to find message position
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * If not 0, only messages in the specified thread will be considered; supergroups only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats
 */
export type getChatMessagePosition$DirectInput = {
  /**
   * Identifier of the chat in which to find message position
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * If not 0, only messages in the specified thread will be considered; supergroups only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats
 *
 * @param {getChatMessagePosition$Input} parameters {@link getChatMessagePosition$Input}
 * @return {Count} {@link Count}
 */
export type getChatMessagePosition = (
  parameters: getChatMessagePosition$Input
) => Count;

/**
 * Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
 */
export type getChatScheduledMessages$Input = {
  readonly _: "getChatScheduledMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
 */
export type getChatScheduledMessages$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
 *
 * @param {getChatScheduledMessages$Input} parameters {@link getChatScheduledMessages$Input}
 * @return {Messages} {@link Messages}
 */
export type getChatScheduledMessages = (
  parameters: getChatScheduledMessages$Input
) => Messages;

/**
 * Returns sponsored messages to be shown in a chat; for channel chats only
 */
export type getChatSponsoredMessages$Input = {
  readonly _: "getChatSponsoredMessages";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns sponsored messages to be shown in a chat; for channel chats only
 */
export type getChatSponsoredMessages$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns sponsored messages to be shown in a chat; for channel chats only
 *
 * @param {getChatSponsoredMessages$Input} parameters {@link getChatSponsoredMessages$Input}
 * @return {SponsoredMessages} {@link SponsoredMessages}
 */
export type getChatSponsoredMessages = (
  parameters: getChatSponsoredMessages$Input
) => SponsoredMessages;

/**
 * Informs TDLib that the user opened the sponsored chat via the button, the name, the photo, or a mention in the sponsored message
 */
export type clickChatSponsoredMessage$Input = {
  readonly _: "clickChatSponsoredMessage";

  /**
   * Chat identifier of the sponsored message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sponsored message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that the user opened the sponsored chat via the button, the name, the photo, or a mention in the sponsored message
 */
export type clickChatSponsoredMessage$DirectInput = {
  /**
   * Chat identifier of the sponsored message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sponsored message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that the user opened the sponsored chat via the button, the name, the photo, or a mention in the sponsored message
 *
 * @param {clickChatSponsoredMessage$Input} parameters {@link clickChatSponsoredMessage$Input}
 * @return {Ok} {@link Ok}
 */
export type clickChatSponsoredMessage = (
  parameters: clickChatSponsoredMessage$Input
) => Ok;

/**
 * Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
 */
export type removeNotification$Input = {
  readonly _: "removeNotification";

  /**
   * Identifier of notification group to which the notification belongs
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * Identifier of removed notification
   * @type {int32} {@link int32}
   */
  readonly notification_id?: int32;
};

/**
 * Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
 */
export type removeNotification$DirectInput = {
  /**
   * Identifier of notification group to which the notification belongs
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * Identifier of removed notification
   * @type {int32} {@link int32}
   */
  readonly notification_id?: int32;
};

/**
 * Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
 *
 * @param {removeNotification$Input} parameters {@link removeNotification$Input}
 * @return {Ok} {@link Ok}
 */
export type removeNotification = (parameters: removeNotification$Input) => Ok;

/**
 * Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
 */
export type removeNotificationGroup$Input = {
  readonly _: "removeNotificationGroup";

  /**
   * Notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * The maximum identifier of removed notifications
   * @type {int32} {@link int32}
   */
  readonly max_notification_id?: int32;
};

/**
 * Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
 */
export type removeNotificationGroup$DirectInput = {
  /**
   * Notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * The maximum identifier of removed notifications
   * @type {int32} {@link int32}
   */
  readonly max_notification_id?: int32;
};

/**
 * Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
 *
 * @param {removeNotificationGroup$Input} parameters {@link removeNotificationGroup$Input}
 * @return {Ok} {@link Ok}
 */
export type removeNotificationGroup = (
  parameters: removeNotificationGroup$Input
) => Ok;

/**
 * Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
 */
export type getMessageLink$Input = {
  readonly _: "getMessageLink";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * If not 0, timestamp from which the video/audio/video note/voice note/story playing must start, in seconds. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;

  /**
   * Pass true to create a link for the whole media album
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_album?: Bool$Input;

  /**
   * Pass true to create a link to the message as a channel post comment, in a message thread, or a forum topic
   * @type {Bool$Input} {@link Bool}
   */
  readonly in_message_thread?: Bool$Input;
};

/**
 * Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
 */
export type getMessageLink$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * If not 0, timestamp from which the video/audio/video note/voice note/story playing must start, in seconds. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;

  /**
   * Pass true to create a link for the whole media album
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_album?: Bool$Input;

  /**
   * Pass true to create a link to the message as a channel post comment, in a message thread, or a forum topic
   * @type {Bool$Input} {@link Bool}
   */
  readonly in_message_thread?: Bool$Input;
};

/**
 * Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
 *
 * @param {getMessageLink$Input} parameters {@link getMessageLink$Input}
 * @return {MessageLink} {@link MessageLink}
 */
export type getMessageLink = (parameters: getMessageLink$Input) => MessageLink;

/**
 * Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
 */
export type getMessageEmbeddingCode$Input = {
  readonly _: "getMessageEmbeddingCode";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to return an HTML code for embedding of the whole media album
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_album?: Bool$Input;
};

/**
 * Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
 */
export type getMessageEmbeddingCode$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to return an HTML code for embedding of the whole media album
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_album?: Bool$Input;
};

/**
 * Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
 *
 * @param {getMessageEmbeddingCode$Input} parameters {@link getMessageEmbeddingCode$Input}
 * @return {Text} {@link Text}
 */
export type getMessageEmbeddingCode = (
  parameters: getMessageEmbeddingCode$Input
) => Text;

/**
 * Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
 */
export type getMessageLinkInfo$Input = {
  readonly _: "getMessageLinkInfo";

  /**
   * The message link
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
 */
export type getMessageLinkInfo$DirectInput = {
  /**
   * The message link
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
 *
 * @param {getMessageLinkInfo$Input} parameters {@link getMessageLinkInfo$Input}
 * @return {MessageLinkInfo} {@link MessageLinkInfo}
 */
export type getMessageLinkInfo = (
  parameters: getMessageLinkInfo$Input
) => MessageLinkInfo;

/**
 * Translates a text to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
 */
export type translateText$Input = {
  readonly _: "translateText";

  /**
   * Text to translate
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Language code of the language to which the message is translated. Must be one of
   *
   * - "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en", "eo", "et",
   *
   * - "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko",
   *
   * - "ku", "ky", "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr",
   *
   * - "st", "sn", "sd", "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te", "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo", "zu"
   * @type {string} {@link string}
   */
  readonly to_language_code?: string;
};

/**
 * Translates a text to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
 */
export type translateText$DirectInput = {
  /**
   * Text to translate
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Language code of the language to which the message is translated. Must be one of
   *
   * - "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en", "eo", "et",
   *
   * - "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko",
   *
   * - "ku", "ky", "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr",
   *
   * - "st", "sn", "sd", "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te", "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo", "zu"
   * @type {string} {@link string}
   */
  readonly to_language_code?: string;
};

/**
 * Translates a text to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
 *
 * @param {translateText$Input} parameters {@link translateText$Input}
 * @return {FormattedText} {@link FormattedText}
 */
export type translateText = (parameters: translateText$Input) => FormattedText;

/**
 * Extracts text or caption of the given message and translates it to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
 */
export type translateMessageText$Input = {
  readonly _: "translateMessageText";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Language code of the language to which the message is translated. Must be one of
   *
   * - "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en", "eo", "et",
   *
   * - "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko",
   *
   * - "ku", "ky", "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr",
   *
   * - "st", "sn", "sd", "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te", "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo", "zu"
   * @type {string} {@link string}
   */
  readonly to_language_code?: string;
};

/**
 * Extracts text or caption of the given message and translates it to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
 */
export type translateMessageText$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Language code of the language to which the message is translated. Must be one of
   *
   * - "af", "sq", "am", "ar", "hy", "az", "eu", "be", "bn", "bs", "bg", "ca", "ceb", "zh-CN", "zh", "zh-Hans", "zh-TW", "zh-Hant", "co", "hr", "cs", "da", "nl", "en", "eo", "et",
   *
   * - "fi", "fr", "fy", "gl", "ka", "de", "el", "gu", "ht", "ha", "haw", "he", "iw", "hi", "hmn", "hu", "is", "ig", "id", "in", "ga", "it", "ja", "jv", "kn", "kk", "km", "rw", "ko",
   *
   * - "ku", "ky", "lo", "la", "lv", "lt", "lb", "mk", "mg", "ms", "ml", "mt", "mi", "mr", "mn", "my", "ne", "no", "ny", "or", "ps", "fa", "pl", "pt", "pa", "ro", "ru", "sm", "gd", "sr",
   *
   * - "st", "sn", "sd", "si", "sk", "sl", "so", "es", "su", "sw", "sv", "tl", "tg", "ta", "tt", "te", "th", "tr", "tk", "uk", "ur", "ug", "uz", "vi", "cy", "xh", "yi", "ji", "yo", "zu"
   * @type {string} {@link string}
   */
  readonly to_language_code?: string;
};

/**
 * Extracts text or caption of the given message and translates it to the given language. If the current user is a Telegram Premium user, then text formatting is preserved
 *
 * @param {translateMessageText$Input} parameters {@link translateMessageText$Input}
 * @return {FormattedText} {@link FormattedText}
 */
export type translateMessageText = (
  parameters: translateMessageText$Input
) => FormattedText;

/**
 * Recognizes speech in a video note or a voice note message. The message must be successfully sent, must not be scheduled, and must be from a non-secret chat
 */
export type recognizeSpeech$Input = {
  readonly _: "recognizeSpeech";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Recognizes speech in a video note or a voice note message. The message must be successfully sent, must not be scheduled, and must be from a non-secret chat
 */
export type recognizeSpeech$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Recognizes speech in a video note or a voice note message. The message must be successfully sent, must not be scheduled, and must be from a non-secret chat
 *
 * @param {recognizeSpeech$Input} parameters {@link recognizeSpeech$Input}
 * @return {Ok} {@link Ok}
 */
export type recognizeSpeech = (parameters: recognizeSpeech$Input) => Ok;

/**
 * Rates recognized speech in a video note or a voice note message
 */
export type rateSpeechRecognition$Input = {
  readonly _: "rateSpeechRecognition";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true if the speech recognition is good
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_good?: Bool$Input;
};

/**
 * Rates recognized speech in a video note or a voice note message
 */
export type rateSpeechRecognition$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true if the speech recognition is good
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_good?: Bool$Input;
};

/**
 * Rates recognized speech in a video note or a voice note message
 *
 * @param {rateSpeechRecognition$Input} parameters {@link rateSpeechRecognition$Input}
 * @return {Ok} {@link Ok}
 */
export type rateSpeechRecognition = (parameters: rateSpeechRecognition$Input) => Ok;

/**
 * Returns list of message sender identifiers, which can be used to send messages in a chat
 */
export type getChatAvailableMessageSenders$Input = {
  readonly _: "getChatAvailableMessageSenders";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of message sender identifiers, which can be used to send messages in a chat
 */
export type getChatAvailableMessageSenders$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of message sender identifiers, which can be used to send messages in a chat
 *
 * @param {getChatAvailableMessageSenders$Input} parameters {@link getChatAvailableMessageSenders$Input}
 * @return {ChatMessageSenders} {@link ChatMessageSenders}
 */
export type getChatAvailableMessageSenders = (
  parameters: getChatAvailableMessageSenders$Input
) => ChatMessageSenders;

/**
 * Selects a message sender to send messages in a chat
 */
export type setChatMessageSender$Input = {
  readonly _: "setChatMessageSender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New message sender for the chat
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input;
};

/**
 * Selects a message sender to send messages in a chat
 */
export type setChatMessageSender$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New message sender for the chat
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input;
};

/**
 * Selects a message sender to send messages in a chat
 *
 * @param {setChatMessageSender$Input} parameters {@link setChatMessageSender$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatMessageSender = (parameters: setChatMessageSender$Input) => Ok;

/**
 * Sends a message. Returns the sent message
 */
export type sendMessage$Input = {
  readonly _: "sendMessage";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Options to be used to send the message; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Markup for replying to the message; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Sends a message. Returns the sent message
 */
export type sendMessage$DirectInput = {
  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Options to be used to send the message; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Markup for replying to the message; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * The content of the message to be sent
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Sends a message. Returns the sent message
 *
 * @param {sendMessage$Input} parameters {@link sendMessage$Input}
 * @return {Message} {@link Message}
 */
export type sendMessage = (parameters: sendMessage$Input) => Message;

/**
 * Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
 */
export type sendMessageAlbum$Input = {
  readonly _: "sendMessageAlbum";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the messages will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Options to be used to send the messages; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Contents of messages to be sent. At most 10 messages can be added to an album
   * @type {vector$Input<InputMessageContent$Input>} {@link vector<InputMessageContent>}
   */
  readonly input_message_contents?: vector$Input<InputMessageContent$Input>;
};

/**
 * Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
 */
export type sendMessageAlbum$DirectInput = {
  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the messages will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Options to be used to send the messages; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Contents of messages to be sent. At most 10 messages can be added to an album
   * @type {vector$Input<InputMessageContent$Input>} {@link vector<InputMessageContent>}
   */
  readonly input_message_contents?: vector$Input<InputMessageContent$Input>;
};

/**
 * Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
 *
 * @param {sendMessageAlbum$Input} parameters {@link sendMessageAlbum$Input}
 * @return {Messages} {@link Messages}
 */
export type sendMessageAlbum = (parameters: sendMessageAlbum$Input) => Messages;

/**
 * Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
 */
export type sendBotStartMessage$Input = {
  readonly _: "sendBotStartMessage";

  /**
   * Identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Identifier of the target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)
   * @type {string} {@link string}
   */
  readonly parameter?: string;
};

/**
 * Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
 */
export type sendBotStartMessage$DirectInput = {
  /**
   * Identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Identifier of the target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)
   * @type {string} {@link string}
   */
  readonly parameter?: string;
};

/**
 * Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
 *
 * @param {sendBotStartMessage$Input} parameters {@link sendBotStartMessage$Input}
 * @return {Message} {@link Message}
 */
export type sendBotStartMessage = (parameters: sendBotStartMessage$Input) => Message;

/**
 * Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
 */
export type sendInlineQueryResultMessage$Input = {
  readonly _: "sendInlineQueryResultMessage";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Options to be used to send the message; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Identifier of the inline query
   * @type {int64$Input} {@link int64}
   */
  readonly query_id?: int64$Input;

  /**
   * Identifier of the inline query result
   * @type {string} {@link string}
   */
  readonly result_id?: string;

  /**
   * Pass true to hide the bot, via which the message is sent. Can be used only for bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"), and getOption("venue_search_bot_username")
   * @type {Bool$Input} {@link Bool}
   */
  readonly hide_via_bot?: Bool$Input;
};

/**
 * Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
 */
export type sendInlineQueryResultMessage$DirectInput = {
  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Options to be used to send the message; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Identifier of the inline query
   * @type {int64$Input} {@link int64}
   */
  readonly query_id?: int64$Input;

  /**
   * Identifier of the inline query result
   * @type {string} {@link string}
   */
  readonly result_id?: string;

  /**
   * Pass true to hide the bot, via which the message is sent. Can be used only for bots getOption("animation_search_bot_username"), getOption("photo_search_bot_username"), and getOption("venue_search_bot_username")
   * @type {Bool$Input} {@link Bool}
   */
  readonly hide_via_bot?: Bool$Input;
};

/**
 * Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
 *
 * @param {sendInlineQueryResultMessage$Input} parameters {@link sendInlineQueryResultMessage$Input}
 * @return {Message} {@link Message}
 */
export type sendInlineQueryResultMessage = (
  parameters: sendInlineQueryResultMessage$Input
) => Message;

/**
 * Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
 */
export type forwardMessages$Input = {
  readonly _: "forwardMessages";

  /**
   * Identifier of the chat to which to forward messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent; for forum threads only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of the chat from which to forward messages
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order. At most 100 messages can be forwarded simultaneously. A message can be forwarded only if message.can_be_forwarded
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Options to be used to send the messages; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Pass true to copy content of the messages without reference to the original sender. Always true if the messages are forwarded to a secret chat or are local
   * @type {Bool$Input} {@link Bool}
   */
  readonly send_copy?: Bool$Input;

  /**
   * Pass true to remove media captions of message copies. Ignored if send_copy is false
   * @type {Bool$Input} {@link Bool}
   */
  readonly remove_caption?: Bool$Input;
};

/**
 * Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
 */
export type forwardMessages$DirectInput = {
  /**
   * Identifier of the chat to which to forward messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent; for forum threads only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of the chat from which to forward messages
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order. At most 100 messages can be forwarded simultaneously. A message can be forwarded only if message.can_be_forwarded
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Options to be used to send the messages; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input | null;

  /**
   * Pass true to copy content of the messages without reference to the original sender. Always true if the messages are forwarded to a secret chat or are local
   * @type {Bool$Input} {@link Bool}
   */
  readonly send_copy?: Bool$Input;

  /**
   * Pass true to remove media captions of message copies. Ignored if send_copy is false
   * @type {Bool$Input} {@link Bool}
   */
  readonly remove_caption?: Bool$Input;
};

/**
 * Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
 *
 * @param {forwardMessages$Input} parameters {@link forwardMessages$Input}
 * @return {Messages} {@link Messages}
 */
export type forwardMessages = (parameters: forwardMessages$Input) => Messages;

/**
 * Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
 *
 * - If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
 */
export type resendMessages$Input = {
  readonly _: "resendMessages";

  /**
   * Identifier of the chat to send messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * New manually chosen quote from the message to be replied; pass null if none. Ignored if more than one message is re-sent, or if messageSendingStateFailed.need_another_reply_quote == false
   * @type {inputTextQuote$Input} {@link inputTextQuote}
   */
  readonly quote?: inputTextQuote$Input | null;
};

/**
 * Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
 *
 * - If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
 */
export type resendMessages$DirectInput = {
  /**
   * Identifier of the chat to send messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * New manually chosen quote from the message to be replied; pass null if none. Ignored if more than one message is re-sent, or if messageSendingStateFailed.need_another_reply_quote == false
   * @type {inputTextQuote$Input} {@link inputTextQuote}
   */
  readonly quote?: inputTextQuote$Input | null;
};

/**
 * Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
 *
 * - If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
 *
 * @param {resendMessages$Input} parameters {@link resendMessages$Input}
 * @return {Messages} {@link Messages}
 */
export type resendMessages = (parameters: resendMessages$Input) => Messages;

/**
 * Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
 */
export type addLocalMessage$Input = {
  readonly _: "addLocalMessage";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Pass true to disable notification for the message
   * @type {Bool$Input} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * The content of the message to be added
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
 */
export type addLocalMessage$DirectInput = {
  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Information about the message or story to be replied; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;

  /**
   * Pass true to disable notification for the message
   * @type {Bool$Input} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * The content of the message to be added
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
 *
 * @param {addLocalMessage$Input} parameters {@link addLocalMessage$Input}
 * @return {Message} {@link Message}
 */
export type addLocalMessage = (parameters: addLocalMessage$Input) => Message;

/**
 * Deletes messages
 */
export type deleteMessages$Input = {
  readonly _: "deleteMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to be deleted
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Pass true to delete messages for all chat members. Always true for supergroups, channels and secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes messages
 */
export type deleteMessages$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to be deleted
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Pass true to delete messages for all chat members. Always true for supergroups, channels and secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes messages
 *
 * @param {deleteMessages$Input} parameters {@link deleteMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteMessages = (parameters: deleteMessages$Input) => Ok;

/**
 * Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
 */
export type deleteChatMessagesBySender$Input = {
  readonly _: "deleteChatMessagesBySender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sender of messages to delete
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/**
 * Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
 */
export type deleteChatMessagesBySender$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sender of messages to delete
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/**
 * Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
 *
 * @param {deleteChatMessagesBySender$Input} parameters {@link deleteChatMessagesBySender$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatMessagesBySender = (
  parameters: deleteChatMessagesBySender$Input
) => Ok;

/**
 * Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
 */
export type deleteChatMessagesByDate$Input = {
  readonly _: "deleteChatMessagesByDate";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The minimum date of the messages to delete
   * @type {int32} {@link int32}
   */
  readonly min_date?: int32;

  /**
   * The maximum date of the messages to delete
   * @type {int32} {@link int32}
   */
  readonly max_date?: int32;

  /**
   * Pass true to delete chat messages for all users; private chats only
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
 */
export type deleteChatMessagesByDate$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The minimum date of the messages to delete
   * @type {int32} {@link int32}
   */
  readonly min_date?: int32;

  /**
   * The maximum date of the messages to delete
   * @type {int32} {@link int32}
   */
  readonly max_date?: int32;

  /**
   * Pass true to delete chat messages for all users; private chats only
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
 *
 * @param {deleteChatMessagesByDate$Input} parameters {@link deleteChatMessagesByDate$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatMessagesByDate = (
  parameters: deleteChatMessagesByDate$Input
) => Ok;

/**
 * Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
 */
export type editMessageText$Input = {
  readonly _: "editMessageText";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New text content of the message. Must be of type inputMessageText
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
 */
export type editMessageText$DirectInput = {
  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New text content of the message. Must be of type inputMessageText
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageText$Input} parameters {@link editMessageText$Input}
 * @return {Message} {@link Message}
 */
export type editMessageText = (parameters: editMessageText$Input) => Message;

/**
 * Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
 */
export type editMessageLiveLocation$Input = {
  readonly _: "editMessageLiveLocation";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New location content of the message; pass null to stop sharing the live location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input | null;

  /**
   * The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
 */
export type editMessageLiveLocation$DirectInput = {
  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New location content of the message; pass null to stop sharing the live location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input | null;

  /**
   * The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageLiveLocation$Input} parameters {@link editMessageLiveLocation$Input}
 * @return {Message} {@link Message}
 */
export type editMessageLiveLocation = (
  parameters: editMessageLiveLocation$Input
) => Message;

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
 *
 * - The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
 */
export type editMessageMedia$Input = {
  readonly _: "editMessageMedia";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
 *
 * - The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
 */
export type editMessageMedia$DirectInput = {
  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
 *
 * - The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageMedia$Input} parameters {@link editMessageMedia$Input}
 * @return {Message} {@link Message}
 */
export type editMessageMedia = (parameters: editMessageMedia$Input) => Message;

/**
 * Edits the message content caption. Returns the edited message after the edit is completed on the server side
 */
export type editMessageCaption$Input = {
  readonly _: "editMessageCaption";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New message content caption; 0-getOption("message_caption_length_max") characters; pass null to remove caption
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * Edits the message content caption. Returns the edited message after the edit is completed on the server side
 */
export type editMessageCaption$DirectInput = {
  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New message content caption; 0-getOption("message_caption_length_max") characters; pass null to remove caption
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * Edits the message content caption. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageCaption$Input} parameters {@link editMessageCaption$Input}
 * @return {Message} {@link Message}
 */
export type editMessageCaption = (parameters: editMessageCaption$Input) => Message;

/**
 * Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
 */
export type editMessageReplyMarkup$Input = {
  readonly _: "editMessageReplyMarkup";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
 */
export type editMessageReplyMarkup$DirectInput = {
  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageReplyMarkup$Input} parameters {@link editMessageReplyMarkup$Input}
 * @return {Message} {@link Message}
 */
export type editMessageReplyMarkup = (
  parameters: editMessageReplyMarkup$Input
) => Message;

/**
 * Edits the text of an inline text or game message sent via a bot; for bots only
 */
export type editInlineMessageText$Input = {
  readonly _: "editInlineMessageText";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New text content of the message. Must be of type inputMessageText
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the text of an inline text or game message sent via a bot; for bots only
 */
export type editInlineMessageText$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New text content of the message. Must be of type inputMessageText
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the text of an inline text or game message sent via a bot; for bots only
 *
 * @param {editInlineMessageText$Input} parameters {@link editInlineMessageText$Input}
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageText = (parameters: editInlineMessageText$Input) => Ok;

/**
 * Edits the content of a live location in an inline message sent via a bot; for bots only
 */
export type editInlineMessageLiveLocation$Input = {
  readonly _: "editInlineMessageLiveLocation";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New location content of the message; pass null to stop sharing the live location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input | null;

  /**
   * The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * Edits the content of a live location in an inline message sent via a bot; for bots only
 */
export type editInlineMessageLiveLocation$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New location content of the message; pass null to stop sharing the live location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input | null;

  /**
   * The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * Edits the content of a live location in an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageLiveLocation$Input} parameters {@link editInlineMessageLiveLocation$Input}
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageLiveLocation = (
  parameters: editInlineMessageLiveLocation$Input
) => Ok;

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
 */
export type editInlineMessageMedia$Input = {
  readonly _: "editInlineMessageMedia";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
 */
export type editInlineMessageMedia$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageMedia$Input} parameters {@link editInlineMessageMedia$Input}
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageMedia = (
  parameters: editInlineMessageMedia$Input
) => Ok;

/**
 * Edits the caption of an inline message sent via a bot; for bots only
 */
export type editInlineMessageCaption$Input = {
  readonly _: "editInlineMessageCaption";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * Edits the caption of an inline message sent via a bot; for bots only
 */
export type editInlineMessageCaption$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;

  /**
   * New message content caption; pass null to remove caption; 0-getOption("message_caption_length_max") characters
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * Edits the caption of an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageCaption$Input} parameters {@link editInlineMessageCaption$Input}
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageCaption = (
  parameters: editInlineMessageCaption$Input
) => Ok;

/**
 * Edits the reply markup of an inline message sent via a bot; for bots only
 */
export type editInlineMessageReplyMarkup$Input = {
  readonly _: "editInlineMessageReplyMarkup";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Edits the reply markup of an inline message sent via a bot; for bots only
 */
export type editInlineMessageReplyMarkup$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Edits the reply markup of an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageReplyMarkup$Input} parameters {@link editInlineMessageReplyMarkup$Input}
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageReplyMarkup = (
  parameters: editInlineMessageReplyMarkup$Input
) => Ok;

/**
 * Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
 */
export type editMessageSchedulingState$Input = {
  readonly _: "editMessageSchedulingState";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message scheduling state; pass null to send the message immediately
   * @type {MessageSchedulingState$Input} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input | null;
};

/**
 * Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
 */
export type editMessageSchedulingState$DirectInput = {
  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message scheduling state; pass null to send the message immediately
   * @type {MessageSchedulingState$Input} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input | null;
};

/**
 * Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
 *
 * @param {editMessageSchedulingState$Input} parameters {@link editMessageSchedulingState$Input}
 * @return {Ok} {@link Ok}
 */
export type editMessageSchedulingState = (
  parameters: editMessageSchedulingState$Input
) => Ok;

/**
 * Returns list of custom emojis, which can be used as forum topic icon by all users
 */
export type getForumTopicDefaultIcons$Input = {
  readonly _: "getForumTopicDefaultIcons";
};

/**
 * Returns list of custom emojis, which can be used as forum topic icon by all users
 */
export type getForumTopicDefaultIcons$DirectInput = {};

/**
 * Returns list of custom emojis, which can be used as forum topic icon by all users
 *
 * @param {getForumTopicDefaultIcons$Input} parameters {@link getForumTopicDefaultIcons$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getForumTopicDefaultIcons = (
  parameters: getForumTopicDefaultIcons$Input
) => Stickers;

/**
 * Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup
 */
export type createForumTopic$Input = {
  readonly _: "createForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Name of the topic; 1-128 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98, 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons
   * @type {forumTopicIcon$Input} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;
};

/**
 * Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup
 */
export type createForumTopic$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Name of the topic; 1-128 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98, 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons
   * @type {forumTopicIcon$Input} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;
};

/**
 * Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup
 *
 * @param {createForumTopic$Input} parameters {@link createForumTopic$Input}
 * @return {ForumTopicInfo} {@link ForumTopicInfo}
 */
export type createForumTopic = (
  parameters: createForumTopic$Input
) => ForumTopicInfo;

/**
 * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
 */
export type editForumTopic$Input = {
  readonly _: "editForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New name of the topic; 0-128 characters. If empty, the previous topic name is kept
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Pass true to edit the icon of the topic. Icon of the General topic can't be edited
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_icon_custom_emoji?: Bool$Input;

  /**
   * Identifier of the new custom emoji for topic icon; pass 0 to remove the custom emoji. Ignored if edit_icon_custom_emoji is false. Telegram Premium users can use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons
   * @type {int64$Input} {@link int64}
   */
  readonly icon_custom_emoji_id?: int64$Input;
};

/**
 * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
 */
export type editForumTopic$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New name of the topic; 0-128 characters. If empty, the previous topic name is kept
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Pass true to edit the icon of the topic. Icon of the General topic can't be edited
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_icon_custom_emoji?: Bool$Input;

  /**
   * Identifier of the new custom emoji for topic icon; pass 0 to remove the custom emoji. Ignored if edit_icon_custom_emoji is false. Telegram Premium users can use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons
   * @type {int64$Input} {@link int64}
   */
  readonly icon_custom_emoji_id?: int64$Input;
};

/**
 * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
 *
 * @param {editForumTopic$Input} parameters {@link editForumTopic$Input}
 * @return {Ok} {@link Ok}
 */
export type editForumTopic = (parameters: editForumTopic$Input) => Ok;

/**
 * Returns information about a forum topic
 */
export type getForumTopic$Input = {
  readonly _: "getForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns information about a forum topic
 */
export type getForumTopic$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns information about a forum topic
 *
 * @param {getForumTopic$Input} parameters {@link getForumTopic$Input}
 * @return {ForumTopic} {@link ForumTopic}
 */
export type getForumTopic = (parameters: getForumTopic$Input) => ForumTopic;

/**
 * Returns an HTTPS link to a topic in a forum chat. This is an offline request
 */
export type getForumTopicLink$Input = {
  readonly _: "getForumTopicLink";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns an HTTPS link to a topic in a forum chat. This is an offline request
 */
export type getForumTopicLink$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns an HTTPS link to a topic in a forum chat. This is an offline request
 *
 * @param {getForumTopicLink$Input} parameters {@link getForumTopicLink$Input}
 * @return {MessageLink} {@link MessageLink}
 */
export type getForumTopicLink = (parameters: getForumTopicLink$Input) => MessageLink;

/**
 * Returns found forum topics in a forum chat. This is a temporary method for getting information about topic list from the server
 */
export type getForumTopics$Input = {
  readonly _: "getForumTopics";

  /**
   * Identifier of the forum chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for in the forum topic's name
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The date starting from which the results need to be fetched. Use 0 or any date in the future to get results from the last topic
   * @type {int32} {@link int32}
   */
  readonly offset_date?: int32;

  /**
   * The message identifier of the last message in the last found topic, or 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_message_id?: int53;

  /**
   * The message thread identifier of the last found topic, or 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_message_thread_id?: int53;

  /**
   * The maximum number of forum topics to be returned; up to 100. For optimal performance, the number of returned forum topics is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns found forum topics in a forum chat. This is a temporary method for getting information about topic list from the server
 */
export type getForumTopics$DirectInput = {
  /**
   * Identifier of the forum chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for in the forum topic's name
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The date starting from which the results need to be fetched. Use 0 or any date in the future to get results from the last topic
   * @type {int32} {@link int32}
   */
  readonly offset_date?: int32;

  /**
   * The message identifier of the last message in the last found topic, or 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_message_id?: int53;

  /**
   * The message thread identifier of the last found topic, or 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_message_thread_id?: int53;

  /**
   * The maximum number of forum topics to be returned; up to 100. For optimal performance, the number of returned forum topics is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns found forum topics in a forum chat. This is a temporary method for getting information about topic list from the server
 *
 * @param {getForumTopics$Input} parameters {@link getForumTopics$Input}
 * @return {ForumTopics} {@link ForumTopics}
 */
export type getForumTopics = (parameters: getForumTopics$Input) => ForumTopics;

/**
 * Changes the notification settings of a forum topic
 */
export type setForumTopicNotificationSettings$Input = {
  readonly _: "setForumTopicNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New notification settings for the forum topic. If the topic is muted for more than 366 days, it is considered to be muted forever
   * @type {chatNotificationSettings$Input} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/**
 * Changes the notification settings of a forum topic
 */
export type setForumTopicNotificationSettings$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New notification settings for the forum topic. If the topic is muted for more than 366 days, it is considered to be muted forever
   * @type {chatNotificationSettings$Input} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/**
 * Changes the notification settings of a forum topic
 *
 * @param {setForumTopicNotificationSettings$Input} parameters {@link setForumTopicNotificationSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setForumTopicNotificationSettings = (
  parameters: setForumTopicNotificationSettings$Input
) => Ok;

/**
 * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
 */
export type toggleForumTopicIsClosed$Input = {
  readonly _: "toggleForumTopicIsClosed";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Pass true to close the topic; pass false to reopen it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/**
 * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
 */
export type toggleForumTopicIsClosed$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Pass true to close the topic; pass false to reopen it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/**
 * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup unless the user is creator of the topic
 *
 * @param {toggleForumTopicIsClosed$Input} parameters {@link toggleForumTopicIsClosed$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleForumTopicIsClosed = (
  parameters: toggleForumTopicIsClosed$Input
) => Ok;

/**
 * Toggles whether a General topic is hidden in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup
 */
export type toggleGeneralForumTopicIsHidden$Input = {
  readonly _: "toggleGeneralForumTopicIsHidden";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to hide and close the General topic; pass false to unhide it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_hidden?: Bool$Input;
};

/**
 * Toggles whether a General topic is hidden in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup
 */
export type toggleGeneralForumTopicIsHidden$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to hide and close the General topic; pass false to unhide it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_hidden?: Bool$Input;
};

/**
 * Toggles whether a General topic is hidden in a forum supergroup chat; requires can_manage_topics administrator right in the supergroup
 *
 * @param {toggleGeneralForumTopicIsHidden$Input} parameters {@link toggleGeneralForumTopicIsHidden$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGeneralForumTopicIsHidden = (
  parameters: toggleGeneralForumTopicIsHidden$Input
) => Ok;

/**
 * Changes the pinned state of a forum topic; requires can_manage_topics administrator right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max") pinned forum topics
 */
export type toggleForumTopicIsPinned$Input = {
  readonly _: "toggleForumTopicIsPinned";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Pass true to pin the topic; pass false to unpin it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Changes the pinned state of a forum topic; requires can_manage_topics administrator right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max") pinned forum topics
 */
export type toggleForumTopicIsPinned$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Pass true to pin the topic; pass false to unpin it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Changes the pinned state of a forum topic; requires can_manage_topics administrator right in the supergroup. There can be up to getOption("pinned_forum_topic_count_max") pinned forum topics
 *
 * @param {toggleForumTopicIsPinned$Input} parameters {@link toggleForumTopicIsPinned$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleForumTopicIsPinned = (
  parameters: toggleForumTopicIsPinned$Input
) => Ok;

/**
 * Changes the order of pinned forum topics
 */
export type setPinnedForumTopics$Input = {
  readonly _: "setPinnedForumTopics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new list of pinned forum topics
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_thread_ids?: vector$Input<int53>;
};

/**
 * Changes the order of pinned forum topics
 */
export type setPinnedForumTopics$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new list of pinned forum topics
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_thread_ids?: vector$Input<int53>;
};

/**
 * Changes the order of pinned forum topics
 *
 * @param {setPinnedForumTopics$Input} parameters {@link setPinnedForumTopics$Input}
 * @return {Ok} {@link Ok}
 */
export type setPinnedForumTopics = (parameters: setPinnedForumTopics$Input) => Ok;

/**
 * Deletes all messages in a forum topic; requires can_delete_messages administrator right in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages
 */
export type deleteForumTopic$Input = {
  readonly _: "deleteForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Deletes all messages in a forum topic; requires can_delete_messages administrator right in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages
 */
export type deleteForumTopic$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Deletes all messages in a forum topic; requires can_delete_messages administrator right in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages
 *
 * @param {deleteForumTopic$Input} parameters {@link deleteForumTopic$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteForumTopic = (parameters: deleteForumTopic$Input) => Ok;

/**
 * Returns information about a emoji reaction. Returns a 404 error if the reaction is not found
 */
export type getEmojiReaction$Input = {
  readonly _: "getEmojiReaction";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * Returns information about a emoji reaction. Returns a 404 error if the reaction is not found
 */
export type getEmojiReaction$DirectInput = {
  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * Returns information about a emoji reaction. Returns a 404 error if the reaction is not found
 *
 * @param {getEmojiReaction$Input} parameters {@link getEmojiReaction$Input}
 * @return {EmojiReaction} {@link EmojiReaction}
 */
export type getEmojiReaction = (parameters: getEmojiReaction$Input) => EmojiReaction;

/**
 * Returns TGS stickers with generic animations for custom emoji reactions
 */
export type getCustomEmojiReactionAnimations$Input = {
  readonly _: "getCustomEmojiReactionAnimations";
};

/**
 * Returns TGS stickers with generic animations for custom emoji reactions
 */
export type getCustomEmojiReactionAnimations$DirectInput = {};

/**
 * Returns TGS stickers with generic animations for custom emoji reactions
 *
 * @param {getCustomEmojiReactionAnimations$Input} parameters {@link getCustomEmojiReactionAnimations$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getCustomEmojiReactionAnimations = (
  parameters: getCustomEmojiReactionAnimations$Input
) => Stickers;

/**
 * Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message
 */
export type getMessageAvailableReactions$Input = {
  readonly _: "getMessageAvailableReactions";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Number of reaction per row, 5-25
   * @type {int32} {@link int32}
   */
  readonly row_size?: int32;
};

/**
 * Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message
 */
export type getMessageAvailableReactions$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Number of reaction per row, 5-25
   * @type {int32} {@link int32}
   */
  readonly row_size?: int32;
};

/**
 * Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message
 *
 * @param {getMessageAvailableReactions$Input} parameters {@link getMessageAvailableReactions$Input}
 * @return {AvailableReactions} {@link AvailableReactions}
 */
export type getMessageAvailableReactions = (
  parameters: getMessageAvailableReactions$Input
) => AvailableReactions;

/**
 * Clears the list of recently used reactions
 */
export type clearRecentReactions$Input = {
  readonly _: "clearRecentReactions";
};

/**
 * Clears the list of recently used reactions
 */
export type clearRecentReactions$DirectInput = {};

/**
 * Clears the list of recently used reactions
 *
 * @param {clearRecentReactions$Input} parameters {@link clearRecentReactions$Input}
 * @return {Ok} {@link Ok}
 */
export type clearRecentReactions = (parameters: clearRecentReactions$Input) => Ok;

/**
 * Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message
 */
export type addMessageReaction$Input = {
  readonly _: "addMessageReaction";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reaction to add
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;

  /**
   * Pass true if the reaction is added with a big animation
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_big?: Bool$Input;

  /**
   * Pass true if the reaction needs to be added to recent reactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly update_recent_reactions?: Bool$Input;
};

/**
 * Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message
 */
export type addMessageReaction$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reaction to add
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;

  /**
   * Pass true if the reaction is added with a big animation
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_big?: Bool$Input;

  /**
   * Pass true if the reaction needs to be added to recent reactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly update_recent_reactions?: Bool$Input;
};

/**
 * Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message
 *
 * @param {addMessageReaction$Input} parameters {@link addMessageReaction$Input}
 * @return {Ok} {@link Ok}
 */
export type addMessageReaction = (parameters: addMessageReaction$Input) => Ok;

/**
 * Removes a reaction from a message. A chosen reaction can always be removed
 */
export type removeMessageReaction$Input = {
  readonly _: "removeMessageReaction";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reaction to remove
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * Removes a reaction from a message. A chosen reaction can always be removed
 */
export type removeMessageReaction$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reaction to remove
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * Removes a reaction from a message. A chosen reaction can always be removed
 *
 * @param {removeMessageReaction$Input} parameters {@link removeMessageReaction$Input}
 * @return {Ok} {@link Ok}
 */
export type removeMessageReaction = (parameters: removeMessageReaction$Input) => Ok;

/**
 * Sets reactions on a message; for bots only
 */
export type setMessageReactions$Input = {
  readonly _: "setMessageReactions";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Types of the reaction to set
   * @type {vector$Input<ReactionType$Input>} {@link vector<ReactionType>}
   */
  readonly reaction_types?: vector$Input<ReactionType$Input>;

  /**
   * Pass true if the reactions are added with a big animation
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_big?: Bool$Input;
};

/**
 * Sets reactions on a message; for bots only
 */
export type setMessageReactions$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Types of the reaction to set
   * @type {vector$Input<ReactionType$Input>} {@link vector<ReactionType>}
   */
  readonly reaction_types?: vector$Input<ReactionType$Input>;

  /**
   * Pass true if the reactions are added with a big animation
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_big?: Bool$Input;
};

/**
 * Sets reactions on a message; for bots only
 *
 * @param {setMessageReactions$Input} parameters {@link setMessageReactions$Input}
 * @return {Ok} {@link Ok}
 */
export type setMessageReactions = (parameters: setMessageReactions$Input) => Ok;

/**
 * Returns reactions added for a message, along with their sender
 */
export type getMessageAddedReactions$Input = {
  readonly _: "getMessageAddedReactions";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reactions to return; pass null to return all added reactions
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input | null;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of reactions to be returned; must be positive and can't be greater than 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns reactions added for a message, along with their sender
 */
export type getMessageAddedReactions$DirectInput = {
  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reactions to return; pass null to return all added reactions
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input | null;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of reactions to be returned; must be positive and can't be greater than 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns reactions added for a message, along with their sender
 *
 * @param {getMessageAddedReactions$Input} parameters {@link getMessageAddedReactions$Input}
 * @return {AddedReactions} {@link AddedReactions}
 */
export type getMessageAddedReactions = (
  parameters: getMessageAddedReactions$Input
) => AddedReactions;

/**
 * Changes type of default reaction for the current user
 */
export type setDefaultReactionType$Input = {
  readonly _: "setDefaultReactionType";

  /**
   * New type of the default reaction
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * Changes type of default reaction for the current user
 */
export type setDefaultReactionType$DirectInput = {
  /**
   * New type of the default reaction
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * Changes type of default reaction for the current user
 *
 * @param {setDefaultReactionType$Input} parameters {@link setDefaultReactionType$Input}
 * @return {Ok} {@link Ok}
 */
export type setDefaultReactionType = (
  parameters: setDefaultReactionType$Input
) => Ok;

/**
 * Searches for a given quote in a text. Returns found quote start position in UTF-16 code units. Returns a 404 error if the quote is not found. Can be called synchronously
 */
export type searchQuote$Input = {
  readonly _: "searchQuote";

  /**
   * Text in which to search for the quote
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Quote to search for
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly quote?: formattedText$Input;

  /**
   * Approximate quote position in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly quote_position?: int32;
};

/**
 * Searches for a given quote in a text. Returns found quote start position in UTF-16 code units. Returns a 404 error if the quote is not found. Can be called synchronously
 */
export type searchQuote$DirectInput = {
  /**
   * Text in which to search for the quote
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Quote to search for
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly quote?: formattedText$Input;

  /**
   * Approximate quote position in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly quote_position?: int32;
};

/**
 * Searches for a given quote in a text. Returns found quote start position in UTF-16 code units. Returns a 404 error if the quote is not found. Can be called synchronously
 *
 * @param {searchQuote$Input} parameters {@link searchQuote$Input}
 * @return {FoundPosition} {@link FoundPosition}
 */
export type searchQuote = (parameters: searchQuote$Input) => FoundPosition;

/**
 * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
 */
export type getTextEntities$Input = {
  readonly _: "getTextEntities";

  /**
   * The text in which to look for entities
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
 */
export type getTextEntities$DirectInput = {
  /**
   * The text in which to look for entities
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
 *
 * @param {getTextEntities$Input} parameters {@link getTextEntities$Input}
 * @return {TextEntities} {@link TextEntities}
 */
export type getTextEntities = (parameters: getTextEntities$Input) => TextEntities;

/**
 * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
 */
export type parseTextEntities$Input = {
  readonly _: "parseTextEntities";

  /**
   * The text to parse
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Text parse mode
   * @type {TextParseMode$Input} {@link TextParseMode}
   */
  readonly parse_mode?: TextParseMode$Input;
};

/**
 * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
 */
export type parseTextEntities$DirectInput = {
  /**
   * The text to parse
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Text parse mode
   * @type {TextParseMode$Input} {@link TextParseMode}
   */
  readonly parse_mode?: TextParseMode$Input;
};

/**
 * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, BlockQuote, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
 *
 * @param {parseTextEntities$Input} parameters {@link parseTextEntities$Input}
 * @return {FormattedText} {@link FormattedText}
 */
export type parseTextEntities = (
  parameters: parseTextEntities$Input
) => FormattedText;

/**
 * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
 */
export type parseMarkdown$Input = {
  readonly _: "parseMarkdown";

  /**
   * The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
 */
export type parseMarkdown$DirectInput = {
  /**
   * The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
 *
 * @param {parseMarkdown$Input} parameters {@link parseMarkdown$Input}
 * @return {FormattedText} {@link FormattedText}
 */
export type parseMarkdown = (parameters: parseMarkdown$Input) => FormattedText;

/**
 * Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
 */
export type getMarkdownText$Input = {
  readonly _: "getMarkdownText";

  /**
   * The text
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
 */
export type getMarkdownText$DirectInput = {
  /**
   * The text
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
 *
 * @param {getMarkdownText$Input} parameters {@link getMarkdownText$Input}
 * @return {FormattedText} {@link FormattedText}
 */
export type getMarkdownText = (parameters: getMarkdownText$Input) => FormattedText;

/**
 * Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
 */
export type getFileMimeType$Input = {
  readonly _: "getFileMimeType";

  /**
   * The name of the file or path to the file
   * @type {string} {@link string}
   */
  readonly file_name?: string;
};

/**
 * Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
 */
export type getFileMimeType$DirectInput = {
  /**
   * The name of the file or path to the file
   * @type {string} {@link string}
   */
  readonly file_name?: string;
};

/**
 * Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
 *
 * @param {getFileMimeType$Input} parameters {@link getFileMimeType$Input}
 * @return {Text} {@link Text}
 */
export type getFileMimeType = (parameters: getFileMimeType$Input) => Text;

/**
 * Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
 */
export type getFileExtension$Input = {
  readonly _: "getFileExtension";

  /**
   * The MIME type of the file
   * @type {string} {@link string}
   */
  readonly mime_type?: string;
};

/**
 * Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
 */
export type getFileExtension$DirectInput = {
  /**
   * The MIME type of the file
   * @type {string} {@link string}
   */
  readonly mime_type?: string;
};

/**
 * Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
 *
 * @param {getFileExtension$Input} parameters {@link getFileExtension$Input}
 * @return {Text} {@link Text}
 */
export type getFileExtension = (parameters: getFileExtension$Input) => Text;

/**
 * Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
 */
export type cleanFileName$Input = {
  readonly _: "cleanFileName";

  /**
   * File name or path to the file
   * @type {string} {@link string}
   */
  readonly file_name?: string;
};

/**
 * Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
 */
export type cleanFileName$DirectInput = {
  /**
   * File name or path to the file
   * @type {string} {@link string}
   */
  readonly file_name?: string;
};

/**
 * Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
 *
 * @param {cleanFileName$Input} parameters {@link cleanFileName$Input}
 * @return {Text} {@link Text}
 */
export type cleanFileName = (parameters: cleanFileName$Input) => Text;

/**
 * Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
 */
export type getLanguagePackString$Input = {
  readonly _: "getLanguagePackString";

  /**
   * Path to the language pack database in which strings are stored
   * @type {string} {@link string}
   */
  readonly language_pack_database_path?: string;

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  readonly localization_target?: string;

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * Language pack key of the string to be returned
   * @type {string} {@link string}
   */
  readonly key?: string;
};

/**
 * Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
 */
export type getLanguagePackString$DirectInput = {
  /**
   * Path to the language pack database in which strings are stored
   * @type {string} {@link string}
   */
  readonly language_pack_database_path?: string;

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  readonly localization_target?: string;

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * Language pack key of the string to be returned
   * @type {string} {@link string}
   */
  readonly key?: string;
};

/**
 * Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
 *
 * @param {getLanguagePackString$Input} parameters {@link getLanguagePackString$Input}
 * @return {LanguagePackStringValue} {@link LanguagePackStringValue}
 */
export type getLanguagePackString = (
  parameters: getLanguagePackString$Input
) => LanguagePackStringValue;

/**
 * Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
 */
export type getJsonValue$Input = {
  readonly _: "getJsonValue";

  /**
   * The JSON-serialized string
   * @type {string} {@link string}
   */
  readonly json?: string;
};

/**
 * Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
 */
export type getJsonValue$DirectInput = {
  /**
   * The JSON-serialized string
   * @type {string} {@link string}
   */
  readonly json?: string;
};

/**
 * Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
 *
 * @param {getJsonValue$Input} parameters {@link getJsonValue$Input}
 * @return {JsonValue} {@link JsonValue}
 */
export type getJsonValue = (parameters: getJsonValue$Input) => JsonValue;

/**
 * Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
 */
export type getJsonString$Input = {
  readonly _: "getJsonString";

  /**
   * The JsonValue object
   * @type {JsonValue$Input} {@link JsonValue}
   */
  readonly json_value?: JsonValue$Input;
};

/**
 * Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
 */
export type getJsonString$DirectInput = {
  /**
   * The JsonValue object
   * @type {JsonValue$Input} {@link JsonValue}
   */
  readonly json_value?: JsonValue$Input;
};

/**
 * Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
 *
 * @param {getJsonString$Input} parameters {@link getJsonString$Input}
 * @return {Text} {@link Text}
 */
export type getJsonString = (parameters: getJsonString$Input) => Text;

/**
 * Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
 */
export type getThemeParametersJsonString$Input = {
  readonly _: "getThemeParametersJsonString";

  /**
   * Theme parameters to convert to JSON
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input;
};

/**
 * Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
 */
export type getThemeParametersJsonString$DirectInput = {
  /**
   * Theme parameters to convert to JSON
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input;
};

/**
 * Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
 *
 * @param {getThemeParametersJsonString$Input} parameters {@link getThemeParametersJsonString$Input}
 * @return {Text} {@link Text}
 */
export type getThemeParametersJsonString = (
  parameters: getThemeParametersJsonString$Input
) => Text;

/**
 * Changes the user answer to a poll. A poll in quiz mode can be answered only once
 */
export type setPollAnswer$Input = {
  readonly _: "setPollAnswer";

  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * 0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly option_ids?: vector$Input<int32>;
};

/**
 * Changes the user answer to a poll. A poll in quiz mode can be answered only once
 */
export type setPollAnswer$DirectInput = {
  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * 0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly option_ids?: vector$Input<int32>;
};

/**
 * Changes the user answer to a poll. A poll in quiz mode can be answered only once
 *
 * @param {setPollAnswer$Input} parameters {@link setPollAnswer$Input}
 * @return {Ok} {@link Ok}
 */
export type setPollAnswer = (parameters: setPollAnswer$Input) => Ok;

/**
 * Returns message senders voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
 */
export type getPollVoters$Input = {
  readonly _: "getPollVoters";

  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * 0-based identifier of the answer option
   * @type {int32} {@link int32}
   */
  readonly option_id?: int32;

  /**
   * Number of voters to skip in the result; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of voters to be returned; must be positive and can't be greater than 50. For optimal performance, the number of returned voters is chosen by TDLib and can be smaller than the specified limit, even if the end of the voter list has not been reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns message senders voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
 */
export type getPollVoters$DirectInput = {
  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * 0-based identifier of the answer option
   * @type {int32} {@link int32}
   */
  readonly option_id?: int32;

  /**
   * Number of voters to skip in the result; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of voters to be returned; must be positive and can't be greater than 50. For optimal performance, the number of returned voters is chosen by TDLib and can be smaller than the specified limit, even if the end of the voter list has not been reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns message senders voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
 *
 * @param {getPollVoters$Input} parameters {@link getPollVoters$Input}
 * @return {MessageSenders} {@link MessageSenders}
 */
export type getPollVoters = (parameters: getPollVoters$Input) => MessageSenders;

/**
 * Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag is set
 */
export type stopPoll$Input = {
  readonly _: "stopPoll";

  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag is set
 */
export type stopPoll$DirectInput = {
  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input | null;
};

/**
 * Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag is set
 *
 * @param {stopPoll$Input} parameters {@link stopPoll$Input}
 * @return {Ok} {@link Ok}
 */
export type stopPoll = (parameters: stopPoll$Input) => Ok;

/**
 * Hides a suggested action
 */
export type hideSuggestedAction$Input = {
  readonly _: "hideSuggestedAction";

  /**
   * Suggested action to hide
   * @type {SuggestedAction$Input} {@link SuggestedAction}
   */
  readonly action?: SuggestedAction$Input;
};

/**
 * Hides a suggested action
 */
export type hideSuggestedAction$DirectInput = {
  /**
   * Suggested action to hide
   * @type {SuggestedAction$Input} {@link SuggestedAction}
   */
  readonly action?: SuggestedAction$Input;
};

/**
 * Hides a suggested action
 *
 * @param {hideSuggestedAction$Input} parameters {@link hideSuggestedAction$Input}
 * @return {Ok} {@link Ok}
 */
export type hideSuggestedAction = (parameters: hideSuggestedAction$Input) => Ok;

/**
 * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
 */
export type getLoginUrlInfo$Input = {
  readonly _: "getLoginUrlInfo";

  /**
   * Chat identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Button identifier
   * @type {int53} {@link int53}
   */
  readonly button_id?: int53;
};

/**
 * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
 */
export type getLoginUrlInfo$DirectInput = {
  /**
   * Chat identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Button identifier
   * @type {int53} {@link int53}
   */
  readonly button_id?: int53;
};

/**
 * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
 *
 * @param {getLoginUrlInfo$Input} parameters {@link getLoginUrlInfo$Input}
 * @return {LoginUrlInfo} {@link LoginUrlInfo}
 */
export type getLoginUrlInfo = (parameters: getLoginUrlInfo$Input) => LoginUrlInfo;

/**
 * Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
 *
 * - Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
 */
export type getLoginUrl$Input = {
  readonly _: "getLoginUrl";

  /**
   * Chat identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Button identifier
   * @type {int53} {@link int53}
   */
  readonly button_id?: int53;

  /**
   * Pass true to allow the bot to send messages to the current user
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
 *
 * - Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
 */
export type getLoginUrl$DirectInput = {
  /**
   * Chat identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Button identifier
   * @type {int53} {@link int53}
   */
  readonly button_id?: int53;

  /**
   * Pass true to allow the bot to send messages to the current user
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
 *
 * - Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
 *
 * @param {getLoginUrl$Input} parameters {@link getLoginUrl$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getLoginUrl = (parameters: getLoginUrl$Input) => HttpUrl;

/**
 * Shares users after pressing a keyboardButtonTypeRequestUsers button with the bot
 */
export type shareUsersWithBot$Input = {
  readonly _: "shareUsersWithBot";

  /**
   * Identifier of the chat with the bot
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the button
   * @type {int32} {@link int32}
   */
  readonly button_id?: int32;

  /**
   * Identifiers of the shared users
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly shared_user_ids?: vector$Input<int53>;

  /**
   * Pass true to check that the users can be shared by the button instead of actually sharing them
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_check?: Bool$Input;
};

/**
 * Shares users after pressing a keyboardButtonTypeRequestUsers button with the bot
 */
export type shareUsersWithBot$DirectInput = {
  /**
   * Identifier of the chat with the bot
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the button
   * @type {int32} {@link int32}
   */
  readonly button_id?: int32;

  /**
   * Identifiers of the shared users
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly shared_user_ids?: vector$Input<int53>;

  /**
   * Pass true to check that the users can be shared by the button instead of actually sharing them
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_check?: Bool$Input;
};

/**
 * Shares users after pressing a keyboardButtonTypeRequestUsers button with the bot
 *
 * @param {shareUsersWithBot$Input} parameters {@link shareUsersWithBot$Input}
 * @return {Ok} {@link Ok}
 */
export type shareUsersWithBot = (parameters: shareUsersWithBot$Input) => Ok;

/**
 * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the bot
 */
export type shareChatWithBot$Input = {
  readonly _: "shareChatWithBot";

  /**
   * Identifier of the chat with the bot
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the button
   * @type {int32} {@link int32}
   */
  readonly button_id?: int32;

  /**
   * Identifier of the shared chat
   * @type {int53} {@link int53}
   */
  readonly shared_chat_id?: int53;

  /**
   * Pass true to check that the chat can be shared by the button instead of actually sharing it. Doesn't check bot_is_member and bot_administrator_rights restrictions.
   *
   * - If the bot must be a member, then all chats from getGroupsInCommon and all chats, where the user can add the bot, are suitable. In the latter case the bot will be automatically added to the chat.
   *
   * - If the bot must be an administrator, then all chats, where the bot already has requested rights or can be added to administrators by the user, are suitable. In the latter case the bot will be automatically granted requested rights
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_check?: Bool$Input;
};

/**
 * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the bot
 */
export type shareChatWithBot$DirectInput = {
  /**
   * Identifier of the chat with the bot
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the button
   * @type {int32} {@link int32}
   */
  readonly button_id?: int32;

  /**
   * Identifier of the shared chat
   * @type {int53} {@link int53}
   */
  readonly shared_chat_id?: int53;

  /**
   * Pass true to check that the chat can be shared by the button instead of actually sharing it. Doesn't check bot_is_member and bot_administrator_rights restrictions.
   *
   * - If the bot must be a member, then all chats from getGroupsInCommon and all chats, where the user can add the bot, are suitable. In the latter case the bot will be automatically added to the chat.
   *
   * - If the bot must be an administrator, then all chats, where the bot already has requested rights or can be added to administrators by the user, are suitable. In the latter case the bot will be automatically granted requested rights
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_check?: Bool$Input;
};

/**
 * Shares a chat after pressing a keyboardButtonTypeRequestChat button with the bot
 *
 * @param {shareChatWithBot$Input} parameters {@link shareChatWithBot$Input}
 * @return {Ok} {@link Ok}
 */
export type shareChatWithBot = (parameters: shareChatWithBot$Input) => Ok;

/**
 * Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 */
export type getInlineQueryResults$Input = {
  readonly _: "getInlineQueryResults";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Location of the user; pass null if unknown or the bot doesn't need user's location
   * @type {location$Input} {@link location}
   */
  readonly user_location?: location$Input | null;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;
};

/**
 * Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 */
export type getInlineQueryResults$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Location of the user; pass null if unknown or the bot doesn't need user's location
   * @type {location$Input} {@link location}
   */
  readonly user_location?: location$Input | null;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;
};

/**
 * Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 *
 * @param {getInlineQueryResults$Input} parameters {@link getInlineQueryResults$Input}
 * @return {InlineQueryResults} {@link InlineQueryResults}
 */
export type getInlineQueryResults = (
  parameters: getInlineQueryResults$Input
) => InlineQueryResults;

/**
 * Sets the result of an inline query; for bots only
 */
export type answerInlineQuery$Input = {
  readonly _: "answerInlineQuery";

  /**
   * Identifier of the inline query
   * @type {int64$Input} {@link int64}
   */
  readonly inline_query_id?: int64$Input;

  /**
   * Pass true if results may be cached and returned only for the user that sent the query. By default, results may be returned to any user who sends the same query
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * Button to be shown above inline query results; pass null if none
   * @type {inlineQueryResultsButton$Input} {@link inlineQueryResultsButton}
   */
  readonly button?: inlineQueryResultsButton$Input | null;

  /**
   * The results of the query
   * @type {vector$Input<InputInlineQueryResult$Input>} {@link vector<InputInlineQueryResult>}
   */
  readonly results?: vector$Input<InputInlineQueryResult$Input>;

  /**
   * Allowed time to cache the results of the query, in seconds
   * @type {int32} {@link int32}
   */
  readonly cache_time?: int32;

  /**
   * Offset for the next inline query; pass an empty string if there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Sets the result of an inline query; for bots only
 */
export type answerInlineQuery$DirectInput = {
  /**
   * Identifier of the inline query
   * @type {int64$Input} {@link int64}
   */
  readonly inline_query_id?: int64$Input;

  /**
   * Pass true if results may be cached and returned only for the user that sent the query. By default, results may be returned to any user who sends the same query
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * Button to be shown above inline query results; pass null if none
   * @type {inlineQueryResultsButton$Input} {@link inlineQueryResultsButton}
   */
  readonly button?: inlineQueryResultsButton$Input | null;

  /**
   * The results of the query
   * @type {vector$Input<InputInlineQueryResult$Input>} {@link vector<InputInlineQueryResult>}
   */
  readonly results?: vector$Input<InputInlineQueryResult$Input>;

  /**
   * Allowed time to cache the results of the query, in seconds
   * @type {int32} {@link int32}
   */
  readonly cache_time?: int32;

  /**
   * Offset for the next inline query; pass an empty string if there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/**
 * Sets the result of an inline query; for bots only
 *
 * @param {answerInlineQuery$Input} parameters {@link answerInlineQuery$Input}
 * @return {Ok} {@link Ok}
 */
export type answerInlineQuery = (parameters: answerInlineQuery$Input) => Ok;

/**
 * Returns information about a Web App by its short name. Returns a 404 error if the Web App is not found
 */
export type searchWebApp$Input = {
  readonly _: "searchWebApp";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Short name of the Web App
   * @type {string} {@link string}
   */
  readonly web_app_short_name?: string;
};

/**
 * Returns information about a Web App by its short name. Returns a 404 error if the Web App is not found
 */
export type searchWebApp$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Short name of the Web App
   * @type {string} {@link string}
   */
  readonly web_app_short_name?: string;
};

/**
 * Returns information about a Web App by its short name. Returns a 404 error if the Web App is not found
 *
 * @param {searchWebApp$Input} parameters {@link searchWebApp$Input}
 * @return {FoundWebApp} {@link FoundWebApp}
 */
export type searchWebApp = (parameters: searchWebApp$Input) => FoundWebApp;

/**
 * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp is clicked
 */
export type getWebAppLinkUrl$Input = {
  readonly _: "getWebAppLinkUrl";

  /**
   * Identifier of the chat in which the link was clicked; pass 0 if none
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Short name of the Web App
   * @type {string} {@link string}
   */
  readonly web_app_short_name?: string;

  /**
   * Start parameter from internalLinkTypeWebApp
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * Pass true if the current user allowed the bot to send them messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp is clicked
 */
export type getWebAppLinkUrl$DirectInput = {
  /**
   * Identifier of the chat in which the link was clicked; pass 0 if none
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Short name of the Web App
   * @type {string} {@link string}
   */
  readonly web_app_short_name?: string;

  /**
   * Start parameter from internalLinkTypeWebApp
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * Pass true if the current user allowed the bot to send them messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTPS URL of a Web App to open after a link of the type internalLinkTypeWebApp is clicked
 *
 * @param {getWebAppLinkUrl$Input} parameters {@link getWebAppLinkUrl$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getWebAppLinkUrl = (parameters: getWebAppLinkUrl$Input) => HttpUrl;

/**
 * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot link
 */
export type getWebAppUrl$Input = {
  readonly _: "getWebAppUrl";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The URL from a keyboardButtonTypeWebApp button, inlineQueryResultsButtonTypeWebApp button, an internalLinkTypeSideMenuBot link, or an empty when the bot is opened from the side menu
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;
};

/**
 * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot link
 */
export type getWebAppUrl$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The URL from a keyboardButtonTypeWebApp button, inlineQueryResultsButtonTypeWebApp button, an internalLinkTypeSideMenuBot link, or an empty when the bot is opened from the side menu
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;
};

/**
 * Returns an HTTPS URL of a Web App to open from the side menu, a keyboardButtonTypeWebApp button, an inlineQueryResultsButtonTypeWebApp button, or an internalLinkTypeSideMenuBot link
 *
 * @param {getWebAppUrl$Input} parameters {@link getWebAppUrl$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getWebAppUrl = (parameters: getWebAppUrl$Input) => HttpUrl;

/**
 * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
 */
export type sendWebAppData$Input = {
  readonly _: "sendWebAppData";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;

  /**
   * The data
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
 */
export type sendWebAppData$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;

  /**
   * The data
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
 *
 * @param {sendWebAppData$Input} parameters {@link sendWebAppData$Input}
 * @return {Ok} {@link Ok}
 */
export type sendWebAppData = (parameters: sendWebAppData$Input) => Ok;

/**
 * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
 *
 * - For each bot, a confirmation alert about data sent to the bot must be shown once
 */
export type openWebApp$Input = {
  readonly _: "openWebApp";

  /**
   * Identifier of the chat in which the Web App is opened. The Web App can't be opened in secret chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the bot, providing the Web App
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied in the message sent by the Web App; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;
};

/**
 * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
 *
 * - For each bot, a confirmation alert about data sent to the bot must be shown once
 */
export type openWebApp$DirectInput = {
  /**
   * Identifier of the chat in which the Web App is opened. The Web App can't be opened in secret chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the bot, providing the Web App
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message or story to be replied in the message sent by the Web App; pass null if none
   * @type {InputMessageReplyTo$Input} {@link InputMessageReplyTo}
   */
  readonly reply_to?: InputMessageReplyTo$Input | null;
};

/**
 * Informs TDLib that a Web App is being opened from the attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
 *
 * - For each bot, a confirmation alert about data sent to the bot must be shown once
 *
 * @param {openWebApp$Input} parameters {@link openWebApp$Input}
 * @return {WebAppInfo} {@link WebAppInfo}
 */
export type openWebApp = (parameters: openWebApp$Input) => WebAppInfo;

/**
 * Informs TDLib that a previously opened Web App was closed
 */
export type closeWebApp$Input = {
  readonly _: "closeWebApp";

  /**
   * Identifier of Web App launch, received from openWebApp
   * @type {int64$Input} {@link int64}
   */
  readonly web_app_launch_id?: int64$Input;
};

/**
 * Informs TDLib that a previously opened Web App was closed
 */
export type closeWebApp$DirectInput = {
  /**
   * Identifier of Web App launch, received from openWebApp
   * @type {int64$Input} {@link int64}
   */
  readonly web_app_launch_id?: int64$Input;
};

/**
 * Informs TDLib that a previously opened Web App was closed
 *
 * @param {closeWebApp$Input} parameters {@link closeWebApp$Input}
 * @return {Ok} {@link Ok}
 */
export type closeWebApp = (parameters: closeWebApp$Input) => Ok;

/**
 * Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only
 */
export type answerWebAppQuery$Input = {
  readonly _: "answerWebAppQuery";

  /**
   * Identifier of the Web App query
   * @type {string} {@link string}
   */
  readonly web_app_query_id?: string;

  /**
   * The result of the query
   * @type {InputInlineQueryResult$Input} {@link InputInlineQueryResult}
   */
  readonly result?: InputInlineQueryResult$Input;
};

/**
 * Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only
 */
export type answerWebAppQuery$DirectInput = {
  /**
   * Identifier of the Web App query
   * @type {string} {@link string}
   */
  readonly web_app_query_id?: string;

  /**
   * The result of the query
   * @type {InputInlineQueryResult$Input} {@link InputInlineQueryResult}
   */
  readonly result?: InputInlineQueryResult$Input;
};

/**
 * Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only
 *
 * @param {answerWebAppQuery$Input} parameters {@link answerWebAppQuery$Input}
 * @return {SentWebAppMessage} {@link SentWebAppMessage}
 */
export type answerWebAppQuery = (
  parameters: answerWebAppQuery$Input
) => SentWebAppMessage;

/**
 * Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 */
export type getCallbackQueryAnswer$Input = {
  readonly _: "getCallbackQueryAnswer";

  /**
   * Identifier of the chat with the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Query payload
   * @type {CallbackQueryPayload$Input} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/**
 * Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 */
export type getCallbackQueryAnswer$DirectInput = {
  /**
   * Identifier of the chat with the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Query payload
   * @type {CallbackQueryPayload$Input} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/**
 * Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 *
 * @param {getCallbackQueryAnswer$Input} parameters {@link getCallbackQueryAnswer$Input}
 * @return {CallbackQueryAnswer} {@link CallbackQueryAnswer}
 */
export type getCallbackQueryAnswer = (
  parameters: getCallbackQueryAnswer$Input
) => CallbackQueryAnswer;

/**
 * Sets the result of a callback query; for bots only
 */
export type answerCallbackQuery$Input = {
  readonly _: "answerCallbackQuery";

  /**
   * Identifier of the callback query
   * @type {int64$Input} {@link int64}
   */
  readonly callback_query_id?: int64$Input;

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Pass true to show an alert to the user instead of a toast notification
   * @type {Bool$Input} {@link Bool}
   */
  readonly show_alert?: Bool$Input;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Time during which the result of the query can be cached, in seconds
   * @type {int32} {@link int32}
   */
  readonly cache_time?: int32;
};

/**
 * Sets the result of a callback query; for bots only
 */
export type answerCallbackQuery$DirectInput = {
  /**
   * Identifier of the callback query
   * @type {int64$Input} {@link int64}
   */
  readonly callback_query_id?: int64$Input;

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Pass true to show an alert to the user instead of a toast notification
   * @type {Bool$Input} {@link Bool}
   */
  readonly show_alert?: Bool$Input;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Time during which the result of the query can be cached, in seconds
   * @type {int32} {@link int32}
   */
  readonly cache_time?: int32;
};

/**
 * Sets the result of a callback query; for bots only
 *
 * @param {answerCallbackQuery$Input} parameters {@link answerCallbackQuery$Input}
 * @return {Ok} {@link Ok}
 */
export type answerCallbackQuery = (parameters: answerCallbackQuery$Input) => Ok;

/**
 * Sets the result of a shipping query; for bots only
 */
export type answerShippingQuery$Input = {
  readonly _: "answerShippingQuery";

  /**
   * Identifier of the shipping query
   * @type {int64$Input} {@link int64}
   */
  readonly shipping_query_id?: int64$Input;

  /**
   * Available shipping options
   * @type {vector$Input<shippingOption$Input>} {@link vector<shippingOption>}
   */
  readonly shipping_options?: vector$Input<shippingOption$Input>;

  /**
   * An error message, empty on success
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Sets the result of a shipping query; for bots only
 */
export type answerShippingQuery$DirectInput = {
  /**
   * Identifier of the shipping query
   * @type {int64$Input} {@link int64}
   */
  readonly shipping_query_id?: int64$Input;

  /**
   * Available shipping options
   * @type {vector$Input<shippingOption$Input>} {@link vector<shippingOption>}
   */
  readonly shipping_options?: vector$Input<shippingOption$Input>;

  /**
   * An error message, empty on success
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Sets the result of a shipping query; for bots only
 *
 * @param {answerShippingQuery$Input} parameters {@link answerShippingQuery$Input}
 * @return {Ok} {@link Ok}
 */
export type answerShippingQuery = (parameters: answerShippingQuery$Input) => Ok;

/**
 * Sets the result of a pre-checkout query; for bots only
 */
export type answerPreCheckoutQuery$Input = {
  readonly _: "answerPreCheckoutQuery";

  /**
   * Identifier of the pre-checkout query
   * @type {int64$Input} {@link int64}
   */
  readonly pre_checkout_query_id?: int64$Input;

  /**
   * An error message, empty on success
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Sets the result of a pre-checkout query; for bots only
 */
export type answerPreCheckoutQuery$DirectInput = {
  /**
   * Identifier of the pre-checkout query
   * @type {int64$Input} {@link int64}
   */
  readonly pre_checkout_query_id?: int64$Input;

  /**
   * An error message, empty on success
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Sets the result of a pre-checkout query; for bots only
 *
 * @param {answerPreCheckoutQuery$Input} parameters {@link answerPreCheckoutQuery$Input}
 * @return {Ok} {@link Ok}
 */
export type answerPreCheckoutQuery = (
  parameters: answerPreCheckoutQuery$Input
) => Ok;

/**
 * Updates the game score of the specified user in the game; for bots only
 */
export type setGameScore$Input = {
  readonly _: "setGameScore";

  /**
   * The chat to which the message with the game belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to edit the game message to include the current scoreboard
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_message?: Bool$Input;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The new score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Updates the game score of the specified user in the game; for bots only
 */
export type setGameScore$DirectInput = {
  /**
   * The chat to which the message with the game belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to edit the game message to include the current scoreboard
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_message?: Bool$Input;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The new score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Updates the game score of the specified user in the game; for bots only
 *
 * @param {setGameScore$Input} parameters {@link setGameScore$Input}
 * @return {Message} {@link Message}
 */
export type setGameScore = (parameters: setGameScore$Input) => Message;

/**
 * Updates the game score of the specified user in a game; for bots only
 */
export type setInlineGameScore$Input = {
  readonly _: "setInlineGameScore";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * Pass true to edit the game message to include the current scoreboard
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_message?: Bool$Input;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The new score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Updates the game score of the specified user in a game; for bots only
 */
export type setInlineGameScore$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * Pass true to edit the game message to include the current scoreboard
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_message?: Bool$Input;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The new score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Updates the game score of the specified user in a game; for bots only
 *
 * @param {setInlineGameScore$Input} parameters {@link setInlineGameScore$Input}
 * @return {Ok} {@link Ok}
 */
export type setInlineGameScore = (parameters: setInlineGameScore$Input) => Ok;

/**
 * Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
 */
export type getGameHighScores$Input = {
  readonly _: "getGameHighScores";

  /**
   * The chat that contains the message with the game
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
 */
export type getGameHighScores$DirectInput = {
  /**
   * The chat that contains the message with the game
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
 *
 * @param {getGameHighScores$Input} parameters {@link getGameHighScores$Input}
 * @return {GameHighScores} {@link GameHighScores}
 */
export type getGameHighScores = (
  parameters: getGameHighScores$Input
) => GameHighScores;

/**
 * Returns game high scores and some part of the high score table in the range of the specified user; for bots only
 */
export type getInlineGameHighScores$Input = {
  readonly _: "getInlineGameHighScores";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns game high scores and some part of the high score table in the range of the specified user; for bots only
 */
export type getInlineGameHighScores$DirectInput = {
  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns game high scores and some part of the high score table in the range of the specified user; for bots only
 *
 * @param {getInlineGameHighScores$Input} parameters {@link getInlineGameHighScores$Input}
 * @return {GameHighScores} {@link GameHighScores}
 */
export type getInlineGameHighScores = (
  parameters: getInlineGameHighScores$Input
) => GameHighScores;

/**
 * Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup update will be sent if the reply markup is changed
 */
export type deleteChatReplyMarkup$Input = {
  readonly _: "deleteChatReplyMarkup";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The message identifier of the used keyboard
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup update will be sent if the reply markup is changed
 */
export type deleteChatReplyMarkup$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The message identifier of the used keyboard
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a replyMarkupForceReply reply markup has been used. An updateChatReplyMarkup update will be sent if the reply markup is changed
 *
 * @param {deleteChatReplyMarkup$Input} parameters {@link deleteChatReplyMarkup$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatReplyMarkup = (parameters: deleteChatReplyMarkup$Input) => Ok;

/**
 * Sends a notification about user activity in a chat
 */
export type sendChatAction$Input = {
  readonly _: "sendChatAction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * The action description; pass null to cancel the currently active action
   * @type {ChatAction$Input} {@link ChatAction}
   */
  readonly action?: ChatAction$Input | null;
};

/**
 * Sends a notification about user activity in a chat
 */
export type sendChatAction$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * The action description; pass null to cancel the currently active action
   * @type {ChatAction$Input} {@link ChatAction}
   */
  readonly action?: ChatAction$Input | null;
};

/**
 * Sends a notification about user activity in a chat
 *
 * @param {sendChatAction$Input} parameters {@link sendChatAction$Input}
 * @return {Ok} {@link Ok}
 */
export type sendChatAction = (parameters: sendChatAction$Input) => Ok;

/**
 * Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
 */
export type openChat$Input = {
  readonly _: "openChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
 */
export type openChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
 *
 * @param {openChat$Input} parameters {@link openChat$Input}
 * @return {Ok} {@link Ok}
 */
export type openChat = (parameters: openChat$Input) => Ok;

/**
 * Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
 */
export type closeChat$Input = {
  readonly _: "closeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
 */
export type closeChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
 *
 * @param {closeChat$Input} parameters {@link closeChat$Input}
 * @return {Ok} {@link Ok}
 */
export type closeChat = (parameters: closeChat$Input) => Ok;

/**
 * Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button).
 *
 * - Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
 */
export type viewMessages$Input = {
  readonly _: "viewMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The identifiers of the messages being viewed
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Source of the message view; pass null to guess the source based on chat open state
   * @type {MessageSource$Input} {@link MessageSource}
   */
  readonly source?: MessageSource$Input | null;

  /**
   * Pass true to mark as read the specified messages even the chat is closed
   * @type {Bool$Input} {@link Bool}
   */
  readonly force_read?: Bool$Input;
};

/**
 * Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button).
 *
 * - Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
 */
export type viewMessages$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The identifiers of the messages being viewed
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Source of the message view; pass null to guess the source based on chat open state
   * @type {MessageSource$Input} {@link MessageSource}
   */
  readonly source?: MessageSource$Input | null;

  /**
   * Pass true to mark as read the specified messages even the chat is closed
   * @type {Bool$Input} {@link Bool}
   */
  readonly force_read?: Bool$Input;
};

/**
 * Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button).
 *
 * - Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
 *
 * @param {viewMessages$Input} parameters {@link viewMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type viewMessages = (parameters: viewMessages$Input) => Ok;

/**
 * Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message).
 *
 * - An updateMessageContentOpened update will be generated if something has changed
 */
export type openMessageContent$Input = {
  readonly _: "openMessageContent";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the opened content
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message).
 *
 * - An updateMessageContentOpened update will be generated if something has changed
 */
export type openMessageContent$DirectInput = {
  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the opened content
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message).
 *
 * - An updateMessageContentOpened update will be generated if something has changed
 *
 * @param {openMessageContent$Input} parameters {@link openMessageContent$Input}
 * @return {Ok} {@link Ok}
 */
export type openMessageContent = (parameters: openMessageContent$Input) => Ok;

/**
 * Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
 */
export type clickAnimatedEmojiMessage$Input = {
  readonly _: "clickAnimatedEmojiMessage";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the clicked message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
 */
export type clickAnimatedEmojiMessage$DirectInput = {
  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the clicked message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
 *
 * @param {clickAnimatedEmojiMessage$Input} parameters {@link clickAnimatedEmojiMessage$Input}
 * @return {Sticker} {@link Sticker}
 */
export type clickAnimatedEmojiMessage = (
  parameters: clickAnimatedEmojiMessage$Input
) => Sticker;

/**
 * Returns an HTTPS or a tg: link with the given type. Can be called before authorization
 */
export type getInternalLink$Input = {
  readonly _: "getInternalLink";

  /**
   * Expected type of the link
   * @type {InternalLinkType$Input} {@link InternalLinkType}
   */
  readonly type?: InternalLinkType$Input;

  /**
   * Pass true to create an HTTPS link (only available for some link types); pass false to create a tg: link
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_http?: Bool$Input;
};

/**
 * Returns an HTTPS or a tg: link with the given type. Can be called before authorization
 */
export type getInternalLink$DirectInput = {
  /**
   * Expected type of the link
   * @type {InternalLinkType$Input} {@link InternalLinkType}
   */
  readonly type?: InternalLinkType$Input;

  /**
   * Pass true to create an HTTPS link (only available for some link types); pass false to create a tg: link
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_http?: Bool$Input;
};

/**
 * Returns an HTTPS or a tg: link with the given type. Can be called before authorization
 *
 * @param {getInternalLink$Input} parameters {@link getInternalLink$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getInternalLink = (parameters: getInternalLink$Input) => HttpUrl;

/**
 * Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
 */
export type getInternalLinkType$Input = {
  readonly _: "getInternalLinkType";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
 */
export type getInternalLinkType$DirectInput = {
  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
 *
 * @param {getInternalLinkType$Input} parameters {@link getInternalLinkType$Input}
 * @return {InternalLinkType} {@link InternalLinkType}
 */
export type getInternalLinkType = (
  parameters: getInternalLinkType$Input
) => InternalLinkType;

/**
 * Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
 */
export type getExternalLinkInfo$Input = {
  readonly _: "getExternalLinkInfo";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
 */
export type getExternalLinkInfo$DirectInput = {
  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
 *
 * @param {getExternalLinkInfo$Input} parameters {@link getExternalLinkInfo$Input}
 * @return {LoginUrlInfo} {@link LoginUrlInfo}
 */
export type getExternalLinkInfo = (
  parameters: getExternalLinkInfo$Input
) => LoginUrlInfo;

/**
 * Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
 */
export type getExternalLink$Input = {
  readonly _: "getExternalLink";

  /**
   * The HTTP link
   * @type {string} {@link string}
   */
  readonly link?: string;

  /**
   * Pass true if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
 */
export type getExternalLink$DirectInput = {
  /**
   * The HTTP link
   * @type {string} {@link string}
   */
  readonly link?: string;

  /**
   * Pass true if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
 *
 * @param {getExternalLink$Input} parameters {@link getExternalLink$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getExternalLink = (parameters: getExternalLink$Input) => HttpUrl;

/**
 * Marks all mentions in a chat as read
 */
export type readAllChatMentions$Input = {
  readonly _: "readAllChatMentions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Marks all mentions in a chat as read
 */
export type readAllChatMentions$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Marks all mentions in a chat as read
 *
 * @param {readAllChatMentions$Input} parameters {@link readAllChatMentions$Input}
 * @return {Ok} {@link Ok}
 */
export type readAllChatMentions = (parameters: readAllChatMentions$Input) => Ok;

/**
 * Marks all mentions in a forum topic as read
 */
export type readAllMessageThreadMentions$Input = {
  readonly _: "readAllMessageThreadMentions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which mentions are marked as read
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Marks all mentions in a forum topic as read
 */
export type readAllMessageThreadMentions$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which mentions are marked as read
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Marks all mentions in a forum topic as read
 *
 * @param {readAllMessageThreadMentions$Input} parameters {@link readAllMessageThreadMentions$Input}
 * @return {Ok} {@link Ok}
 */
export type readAllMessageThreadMentions = (
  parameters: readAllMessageThreadMentions$Input
) => Ok;

/**
 * Marks all reactions in a chat or a forum topic as read
 */
export type readAllChatReactions$Input = {
  readonly _: "readAllChatReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Marks all reactions in a chat or a forum topic as read
 */
export type readAllChatReactions$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Marks all reactions in a chat or a forum topic as read
 *
 * @param {readAllChatReactions$Input} parameters {@link readAllChatReactions$Input}
 * @return {Ok} {@link Ok}
 */
export type readAllChatReactions = (parameters: readAllChatReactions$Input) => Ok;

/**
 * Marks all reactions in a forum topic as read
 */
export type readAllMessageThreadReactions$Input = {
  readonly _: "readAllMessageThreadReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which reactions are marked as read
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Marks all reactions in a forum topic as read
 */
export type readAllMessageThreadReactions$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which reactions are marked as read
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Marks all reactions in a forum topic as read
 *
 * @param {readAllMessageThreadReactions$Input} parameters {@link readAllMessageThreadReactions$Input}
 * @return {Ok} {@link Ok}
 */
export type readAllMessageThreadReactions = (
  parameters: readAllMessageThreadReactions$Input
) => Ok;

/**
 * Returns an existing chat corresponding to a given user
 */
export type createPrivateChat$Input = {
  readonly _: "createPrivateChat";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a given user
 */
export type createPrivateChat$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a given user
 *
 * @param {createPrivateChat$Input} parameters {@link createPrivateChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createPrivateChat = (parameters: createPrivateChat$Input) => Chat;

/**
 * Returns an existing chat corresponding to a known basic group
 */
export type createBasicGroupChat$Input = {
  readonly _: "createBasicGroupChat";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a known basic group
 */
export type createBasicGroupChat$DirectInput = {
  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a known basic group
 *
 * @param {createBasicGroupChat$Input} parameters {@link createBasicGroupChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createBasicGroupChat = (parameters: createBasicGroupChat$Input) => Chat;

/**
 * Returns an existing chat corresponding to a known supergroup or channel
 */
export type createSupergroupChat$Input = {
  readonly _: "createSupergroupChat";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a known supergroup or channel
 */
export type createSupergroupChat$DirectInput = {
  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a known supergroup or channel
 *
 * @param {createSupergroupChat$Input} parameters {@link createSupergroupChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createSupergroupChat = (parameters: createSupergroupChat$Input) => Chat;

/**
 * Returns an existing chat corresponding to a known secret chat
 */
export type createSecretChat$Input = {
  readonly _: "createSecretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Returns an existing chat corresponding to a known secret chat
 */
export type createSecretChat$DirectInput = {
  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Returns an existing chat corresponding to a known secret chat
 *
 * @param {createSecretChat$Input} parameters {@link createSecretChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createSecretChat = (parameters: createSecretChat$Input) => Chat;

/**
 * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
 */
export type createNewBasicGroupChat$Input = {
  readonly _: "createNewBasicGroupChat";

  /**
   * Identifiers of users to be added to the basic group; may be empty to create a basic group without other members
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * Title of the new basic group; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;
};

/**
 * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
 */
export type createNewBasicGroupChat$DirectInput = {
  /**
   * Identifiers of users to be added to the basic group; may be empty to create a basic group without other members
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * Title of the new basic group; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;
};

/**
 * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
 *
 * @param {createNewBasicGroupChat$Input} parameters {@link createNewBasicGroupChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createNewBasicGroupChat = (
  parameters: createNewBasicGroupChat$Input
) => Chat;

/**
 * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
 */
export type createNewSupergroupChat$Input = {
  readonly _: "createNewSupergroupChat";

  /**
   * Title of the new chat; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Pass true to create a forum supergroup chat
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_forum?: Bool$Input;

  /**
   * Pass true to create a channel chat; ignored if a forum is created
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Chat location if a location-based supergroup is being created; pass null to create an ordinary supergroup chat
   * @type {chatLocation$Input} {@link chatLocation}
   */
  readonly location?: chatLocation$Input | null;

  /**
   * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;

  /**
   * Pass true to create a supergroup for importing messages using importMessages
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_import?: Bool$Input;
};

/**
 * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
 */
export type createNewSupergroupChat$DirectInput = {
  /**
   * Title of the new chat; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Pass true to create a forum supergroup chat
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_forum?: Bool$Input;

  /**
   * Pass true to create a channel chat; ignored if a forum is created
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Chat location if a location-based supergroup is being created; pass null to create an ordinary supergroup chat
   * @type {chatLocation$Input} {@link chatLocation}
   */
  readonly location?: chatLocation$Input | null;

  /**
   * Message auto-delete time value, in seconds; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;

  /**
   * Pass true to create a supergroup for importing messages using importMessages
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_import?: Bool$Input;
};

/**
 * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
 *
 * @param {createNewSupergroupChat$Input} parameters {@link createNewSupergroupChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createNewSupergroupChat = (
  parameters: createNewSupergroupChat$Input
) => Chat;

/**
 * Creates a new secret chat. Returns the newly created chat
 */
export type createNewSecretChat$Input = {
  readonly _: "createNewSecretChat";

  /**
   * Identifier of the target user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Creates a new secret chat. Returns the newly created chat
 */
export type createNewSecretChat$DirectInput = {
  /**
   * Identifier of the target user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Creates a new secret chat. Returns the newly created chat
 *
 * @param {createNewSecretChat$Input} parameters {@link createNewSecretChat$Input}
 * @return {Chat} {@link Chat}
 */
export type createNewSecretChat = (parameters: createNewSecretChat$Input) => Chat;

/**
 * Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
 */
export type upgradeBasicGroupChatToSupergroupChat$Input = {
  readonly _: "upgradeBasicGroupChatToSupergroupChat";

  /**
   * Identifier of the chat to upgrade
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
 */
export type upgradeBasicGroupChatToSupergroupChat$DirectInput = {
  /**
   * Identifier of the chat to upgrade
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
 *
 * @param {upgradeBasicGroupChatToSupergroupChat$Input} parameters {@link upgradeBasicGroupChatToSupergroupChat$Input}
 * @return {Chat} {@link Chat}
 */
export type upgradeBasicGroupChatToSupergroupChat = (
  parameters: upgradeBasicGroupChatToSupergroupChat$Input
) => Chat;

/**
 * Returns chat lists to which the chat can be added. This is an offline request
 */
export type getChatListsToAddChat$Input = {
  readonly _: "getChatListsToAddChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns chat lists to which the chat can be added. This is an offline request
 */
export type getChatListsToAddChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns chat lists to which the chat can be added. This is an offline request
 *
 * @param {getChatListsToAddChat$Input} parameters {@link getChatListsToAddChat$Input}
 * @return {ChatLists} {@link ChatLists}
 */
export type getChatListsToAddChat = (
  parameters: getChatListsToAddChat$Input
) => ChatLists;

/**
 * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
 */
export type addChatToList$Input = {
  readonly _: "addChatToList";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The chat list. Use getChatListsToAddChat to get suitable chat lists
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;
};

/**
 * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
 */
export type addChatToList$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The chat list. Use getChatListsToAddChat to get suitable chat lists
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;
};

/**
 * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
 *
 * @param {addChatToList$Input} parameters {@link addChatToList$Input}
 * @return {Ok} {@link Ok}
 */
export type addChatToList = (parameters: addChatToList$Input) => Ok;

/**
 * Returns information about a chat folder by its identifier
 */
export type getChatFolder$Input = {
  readonly _: "getChatFolder";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns information about a chat folder by its identifier
 */
export type getChatFolder$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns information about a chat folder by its identifier
 *
 * @param {getChatFolder$Input} parameters {@link getChatFolder$Input}
 * @return {ChatFolder} {@link ChatFolder}
 */
export type getChatFolder = (parameters: getChatFolder$Input) => ChatFolder;

/**
 * Creates new chat folder. Returns information about the created chat folder. There can be up to getOption("chat_folder_count_max") chat folders, but the limit can be increased with Telegram Premium
 */
export type createChatFolder$Input = {
  readonly _: "createChatFolder";

  /**
   * The new chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Creates new chat folder. Returns information about the created chat folder. There can be up to getOption("chat_folder_count_max") chat folders, but the limit can be increased with Telegram Premium
 */
export type createChatFolder$DirectInput = {
  /**
   * The new chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Creates new chat folder. Returns information about the created chat folder. There can be up to getOption("chat_folder_count_max") chat folders, but the limit can be increased with Telegram Premium
 *
 * @param {createChatFolder$Input} parameters {@link createChatFolder$Input}
 * @return {ChatFolderInfo} {@link ChatFolderInfo}
 */
export type createChatFolder = (
  parameters: createChatFolder$Input
) => ChatFolderInfo;

/**
 * Edits existing chat folder. Returns information about the edited chat folder
 */
export type editChatFolder$Input = {
  readonly _: "editChatFolder";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * The edited chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Edits existing chat folder. Returns information about the edited chat folder
 */
export type editChatFolder$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * The edited chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Edits existing chat folder. Returns information about the edited chat folder
 *
 * @param {editChatFolder$Input} parameters {@link editChatFolder$Input}
 * @return {ChatFolderInfo} {@link ChatFolderInfo}
 */
export type editChatFolder = (parameters: editChatFolder$Input) => ChatFolderInfo;

/**
 * Deletes existing chat folder
 */
export type deleteChatFolder$Input = {
  readonly _: "deleteChatFolder";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Identifiers of the chats to leave. The chats must be pinned or always included in the folder
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly leave_chat_ids?: vector$Input<int53>;
};

/**
 * Deletes existing chat folder
 */
export type deleteChatFolder$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Identifiers of the chats to leave. The chats must be pinned or always included in the folder
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly leave_chat_ids?: vector$Input<int53>;
};

/**
 * Deletes existing chat folder
 *
 * @param {deleteChatFolder$Input} parameters {@link deleteChatFolder$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatFolder = (parameters: deleteChatFolder$Input) => Ok;

/**
 * Returns identifiers of pinned or always included chats from a chat folder, which are suggested to be left when the chat folder is deleted
 */
export type getChatFolderChatsToLeave$Input = {
  readonly _: "getChatFolderChatsToLeave";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns identifiers of pinned or always included chats from a chat folder, which are suggested to be left when the chat folder is deleted
 */
export type getChatFolderChatsToLeave$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns identifiers of pinned or always included chats from a chat folder, which are suggested to be left when the chat folder is deleted
 *
 * @param {getChatFolderChatsToLeave$Input} parameters {@link getChatFolderChatsToLeave$Input}
 * @return {Chats} {@link Chats}
 */
export type getChatFolderChatsToLeave = (
  parameters: getChatFolderChatsToLeave$Input
) => Chats;

/**
 * Returns approximate number of chats in a being created chat folder. Main and archive chat lists must be fully preloaded for this function to work correctly
 */
export type getChatFolderChatCount$Input = {
  readonly _: "getChatFolderChatCount";

  /**
   * The new chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Returns approximate number of chats in a being created chat folder. Main and archive chat lists must be fully preloaded for this function to work correctly
 */
export type getChatFolderChatCount$DirectInput = {
  /**
   * The new chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Returns approximate number of chats in a being created chat folder. Main and archive chat lists must be fully preloaded for this function to work correctly
 *
 * @param {getChatFolderChatCount$Input} parameters {@link getChatFolderChatCount$Input}
 * @return {Count} {@link Count}
 */
export type getChatFolderChatCount = (
  parameters: getChatFolderChatCount$Input
) => Count;

/**
 * Changes the order of chat folders
 */
export type reorderChatFolders$Input = {
  readonly _: "reorderChatFolders";

  /**
   * Identifiers of chat folders in the new correct order
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly chat_folder_ids?: vector$Input<int32>;

  /**
   * Position of the main chat list among chat folders, 0-based. Can be non-zero only for Premium users
   * @type {int32} {@link int32}
   */
  readonly main_chat_list_position?: int32;
};

/**
 * Changes the order of chat folders
 */
export type reorderChatFolders$DirectInput = {
  /**
   * Identifiers of chat folders in the new correct order
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly chat_folder_ids?: vector$Input<int32>;

  /**
   * Position of the main chat list among chat folders, 0-based. Can be non-zero only for Premium users
   * @type {int32} {@link int32}
   */
  readonly main_chat_list_position?: int32;
};

/**
 * Changes the order of chat folders
 *
 * @param {reorderChatFolders$Input} parameters {@link reorderChatFolders$Input}
 * @return {Ok} {@link Ok}
 */
export type reorderChatFolders = (parameters: reorderChatFolders$Input) => Ok;

/**
 * Returns recommended chat folders for the current user
 */
export type getRecommendedChatFolders$Input = {
  readonly _: "getRecommendedChatFolders";
};

/**
 * Returns recommended chat folders for the current user
 */
export type getRecommendedChatFolders$DirectInput = {};

/**
 * Returns recommended chat folders for the current user
 *
 * @param {getRecommendedChatFolders$Input} parameters {@link getRecommendedChatFolders$Input}
 * @return {RecommendedChatFolders} {@link RecommendedChatFolders}
 */
export type getRecommendedChatFolders = (
  parameters: getRecommendedChatFolders$Input
) => RecommendedChatFolders;

/**
 * Returns default icon name for a folder. Can be called synchronously
 */
export type getChatFolderDefaultIconName$Input = {
  readonly _: "getChatFolderDefaultIconName";

  /**
   * Chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Returns default icon name for a folder. Can be called synchronously
 */
export type getChatFolderDefaultIconName$DirectInput = {
  /**
   * Chat folder
   * @type {chatFolder$Input} {@link chatFolder}
   */
  readonly folder?: chatFolder$Input;
};

/**
 * Returns default icon name for a folder. Can be called synchronously
 *
 * @param {getChatFolderDefaultIconName$Input} parameters {@link getChatFolderDefaultIconName$Input}
 * @return {ChatFolderIcon} {@link ChatFolderIcon}
 */
export type getChatFolderDefaultIconName = (
  parameters: getChatFolderDefaultIconName$Input
) => ChatFolderIcon;

/**
 * Returns identifiers of chats from a chat folder, suitable for adding to a chat folder invite link
 */
export type getChatsForChatFolderInviteLink$Input = {
  readonly _: "getChatsForChatFolderInviteLink";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns identifiers of chats from a chat folder, suitable for adding to a chat folder invite link
 */
export type getChatsForChatFolderInviteLink$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns identifiers of chats from a chat folder, suitable for adding to a chat folder invite link
 *
 * @param {getChatsForChatFolderInviteLink$Input} parameters {@link getChatsForChatFolderInviteLink$Input}
 * @return {Chats} {@link Chats}
 */
export type getChatsForChatFolderInviteLink = (
  parameters: getChatsForChatFolderInviteLink$Input
) => Chats;

/**
 * Creates a new invite link for a chat folder. A link can be created for a chat folder if it has only pinned and included chats
 */
export type createChatFolderInviteLink$Input = {
  readonly _: "createChatFolderInviteLink";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Name of the link; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic groups will be automatically converted to supergroups before link creation
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Creates a new invite link for a chat folder. A link can be created for a chat folder if it has only pinned and included chats
 */
export type createChatFolderInviteLink$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Name of the link; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic groups will be automatically converted to supergroups before link creation
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Creates a new invite link for a chat folder. A link can be created for a chat folder if it has only pinned and included chats
 *
 * @param {createChatFolderInviteLink$Input} parameters {@link createChatFolderInviteLink$Input}
 * @return {ChatFolderInviteLink} {@link ChatFolderInviteLink}
 */
export type createChatFolderInviteLink = (
  parameters: createChatFolderInviteLink$Input
) => ChatFolderInviteLink;

/**
 * Returns invite links created by the current user for a shareable chat folder
 */
export type getChatFolderInviteLinks$Input = {
  readonly _: "getChatFolderInviteLinks";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns invite links created by the current user for a shareable chat folder
 */
export type getChatFolderInviteLinks$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns invite links created by the current user for a shareable chat folder
 *
 * @param {getChatFolderInviteLinks$Input} parameters {@link getChatFolderInviteLinks$Input}
 * @return {ChatFolderInviteLinks} {@link ChatFolderInviteLinks}
 */
export type getChatFolderInviteLinks = (
  parameters: getChatFolderInviteLinks$Input
) => ChatFolderInviteLinks;

/**
 * Edits an invite link for a chat folder
 */
export type editChatFolderInviteLink$Input = {
  readonly _: "editChatFolderInviteLink";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Invite link to be edited
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * New name of the link; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * New identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic groups will be automatically converted to supergroups before link editing
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Edits an invite link for a chat folder
 */
export type editChatFolderInviteLink$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Invite link to be edited
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * New name of the link; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * New identifiers of chats to be accessible by the invite link. Use getChatsForChatFolderInviteLink to get suitable chats. Basic groups will be automatically converted to supergroups before link editing
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Edits an invite link for a chat folder
 *
 * @param {editChatFolderInviteLink$Input} parameters {@link editChatFolderInviteLink$Input}
 * @return {ChatFolderInviteLink} {@link ChatFolderInviteLink}
 */
export type editChatFolderInviteLink = (
  parameters: editChatFolderInviteLink$Input
) => ChatFolderInviteLink;

/**
 * Deletes an invite link for a chat folder
 */
export type deleteChatFolderInviteLink$Input = {
  readonly _: "deleteChatFolderInviteLink";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Invite link to be deleted
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Deletes an invite link for a chat folder
 */
export type deleteChatFolderInviteLink$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Invite link to be deleted
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Deletes an invite link for a chat folder
 *
 * @param {deleteChatFolderInviteLink$Input} parameters {@link deleteChatFolderInviteLink$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatFolderInviteLink = (
  parameters: deleteChatFolderInviteLink$Input
) => Ok;

/**
 * Checks the validity of an invite link for a chat folder and returns information about the corresponding chat folder
 */
export type checkChatFolderInviteLink$Input = {
  readonly _: "checkChatFolderInviteLink";

  /**
   * Invite link to be checked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Checks the validity of an invite link for a chat folder and returns information about the corresponding chat folder
 */
export type checkChatFolderInviteLink$DirectInput = {
  /**
   * Invite link to be checked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Checks the validity of an invite link for a chat folder and returns information about the corresponding chat folder
 *
 * @param {checkChatFolderInviteLink$Input} parameters {@link checkChatFolderInviteLink$Input}
 * @return {ChatFolderInviteLinkInfo} {@link ChatFolderInviteLinkInfo}
 */
export type checkChatFolderInviteLink = (
  parameters: checkChatFolderInviteLink$Input
) => ChatFolderInviteLinkInfo;

/**
 * Adds a chat folder by an invite link
 */
export type addChatFolderByInviteLink$Input = {
  readonly _: "addChatFolderByInviteLink";

  /**
   * Invite link for the chat folder
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Identifiers of the chats added to the chat folder. The chats are automatically joined if they aren't joined yet
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Adds a chat folder by an invite link
 */
export type addChatFolderByInviteLink$DirectInput = {
  /**
   * Invite link for the chat folder
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Identifiers of the chats added to the chat folder. The chats are automatically joined if they aren't joined yet
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Adds a chat folder by an invite link
 *
 * @param {addChatFolderByInviteLink$Input} parameters {@link addChatFolderByInviteLink$Input}
 * @return {Ok} {@link Ok}
 */
export type addChatFolderByInviteLink = (
  parameters: addChatFolderByInviteLink$Input
) => Ok;

/**
 * Returns new chats added to a shareable chat folder by its owner. The method must be called at most once in getOption("chat_folder_new_chats_update_period") for the given chat folder
 */
export type getChatFolderNewChats$Input = {
  readonly _: "getChatFolderNewChats";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns new chats added to a shareable chat folder by its owner. The method must be called at most once in getOption("chat_folder_new_chats_update_period") for the given chat folder
 */
export type getChatFolderNewChats$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;
};

/**
 * Returns new chats added to a shareable chat folder by its owner. The method must be called at most once in getOption("chat_folder_new_chats_update_period") for the given chat folder
 *
 * @param {getChatFolderNewChats$Input} parameters {@link getChatFolderNewChats$Input}
 * @return {Chats} {@link Chats}
 */
export type getChatFolderNewChats = (
  parameters: getChatFolderNewChats$Input
) => Chats;

/**
 * Process new chats added to a shareable chat folder by its owner
 */
export type processChatFolderNewChats$Input = {
  readonly _: "processChatFolderNewChats";

  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Identifiers of the new chats, which are added to the chat folder. The chats are automatically joined if they aren't joined yet
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly added_chat_ids?: vector$Input<int53>;
};

/**
 * Process new chats added to a shareable chat folder by its owner
 */
export type processChatFolderNewChats$DirectInput = {
  /**
   * Chat folder identifier
   * @type {int32} {@link int32}
   */
  readonly chat_folder_id?: int32;

  /**
   * Identifiers of the new chats, which are added to the chat folder. The chats are automatically joined if they aren't joined yet
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly added_chat_ids?: vector$Input<int53>;
};

/**
 * Process new chats added to a shareable chat folder by its owner
 *
 * @param {processChatFolderNewChats$Input} parameters {@link processChatFolderNewChats$Input}
 * @return {Ok} {@link Ok}
 */
export type processChatFolderNewChats = (
  parameters: processChatFolderNewChats$Input
) => Ok;

/**
 * Returns settings for automatic moving of chats to and from the Archive chat lists
 */
export type getArchiveChatListSettings$Input = {
  readonly _: "getArchiveChatListSettings";
};

/**
 * Returns settings for automatic moving of chats to and from the Archive chat lists
 */
export type getArchiveChatListSettings$DirectInput = {};

/**
 * Returns settings for automatic moving of chats to and from the Archive chat lists
 *
 * @param {getArchiveChatListSettings$Input} parameters {@link getArchiveChatListSettings$Input}
 * @return {ArchiveChatListSettings} {@link ArchiveChatListSettings}
 */
export type getArchiveChatListSettings = (
  parameters: getArchiveChatListSettings$Input
) => ArchiveChatListSettings;

/**
 * Changes settings for automatic moving of chats to and from the Archive chat lists
 */
export type setArchiveChatListSettings$Input = {
  readonly _: "setArchiveChatListSettings";

  /**
   * New settings
   * @type {archiveChatListSettings$Input} {@link archiveChatListSettings}
   */
  readonly settings?: archiveChatListSettings$Input;
};

/**
 * Changes settings for automatic moving of chats to and from the Archive chat lists
 */
export type setArchiveChatListSettings$DirectInput = {
  /**
   * New settings
   * @type {archiveChatListSettings$Input} {@link archiveChatListSettings}
   */
  readonly settings?: archiveChatListSettings$Input;
};

/**
 * Changes settings for automatic moving of chats to and from the Archive chat lists
 *
 * @param {setArchiveChatListSettings$Input} parameters {@link setArchiveChatListSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setArchiveChatListSettings = (
  parameters: setArchiveChatListSettings$Input
) => Ok;

/**
 * Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 */
export type setChatTitle$Input = {
  readonly _: "setChatTitle";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New title of the chat; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 */
export type setChatTitle$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New title of the chat; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 *
 * @param {setChatTitle$Input} parameters {@link setChatTitle$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatTitle = (parameters: setChatTitle$Input) => Ok;

/**
 * Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 */
export type setChatPhoto$Input = {
  readonly _: "setChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New chat photo; pass null to delete the chat photo
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input | null;
};

/**
 * Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 */
export type setChatPhoto$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New chat photo; pass null to delete the chat photo
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input | null;
};

/**
 * Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 *
 * @param {setChatPhoto$Input} parameters {@link setChatPhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatPhoto = (parameters: setChatPhoto$Input) => Ok;

/**
 * Changes accent color and background custom emoji of a chat. Requires can_change_info administrator right
 */
export type setChatAccentColor$Input = {
  readonly _: "setChatAccentColor";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the accent color to use. The chat must have at least accentColor.min_chat_boost_level boost level to pass the corresponding color
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. Use chatBoostLevelFeatures.can_set_background_custom_emoji to check whether a custom emoji can be set
   * @type {int64$Input} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji of a chat. Requires can_change_info administrator right
 */
export type setChatAccentColor$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the accent color to use. The chat must have at least accentColor.min_chat_boost_level boost level to pass the corresponding color
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none. Use chatBoostLevelFeatures.can_set_background_custom_emoji to check whether a custom emoji can be set
   * @type {int64$Input} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji of a chat. Requires can_change_info administrator right
 *
 * @param {setChatAccentColor$Input} parameters {@link setChatAccentColor$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatAccentColor = (parameters: setChatAccentColor$Input) => Ok;

/**
 * Changes accent color and background custom emoji for profile of a chat. Requires can_change_info administrator right
 */
export type setChatProfileAccentColor$Input = {
  readonly _: "setChatProfileAccentColor";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the accent color to use for profile; pass -1 if none. The chat must have at least profileAccentColor.min_chat_boost_level boost level to pass the corresponding color
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the chat's profile photo background; 0 if none. Use chatBoostLevelFeatures.can_set_profile_background_custom_emoji to check whether a custom emoji can be set
   * @type {int64$Input} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji for profile of a chat. Requires can_change_info administrator right
 */
export type setChatProfileAccentColor$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the accent color to use for profile; pass -1 if none. The chat must have at least profileAccentColor.min_chat_boost_level boost level to pass the corresponding color
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the chat's profile photo background; 0 if none. Use chatBoostLevelFeatures.can_set_profile_background_custom_emoji to check whether a custom emoji can be set
   * @type {int64$Input} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji for profile of a chat. Requires can_change_info administrator right
 *
 * @param {setChatProfileAccentColor$Input} parameters {@link setChatProfileAccentColor$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatProfileAccentColor = (
  parameters: setChatProfileAccentColor$Input
) => Ok;

/**
 * Changes the message auto-delete or self-destruct (for secret chats) time in a chat. Requires change_info administrator right in basic groups, supergroups and channels
 *
 * - Message auto-delete time can't be changed in a chat with the current user (Saved Messages) and the chat 777000 (Telegram).
 */
export type setChatMessageAutoDeleteTime$Input = {
  readonly _: "setChatMessageAutoDeleteTime";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New time value, in seconds; unless the chat is secret, it must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;
};

/**
 * Changes the message auto-delete or self-destruct (for secret chats) time in a chat. Requires change_info administrator right in basic groups, supergroups and channels
 *
 * - Message auto-delete time can't be changed in a chat with the current user (Saved Messages) and the chat 777000 (Telegram).
 */
export type setChatMessageAutoDeleteTime$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New time value, in seconds; unless the chat is secret, it must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {int32} {@link int32}
   */
  readonly message_auto_delete_time?: int32;
};

/**
 * Changes the message auto-delete or self-destruct (for secret chats) time in a chat. Requires change_info administrator right in basic groups, supergroups and channels
 *
 * - Message auto-delete time can't be changed in a chat with the current user (Saved Messages) and the chat 777000 (Telegram).
 *
 * @param {setChatMessageAutoDeleteTime$Input} parameters {@link setChatMessageAutoDeleteTime$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatMessageAutoDeleteTime = (
  parameters: setChatMessageAutoDeleteTime$Input
) => Ok;

/**
 * Changes the emoji status of a chat. Use chatBoostLevelFeatures.can_set_emoji_status to check whether an emoji status can be set. Requires can_change_info administrator right
 */
export type setChatEmojiStatus$Input = {
  readonly _: "setChatEmojiStatus";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New emoji status; pass null to remove emoji status
   * @type {emojiStatus$Input} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;
};

/**
 * Changes the emoji status of a chat. Use chatBoostLevelFeatures.can_set_emoji_status to check whether an emoji status can be set. Requires can_change_info administrator right
 */
export type setChatEmojiStatus$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New emoji status; pass null to remove emoji status
   * @type {emojiStatus$Input} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;
};

/**
 * Changes the emoji status of a chat. Use chatBoostLevelFeatures.can_set_emoji_status to check whether an emoji status can be set. Requires can_change_info administrator right
 *
 * @param {setChatEmojiStatus$Input} parameters {@link setChatEmojiStatus$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatEmojiStatus = (parameters: setChatEmojiStatus$Input) => Ok;

/**
 * Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
 */
export type setChatPermissions$Input = {
  readonly _: "setChatPermissions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New non-administrator members permissions in the chat
   * @type {chatPermissions$Input} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/**
 * Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
 */
export type setChatPermissions$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New non-administrator members permissions in the chat
   * @type {chatPermissions$Input} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/**
 * Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
 *
 * @param {setChatPermissions$Input} parameters {@link setChatPermissions$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatPermissions = (parameters: setChatPermissions$Input) => Ok;

/**
 * Sets the background in a specific chat. Supported only in private and secret chats with non-deleted users, and in chats with sufficient boost level and can_change_info administrator right
 */
export type setChatBackground$Input = {
  readonly _: "setChatBackground";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The input background to use; pass null to create a new filled or chat theme background
   * @type {InputBackground$Input} {@link InputBackground}
   */
  readonly background?: InputBackground$Input | null;

  /**
   * Background type; pass null to use default background type for the chosen background; backgroundTypeChatTheme isn't supported for private and secret chats.
   *
   * - Use chatBoostLevelFeatures.chat_theme_background_count and chatBoostLevelFeatures.can_set_custom_background to check whether the background type can be set in the boosted chat
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input | null;

  /**
   * Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
   * @type {int32} {@link int32}
   */
  readonly dark_theme_dimming?: int32;

  /**
   * Pass true to set background only for self; pass false to set background for all chat users. Always false for backgrounds set in boosted chats. Background can be set for both users only by Telegram Premium users and if set background isn't of the type inputBackgroundPrevious
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_for_self?: Bool$Input;
};

/**
 * Sets the background in a specific chat. Supported only in private and secret chats with non-deleted users, and in chats with sufficient boost level and can_change_info administrator right
 */
export type setChatBackground$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The input background to use; pass null to create a new filled or chat theme background
   * @type {InputBackground$Input} {@link InputBackground}
   */
  readonly background?: InputBackground$Input | null;

  /**
   * Background type; pass null to use default background type for the chosen background; backgroundTypeChatTheme isn't supported for private and secret chats.
   *
   * - Use chatBoostLevelFeatures.chat_theme_background_count and chatBoostLevelFeatures.can_set_custom_background to check whether the background type can be set in the boosted chat
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input | null;

  /**
   * Dimming of the background in dark themes, as a percentage; 0-100. Applied only to Wallpaper and Fill types of background
   * @type {int32} {@link int32}
   */
  readonly dark_theme_dimming?: int32;

  /**
   * Pass true to set background only for self; pass false to set background for all chat users. Always false for backgrounds set in boosted chats. Background can be set for both users only by Telegram Premium users and if set background isn't of the type inputBackgroundPrevious
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_for_self?: Bool$Input;
};

/**
 * Sets the background in a specific chat. Supported only in private and secret chats with non-deleted users, and in chats with sufficient boost level and can_change_info administrator right
 *
 * @param {setChatBackground$Input} parameters {@link setChatBackground$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatBackground = (parameters: setChatBackground$Input) => Ok;

/**
 * Deletes background in a specific chat
 */
export type deleteChatBackground$Input = {
  readonly _: "deleteChatBackground";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to restore previously set background. Can be used only in private and secret chats with non-deleted users if userFullInfo.set_chat_background == true.
   *
   * - Supposed to be used from messageChatSetBackground messages with the currently set background that was set for both sides by the other user
   * @type {Bool$Input} {@link Bool}
   */
  readonly restore_previous?: Bool$Input;
};

/**
 * Deletes background in a specific chat
 */
export type deleteChatBackground$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to restore previously set background. Can be used only in private and secret chats with non-deleted users if userFullInfo.set_chat_background == true.
   *
   * - Supposed to be used from messageChatSetBackground messages with the currently set background that was set for both sides by the other user
   * @type {Bool$Input} {@link Bool}
   */
  readonly restore_previous?: Bool$Input;
};

/**
 * Deletes background in a specific chat
 *
 * @param {deleteChatBackground$Input} parameters {@link deleteChatBackground$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteChatBackground = (parameters: deleteChatBackground$Input) => Ok;

/**
 * Changes the chat theme. Supported only in private and secret chats
 */
export type setChatTheme$Input = {
  readonly _: "setChatTheme";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Name of the new chat theme; pass an empty string to return the default theme
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * Changes the chat theme. Supported only in private and secret chats
 */
export type setChatTheme$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Name of the new chat theme; pass an empty string to return the default theme
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * Changes the chat theme. Supported only in private and secret chats
 *
 * @param {setChatTheme$Input} parameters {@link setChatTheme$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatTheme = (parameters: setChatTheme$Input) => Ok;

/**
 * Changes the draft message in a chat
 */
export type setChatDraftMessage$Input = {
  readonly _: "setChatDraftMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the draft was changed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New draft message; pass null to remove the draft
   * @type {draftMessage$Input} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input | null;
};

/**
 * Changes the draft message in a chat
 */
export type setChatDraftMessage$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the draft was changed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New draft message; pass null to remove the draft
   * @type {draftMessage$Input} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input | null;
};

/**
 * Changes the draft message in a chat
 *
 * @param {setChatDraftMessage$Input} parameters {@link setChatDraftMessage$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatDraftMessage = (parameters: setChatDraftMessage$Input) => Ok;

/**
 * Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
 */
export type setChatNotificationSettings$Input = {
  readonly _: "setChatNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New notification settings for the chat. If the chat is muted for more than 366 days, it is considered to be muted forever
   * @type {chatNotificationSettings$Input} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/**
 * Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
 */
export type setChatNotificationSettings$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New notification settings for the chat. If the chat is muted for more than 366 days, it is considered to be muted forever
   * @type {chatNotificationSettings$Input} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/**
 * Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
 *
 * @param {setChatNotificationSettings$Input} parameters {@link setChatNotificationSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatNotificationSettings = (
  parameters: setChatNotificationSettings$Input
) => Ok;

/**
 * Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges
 */
export type toggleChatHasProtectedContent$Input = {
  readonly _: "toggleChatHasProtectedContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_protected_content
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/**
 * Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges
 */
export type toggleChatHasProtectedContent$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_protected_content
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/**
 * Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges
 *
 * @param {toggleChatHasProtectedContent$Input} parameters {@link toggleChatHasProtectedContent$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleChatHasProtectedContent = (
  parameters: toggleChatHasProtectedContent$Input
) => Ok;

/**
 * Changes the view_as_topics setting of a forum chat
 */
export type toggleChatViewAsTopics$Input = {
  readonly _: "toggleChatViewAsTopics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of view_as_topics
   * @type {Bool$Input} {@link Bool}
   */
  readonly view_as_topics?: Bool$Input;
};

/**
 * Changes the view_as_topics setting of a forum chat
 */
export type toggleChatViewAsTopics$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of view_as_topics
   * @type {Bool$Input} {@link Bool}
   */
  readonly view_as_topics?: Bool$Input;
};

/**
 * Changes the view_as_topics setting of a forum chat
 *
 * @param {toggleChatViewAsTopics$Input} parameters {@link toggleChatViewAsTopics$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleChatViewAsTopics = (
  parameters: toggleChatViewAsTopics$Input
) => Ok;

/**
 * Changes the translatable state of a chat
 */
export type toggleChatIsTranslatable$Input = {
  readonly _: "toggleChatIsTranslatable";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_translatable
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_translatable?: Bool$Input;
};

/**
 * Changes the translatable state of a chat
 */
export type toggleChatIsTranslatable$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_translatable
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_translatable?: Bool$Input;
};

/**
 * Changes the translatable state of a chat
 *
 * @param {toggleChatIsTranslatable$Input} parameters {@link toggleChatIsTranslatable$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleChatIsTranslatable = (
  parameters: toggleChatIsTranslatable$Input
) => Ok;

/**
 * Changes the marked as unread state of a chat
 */
export type toggleChatIsMarkedAsUnread$Input = {
  readonly _: "toggleChatIsMarkedAsUnread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;
};

/**
 * Changes the marked as unread state of a chat
 */
export type toggleChatIsMarkedAsUnread$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;
};

/**
 * Changes the marked as unread state of a chat
 *
 * @param {toggleChatIsMarkedAsUnread$Input} parameters {@link toggleChatIsMarkedAsUnread$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleChatIsMarkedAsUnread = (
  parameters: toggleChatIsMarkedAsUnread$Input
) => Ok;

/**
 * Changes the value of the default disable_notification parameter, used when a message is sent to a chat
 */
export type toggleChatDefaultDisableNotification$Input = {
  readonly _: "toggleChatDefaultDisableNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of default_disable_notification
   * @type {Bool$Input} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;
};

/**
 * Changes the value of the default disable_notification parameter, used when a message is sent to a chat
 */
export type toggleChatDefaultDisableNotification$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of default_disable_notification
   * @type {Bool$Input} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;
};

/**
 * Changes the value of the default disable_notification parameter, used when a message is sent to a chat
 *
 * @param {toggleChatDefaultDisableNotification$Input} parameters {@link toggleChatDefaultDisableNotification$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleChatDefaultDisableNotification = (
  parameters: toggleChatDefaultDisableNotification$Input
) => Ok;

/**
 * Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 */
export type setChatAvailableReactions$Input = {
  readonly _: "setChatAvailableReactions";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Reactions available in the chat. All explicitly specified emoji reactions must be active. Up to the chat's boost level custom emoji reactions can be explicitly specified
   * @type {ChatAvailableReactions$Input} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;
};

/**
 * Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 */
export type setChatAvailableReactions$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Reactions available in the chat. All explicitly specified emoji reactions must be active. Up to the chat's boost level custom emoji reactions can be explicitly specified
   * @type {ChatAvailableReactions$Input} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;
};

/**
 * Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 *
 * @param {setChatAvailableReactions$Input} parameters {@link setChatAvailableReactions$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatAvailableReactions = (
  parameters: setChatAvailableReactions$Input
) => Ok;

/**
 * Changes application-specific data associated with a chat
 */
export type setChatClientData$Input = {
  readonly _: "setChatClientData";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of client_data
   * @type {string} {@link string}
   */
  readonly client_data?: string;
};

/**
 * Changes application-specific data associated with a chat
 */
export type setChatClientData$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of client_data
   * @type {string} {@link string}
   */
  readonly client_data?: string;
};

/**
 * Changes application-specific data associated with a chat
 *
 * @param {setChatClientData$Input} parameters {@link setChatClientData$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatClientData = (parameters: setChatClientData$Input) => Ok;

/**
 * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 */
export type setChatDescription$Input = {
  readonly _: "setChatDescription";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 */
export type setChatDescription$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 *
 * @param {setChatDescription$Input} parameters {@link setChatDescription$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatDescription = (parameters: setChatDescription$Input) => Ok;

/**
 * Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
 */
export type setChatDiscussionGroup$Input = {
  readonly _: "setChatDiscussionGroup";

  /**
   * Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of a new channel's discussion group. Use 0 to remove the discussion group. Use the method getSuitableDiscussionChats to find all suitable groups.
   *
   * - Basic group chats must be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable must be used first to change that
   * @type {int53} {@link int53}
   */
  readonly discussion_chat_id?: int53;
};

/**
 * Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
 */
export type setChatDiscussionGroup$DirectInput = {
  /**
   * Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of a new channel's discussion group. Use 0 to remove the discussion group. Use the method getSuitableDiscussionChats to find all suitable groups.
   *
   * - Basic group chats must be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable must be used first to change that
   * @type {int53} {@link int53}
   */
  readonly discussion_chat_id?: int53;
};

/**
 * Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
 *
 * @param {setChatDiscussionGroup$Input} parameters {@link setChatDiscussionGroup$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatDiscussionGroup = (
  parameters: setChatDiscussionGroup$Input
) => Ok;

/**
 * Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
 */
export type setChatLocation$Input = {
  readonly _: "setChatLocation";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New location for the chat; must be valid and not null
   * @type {chatLocation$Input} {@link chatLocation}
   */
  readonly location?: chatLocation$Input;
};

/**
 * Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
 */
export type setChatLocation$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New location for the chat; must be valid and not null
   * @type {chatLocation$Input} {@link chatLocation}
   */
  readonly location?: chatLocation$Input;
};

/**
 * Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
 *
 * @param {setChatLocation$Input} parameters {@link setChatLocation$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatLocation = (parameters: setChatLocation$Input) => Ok;

/**
 * Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
 */
export type setChatSlowModeDelay$Input = {
  readonly _: "setChatSlowModeDelay";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300, 900, 3600
   * @type {int32} {@link int32}
   */
  readonly slow_mode_delay?: int32;
};

/**
 * Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
 */
export type setChatSlowModeDelay$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300, 900, 3600
   * @type {int32} {@link int32}
   */
  readonly slow_mode_delay?: int32;
};

/**
 * Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
 *
 * @param {setChatSlowModeDelay$Input} parameters {@link setChatSlowModeDelay$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatSlowModeDelay = (parameters: setChatSlowModeDelay$Input) => Ok;

/**
 * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
 */
export type pinChatMessage$Input = {
  readonly _: "pinChatMessage";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the new pinned message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to disable notification about the pinned message. Notifications are always disabled in channels and private chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * Pass true to pin the message only for self; private chats only
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_for_self?: Bool$Input;
};

/**
 * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
 */
export type pinChatMessage$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the new pinned message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to disable notification about the pinned message. Notifications are always disabled in channels and private chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * Pass true to pin the message only for self; private chats only
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_for_self?: Bool$Input;
};

/**
 * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
 *
 * @param {pinChatMessage$Input} parameters {@link pinChatMessage$Input}
 * @return {Ok} {@link Ok}
 */
export type pinChatMessage = (parameters: pinChatMessage$Input) => Ok;

/**
 * Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 */
export type unpinChatMessage$Input = {
  readonly _: "unpinChatMessage";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the removed pinned message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 */
export type unpinChatMessage$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the removed pinned message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 *
 * @param {unpinChatMessage$Input} parameters {@link unpinChatMessage$Input}
 * @return {Ok} {@link Ok}
 */
export type unpinChatMessage = (parameters: unpinChatMessage$Input) => Ok;

/**
 * Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 */
export type unpinAllChatMessages$Input = {
  readonly _: "unpinAllChatMessages";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 */
export type unpinAllChatMessages$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 *
 * @param {unpinAllChatMessages$Input} parameters {@link unpinAllChatMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type unpinAllChatMessages = (parameters: unpinAllChatMessages$Input) => Ok;

/**
 * Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup
 */
export type unpinAllMessageThreadMessages$Input = {
  readonly _: "unpinAllMessageThreadMessages";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which messages will be unpinned
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup
 */
export type unpinAllMessageThreadMessages$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which messages will be unpinned
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup
 *
 * @param {unpinAllMessageThreadMessages$Input} parameters {@link unpinAllMessageThreadMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type unpinAllMessageThreadMessages = (
  parameters: unpinAllMessageThreadMessages$Input
) => Ok;

/**
 * Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 */
export type joinChat$Input = {
  readonly _: "joinChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 */
export type joinChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 *
 * @param {joinChat$Input} parameters {@link joinChat$Input}
 * @return {Ok} {@link Ok}
 */
export type joinChat = (parameters: joinChat$Input) => Ok;

/**
 * Removes the current user from chat members. Private and secret chats can't be left using this method
 */
export type leaveChat$Input = {
  readonly _: "leaveChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes the current user from chat members. Private and secret chats can't be left using this method
 */
export type leaveChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes the current user from chat members. Private and secret chats can't be left using this method
 *
 * @param {leaveChat$Input} parameters {@link leaveChat$Input}
 * @return {Ok} {@link Ok}
 */
export type leaveChat = (parameters: leaveChat$Input) => Ok;

/**
 * Adds a new member to a chat. Members can't be added to private or secret chats
 */
export type addChatMember$Input = {
  readonly _: "addChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels, or if the added user is a bot
   * @type {int32} {@link int32}
   */
  readonly forward_limit?: int32;
};

/**
 * Adds a new member to a chat. Members can't be added to private or secret chats
 */
export type addChatMember$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels, or if the added user is a bot
   * @type {int32} {@link int32}
   */
  readonly forward_limit?: int32;
};

/**
 * Adds a new member to a chat. Members can't be added to private or secret chats
 *
 * @param {addChatMember$Input} parameters {@link addChatMember$Input}
 * @return {Ok} {@link Ok}
 */
export type addChatMember = (parameters: addChatMember$Input) => Ok;

/**
 * Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
 */
export type addChatMembers$Input = {
  readonly _: "addChatMembers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
 */
export type addChatMembers$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
 *
 * @param {addChatMembers$Input} parameters {@link addChatMembers$Input}
 * @return {Ok} {@link Ok}
 */
export type addChatMembers = (parameters: addChatMembers$Input) => Ok;

/**
 * Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
 */
export type setChatMemberStatus$Input = {
  readonly _: "setChatMemberStatus";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier. Chats can be only banned and unbanned in supergroups and channels
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * The new status of the member in the chat
   * @type {ChatMemberStatus$Input} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/**
 * Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
 */
export type setChatMemberStatus$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier. Chats can be only banned and unbanned in supergroups and channels
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * The new status of the member in the chat
   * @type {ChatMemberStatus$Input} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/**
 * Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
 *
 * @param {setChatMemberStatus$Input} parameters {@link setChatMemberStatus$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatMemberStatus = (parameters: setChatMemberStatus$Input) => Ok;

/**
 * Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
 */
export type banChatMember$Input = {
  readonly _: "banChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups and if a chat is banned
   * @type {int32} {@link int32}
   */
  readonly banned_until_date?: int32;

  /**
   * Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke_messages?: Bool$Input;
};

/**
 * Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
 */
export type banChatMember$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups and if a chat is banned
   * @type {int32} {@link int32}
   */
  readonly banned_until_date?: int32;

  /**
   * Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke_messages?: Bool$Input;
};

/**
 * Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
 *
 * @param {banChatMember$Input} parameters {@link banChatMember$Input}
 * @return {Ok} {@link Ok}
 */
export type banChatMember = (parameters: banChatMember$Input) => Ok;

/**
 * Checks whether the current session can be used to transfer a chat ownership to another user
 */
export type canTransferOwnership$Input = {
  readonly _: "canTransferOwnership";
};

/**
 * Checks whether the current session can be used to transfer a chat ownership to another user
 */
export type canTransferOwnership$DirectInput = {};

/**
 * Checks whether the current session can be used to transfer a chat ownership to another user
 *
 * @param {canTransferOwnership$Input} parameters {@link canTransferOwnership$Input}
 * @return {CanTransferOwnershipResult} {@link CanTransferOwnershipResult}
 */
export type canTransferOwnership = (
  parameters: canTransferOwnership$Input
) => CanTransferOwnershipResult;

/**
 * Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
 */
export type transferChatOwnership$Input = {
  readonly _: "transferChatOwnership";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
 */
export type transferChatOwnership$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
 *
 * @param {transferChatOwnership$Input} parameters {@link transferChatOwnership$Input}
 * @return {Ok} {@link Ok}
 */
export type transferChatOwnership = (parameters: transferChatOwnership$Input) => Ok;

/**
 * Returns information about a single member of a chat
 */
export type getChatMember$Input = {
  readonly _: "getChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;
};

/**
 * Returns information about a single member of a chat
 */
export type getChatMember$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;
};

/**
 * Returns information about a single member of a chat
 *
 * @param {getChatMember$Input} parameters {@link getChatMember$Input}
 * @return {ChatMember} {@link ChatMember}
 */
export type getChatMember = (parameters: getChatMember$Input) => ChatMember;

/**
 * Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels
 */
export type searchChatMembers$Input = {
  readonly _: "searchChatMembers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of users to be returned; up to 200
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * The type of users to search for; pass null to search among all chat members
   * @type {ChatMembersFilter$Input} {@link ChatMembersFilter}
   */
  readonly filter?: ChatMembersFilter$Input | null;
};

/**
 * Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels
 */
export type searchChatMembers$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of users to be returned; up to 200
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * The type of users to search for; pass null to search among all chat members
   * @type {ChatMembersFilter$Input} {@link ChatMembersFilter}
   */
  readonly filter?: ChatMembersFilter$Input | null;
};

/**
 * Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels
 *
 * @param {searchChatMembers$Input} parameters {@link searchChatMembers$Input}
 * @return {ChatMembers} {@link ChatMembers}
 */
export type searchChatMembers = (parameters: searchChatMembers$Input) => ChatMembers;

/**
 * Returns a list of administrators of the chat with their custom titles
 */
export type getChatAdministrators$Input = {
  readonly _: "getChatAdministrators";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a list of administrators of the chat with their custom titles
 */
export type getChatAdministrators$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a list of administrators of the chat with their custom titles
 *
 * @param {getChatAdministrators$Input} parameters {@link getChatAdministrators$Input}
 * @return {ChatAdministrators} {@link ChatAdministrators}
 */
export type getChatAdministrators = (
  parameters: getChatAdministrators$Input
) => ChatAdministrators;

/**
 * Clears message drafts in all chats
 */
export type clearAllDraftMessages$Input = {
  readonly _: "clearAllDraftMessages";

  /**
   * Pass true to keep local message drafts in secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly exclude_secret_chats?: Bool$Input;
};

/**
 * Clears message drafts in all chats
 */
export type clearAllDraftMessages$DirectInput = {
  /**
   * Pass true to keep local message drafts in secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly exclude_secret_chats?: Bool$Input;
};

/**
 * Clears message drafts in all chats
 *
 * @param {clearAllDraftMessages$Input} parameters {@link clearAllDraftMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type clearAllDraftMessages = (parameters: clearAllDraftMessages$Input) => Ok;

/**
 * Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier
 */
export type getSavedNotificationSound$Input = {
  readonly _: "getSavedNotificationSound";

  /**
   * Identifier of the notification sound
   * @type {int64$Input} {@link int64}
   */
  readonly notification_sound_id?: int64$Input;
};

/**
 * Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier
 */
export type getSavedNotificationSound$DirectInput = {
  /**
   * Identifier of the notification sound
   * @type {int64$Input} {@link int64}
   */
  readonly notification_sound_id?: int64$Input;
};

/**
 * Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier
 *
 * @param {getSavedNotificationSound$Input} parameters {@link getSavedNotificationSound$Input}
 * @return {NotificationSounds} {@link NotificationSounds}
 */
export type getSavedNotificationSound = (
  parameters: getSavedNotificationSound$Input
) => NotificationSounds;

/**
 * Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used
 */
export type getSavedNotificationSounds$Input = {
  readonly _: "getSavedNotificationSounds";
};

/**
 * Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used
 */
export type getSavedNotificationSounds$DirectInput = {};

/**
 * Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used
 *
 * @param {getSavedNotificationSounds$Input} parameters {@link getSavedNotificationSounds$Input}
 * @return {NotificationSounds} {@link NotificationSounds}
 */
export type getSavedNotificationSounds = (
  parameters: getSavedNotificationSounds$Input
) => NotificationSounds;

/**
 * Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed
 */
export type addSavedNotificationSound$Input = {
  readonly _: "addSavedNotificationSound";

  /**
   * Notification sound file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sound?: InputFile$Input;
};

/**
 * Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed
 */
export type addSavedNotificationSound$DirectInput = {
  /**
   * Notification sound file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sound?: InputFile$Input;
};

/**
 * Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed
 *
 * @param {addSavedNotificationSound$Input} parameters {@link addSavedNotificationSound$Input}
 * @return {NotificationSound} {@link NotificationSound}
 */
export type addSavedNotificationSound = (
  parameters: addSavedNotificationSound$Input
) => NotificationSound;

/**
 * Removes a notification sound from the list of saved notification sounds
 */
export type removeSavedNotificationSound$Input = {
  readonly _: "removeSavedNotificationSound";

  /**
   * Identifier of the notification sound
   * @type {int64$Input} {@link int64}
   */
  readonly notification_sound_id?: int64$Input;
};

/**
 * Removes a notification sound from the list of saved notification sounds
 */
export type removeSavedNotificationSound$DirectInput = {
  /**
   * Identifier of the notification sound
   * @type {int64$Input} {@link int64}
   */
  readonly notification_sound_id?: int64$Input;
};

/**
 * Removes a notification sound from the list of saved notification sounds
 *
 * @param {removeSavedNotificationSound$Input} parameters {@link removeSavedNotificationSound$Input}
 * @return {Ok} {@link Ok}
 */
export type removeSavedNotificationSound = (
  parameters: removeSavedNotificationSound$Input
) => Ok;

/**
 * Returns list of chats with non-default notification settings for new messages
 */
export type getChatNotificationSettingsExceptions$Input = {
  readonly _: "getChatNotificationSettingsExceptions";

  /**
   * If specified, only chats from the scope will be returned; pass null to return chats from all scopes
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input | null;

  /**
   * Pass true to include in the response chats with only non-default sound
   * @type {Bool$Input} {@link Bool}
   */
  readonly compare_sound?: Bool$Input;
};

/**
 * Returns list of chats with non-default notification settings for new messages
 */
export type getChatNotificationSettingsExceptions$DirectInput = {
  /**
   * If specified, only chats from the scope will be returned; pass null to return chats from all scopes
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input | null;

  /**
   * Pass true to include in the response chats with only non-default sound
   * @type {Bool$Input} {@link Bool}
   */
  readonly compare_sound?: Bool$Input;
};

/**
 * Returns list of chats with non-default notification settings for new messages
 *
 * @param {getChatNotificationSettingsExceptions$Input} parameters {@link getChatNotificationSettingsExceptions$Input}
 * @return {Chats} {@link Chats}
 */
export type getChatNotificationSettingsExceptions = (
  parameters: getChatNotificationSettingsExceptions$Input
) => Chats;

/**
 * Returns the notification settings for chats of a given type
 */
export type getScopeNotificationSettings$Input = {
  readonly _: "getScopeNotificationSettings";

  /**
   * Types of chats for which to return the notification settings information
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;
};

/**
 * Returns the notification settings for chats of a given type
 */
export type getScopeNotificationSettings$DirectInput = {
  /**
   * Types of chats for which to return the notification settings information
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;
};

/**
 * Returns the notification settings for chats of a given type
 *
 * @param {getScopeNotificationSettings$Input} parameters {@link getScopeNotificationSettings$Input}
 * @return {ScopeNotificationSettings} {@link ScopeNotificationSettings}
 */
export type getScopeNotificationSettings = (
  parameters: getScopeNotificationSettings$Input
) => ScopeNotificationSettings;

/**
 * Changes notification settings for chats of a given type
 */
export type setScopeNotificationSettings$Input = {
  readonly _: "setScopeNotificationSettings";

  /**
   * Types of chats for which to change the notification settings
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;

  /**
   * The new notification settings for the given scope
   * @type {scopeNotificationSettings$Input} {@link scopeNotificationSettings}
   */
  readonly notification_settings?: scopeNotificationSettings$Input;
};

/**
 * Changes notification settings for chats of a given type
 */
export type setScopeNotificationSettings$DirectInput = {
  /**
   * Types of chats for which to change the notification settings
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;

  /**
   * The new notification settings for the given scope
   * @type {scopeNotificationSettings$Input} {@link scopeNotificationSettings}
   */
  readonly notification_settings?: scopeNotificationSettings$Input;
};

/**
 * Changes notification settings for chats of a given type
 *
 * @param {setScopeNotificationSettings$Input} parameters {@link setScopeNotificationSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setScopeNotificationSettings = (
  parameters: setScopeNotificationSettings$Input
) => Ok;

/**
 * Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown
 */
export type resetAllNotificationSettings$Input = {
  readonly _: "resetAllNotificationSettings";
};

/**
 * Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown
 */
export type resetAllNotificationSettings$DirectInput = {};

/**
 * Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown
 *
 * @param {resetAllNotificationSettings$Input} parameters {@link resetAllNotificationSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type resetAllNotificationSettings = (
  parameters: resetAllNotificationSettings$Input
) => Ok;

/**
 * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium
 */
export type toggleChatIsPinned$Input = {
  readonly _: "toggleChatIsPinned";

  /**
   * Chat list in which to change the pinned state of the chat
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to pin the chat; pass false to unpin it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium
 */
export type toggleChatIsPinned$DirectInput = {
  /**
   * Chat list in which to change the pinned state of the chat
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to pin the chat; pass false to unpin it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Changes the pinned state of a chat. There can be up to getOption("pinned_chat_count_max")/getOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium
 *
 * @param {toggleChatIsPinned$Input} parameters {@link toggleChatIsPinned$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleChatIsPinned = (parameters: toggleChatIsPinned$Input) => Ok;

/**
 * Changes the order of pinned chats
 */
export type setPinnedChats$Input = {
  readonly _: "setPinnedChats";

  /**
   * Chat list in which to change the order of pinned chats
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * The new list of pinned chats
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Changes the order of pinned chats
 */
export type setPinnedChats$DirectInput = {
  /**
   * Chat list in which to change the order of pinned chats
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * The new list of pinned chats
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Changes the order of pinned chats
 *
 * @param {setPinnedChats$Input} parameters {@link setPinnedChats$Input}
 * @return {Ok} {@link Ok}
 */
export type setPinnedChats = (parameters: setPinnedChats$Input) => Ok;

/**
 * Traverse all chats in a chat list and marks all messages in the chats as read
 */
export type readChatList$Input = {
  readonly _: "readChatList";

  /**
   * Chat list in which to mark all chats as read
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;
};

/**
 * Traverse all chats in a chat list and marks all messages in the chats as read
 */
export type readChatList$DirectInput = {
  /**
   * Chat list in which to mark all chats as read
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;
};

/**
 * Traverse all chats in a chat list and marks all messages in the chats as read
 *
 * @param {readChatList$Input} parameters {@link readChatList$Input}
 * @return {Ok} {@link Ok}
 */
export type readChatList = (parameters: readChatList$Input) => Ok;

/**
 * Returns a story
 */
export type getStory$Input = {
  readonly _: "getStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass true to get only locally available information without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns a story
 */
export type getStory$DirectInput = {
  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass true to get only locally available information without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns a story
 *
 * @param {getStory$Input} parameters {@link getStory$Input}
 * @return {Story} {@link Story}
 */
export type getStory = (parameters: getStory$Input) => Story;

/**
 * Returns channel chats in which the current user has the right to post stories. The chats must be rechecked with canSendStory before actually trying to post a story there
 */
export type getChatsToSendStories$Input = {
  readonly _: "getChatsToSendStories";
};

/**
 * Returns channel chats in which the current user has the right to post stories. The chats must be rechecked with canSendStory before actually trying to post a story there
 */
export type getChatsToSendStories$DirectInput = {};

/**
 * Returns channel chats in which the current user has the right to post stories. The chats must be rechecked with canSendStory before actually trying to post a story there
 *
 * @param {getChatsToSendStories$Input} parameters {@link getChatsToSendStories$Input}
 * @return {Chats} {@link Chats}
 */
export type getChatsToSendStories = (
  parameters: getChatsToSendStories$Input
) => Chats;

/**
 * Checks whether the current user can send a story on behalf of a chat; requires can_post_stories rights for channel chats
 */
export type canSendStory$Input = {
  readonly _: "canSendStory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Checks whether the current user can send a story on behalf of a chat; requires can_post_stories rights for channel chats
 */
export type canSendStory$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Checks whether the current user can send a story on behalf of a chat; requires can_post_stories rights for channel chats
 *
 * @param {canSendStory$Input} parameters {@link canSendStory$Input}
 * @return {CanSendStoryResult} {@link CanSendStoryResult}
 */
export type canSendStory = (parameters: canSendStory$Input) => CanSendStoryResult;

/**
 * Sends a new story to a chat; requires can_post_stories rights for channel chats. Returns a temporary story
 */
export type sendStory$Input = {
  readonly _: "sendStory";

  /**
   * Identifier of the chat that will post the story
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Content of the story
   * @type {InputStoryContent$Input} {@link InputStoryContent}
   */
  readonly content?: InputStoryContent$Input;

  /**
   * Clickable rectangle areas to be shown on the story media; pass null if none
   * @type {inputStoryAreas$Input} {@link inputStoryAreas}
   */
  readonly areas?: inputStoryAreas$Input | null;

  /**
   * Story caption; pass null to use an empty caption; 0-getOption("story_caption_length_max") characters
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;

  /**
   * The privacy settings for the story
   * @type {StoryPrivacySettings$Input} {@link StoryPrivacySettings}
   */
  readonly privacy_settings?: StoryPrivacySettings$Input;

  /**
   * Period after which the story is moved to archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400 for Telegram Premium users, and 86400 otherwise
   * @type {int32} {@link int32}
   */
  readonly active_period?: int32;

  /**
   * Full identifier of the original story, which content was used to create the story
   * @type {storyFullId$Input} {@link storyFullId}
   */
  readonly from_story_full_id?: storyFullId$Input;

  /**
   * Pass true to keep the story accessible after expiration
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * Pass true if the content of the story must be protected from forwarding and screenshotting
   * @type {Bool$Input} {@link Bool}
   */
  readonly protect_content?: Bool$Input;
};

/**
 * Sends a new story to a chat; requires can_post_stories rights for channel chats. Returns a temporary story
 */
export type sendStory$DirectInput = {
  /**
   * Identifier of the chat that will post the story
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Content of the story
   * @type {InputStoryContent$Input} {@link InputStoryContent}
   */
  readonly content?: InputStoryContent$Input;

  /**
   * Clickable rectangle areas to be shown on the story media; pass null if none
   * @type {inputStoryAreas$Input} {@link inputStoryAreas}
   */
  readonly areas?: inputStoryAreas$Input | null;

  /**
   * Story caption; pass null to use an empty caption; 0-getOption("story_caption_length_max") characters
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;

  /**
   * The privacy settings for the story
   * @type {StoryPrivacySettings$Input} {@link StoryPrivacySettings}
   */
  readonly privacy_settings?: StoryPrivacySettings$Input;

  /**
   * Period after which the story is moved to archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400 for Telegram Premium users, and 86400 otherwise
   * @type {int32} {@link int32}
   */
  readonly active_period?: int32;

  /**
   * Full identifier of the original story, which content was used to create the story
   * @type {storyFullId$Input} {@link storyFullId}
   */
  readonly from_story_full_id?: storyFullId$Input;

  /**
   * Pass true to keep the story accessible after expiration
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * Pass true if the content of the story must be protected from forwarding and screenshotting
   * @type {Bool$Input} {@link Bool}
   */
  readonly protect_content?: Bool$Input;
};

/**
 * Sends a new story to a chat; requires can_post_stories rights for channel chats. Returns a temporary story
 *
 * @param {sendStory$Input} parameters {@link sendStory$Input}
 * @return {Story} {@link Story}
 */
export type sendStory = (parameters: sendStory$Input) => Story;

/**
 * Changes content and caption of a story. Can be called only if story.can_be_edited == true
 */
export type editStory$Input = {
  readonly _: "editStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story to edit
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * New content of the story; pass null to keep the current content
   * @type {InputStoryContent$Input} {@link InputStoryContent}
   */
  readonly content?: InputStoryContent$Input | null;

  /**
   * New clickable rectangle areas to be shown on the story media; pass null to keep the current areas. Areas can't be edited if story content isn't changed
   * @type {inputStoryAreas$Input} {@link inputStoryAreas}
   */
  readonly areas?: inputStoryAreas$Input | null;

  /**
   * New story caption; pass null to keep the current caption
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * Changes content and caption of a story. Can be called only if story.can_be_edited == true
 */
export type editStory$DirectInput = {
  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story to edit
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * New content of the story; pass null to keep the current content
   * @type {InputStoryContent$Input} {@link InputStoryContent}
   */
  readonly content?: InputStoryContent$Input | null;

  /**
   * New clickable rectangle areas to be shown on the story media; pass null to keep the current areas. Areas can't be edited if story content isn't changed
   * @type {inputStoryAreas$Input} {@link inputStoryAreas}
   */
  readonly areas?: inputStoryAreas$Input | null;

  /**
   * New story caption; pass null to keep the current caption
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input | null;
};

/**
 * Changes content and caption of a story. Can be called only if story.can_be_edited == true
 *
 * @param {editStory$Input} parameters {@link editStory$Input}
 * @return {Ok} {@link Ok}
 */
export type editStory = (parameters: editStory$Input) => Ok;

/**
 * Changes privacy settings of a story. Can be called only if story.can_be_edited == true
 */
export type setStoryPrivacySettings$Input = {
  readonly _: "setStoryPrivacySettings";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * The new privacy settigs for the story
   * @type {StoryPrivacySettings$Input} {@link StoryPrivacySettings}
   */
  readonly privacy_settings?: StoryPrivacySettings$Input;
};

/**
 * Changes privacy settings of a story. Can be called only if story.can_be_edited == true
 */
export type setStoryPrivacySettings$DirectInput = {
  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * The new privacy settigs for the story
   * @type {StoryPrivacySettings$Input} {@link StoryPrivacySettings}
   */
  readonly privacy_settings?: StoryPrivacySettings$Input;
};

/**
 * Changes privacy settings of a story. Can be called only if story.can_be_edited == true
 *
 * @param {setStoryPrivacySettings$Input} parameters {@link setStoryPrivacySettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setStoryPrivacySettings = (
  parameters: setStoryPrivacySettings$Input
) => Ok;

/**
 * Toggles whether a story is accessible after expiration. Can be called only if story.can_toggle_is_pinned == true
 */
export type toggleStoryIsPinned$Input = {
  readonly _: "toggleStoryIsPinned";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass true to make the story accessible after expiration; pass false to make it private
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Toggles whether a story is accessible after expiration. Can be called only if story.can_toggle_is_pinned == true
 */
export type toggleStoryIsPinned$DirectInput = {
  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass true to make the story accessible after expiration; pass false to make it private
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Toggles whether a story is accessible after expiration. Can be called only if story.can_toggle_is_pinned == true
 *
 * @param {toggleStoryIsPinned$Input} parameters {@link toggleStoryIsPinned$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleStoryIsPinned = (parameters: toggleStoryIsPinned$Input) => Ok;

/**
 * Deletes a previously sent story. Can be called only if story.can_be_deleted == true
 */
export type deleteStory$Input = {
  readonly _: "deleteStory";

  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story to delete
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Deletes a previously sent story. Can be called only if story.can_be_deleted == true
 */
export type deleteStory$DirectInput = {
  /**
   * Identifier of the chat that posted the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Identifier of the story to delete
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Deletes a previously sent story. Can be called only if story.can_be_deleted == true
 *
 * @param {deleteStory$Input} parameters {@link deleteStory$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteStory = (parameters: deleteStory$Input) => Ok;

/**
 * Returns list of chats with non-default notification settings for stories
 */
export type getStoryNotificationSettingsExceptions$Input = {
  readonly _: "getStoryNotificationSettingsExceptions";
};

/**
 * Returns list of chats with non-default notification settings for stories
 */
export type getStoryNotificationSettingsExceptions$DirectInput = {};

/**
 * Returns list of chats with non-default notification settings for stories
 *
 * @param {getStoryNotificationSettingsExceptions$Input} parameters {@link getStoryNotificationSettingsExceptions$Input}
 * @return {Chats} {@link Chats}
 */
export type getStoryNotificationSettingsExceptions = (
  parameters: getStoryNotificationSettingsExceptions$Input
) => Chats;

/**
 * Loads more active stories from a story list. The loaded stories will be sent through updates. Active stories are sorted by
 *
 * - the pair (active_stories.order, active_stories.story_sender_chat_id) in descending order. Returns a 404 error if all active stories have been loaded
 */
export type loadActiveStories$Input = {
  readonly _: "loadActiveStories";

  /**
   * The story list in which to load active stories
   * @type {StoryList$Input} {@link StoryList}
   */
  readonly story_list?: StoryList$Input;
};

/**
 * Loads more active stories from a story list. The loaded stories will be sent through updates. Active stories are sorted by
 *
 * - the pair (active_stories.order, active_stories.story_sender_chat_id) in descending order. Returns a 404 error if all active stories have been loaded
 */
export type loadActiveStories$DirectInput = {
  /**
   * The story list in which to load active stories
   * @type {StoryList$Input} {@link StoryList}
   */
  readonly story_list?: StoryList$Input;
};

/**
 * Loads more active stories from a story list. The loaded stories will be sent through updates. Active stories are sorted by
 *
 * - the pair (active_stories.order, active_stories.story_sender_chat_id) in descending order. Returns a 404 error if all active stories have been loaded
 *
 * @param {loadActiveStories$Input} parameters {@link loadActiveStories$Input}
 * @return {Ok} {@link Ok}
 */
export type loadActiveStories = (parameters: loadActiveStories$Input) => Ok;

/**
 * Changes story list in which stories from the chat are shown
 */
export type setChatActiveStoriesList$Input = {
  readonly _: "setChatActiveStoriesList";

  /**
   * Identifier of the chat that posted stories
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New list for active stories posted by the chat
   * @type {StoryList$Input} {@link StoryList}
   */
  readonly story_list?: StoryList$Input;
};

/**
 * Changes story list in which stories from the chat are shown
 */
export type setChatActiveStoriesList$DirectInput = {
  /**
   * Identifier of the chat that posted stories
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New list for active stories posted by the chat
   * @type {StoryList$Input} {@link StoryList}
   */
  readonly story_list?: StoryList$Input;
};

/**
 * Changes story list in which stories from the chat are shown
 *
 * @param {setChatActiveStoriesList$Input} parameters {@link setChatActiveStoriesList$Input}
 * @return {Ok} {@link Ok}
 */
export type setChatActiveStoriesList = (
  parameters: setChatActiveStoriesList$Input
) => Ok;

/**
 * Returns the list of active stories posted by the given chat
 */
export type getChatActiveStories$Input = {
  readonly _: "getChatActiveStories";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns the list of active stories posted by the given chat
 */
export type getChatActiveStories$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns the list of active stories posted by the given chat
 *
 * @param {getChatActiveStories$Input} parameters {@link getChatActiveStories$Input}
 * @return {ChatActiveStories} {@link ChatActiveStories}
 */
export type getChatActiveStories = (
  parameters: getChatActiveStories$Input
) => ChatActiveStories;

/**
 * Returns the list of pinned stories posted by the given chat. The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id).
 *
 * - For optimal performance, the number of returned stories is chosen by TDLib
 */
export type getChatPinnedStories$Input = {
  readonly _: "getChatPinnedStories";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the story starting from which stories must be returned; use 0 to get results from the last story
   * @type {int32} {@link int32}
   */
  readonly from_story_id?: int32;

  /**
   * The maximum number of stories to be returned
   *
   * - For optimal performance, the number of returned stories is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the list of pinned stories posted by the given chat. The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id).
 *
 * - For optimal performance, the number of returned stories is chosen by TDLib
 */
export type getChatPinnedStories$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the story starting from which stories must be returned; use 0 to get results from the last story
   * @type {int32} {@link int32}
   */
  readonly from_story_id?: int32;

  /**
   * The maximum number of stories to be returned
   *
   * - For optimal performance, the number of returned stories is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the list of pinned stories posted by the given chat. The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id).
 *
 * - For optimal performance, the number of returned stories is chosen by TDLib
 *
 * @param {getChatPinnedStories$Input} parameters {@link getChatPinnedStories$Input}
 * @return {Stories} {@link Stories}
 */
export type getChatPinnedStories = (
  parameters: getChatPinnedStories$Input
) => Stories;

/**
 * Returns the list of all stories posted by the given chat; requires can_edit_stories rights for channel chats.
 *
 * - The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id). For optimal performance, the number of returned stories is chosen by TDLib
 */
export type getChatArchivedStories$Input = {
  readonly _: "getChatArchivedStories";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the story starting from which stories must be returned; use 0 to get results from the last story
   * @type {int32} {@link int32}
   */
  readonly from_story_id?: int32;

  /**
   * The maximum number of stories to be returned
   *
   * - For optimal performance, the number of returned stories is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the list of all stories posted by the given chat; requires can_edit_stories rights for channel chats.
 *
 * - The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id). For optimal performance, the number of returned stories is chosen by TDLib
 */
export type getChatArchivedStories$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the story starting from which stories must be returned; use 0 to get results from the last story
   * @type {int32} {@link int32}
   */
  readonly from_story_id?: int32;

  /**
   * The maximum number of stories to be returned
   *
   * - For optimal performance, the number of returned stories is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the list of all stories posted by the given chat; requires can_edit_stories rights for channel chats.
 *
 * - The stories are returned in a reverse chronological order (i.e., in order of decreasing story_id). For optimal performance, the number of returned stories is chosen by TDLib
 *
 * @param {getChatArchivedStories$Input} parameters {@link getChatArchivedStories$Input}
 * @return {Stories} {@link Stories}
 */
export type getChatArchivedStories = (
  parameters: getChatArchivedStories$Input
) => Stories;

/**
 * Informs TDLib that a story is opened and is being viewed by the user
 */
export type openStory$Input = {
  readonly _: "openStory";

  /**
   * The identifier of the sender of the opened story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Informs TDLib that a story is opened and is being viewed by the user
 */
export type openStory$DirectInput = {
  /**
   * The identifier of the sender of the opened story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Informs TDLib that a story is opened and is being viewed by the user
 *
 * @param {openStory$Input} parameters {@link openStory$Input}
 * @return {Ok} {@link Ok}
 */
export type openStory = (parameters: openStory$Input) => Ok;

/**
 * Informs TDLib that a story is closed by the user
 */
export type closeStory$Input = {
  readonly _: "closeStory";

  /**
   * The identifier of the sender of the story to close
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Informs TDLib that a story is closed by the user
 */
export type closeStory$DirectInput = {
  /**
   * The identifier of the sender of the story to close
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;
};

/**
 * Informs TDLib that a story is closed by the user
 *
 * @param {closeStory$Input} parameters {@link closeStory$Input}
 * @return {Ok} {@link Ok}
 */
export type closeStory = (parameters: closeStory$Input) => Ok;

/**
 * Returns reactions, which can be chosen for a story
 */
export type getStoryAvailableReactions$Input = {
  readonly _: "getStoryAvailableReactions";

  /**
   * Number of reaction per row, 5-25
   * @type {int32} {@link int32}
   */
  readonly row_size?: int32;
};

/**
 * Returns reactions, which can be chosen for a story
 */
export type getStoryAvailableReactions$DirectInput = {
  /**
   * Number of reaction per row, 5-25
   * @type {int32} {@link int32}
   */
  readonly row_size?: int32;
};

/**
 * Returns reactions, which can be chosen for a story
 *
 * @param {getStoryAvailableReactions$Input} parameters {@link getStoryAvailableReactions$Input}
 * @return {AvailableReactions} {@link AvailableReactions}
 */
export type getStoryAvailableReactions = (
  parameters: getStoryAvailableReactions$Input
) => AvailableReactions;

/**
 * Changes chosen reaction on a story
 */
export type setStoryReaction$Input = {
  readonly _: "setStoryReaction";

  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Type of the reaction to set; pass null to remove the reaction. `reactionTypeCustomEmoji` reactions can be used only by Telegram Premium users
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input | null;

  /**
   * Pass true if the reaction needs to be added to recent reactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly update_recent_reactions?: Bool$Input;
};

/**
 * Changes chosen reaction on a story
 */
export type setStoryReaction$DirectInput = {
  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Type of the reaction to set; pass null to remove the reaction. `reactionTypeCustomEmoji` reactions can be used only by Telegram Premium users
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input | null;

  /**
   * Pass true if the reaction needs to be added to recent reactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly update_recent_reactions?: Bool$Input;
};

/**
 * Changes chosen reaction on a story
 *
 * @param {setStoryReaction$Input} parameters {@link setStoryReaction$Input}
 * @return {Ok} {@link Ok}
 */
export type setStoryReaction = (parameters: setStoryReaction$Input) => Ok;

/**
 * Returns interactions with a story. The method can be called only for stories posted on behalf of the current user
 */
export type getStoryInteractions$Input = {
  readonly _: "getStoryInteractions";

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Query to search for in names, usernames and titles; may be empty to get all relevant interactions
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Pass true to get only interactions by contacts; pass false to get all relevant interactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_contacts?: Bool$Input;

  /**
   * Pass true to get forwards and reposts first, then reactions, then other views; pass false to get interactions sorted just by interaction date
   * @type {Bool$Input} {@link Bool}
   */
  readonly prefer_forwards?: Bool$Input;

  /**
   * Pass true to get interactions with reaction first; pass false to get interactions sorted just by interaction date. Ignored if prefer_forwards == true
   * @type {Bool$Input} {@link Bool}
   */
  readonly prefer_with_reaction?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of story interactions to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns interactions with a story. The method can be called only for stories posted on behalf of the current user
 */
export type getStoryInteractions$DirectInput = {
  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Query to search for in names, usernames and titles; may be empty to get all relevant interactions
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Pass true to get only interactions by contacts; pass false to get all relevant interactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_contacts?: Bool$Input;

  /**
   * Pass true to get forwards and reposts first, then reactions, then other views; pass false to get interactions sorted just by interaction date
   * @type {Bool$Input} {@link Bool}
   */
  readonly prefer_forwards?: Bool$Input;

  /**
   * Pass true to get interactions with reaction first; pass false to get interactions sorted just by interaction date. Ignored if prefer_forwards == true
   * @type {Bool$Input} {@link Bool}
   */
  readonly prefer_with_reaction?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of story interactions to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns interactions with a story. The method can be called only for stories posted on behalf of the current user
 *
 * @param {getStoryInteractions$Input} parameters {@link getStoryInteractions$Input}
 * @return {StoryInteractions} {@link StoryInteractions}
 */
export type getStoryInteractions = (
  parameters: getStoryInteractions$Input
) => StoryInteractions;

/**
 * Returns interactions with a story posted in a chat. Can be used only if story is posted on behalf of a chat and the user is an administrator in the chat
 */
export type getChatStoryInteractions$Input = {
  readonly _: "getChatStoryInteractions";

  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass the default heart reaction or a suggested reaction type to receive only interactions with the specified reaction type; pass null to receive all interactions
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input | null;

  /**
   * Pass true to get forwards and reposts first, then reactions, then other views; pass false to get interactions sorted just by interaction date
   * @type {Bool$Input} {@link Bool}
   */
  readonly prefer_forwards?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of story interactions to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns interactions with a story posted in a chat. Can be used only if story is posted on behalf of a chat and the user is an administrator in the chat
 */
export type getChatStoryInteractions$DirectInput = {
  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass the default heart reaction or a suggested reaction type to receive only interactions with the specified reaction type; pass null to receive all interactions
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input | null;

  /**
   * Pass true to get forwards and reposts first, then reactions, then other views; pass false to get interactions sorted just by interaction date
   * @type {Bool$Input} {@link Bool}
   */
  readonly prefer_forwards?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of story interactions to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns interactions with a story posted in a chat. Can be used only if story is posted on behalf of a chat and the user is an administrator in the chat
 *
 * @param {getChatStoryInteractions$Input} parameters {@link getChatStoryInteractions$Input}
 * @return {StoryInteractions} {@link StoryInteractions}
 */
export type getChatStoryInteractions = (
  parameters: getChatStoryInteractions$Input
) => StoryInteractions;

/**
 * Reports a story to the Telegram moderators
 */
export type reportStory$Input = {
  readonly _: "reportStory";

  /**
   * The identifier of the sender of the story to report
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story to report
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * The reason for reporting the story
   * @type {ReportReason$Input} {@link ReportReason}
   */
  readonly reason?: ReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a story to the Telegram moderators
 */
export type reportStory$DirectInput = {
  /**
   * The identifier of the sender of the story to report
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story to report
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * The reason for reporting the story
   * @type {ReportReason$Input} {@link ReportReason}
   */
  readonly reason?: ReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a story to the Telegram moderators
 *
 * @param {reportStory$Input} parameters {@link reportStory$Input}
 * @return {Ok} {@link Ok}
 */
export type reportStory = (parameters: reportStory$Input) => Ok;

/**
 * Activates stealth mode for stories, which hides all views of stories from the current user in the last "story_stealth_mode_past_period" seconds
 *
 * - and for the next "story_stealth_mode_future_period" seconds; for Telegram Premium users only
 */
export type activateStoryStealthMode$Input = {
  readonly _: "activateStoryStealthMode";
};

/**
 * Activates stealth mode for stories, which hides all views of stories from the current user in the last "story_stealth_mode_past_period" seconds
 *
 * - and for the next "story_stealth_mode_future_period" seconds; for Telegram Premium users only
 */
export type activateStoryStealthMode$DirectInput = {};

/**
 * Activates stealth mode for stories, which hides all views of stories from the current user in the last "story_stealth_mode_past_period" seconds
 *
 * - and for the next "story_stealth_mode_future_period" seconds; for Telegram Premium users only
 *
 * @param {activateStoryStealthMode$Input} parameters {@link activateStoryStealthMode$Input}
 * @return {Ok} {@link Ok}
 */
export type activateStoryStealthMode = (
  parameters: activateStoryStealthMode$Input
) => Ok;

/**
 * Returns forwards of a story as a message to public chats and reposts by public channels. Can be used only if the story is posted on behalf of the current user or story.can_get_statistics == true.
 *
 * - For optimal performance, the number of returned messages and stories is chosen by TDLib
 */
export type getStoryPublicForwards$Input = {
  readonly _: "getStoryPublicForwards";

  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages and stories to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned objects is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns forwards of a story as a message to public chats and reposts by public channels. Can be used only if the story is posted on behalf of the current user or story.can_get_statistics == true.
 *
 * - For optimal performance, the number of returned messages and stories is chosen by TDLib
 */
export type getStoryPublicForwards$DirectInput = {
  /**
   * The identifier of the sender of the story
   * @type {int53} {@link int53}
   */
  readonly story_sender_chat_id?: int53;

  /**
   * The identifier of the story
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages and stories to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned objects is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns forwards of a story as a message to public chats and reposts by public channels. Can be used only if the story is posted on behalf of the current user or story.can_get_statistics == true.
 *
 * - For optimal performance, the number of returned messages and stories is chosen by TDLib
 *
 * @param {getStoryPublicForwards$Input} parameters {@link getStoryPublicForwards$Input}
 * @return {PublicForwards} {@link PublicForwards}
 */
export type getStoryPublicForwards = (
  parameters: getStoryPublicForwards$Input
) => PublicForwards;

/**
 * Returns list of features available on the specific chat boost level; this is an offline request
 */
export type getChatBoostLevelFeatures$Input = {
  readonly _: "getChatBoostLevelFeatures";

  /**
   * Chat boost level
   * @type {int32} {@link int32}
   */
  readonly level?: int32;
};

/**
 * Returns list of features available on the specific chat boost level; this is an offline request
 */
export type getChatBoostLevelFeatures$DirectInput = {
  /**
   * Chat boost level
   * @type {int32} {@link int32}
   */
  readonly level?: int32;
};

/**
 * Returns list of features available on the specific chat boost level; this is an offline request
 *
 * @param {getChatBoostLevelFeatures$Input} parameters {@link getChatBoostLevelFeatures$Input}
 * @return {ChatBoostLevelFeatures} {@link ChatBoostLevelFeatures}
 */
export type getChatBoostLevelFeatures = (
  parameters: getChatBoostLevelFeatures$Input
) => ChatBoostLevelFeatures;

/**
 * Returns list of features available on the first 10 chat boost levels; this is an offline request
 */
export type getChatBoostFeatures$Input = {
  readonly _: "getChatBoostFeatures";
};

/**
 * Returns list of features available on the first 10 chat boost levels; this is an offline request
 */
export type getChatBoostFeatures$DirectInput = {};

/**
 * Returns list of features available on the first 10 chat boost levels; this is an offline request
 *
 * @param {getChatBoostFeatures$Input} parameters {@link getChatBoostFeatures$Input}
 * @return {ChatBoostFeatures} {@link ChatBoostFeatures}
 */
export type getChatBoostFeatures = (
  parameters: getChatBoostFeatures$Input
) => ChatBoostFeatures;

/**
 * Returns the list of available chat boost slots for the current user
 */
export type getAvailableChatBoostSlots$Input = {
  readonly _: "getAvailableChatBoostSlots";
};

/**
 * Returns the list of available chat boost slots for the current user
 */
export type getAvailableChatBoostSlots$DirectInput = {};

/**
 * Returns the list of available chat boost slots for the current user
 *
 * @param {getAvailableChatBoostSlots$Input} parameters {@link getAvailableChatBoostSlots$Input}
 * @return {ChatBoostSlots} {@link ChatBoostSlots}
 */
export type getAvailableChatBoostSlots = (
  parameters: getAvailableChatBoostSlots$Input
) => ChatBoostSlots;

/**
 * Returns the current boost status for a channel chat
 */
export type getChatBoostStatus$Input = {
  readonly _: "getChatBoostStatus";

  /**
   * Identifier of the channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns the current boost status for a channel chat
 */
export type getChatBoostStatus$DirectInput = {
  /**
   * Identifier of the channel chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns the current boost status for a channel chat
 *
 * @param {getChatBoostStatus$Input} parameters {@link getChatBoostStatus$Input}
 * @return {ChatBoostStatus} {@link ChatBoostStatus}
 */
export type getChatBoostStatus = (
  parameters: getChatBoostStatus$Input
) => ChatBoostStatus;

/**
 * Boosts a chat and returns the list of available chat boost slots for the current user after the boost
 */
export type boostChat$Input = {
  readonly _: "boostChat";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of boost slots of the current user from which to apply boosts to the chat
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly slot_ids?: vector$Input<int32>;
};

/**
 * Boosts a chat and returns the list of available chat boost slots for the current user after the boost
 */
export type boostChat$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of boost slots of the current user from which to apply boosts to the chat
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly slot_ids?: vector$Input<int32>;
};

/**
 * Boosts a chat and returns the list of available chat boost slots for the current user after the boost
 *
 * @param {boostChat$Input} parameters {@link boostChat$Input}
 * @return {ChatBoostSlots} {@link ChatBoostSlots}
 */
export type boostChat = (parameters: boostChat$Input) => ChatBoostSlots;

/**
 * Returns an HTTPS link to boost the specified channel chat
 */
export type getChatBoostLink$Input = {
  readonly _: "getChatBoostLink";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns an HTTPS link to boost the specified channel chat
 */
export type getChatBoostLink$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns an HTTPS link to boost the specified channel chat
 *
 * @param {getChatBoostLink$Input} parameters {@link getChatBoostLink$Input}
 * @return {ChatBoostLink} {@link ChatBoostLink}
 */
export type getChatBoostLink = (parameters: getChatBoostLink$Input) => ChatBoostLink;

/**
 * Returns information about a link to boost a chat. Can be called for any internal link of the type internalLinkTypeChatBoost
 */
export type getChatBoostLinkInfo$Input = {
  readonly _: "getChatBoostLinkInfo";

  /**
   * The link to boost a chat
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Returns information about a link to boost a chat. Can be called for any internal link of the type internalLinkTypeChatBoost
 */
export type getChatBoostLinkInfo$DirectInput = {
  /**
   * The link to boost a chat
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Returns information about a link to boost a chat. Can be called for any internal link of the type internalLinkTypeChatBoost
 *
 * @param {getChatBoostLinkInfo$Input} parameters {@link getChatBoostLinkInfo$Input}
 * @return {ChatBoostLinkInfo} {@link ChatBoostLinkInfo}
 */
export type getChatBoostLinkInfo = (
  parameters: getChatBoostLinkInfo$Input
) => ChatBoostLinkInfo;

/**
 * Returns list of boosts applied to a chat; requires administrator rights in the channel chat
 */
export type getChatBoosts$Input = {
  readonly _: "getChatBoosts";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to receive only boosts received from gift codes and giveaways created by the chat
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_gift_codes?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of boosts to be returned; up to 100. For optimal performance, the number of returned boosts can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns list of boosts applied to a chat; requires administrator rights in the channel chat
 */
export type getChatBoosts$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to receive only boosts received from gift codes and giveaways created by the chat
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_gift_codes?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of boosts to be returned; up to 100. For optimal performance, the number of returned boosts can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns list of boosts applied to a chat; requires administrator rights in the channel chat
 *
 * @param {getChatBoosts$Input} parameters {@link getChatBoosts$Input}
 * @return {FoundChatBoosts} {@link FoundChatBoosts}
 */
export type getChatBoosts = (parameters: getChatBoosts$Input) => FoundChatBoosts;

/**
 * Returns list of boosts applied to a chat by a given user; requires administrator rights in the channel chat; for bots only
 */
export type getUserChatBoosts$Input = {
  readonly _: "getUserChatBoosts";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns list of boosts applied to a chat by a given user; requires administrator rights in the channel chat; for bots only
 */
export type getUserChatBoosts$DirectInput = {
  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns list of boosts applied to a chat by a given user; requires administrator rights in the channel chat; for bots only
 *
 * @param {getUserChatBoosts$Input} parameters {@link getUserChatBoosts$Input}
 * @return {FoundChatBoosts} {@link FoundChatBoosts}
 */
export type getUserChatBoosts = (
  parameters: getUserChatBoosts$Input
) => FoundChatBoosts;

/**
 * Returns information about a bot that can be added to attachment or side menu
 */
export type getAttachmentMenuBot$Input = {
  readonly _: "getAttachmentMenuBot";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Returns information about a bot that can be added to attachment or side menu
 */
export type getAttachmentMenuBot$DirectInput = {
  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Returns information about a bot that can be added to attachment or side menu
 *
 * @param {getAttachmentMenuBot$Input} parameters {@link getAttachmentMenuBot$Input}
 * @return {AttachmentMenuBot} {@link AttachmentMenuBot}
 */
export type getAttachmentMenuBot = (
  parameters: getAttachmentMenuBot$Input
) => AttachmentMenuBot;

/**
 * Adds or removes a bot to attachment and side menu. Bot can be added to the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
 */
export type toggleBotIsAddedToAttachmentMenu$Input = {
  readonly _: "toggleBotIsAddedToAttachmentMenu";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Pass true to add the bot to attachment menu; pass false to remove the bot from attachment menu
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_added?: Bool$Input;

  /**
   * Pass true if the current user allowed the bot to send them messages. Ignored if is_added is false
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Adds or removes a bot to attachment and side menu. Bot can be added to the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
 */
export type toggleBotIsAddedToAttachmentMenu$DirectInput = {
  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Pass true to add the bot to attachment menu; pass false to remove the bot from attachment menu
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_added?: Bool$Input;

  /**
   * Pass true if the current user allowed the bot to send them messages. Ignored if is_added is false
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Adds or removes a bot to attachment and side menu. Bot can be added to the menu, only if userTypeBot.can_be_added_to_attachment_menu == true
 *
 * @param {toggleBotIsAddedToAttachmentMenu$Input} parameters {@link toggleBotIsAddedToAttachmentMenu$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleBotIsAddedToAttachmentMenu = (
  parameters: toggleBotIsAddedToAttachmentMenu$Input
) => Ok;

/**
 * Returns up to 8 emoji statuses, which must be shown right after the default Premium Badge in the emoji status list for self status
 */
export type getThemedEmojiStatuses$Input = {
  readonly _: "getThemedEmojiStatuses";
};

/**
 * Returns up to 8 emoji statuses, which must be shown right after the default Premium Badge in the emoji status list for self status
 */
export type getThemedEmojiStatuses$DirectInput = {};

/**
 * Returns up to 8 emoji statuses, which must be shown right after the default Premium Badge in the emoji status list for self status
 *
 * @param {getThemedEmojiStatuses$Input} parameters {@link getThemedEmojiStatuses$Input}
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getThemedEmojiStatuses = (
  parameters: getThemedEmojiStatuses$Input
) => EmojiStatuses;

/**
 * Returns recent emoji statuses for self status
 */
export type getRecentEmojiStatuses$Input = {
  readonly _: "getRecentEmojiStatuses";
};

/**
 * Returns recent emoji statuses for self status
 */
export type getRecentEmojiStatuses$DirectInput = {};

/**
 * Returns recent emoji statuses for self status
 *
 * @param {getRecentEmojiStatuses$Input} parameters {@link getRecentEmojiStatuses$Input}
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getRecentEmojiStatuses = (
  parameters: getRecentEmojiStatuses$Input
) => EmojiStatuses;

/**
 * Returns default emoji statuses for self status
 */
export type getDefaultEmojiStatuses$Input = {
  readonly _: "getDefaultEmojiStatuses";
};

/**
 * Returns default emoji statuses for self status
 */
export type getDefaultEmojiStatuses$DirectInput = {};

/**
 * Returns default emoji statuses for self status
 *
 * @param {getDefaultEmojiStatuses$Input} parameters {@link getDefaultEmojiStatuses$Input}
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getDefaultEmojiStatuses = (
  parameters: getDefaultEmojiStatuses$Input
) => EmojiStatuses;

/**
 * Clears the list of recently used emoji statuses for self status
 */
export type clearRecentEmojiStatuses$Input = {
  readonly _: "clearRecentEmojiStatuses";
};

/**
 * Clears the list of recently used emoji statuses for self status
 */
export type clearRecentEmojiStatuses$DirectInput = {};

/**
 * Clears the list of recently used emoji statuses for self status
 *
 * @param {clearRecentEmojiStatuses$Input} parameters {@link clearRecentEmojiStatuses$Input}
 * @return {Ok} {@link Ok}
 */
export type clearRecentEmojiStatuses = (
  parameters: clearRecentEmojiStatuses$Input
) => Ok;

/**
 * Returns up to 8 emoji statuses, which must be shown in the emoji status list for chats
 */
export type getThemedChatEmojiStatuses$Input = {
  readonly _: "getThemedChatEmojiStatuses";
};

/**
 * Returns up to 8 emoji statuses, which must be shown in the emoji status list for chats
 */
export type getThemedChatEmojiStatuses$DirectInput = {};

/**
 * Returns up to 8 emoji statuses, which must be shown in the emoji status list for chats
 *
 * @param {getThemedChatEmojiStatuses$Input} parameters {@link getThemedChatEmojiStatuses$Input}
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getThemedChatEmojiStatuses = (
  parameters: getThemedChatEmojiStatuses$Input
) => EmojiStatuses;

/**
 * Returns default emoji statuses for chats
 */
export type getDefaultChatEmojiStatuses$Input = {
  readonly _: "getDefaultChatEmojiStatuses";
};

/**
 * Returns default emoji statuses for chats
 */
export type getDefaultChatEmojiStatuses$DirectInput = {};

/**
 * Returns default emoji statuses for chats
 *
 * @param {getDefaultChatEmojiStatuses$Input} parameters {@link getDefaultChatEmojiStatuses$Input}
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getDefaultChatEmojiStatuses = (
  parameters: getDefaultChatEmojiStatuses$Input
) => EmojiStatuses;

/**
 * Returns the list of emoji statuses, which can't be used as chat emoji status, even they are from a sticker set with is_allowed_as_chat_emoji_status == true
 */
export type getDisallowedChatEmojiStatuses$Input = {
  readonly _: "getDisallowedChatEmojiStatuses";
};

/**
 * Returns the list of emoji statuses, which can't be used as chat emoji status, even they are from a sticker set with is_allowed_as_chat_emoji_status == true
 */
export type getDisallowedChatEmojiStatuses$DirectInput = {};

/**
 * Returns the list of emoji statuses, which can't be used as chat emoji status, even they are from a sticker set with is_allowed_as_chat_emoji_status == true
 *
 * @param {getDisallowedChatEmojiStatuses$Input} parameters {@link getDisallowedChatEmojiStatuses$Input}
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getDisallowedChatEmojiStatuses = (
  parameters: getDisallowedChatEmojiStatuses$Input
) => EmojiStatuses;

/**
 * Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
 */
export type downloadFile$Input = {
  readonly _: "downloadFile";

  /**
   * Identifier of the file to download
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;

  /**
   * The starting position from which the file needs to be downloaded
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * Number of bytes which need to be downloaded starting from the "offset" position before the download will automatically be canceled; use 0 to download without a limit
   * @type {int53} {@link int53}
   */
  readonly limit?: int53;

  /**
   * Pass true to return response only after the file download has succeeded, has failed, has been canceled, or a new downloadFile request with different offset/limit parameters was sent; pass false to return file state immediately, just after the download has been started
   * @type {Bool$Input} {@link Bool}
   */
  readonly synchronous?: Bool$Input;
};

/**
 * Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
 */
export type downloadFile$DirectInput = {
  /**
   * Identifier of the file to download
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;

  /**
   * The starting position from which the file needs to be downloaded
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * Number of bytes which need to be downloaded starting from the "offset" position before the download will automatically be canceled; use 0 to download without a limit
   * @type {int53} {@link int53}
   */
  readonly limit?: int53;

  /**
   * Pass true to return response only after the file download has succeeded, has failed, has been canceled, or a new downloadFile request with different offset/limit parameters was sent; pass false to return file state immediately, just after the download has been started
   * @type {Bool$Input} {@link Bool}
   */
  readonly synchronous?: Bool$Input;
};

/**
 * Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
 *
 * @param {downloadFile$Input} parameters {@link downloadFile$Input}
 * @return {File} {@link File}
 */
export type downloadFile = (parameters: downloadFile$Input) => File;

/**
 * Returns file downloaded prefix size from a given offset, in bytes
 */
export type getFileDownloadedPrefixSize$Input = {
  readonly _: "getFileDownloadedPrefixSize";

  /**
   * Identifier of the file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Offset from which downloaded prefix size needs to be calculated
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;
};

/**
 * Returns file downloaded prefix size from a given offset, in bytes
 */
export type getFileDownloadedPrefixSize$DirectInput = {
  /**
   * Identifier of the file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Offset from which downloaded prefix size needs to be calculated
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;
};

/**
 * Returns file downloaded prefix size from a given offset, in bytes
 *
 * @param {getFileDownloadedPrefixSize$Input} parameters {@link getFileDownloadedPrefixSize$Input}
 * @return {FileDownloadedPrefixSize} {@link FileDownloadedPrefixSize}
 */
export type getFileDownloadedPrefixSize = (
  parameters: getFileDownloadedPrefixSize$Input
) => FileDownloadedPrefixSize;

/**
 * Stops the downloading of a file. If a file has already been downloaded, does nothing
 */
export type cancelDownloadFile$Input = {
  readonly _: "cancelDownloadFile";

  /**
   * Identifier of a file to stop downloading
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_if_pending?: Bool$Input;
};

/**
 * Stops the downloading of a file. If a file has already been downloaded, does nothing
 */
export type cancelDownloadFile$DirectInput = {
  /**
   * Identifier of a file to stop downloading
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_if_pending?: Bool$Input;
};

/**
 * Stops the downloading of a file. If a file has already been downloaded, does nothing
 *
 * @param {cancelDownloadFile$Input} parameters {@link cancelDownloadFile$Input}
 * @return {Ok} {@link Ok}
 */
export type cancelDownloadFile = (parameters: cancelDownloadFile$Input) => Ok;

/**
 * Returns suggested name for saving a file in a given directory
 */
export type getSuggestedFileName$Input = {
  readonly _: "getSuggestedFileName";

  /**
   * Identifier of the file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Directory in which the file is supposed to be saved
   * @type {string} {@link string}
   */
  readonly directory?: string;
};

/**
 * Returns suggested name for saving a file in a given directory
 */
export type getSuggestedFileName$DirectInput = {
  /**
   * Identifier of the file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Directory in which the file is supposed to be saved
   * @type {string} {@link string}
   */
  readonly directory?: string;
};

/**
 * Returns suggested name for saving a file in a given directory
 *
 * @param {getSuggestedFileName$Input} parameters {@link getSuggestedFileName$Input}
 * @return {Text} {@link Text}
 */
export type getSuggestedFileName = (parameters: getSuggestedFileName$Input) => Text;

/**
 * Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used
 *
 * - to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it is sent in a message
 */
export type preliminaryUploadFile$Input = {
  readonly _: "preliminaryUploadFile";

  /**
   * File to upload
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly file?: InputFile$Input;

  /**
   * File type; pass null if unknown
   * @type {FileType$Input} {@link FileType}
   */
  readonly file_type?: FileType$Input | null;

  /**
   * Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which preliminaryUploadFile was called will be uploaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;
};

/**
 * Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used
 *
 * - to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it is sent in a message
 */
export type preliminaryUploadFile$DirectInput = {
  /**
   * File to upload
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly file?: InputFile$Input;

  /**
   * File type; pass null if unknown
   * @type {FileType$Input} {@link FileType}
   */
  readonly file_type?: FileType$Input | null;

  /**
   * Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which preliminaryUploadFile was called will be uploaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;
};

/**
 * Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used
 *
 * - to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it is sent in a message
 *
 * @param {preliminaryUploadFile$Input} parameters {@link preliminaryUploadFile$Input}
 * @return {File} {@link File}
 */
export type preliminaryUploadFile = (
  parameters: preliminaryUploadFile$Input
) => File;

/**
 * Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined
 */
export type cancelPreliminaryUploadFile$Input = {
  readonly _: "cancelPreliminaryUploadFile";

  /**
   * Identifier of the file to stop uploading
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined
 */
export type cancelPreliminaryUploadFile$DirectInput = {
  /**
   * Identifier of the file to stop uploading
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined
 *
 * @param {cancelPreliminaryUploadFile$Input} parameters {@link cancelPreliminaryUploadFile$Input}
 * @return {Ok} {@link Ok}
 */
export type cancelPreliminaryUploadFile = (
  parameters: cancelPreliminaryUploadFile$Input
) => Ok;

/**
 * Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
 */
export type writeGeneratedFilePart$Input = {
  readonly _: "writeGeneratedFilePart";

  /**
   * The identifier of the generation process
   * @type {int64$Input} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * The offset from which to write the data to the file
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * The data to write
   * @type {bytes$Input} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
 */
export type writeGeneratedFilePart$DirectInput = {
  /**
   * The identifier of the generation process
   * @type {int64$Input} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * The offset from which to write the data to the file
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * The data to write
   * @type {bytes$Input} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
 *
 * @param {writeGeneratedFilePart$Input} parameters {@link writeGeneratedFilePart$Input}
 * @return {Ok} {@link Ok}
 */
export type writeGeneratedFilePart = (
  parameters: writeGeneratedFilePart$Input
) => Ok;

/**
 * Informs TDLib on a file generation progress
 */
export type setFileGenerationProgress$Input = {
  readonly _: "setFileGenerationProgress";

  /**
   * The identifier of the generation process
   * @type {int64$Input} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;

  /**
   * The number of bytes already generated
   * @type {int53} {@link int53}
   */
  readonly local_prefix_size?: int53;
};

/**
 * Informs TDLib on a file generation progress
 */
export type setFileGenerationProgress$DirectInput = {
  /**
   * The identifier of the generation process
   * @type {int64$Input} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;

  /**
   * The number of bytes already generated
   * @type {int53} {@link int53}
   */
  readonly local_prefix_size?: int53;
};

/**
 * Informs TDLib on a file generation progress
 *
 * @param {setFileGenerationProgress$Input} parameters {@link setFileGenerationProgress$Input}
 * @return {Ok} {@link Ok}
 */
export type setFileGenerationProgress = (
  parameters: setFileGenerationProgress$Input
) => Ok;

/**
 * Finishes the file generation
 */
export type finishFileGeneration$Input = {
  readonly _: "finishFileGeneration";

  /**
   * The identifier of the generation process
   * @type {int64$Input} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * If passed, the file generation has failed and must be terminated; pass null if the file generation succeeded
   * @type {error$Input} {@link error}
   */
  readonly error?: error$Input | null;
};

/**
 * Finishes the file generation
 */
export type finishFileGeneration$DirectInput = {
  /**
   * The identifier of the generation process
   * @type {int64$Input} {@link int64}
   */
  readonly generation_id?: int64$Input;

  /**
   * If passed, the file generation has failed and must be terminated; pass null if the file generation succeeded
   * @type {error$Input} {@link error}
   */
  readonly error?: error$Input | null;
};

/**
 * Finishes the file generation
 *
 * @param {finishFileGeneration$Input} parameters {@link finishFileGeneration$Input}
 * @return {Ok} {@link Ok}
 */
export type finishFileGeneration = (parameters: finishFileGeneration$Input) => Ok;

/**
 * Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
 */
export type readFilePart$Input = {
  readonly _: "readFilePart";

  /**
   * Identifier of the file. The file must be located in the TDLib file cache
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The offset from which to read the file
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position
   * @type {int53} {@link int53}
   */
  readonly count?: int53;
};

/**
 * Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
 */
export type readFilePart$DirectInput = {
  /**
   * Identifier of the file. The file must be located in the TDLib file cache
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The offset from which to read the file
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position
   * @type {int53} {@link int53}
   */
  readonly count?: int53;
};

/**
 * Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
 *
 * @param {readFilePart$Input} parameters {@link readFilePart$Input}
 * @return {FilePart} {@link FilePart}
 */
export type readFilePart = (parameters: readFilePart$Input) => FilePart;

/**
 * Deletes a file from the TDLib file cache
 */
export type deleteFile$Input = {
  readonly _: "deleteFile";

  /**
   * Identifier of the file to delete
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Deletes a file from the TDLib file cache
 */
export type deleteFile$DirectInput = {
  /**
   * Identifier of the file to delete
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Deletes a file from the TDLib file cache
 *
 * @param {deleteFile$Input} parameters {@link deleteFile$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteFile = (parameters: deleteFile$Input) => Ok;

/**
 * Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
 *
 * - If message database is used, the list of file downloads is persistent across application restarts. The downloading is independent from download using downloadFile, i.e. it continues if downloadFile is canceled or is used to download a part of the file
 */
export type addFileToDownloads$Input = {
  readonly _: "addFileToDownloads";

  /**
   * Identifier of the file to download
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Chat identifier of the message with the file
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;
};

/**
 * Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
 *
 * - If message database is used, the list of file downloads is persistent across application restarts. The downloading is independent from download using downloadFile, i.e. it continues if downloadFile is canceled or is used to download a part of the file
 */
export type addFileToDownloads$DirectInput = {
  /**
   * Identifier of the file to download
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Chat identifier of the message with the file
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;
};

/**
 * Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
 *
 * - If message database is used, the list of file downloads is persistent across application restarts. The downloading is independent from download using downloadFile, i.e. it continues if downloadFile is canceled or is used to download a part of the file
 *
 * @param {addFileToDownloads$Input} parameters {@link addFileToDownloads$Input}
 * @return {File} {@link File}
 */
export type addFileToDownloads = (parameters: addFileToDownloads$Input) => File;

/**
 * Changes pause state of a file in the file download list
 */
export type toggleDownloadIsPaused$Input = {
  readonly _: "toggleDownloadIsPaused";

  /**
   * Identifier of the downloaded file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true if the download is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Changes pause state of a file in the file download list
 */
export type toggleDownloadIsPaused$DirectInput = {
  /**
   * Identifier of the downloaded file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true if the download is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Changes pause state of a file in the file download list
 *
 * @param {toggleDownloadIsPaused$Input} parameters {@link toggleDownloadIsPaused$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleDownloadIsPaused = (
  parameters: toggleDownloadIsPaused$Input
) => Ok;

/**
 * Changes pause state of all files in the file download list
 */
export type toggleAllDownloadsArePaused$Input = {
  readonly _: "toggleAllDownloadsArePaused";

  /**
   * Pass true to pause all downloads; pass false to unpause them
   * @type {Bool$Input} {@link Bool}
   */
  readonly are_paused?: Bool$Input;
};

/**
 * Changes pause state of all files in the file download list
 */
export type toggleAllDownloadsArePaused$DirectInput = {
  /**
   * Pass true to pause all downloads; pass false to unpause them
   * @type {Bool$Input} {@link Bool}
   */
  readonly are_paused?: Bool$Input;
};

/**
 * Changes pause state of all files in the file download list
 *
 * @param {toggleAllDownloadsArePaused$Input} parameters {@link toggleAllDownloadsArePaused$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleAllDownloadsArePaused = (
  parameters: toggleAllDownloadsArePaused$Input
) => Ok;

/**
 * Removes a file from the file download list
 */
export type removeFileFromDownloads$Input = {
  readonly _: "removeFileFromDownloads";

  /**
   * Identifier of the downloaded file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true to delete the file from the TDLib file cache
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_from_cache?: Bool$Input;
};

/**
 * Removes a file from the file download list
 */
export type removeFileFromDownloads$DirectInput = {
  /**
   * Identifier of the downloaded file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true to delete the file from the TDLib file cache
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_from_cache?: Bool$Input;
};

/**
 * Removes a file from the file download list
 *
 * @param {removeFileFromDownloads$Input} parameters {@link removeFileFromDownloads$Input}
 * @return {Ok} {@link Ok}
 */
export type removeFileFromDownloads = (
  parameters: removeFileFromDownloads$Input
) => Ok;

/**
 * Removes all files from the file download list
 */
export type removeAllFilesFromDownloads$Input = {
  readonly _: "removeAllFilesFromDownloads";

  /**
   * Pass true to remove only active downloads, including paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_active?: Bool$Input;

  /**
   * Pass true to remove only completed downloads
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_completed?: Bool$Input;

  /**
   * Pass true to delete the file from the TDLib file cache
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_from_cache?: Bool$Input;
};

/**
 * Removes all files from the file download list
 */
export type removeAllFilesFromDownloads$DirectInput = {
  /**
   * Pass true to remove only active downloads, including paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_active?: Bool$Input;

  /**
   * Pass true to remove only completed downloads
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_completed?: Bool$Input;

  /**
   * Pass true to delete the file from the TDLib file cache
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_from_cache?: Bool$Input;
};

/**
 * Removes all files from the file download list
 *
 * @param {removeAllFilesFromDownloads$Input} parameters {@link removeAllFilesFromDownloads$Input}
 * @return {Ok} {@link Ok}
 */
export type removeAllFilesFromDownloads = (
  parameters: removeAllFilesFromDownloads$Input
) => Ok;

/**
 * Searches for files in the file download list or recently downloaded files from the list
 */
export type searchFileDownloads$Input = {
  readonly _: "searchFileDownloads";

  /**
   * Query to search for; may be empty to return all downloaded files
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Pass true to search only for active downloads, including paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_active?: Bool$Input;

  /**
   * Pass true to search only for completed downloads
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_completed?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of files to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for files in the file download list or recently downloaded files from the list
 */
export type searchFileDownloads$DirectInput = {
  /**
   * Query to search for; may be empty to return all downloaded files
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Pass true to search only for active downloads, including paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_active?: Bool$Input;

  /**
   * Pass true to search only for completed downloads
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_completed?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of files to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for files in the file download list or recently downloaded files from the list
 *
 * @param {searchFileDownloads$Input} parameters {@link searchFileDownloads$Input}
 * @return {FoundFileDownloads} {@link FoundFileDownloads}
 */
export type searchFileDownloads = (
  parameters: searchFileDownloads$Input
) => FoundFileDownloads;

/**
 * Returns information about a file with messages exported from another application
 */
export type getMessageFileType$Input = {
  readonly _: "getMessageFileType";

  /**
   * Beginning of the message file; up to 100 first lines
   * @type {string} {@link string}
   */
  readonly message_file_head?: string;
};

/**
 * Returns information about a file with messages exported from another application
 */
export type getMessageFileType$DirectInput = {
  /**
   * Beginning of the message file; up to 100 first lines
   * @type {string} {@link string}
   */
  readonly message_file_head?: string;
};

/**
 * Returns information about a file with messages exported from another application
 *
 * @param {getMessageFileType$Input} parameters {@link getMessageFileType$Input}
 * @return {MessageFileType} {@link MessageFileType}
 */
export type getMessageFileType = (
  parameters: getMessageFileType$Input
) => MessageFileType;

/**
 * Returns a confirmation text to be shown to the user before starting message import
 */
export type getMessageImportConfirmationText$Input = {
  readonly _: "getMessageImportConfirmationText";

  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a confirmation text to be shown to the user before starting message import
 */
export type getMessageImportConfirmationText$DirectInput = {
  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a confirmation text to be shown to the user before starting message import
 *
 * @param {getMessageImportConfirmationText$Input} parameters {@link getMessageImportConfirmationText$Input}
 * @return {Text} {@link Text}
 */
export type getMessageImportConfirmationText = (
  parameters: getMessageImportConfirmationText$Input
) => Text;

/**
 * Imports messages exported from another app
 */
export type importMessages$Input = {
  readonly _: "importMessages";

  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly message_file?: InputFile$Input;

  /**
   * Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded
   * @type {vector$Input<InputFile$Input>} {@link vector<InputFile>}
   */
  readonly attached_files?: vector$Input<InputFile$Input>;
};

/**
 * Imports messages exported from another app
 */
export type importMessages$DirectInput = {
  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly message_file?: InputFile$Input;

  /**
   * Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded
   * @type {vector$Input<InputFile$Input>} {@link vector<InputFile>}
   */
  readonly attached_files?: vector$Input<InputFile$Input>;
};

/**
 * Imports messages exported from another app
 *
 * @param {importMessages$Input} parameters {@link importMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type importMessages = (parameters: importMessages$Input) => Ok;

/**
 * Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
 */
export type replacePrimaryChatInviteLink$Input = {
  readonly _: "replacePrimaryChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
 */
export type replacePrimaryChatInviteLink$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
 *
 * @param {replacePrimaryChatInviteLink$Input} parameters {@link replacePrimaryChatInviteLink$Input}
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type replacePrimaryChatInviteLink = (
  parameters: replacePrimaryChatInviteLink$Input
) => ChatInviteLink;

/**
 * Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
 */
export type createChatInviteLink$Input = {
  readonly _: "createChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link name; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Point in time (Unix timestamp) when the link will expire; pass 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0
   * @type {Bool$Input} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;
};

/**
 * Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
 */
export type createChatInviteLink$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link name; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Point in time (Unix timestamp) when the link will expire; pass 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0
   * @type {Bool$Input} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;
};

/**
 * Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
 *
 * @param {createChatInviteLink$Input} parameters {@link createChatInviteLink$Input}
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type createChatInviteLink = (
  parameters: createChatInviteLink$Input
) => ChatInviteLink;

/**
 * Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type editChatInviteLink$Input = {
  readonly _: "editChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to be edited
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Invite link name; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Point in time (Unix timestamp) when the link will expire; pass 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0
   * @type {Bool$Input} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;
};

/**
 * Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type editChatInviteLink$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to be edited
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Invite link name; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Point in time (Unix timestamp) when the link will expire; pass 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0
   * @type {Bool$Input} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;
};

/**
 * Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {editChatInviteLink$Input} parameters {@link editChatInviteLink$Input}
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type editChatInviteLink = (
  parameters: editChatInviteLink$Input
) => ChatInviteLink;

/**
 * Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 */
export type getChatInviteLink$Input = {
  readonly _: "getChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to get
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 */
export type getChatInviteLink$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to get
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 *
 * @param {getChatInviteLink$Input} parameters {@link getChatInviteLink$Input}
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type getChatInviteLink = (
  parameters: getChatInviteLink$Input
) => ChatInviteLink;

/**
 * Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
 */
export type getChatInviteLinkCounts$Input = {
  readonly _: "getChatInviteLinkCounts";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
 */
export type getChatInviteLinkCounts$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
 *
 * @param {getChatInviteLinkCounts$Input} parameters {@link getChatInviteLinkCounts$Input}
 * @return {ChatInviteLinkCounts} {@link ChatInviteLinkCounts}
 */
export type getChatInviteLinkCounts = (
  parameters: getChatInviteLinkCounts$Input
) => ChatInviteLinkCounts;

/**
 * Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 */
export type getChatInviteLinks$Input = {
  readonly _: "getChatInviteLinks";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier of a chat administrator. Must be an identifier of the current user for non-owner
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Pass true if revoked links needs to be returned instead of active or expired
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_revoked?: Bool$Input;

  /**
   * Creation date of an invite link starting after which to return invite links; use 0 to get results from the beginning
   * @type {int32} {@link int32}
   */
  readonly offset_date?: int32;

  /**
   * Invite link starting after which to return invite links; use empty string to get results from the beginning
   * @type {string} {@link string}
   */
  readonly offset_invite_link?: string;

  /**
   * The maximum number of invite links to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 */
export type getChatInviteLinks$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier of a chat administrator. Must be an identifier of the current user for non-owner
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Pass true if revoked links needs to be returned instead of active or expired
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_revoked?: Bool$Input;

  /**
   * Creation date of an invite link starting after which to return invite links; use 0 to get results from the beginning
   * @type {int32} {@link int32}
   */
  readonly offset_date?: int32;

  /**
   * Invite link starting after which to return invite links; use empty string to get results from the beginning
   * @type {string} {@link string}
   */
  readonly offset_invite_link?: string;

  /**
   * The maximum number of invite links to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 *
 * @param {getChatInviteLinks$Input} parameters {@link getChatInviteLinks$Input}
 * @return {ChatInviteLinks} {@link ChatInviteLinks}
 */
export type getChatInviteLinks = (
  parameters: getChatInviteLinks$Input
) => ChatInviteLinks;

/**
 * Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type getChatInviteLinkMembers$Input = {
  readonly _: "getChatInviteLinkMembers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to return chat members
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * A chat member from which to return next chat members; pass null to get results from the beginning
   * @type {chatInviteLinkMember$Input} {@link chatInviteLinkMember}
   */
  readonly offset_member?: chatInviteLinkMember$Input | null;

  /**
   * The maximum number of chat members to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type getChatInviteLinkMembers$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to return chat members
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * A chat member from which to return next chat members; pass null to get results from the beginning
   * @type {chatInviteLinkMember$Input} {@link chatInviteLinkMember}
   */
  readonly offset_member?: chatInviteLinkMember$Input | null;

  /**
   * The maximum number of chat members to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {getChatInviteLinkMembers$Input} parameters {@link getChatInviteLinkMembers$Input}
 * @return {ChatInviteLinkMembers} {@link ChatInviteLinkMembers}
 */
export type getChatInviteLinkMembers = (
  parameters: getChatInviteLinkMembers$Input
) => ChatInviteLinkMembers;

/**
 * Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
 *
 * - If a primary link is revoked, then additionally to the revoked link returns new primary link
 */
export type revokeChatInviteLink$Input = {
  readonly _: "revokeChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to be revoked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
 *
 * - If a primary link is revoked, then additionally to the revoked link returns new primary link
 */
export type revokeChatInviteLink$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to be revoked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
 *
 * - If a primary link is revoked, then additionally to the revoked link returns new primary link
 *
 * @param {revokeChatInviteLink$Input} parameters {@link revokeChatInviteLink$Input}
 * @return {ChatInviteLinks} {@link ChatInviteLinks}
 */
export type revokeChatInviteLink = (
  parameters: revokeChatInviteLink$Input
) => ChatInviteLinks;

/**
 * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type deleteRevokedChatInviteLink$Input = {
  readonly _: "deleteRevokedChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to revoke
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type deleteRevokedChatInviteLink$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to revoke
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {deleteRevokedChatInviteLink$Input} parameters {@link deleteRevokedChatInviteLink$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteRevokedChatInviteLink = (
  parameters: deleteRevokedChatInviteLink$Input
) => Ok;

/**
 * Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type deleteAllRevokedChatInviteLinks$Input = {
  readonly _: "deleteAllRevokedChatInviteLinks";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;
};

/**
 * Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 */
export type deleteAllRevokedChatInviteLinks$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;
};

/**
 * Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {deleteAllRevokedChatInviteLinks$Input} parameters {@link deleteAllRevokedChatInviteLinks$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteAllRevokedChatInviteLinks = (
  parameters: deleteAllRevokedChatInviteLinks$Input
) => Ok;

/**
 * Checks the validity of an invite link for a chat and returns information about the corresponding chat
 */
export type checkChatInviteLink$Input = {
  readonly _: "checkChatInviteLink";

  /**
   * Invite link to be checked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Checks the validity of an invite link for a chat and returns information about the corresponding chat
 */
export type checkChatInviteLink$DirectInput = {
  /**
   * Invite link to be checked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Checks the validity of an invite link for a chat and returns information about the corresponding chat
 *
 * @param {checkChatInviteLink$Input} parameters {@link checkChatInviteLink$Input}
 * @return {ChatInviteLinkInfo} {@link ChatInviteLinkInfo}
 */
export type checkChatInviteLink = (
  parameters: checkChatInviteLink$Input
) => ChatInviteLinkInfo;

/**
 * Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 */
export type joinChatByInviteLink$Input = {
  readonly _: "joinChatByInviteLink";

  /**
   * Invite link to use
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 */
export type joinChatByInviteLink$DirectInput = {
  /**
   * Invite link to use
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 *
 * @param {joinChatByInviteLink$Input} parameters {@link joinChatByInviteLink$Input}
 * @return {Chat} {@link Chat}
 */
export type joinChatByInviteLink = (parameters: joinChatByInviteLink$Input) => Chat;

/**
 * Returns pending join requests in a chat
 */
export type getChatJoinRequests$Input = {
  readonly _: "getChatJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to return join requests. If empty, all join requests will be returned. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * A query to search for in the first names, last names and usernames of the users to return
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * A chat join request from which to return next requests; pass null to get results from the beginning
   * @type {chatJoinRequest$Input} {@link chatJoinRequest}
   */
  readonly offset_request?: chatJoinRequest$Input | null;

  /**
   * The maximum number of requests to join the chat to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns pending join requests in a chat
 */
export type getChatJoinRequests$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to return join requests. If empty, all join requests will be returned. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * A query to search for in the first names, last names and usernames of the users to return
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * A chat join request from which to return next requests; pass null to get results from the beginning
   * @type {chatJoinRequest$Input} {@link chatJoinRequest}
   */
  readonly offset_request?: chatJoinRequest$Input | null;

  /**
   * The maximum number of requests to join the chat to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns pending join requests in a chat
 *
 * @param {getChatJoinRequests$Input} parameters {@link getChatJoinRequests$Input}
 * @return {ChatJoinRequests} {@link ChatJoinRequests}
 */
export type getChatJoinRequests = (
  parameters: getChatJoinRequests$Input
) => ChatJoinRequests;

/**
 * Handles a pending join request in a chat
 */
export type processChatJoinRequest$Input = {
  readonly _: "processChatJoinRequest";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user that sent the request
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Pass true to approve the request; pass false to decline it
   * @type {Bool$Input} {@link Bool}
   */
  readonly approve?: Bool$Input;
};

/**
 * Handles a pending join request in a chat
 */
export type processChatJoinRequest$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user that sent the request
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Pass true to approve the request; pass false to decline it
   * @type {Bool$Input} {@link Bool}
   */
  readonly approve?: Bool$Input;
};

/**
 * Handles a pending join request in a chat
 *
 * @param {processChatJoinRequest$Input} parameters {@link processChatJoinRequest$Input}
 * @return {Ok} {@link Ok}
 */
export type processChatJoinRequest = (
  parameters: processChatJoinRequest$Input
) => Ok;

/**
 * Handles all pending join requests for a given link in a chat
 */
export type processChatJoinRequests$Input = {
  readonly _: "processChatJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to process join requests. If empty, all join requests will be processed. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Pass true to approve all requests; pass false to decline them
   * @type {Bool$Input} {@link Bool}
   */
  readonly approve?: Bool$Input;
};

/**
 * Handles all pending join requests for a given link in a chat
 */
export type processChatJoinRequests$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to process join requests. If empty, all join requests will be processed. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Pass true to approve all requests; pass false to decline them
   * @type {Bool$Input} {@link Bool}
   */
  readonly approve?: Bool$Input;
};

/**
 * Handles all pending join requests for a given link in a chat
 *
 * @param {processChatJoinRequests$Input} parameters {@link processChatJoinRequests$Input}
 * @return {Ok} {@link Ok}
 */
export type processChatJoinRequests = (
  parameters: processChatJoinRequests$Input
) => Ok;

/**
 * Creates a new call
 */
export type createCall$Input = {
  readonly _: "createCall";

  /**
   * Identifier of the user to be called
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The call protocols supported by the application
   * @type {callProtocol$Input} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;

  /**
   * Pass true to create a video call
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_video?: Bool$Input;
};

/**
 * Creates a new call
 */
export type createCall$DirectInput = {
  /**
   * Identifier of the user to be called
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The call protocols supported by the application
   * @type {callProtocol$Input} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;

  /**
   * Pass true to create a video call
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_video?: Bool$Input;
};

/**
 * Creates a new call
 *
 * @param {createCall$Input} parameters {@link createCall$Input}
 * @return {CallId} {@link CallId}
 */
export type createCall = (parameters: createCall$Input) => CallId;

/**
 * Accepts an incoming call
 */
export type acceptCall$Input = {
  readonly _: "acceptCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The call protocols supported by the application
   * @type {callProtocol$Input} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;
};

/**
 * Accepts an incoming call
 */
export type acceptCall$DirectInput = {
  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The call protocols supported by the application
   * @type {callProtocol$Input} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;
};

/**
 * Accepts an incoming call
 *
 * @param {acceptCall$Input} parameters {@link acceptCall$Input}
 * @return {Ok} {@link Ok}
 */
export type acceptCall = (parameters: acceptCall$Input) => Ok;

/**
 * Sends call signaling data
 */
export type sendCallSignalingData$Input = {
  readonly _: "sendCallSignalingData";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The data
   * @type {bytes$Input} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * Sends call signaling data
 */
export type sendCallSignalingData$DirectInput = {
  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The data
   * @type {bytes$Input} {@link bytes}
   */
  readonly data?: bytes$Input;
};

/**
 * Sends call signaling data
 *
 * @param {sendCallSignalingData$Input} parameters {@link sendCallSignalingData$Input}
 * @return {Ok} {@link Ok}
 */
export type sendCallSignalingData = (parameters: sendCallSignalingData$Input) => Ok;

/**
 * Discards a call
 */
export type discardCall$Input = {
  readonly _: "discardCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Pass true if the user was disconnected
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_disconnected?: Bool$Input;

  /**
   * The call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Pass true if the call was a video call
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Identifier of the connection used during the call
   * @type {int64$Input} {@link int64}
   */
  readonly connection_id?: int64$Input;
};

/**
 * Discards a call
 */
export type discardCall$DirectInput = {
  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Pass true if the user was disconnected
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_disconnected?: Bool$Input;

  /**
   * The call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Pass true if the call was a video call
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Identifier of the connection used during the call
   * @type {int64$Input} {@link int64}
   */
  readonly connection_id?: int64$Input;
};

/**
 * Discards a call
 *
 * @param {discardCall$Input} parameters {@link discardCall$Input}
 * @return {Ok} {@link Ok}
 */
export type discardCall = (parameters: discardCall$Input) => Ok;

/**
 * Sends a call rating
 */
export type sendCallRating$Input = {
  readonly _: "sendCallRating";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Call rating; 1-5
   * @type {int32} {@link int32}
   */
  readonly rating?: int32;

  /**
   * An optional user comment if the rating is less than 5
   * @type {string} {@link string}
   */
  readonly comment?: string;

  /**
   * List of the exact types of problems with the call, specified by the user
   * @type {vector$Input<CallProblem$Input>} {@link vector<CallProblem>}
   */
  readonly problems?: vector$Input<CallProblem$Input>;
};

/**
 * Sends a call rating
 */
export type sendCallRating$DirectInput = {
  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Call rating; 1-5
   * @type {int32} {@link int32}
   */
  readonly rating?: int32;

  /**
   * An optional user comment if the rating is less than 5
   * @type {string} {@link string}
   */
  readonly comment?: string;

  /**
   * List of the exact types of problems with the call, specified by the user
   * @type {vector$Input<CallProblem$Input>} {@link vector<CallProblem>}
   */
  readonly problems?: vector$Input<CallProblem$Input>;
};

/**
 * Sends a call rating
 *
 * @param {sendCallRating$Input} parameters {@link sendCallRating$Input}
 * @return {Ok} {@link Ok}
 */
export type sendCallRating = (parameters: sendCallRating$Input) => Ok;

/**
 * Sends debug information for a call to Telegram servers
 */
export type sendCallDebugInformation$Input = {
  readonly _: "sendCallDebugInformation";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Debug information in application-specific format
   * @type {string} {@link string}
   */
  readonly debug_information?: string;
};

/**
 * Sends debug information for a call to Telegram servers
 */
export type sendCallDebugInformation$DirectInput = {
  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Debug information in application-specific format
   * @type {string} {@link string}
   */
  readonly debug_information?: string;
};

/**
 * Sends debug information for a call to Telegram servers
 *
 * @param {sendCallDebugInformation$Input} parameters {@link sendCallDebugInformation$Input}
 * @return {Ok} {@link Ok}
 */
export type sendCallDebugInformation = (
  parameters: sendCallDebugInformation$Input
) => Ok;

/**
 * Sends log file for a call to Telegram servers
 */
export type sendCallLog$Input = {
  readonly _: "sendCallLog";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Call log file. Only inputFileLocal and inputFileGenerated are supported
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly log_file?: InputFile$Input;
};

/**
 * Sends log file for a call to Telegram servers
 */
export type sendCallLog$DirectInput = {
  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Call log file. Only inputFileLocal and inputFileGenerated are supported
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly log_file?: InputFile$Input;
};

/**
 * Sends log file for a call to Telegram servers
 *
 * @param {sendCallLog$Input} parameters {@link sendCallLog$Input}
 * @return {Ok} {@link Ok}
 */
export type sendCallLog = (parameters: sendCallLog$Input) => Ok;

/**
 * Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined
 */
export type getVideoChatAvailableParticipants$Input = {
  readonly _: "getVideoChatAvailableParticipants";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined
 */
export type getVideoChatAvailableParticipants$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined
 *
 * @param {getVideoChatAvailableParticipants$Input} parameters {@link getVideoChatAvailableParticipants$Input}
 * @return {MessageSenders} {@link MessageSenders}
 */
export type getVideoChatAvailableParticipants = (
  parameters: getVideoChatAvailableParticipants$Input
) => MessageSenders;

/**
 * Changes default participant identifier, on whose behalf a video chat in the chat will be joined
 */
export type setVideoChatDefaultParticipant$Input = {
  readonly _: "setVideoChatDefaultParticipant";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Default group call participant identifier to join the video chats
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly default_participant_id?: MessageSender$Input;
};

/**
 * Changes default participant identifier, on whose behalf a video chat in the chat will be joined
 */
export type setVideoChatDefaultParticipant$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Default group call participant identifier to join the video chats
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly default_participant_id?: MessageSender$Input;
};

/**
 * Changes default participant identifier, on whose behalf a video chat in the chat will be joined
 *
 * @param {setVideoChatDefaultParticipant$Input} parameters {@link setVideoChatDefaultParticipant$Input}
 * @return {Ok} {@link Ok}
 */
export type setVideoChatDefaultParticipant = (
  parameters: setVideoChatDefaultParticipant$Input
) => Ok;

/**
 * Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
 */
export type createVideoChat$Input = {
  readonly _: "createVideoChat";

  /**
   * Identifier of a chat in which the video chat will be created
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Group call title; if empty, chat title will be used
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 to start the video chat immediately. The date must be at least 10 seconds and at most 8 days in the future
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Pass true to create an RTMP stream instead of an ordinary video chat; requires creator privileges
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_rtmp_stream?: Bool$Input;
};

/**
 * Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
 */
export type createVideoChat$DirectInput = {
  /**
   * Identifier of a chat in which the video chat will be created
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Group call title; if empty, chat title will be used
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 to start the video chat immediately. The date must be at least 10 seconds and at most 8 days in the future
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Pass true to create an RTMP stream instead of an ordinary video chat; requires creator privileges
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_rtmp_stream?: Bool$Input;
};

/**
 * Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
 *
 * @param {createVideoChat$Input} parameters {@link createVideoChat$Input}
 * @return {GroupCallId} {@link GroupCallId}
 */
export type createVideoChat = (parameters: createVideoChat$Input) => GroupCallId;

/**
 * Returns RTMP URL for streaming to the chat; requires creator privileges
 */
export type getVideoChatRtmpUrl$Input = {
  readonly _: "getVideoChatRtmpUrl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns RTMP URL for streaming to the chat; requires creator privileges
 */
export type getVideoChatRtmpUrl$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns RTMP URL for streaming to the chat; requires creator privileges
 *
 * @param {getVideoChatRtmpUrl$Input} parameters {@link getVideoChatRtmpUrl$Input}
 * @return {RtmpUrl} {@link RtmpUrl}
 */
export type getVideoChatRtmpUrl = (parameters: getVideoChatRtmpUrl$Input) => RtmpUrl;

/**
 * Replaces the current RTMP URL for streaming to the chat; requires creator privileges
 */
export type replaceVideoChatRtmpUrl$Input = {
  readonly _: "replaceVideoChatRtmpUrl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Replaces the current RTMP URL for streaming to the chat; requires creator privileges
 */
export type replaceVideoChatRtmpUrl$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Replaces the current RTMP URL for streaming to the chat; requires creator privileges
 *
 * @param {replaceVideoChatRtmpUrl$Input} parameters {@link replaceVideoChatRtmpUrl$Input}
 * @return {RtmpUrl} {@link RtmpUrl}
 */
export type replaceVideoChatRtmpUrl = (
  parameters: replaceVideoChatRtmpUrl$Input
) => RtmpUrl;

/**
 * Returns information about a group call
 */
export type getGroupCall$Input = {
  readonly _: "getGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Returns information about a group call
 */
export type getGroupCall$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Returns information about a group call
 *
 * @param {getGroupCall$Input} parameters {@link getGroupCall$Input}
 * @return {GroupCall} {@link GroupCall}
 */
export type getGroupCall = (parameters: getGroupCall$Input) => GroupCall;

/**
 * Starts a scheduled group call
 */
export type startScheduledGroupCall$Input = {
  readonly _: "startScheduledGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Starts a scheduled group call
 */
export type startScheduledGroupCall$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Starts a scheduled group call
 *
 * @param {startScheduledGroupCall$Input} parameters {@link startScheduledGroupCall$Input}
 * @return {Ok} {@link Ok}
 */
export type startScheduledGroupCall = (
  parameters: startScheduledGroupCall$Input
) => Ok;

/**
 * Toggles whether the current user will receive a notification when the group call starts; scheduled group calls only
 */
export type toggleGroupCallEnabledStartNotification$Input = {
  readonly _: "toggleGroupCallEnabledStartNotification";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New value of the enabled_start_notification setting
   * @type {Bool$Input} {@link Bool}
   */
  readonly enabled_start_notification?: Bool$Input;
};

/**
 * Toggles whether the current user will receive a notification when the group call starts; scheduled group calls only
 */
export type toggleGroupCallEnabledStartNotification$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New value of the enabled_start_notification setting
   * @type {Bool$Input} {@link Bool}
   */
  readonly enabled_start_notification?: Bool$Input;
};

/**
 * Toggles whether the current user will receive a notification when the group call starts; scheduled group calls only
 *
 * @param {toggleGroupCallEnabledStartNotification$Input} parameters {@link toggleGroupCallEnabledStartNotification$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallEnabledStartNotification = (
  parameters: toggleGroupCallEnabledStartNotification$Input
) => Ok;

/**
 * Joins an active group call. Returns join response payload for tgcalls
 */
export type joinGroupCall$Input = {
  readonly _: "joinGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Identifier of a group call participant, which will be used to join the call; pass null to join as self; video chats only
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input | null;

  /**
   * Caller audio channel synchronization source identifier; received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * Group call join payload; received from tgcalls
   * @type {string} {@link string}
   */
  readonly payload?: string;

  /**
   * Pass true to join the call with muted microphone
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_muted?: Bool$Input;

  /**
   * Pass true if the user's video is enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;

  /**
   * If non-empty, invite hash to be used to join the group call without being muted by administrators
   * @type {string} {@link string}
   */
  readonly invite_hash?: string;
};

/**
 * Joins an active group call. Returns join response payload for tgcalls
 */
export type joinGroupCall$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Identifier of a group call participant, which will be used to join the call; pass null to join as self; video chats only
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input | null;

  /**
   * Caller audio channel synchronization source identifier; received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * Group call join payload; received from tgcalls
   * @type {string} {@link string}
   */
  readonly payload?: string;

  /**
   * Pass true to join the call with muted microphone
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_muted?: Bool$Input;

  /**
   * Pass true if the user's video is enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;

  /**
   * If non-empty, invite hash to be used to join the group call without being muted by administrators
   * @type {string} {@link string}
   */
  readonly invite_hash?: string;
};

/**
 * Joins an active group call. Returns join response payload for tgcalls
 *
 * @param {joinGroupCall$Input} parameters {@link joinGroupCall$Input}
 * @return {Text} {@link Text}
 */
export type joinGroupCall = (parameters: joinGroupCall$Input) => Text;

/**
 * Starts screen sharing in a joined group call. Returns join response payload for tgcalls
 */
export type startGroupCallScreenSharing$Input = {
  readonly _: "startGroupCallScreenSharing";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Screen sharing audio channel synchronization source identifier; received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * Group call join payload; received from tgcalls
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Starts screen sharing in a joined group call. Returns join response payload for tgcalls
 */
export type startGroupCallScreenSharing$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Screen sharing audio channel synchronization source identifier; received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * Group call join payload; received from tgcalls
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Starts screen sharing in a joined group call. Returns join response payload for tgcalls
 *
 * @param {startGroupCallScreenSharing$Input} parameters {@link startGroupCallScreenSharing$Input}
 * @return {Text} {@link Text}
 */
export type startGroupCallScreenSharing = (
  parameters: startGroupCallScreenSharing$Input
) => Text;

/**
 * Pauses or unpauses screen sharing in a joined group call
 */
export type toggleGroupCallScreenSharingIsPaused$Input = {
  readonly _: "toggleGroupCallScreenSharingIsPaused";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true to pause screen sharing; pass false to unpause it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Pauses or unpauses screen sharing in a joined group call
 */
export type toggleGroupCallScreenSharingIsPaused$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true to pause screen sharing; pass false to unpause it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Pauses or unpauses screen sharing in a joined group call
 *
 * @param {toggleGroupCallScreenSharingIsPaused$Input} parameters {@link toggleGroupCallScreenSharingIsPaused$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallScreenSharingIsPaused = (
  parameters: toggleGroupCallScreenSharingIsPaused$Input
) => Ok;

/**
 * Ends screen sharing in a joined group call
 */
export type endGroupCallScreenSharing$Input = {
  readonly _: "endGroupCallScreenSharing";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends screen sharing in a joined group call
 */
export type endGroupCallScreenSharing$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends screen sharing in a joined group call
 *
 * @param {endGroupCallScreenSharing$Input} parameters {@link endGroupCallScreenSharing$Input}
 * @return {Ok} {@link Ok}
 */
export type endGroupCallScreenSharing = (
  parameters: endGroupCallScreenSharing$Input
) => Ok;

/**
 * Sets group call title. Requires groupCall.can_be_managed group call flag
 */
export type setGroupCallTitle$Input = {
  readonly _: "setGroupCallTitle";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New group call title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Sets group call title. Requires groupCall.can_be_managed group call flag
 */
export type setGroupCallTitle$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New group call title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Sets group call title. Requires groupCall.can_be_managed group call flag
 *
 * @param {setGroupCallTitle$Input} parameters {@link setGroupCallTitle$Input}
 * @return {Ok} {@link Ok}
 */
export type setGroupCallTitle = (parameters: setGroupCallTitle$Input) => Ok;

/**
 * Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
 */
export type toggleGroupCallMuteNewParticipants$Input = {
  readonly _: "toggleGroupCallMuteNewParticipants";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New value of the mute_new_participants setting
   * @type {Bool$Input} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;
};

/**
 * Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
 */
export type toggleGroupCallMuteNewParticipants$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New value of the mute_new_participants setting
   * @type {Bool$Input} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;
};

/**
 * Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
 *
 * @param {toggleGroupCallMuteNewParticipants$Input} parameters {@link toggleGroupCallMuteNewParticipants$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallMuteNewParticipants = (
  parameters: toggleGroupCallMuteNewParticipants$Input
) => Ok;

/**
 * Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants for video chats
 */
export type inviteGroupCallParticipants$Input = {
  readonly _: "inviteGroupCallParticipants";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * User identifiers. At most 10 users can be invited simultaneously
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants for video chats
 */
export type inviteGroupCallParticipants$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * User identifiers. At most 10 users can be invited simultaneously
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Invites users to an active group call. Sends a service message of type messageInviteVideoChatParticipants for video chats
 *
 * @param {inviteGroupCallParticipants$Input} parameters {@link inviteGroupCallParticipants$Input}
 * @return {Ok} {@link Ok}
 */
export type inviteGroupCallParticipants = (
  parameters: inviteGroupCallParticipants$Input
) => Ok;

/**
 * Returns invite link to a video chat in a public chat
 */
export type getGroupCallInviteLink$Input = {
  readonly _: "getGroupCallInviteLink";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_self_unmute?: Bool$Input;
};

/**
 * Returns invite link to a video chat in a public chat
 */
export type getGroupCallInviteLink$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_self_unmute?: Bool$Input;
};

/**
 * Returns invite link to a video chat in a public chat
 *
 * @param {getGroupCallInviteLink$Input} parameters {@link getGroupCallInviteLink$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getGroupCallInviteLink = (
  parameters: getGroupCallInviteLink$Input
) => HttpUrl;

/**
 * Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
 */
export type revokeGroupCallInviteLink$Input = {
  readonly _: "revokeGroupCallInviteLink";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
 */
export type revokeGroupCallInviteLink$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
 *
 * @param {revokeGroupCallInviteLink$Input} parameters {@link revokeGroupCallInviteLink$Input}
 * @return {Ok} {@link Ok}
 */
export type revokeGroupCallInviteLink = (
  parameters: revokeGroupCallInviteLink$Input
) => Ok;

/**
 * Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
 */
export type startGroupCallRecording$Input = {
  readonly _: "startGroupCallRecording";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Group call recording title; 0-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Pass true to record a video file instead of an audio file
   * @type {Bool$Input} {@link Bool}
   */
  readonly record_video?: Bool$Input;

  /**
   * Pass true to use portrait orientation for video instead of landscape one
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_portrait_orientation?: Bool$Input;
};

/**
 * Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
 */
export type startGroupCallRecording$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Group call recording title; 0-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Pass true to record a video file instead of an audio file
   * @type {Bool$Input} {@link Bool}
   */
  readonly record_video?: Bool$Input;

  /**
   * Pass true to use portrait orientation for video instead of landscape one
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_portrait_orientation?: Bool$Input;
};

/**
 * Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
 *
 * @param {startGroupCallRecording$Input} parameters {@link startGroupCallRecording$Input}
 * @return {Ok} {@link Ok}
 */
export type startGroupCallRecording = (
  parameters: startGroupCallRecording$Input
) => Ok;

/**
 * Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
 */
export type endGroupCallRecording$Input = {
  readonly _: "endGroupCallRecording";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
 */
export type endGroupCallRecording$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
 *
 * @param {endGroupCallRecording$Input} parameters {@link endGroupCallRecording$Input}
 * @return {Ok} {@link Ok}
 */
export type endGroupCallRecording = (parameters: endGroupCallRecording$Input) => Ok;

/**
 * Toggles whether current user's video is paused
 */
export type toggleGroupCallIsMyVideoPaused$Input = {
  readonly _: "toggleGroupCallIsMyVideoPaused";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the current user's video is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_paused?: Bool$Input;
};

/**
 * Toggles whether current user's video is paused
 */
export type toggleGroupCallIsMyVideoPaused$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the current user's video is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_paused?: Bool$Input;
};

/**
 * Toggles whether current user's video is paused
 *
 * @param {toggleGroupCallIsMyVideoPaused$Input} parameters {@link toggleGroupCallIsMyVideoPaused$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallIsMyVideoPaused = (
  parameters: toggleGroupCallIsMyVideoPaused$Input
) => Ok;

/**
 * Toggles whether current user's video is enabled
 */
export type toggleGroupCallIsMyVideoEnabled$Input = {
  readonly _: "toggleGroupCallIsMyVideoEnabled";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the current user's video is enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;
};

/**
 * Toggles whether current user's video is enabled
 */
export type toggleGroupCallIsMyVideoEnabled$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the current user's video is enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;
};

/**
 * Toggles whether current user's video is enabled
 *
 * @param {toggleGroupCallIsMyVideoEnabled$Input} parameters {@link toggleGroupCallIsMyVideoEnabled$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallIsMyVideoEnabled = (
  parameters: toggleGroupCallIsMyVideoEnabled$Input
) => Ok;

/**
 * Informs TDLib that speaking state of a participant of an active group has changed
 */
export type setGroupCallParticipantIsSpeaking$Input = {
  readonly _: "setGroupCallParticipantIsSpeaking";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Group call participant's synchronization audio source identifier, or 0 for the current user
   * @type {int32} {@link int32}
   */
  readonly audio_source?: int32;

  /**
   * Pass true if the user is speaking
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;
};

/**
 * Informs TDLib that speaking state of a participant of an active group has changed
 */
export type setGroupCallParticipantIsSpeaking$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Group call participant's synchronization audio source identifier, or 0 for the current user
   * @type {int32} {@link int32}
   */
  readonly audio_source?: int32;

  /**
   * Pass true if the user is speaking
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;
};

/**
 * Informs TDLib that speaking state of a participant of an active group has changed
 *
 * @param {setGroupCallParticipantIsSpeaking$Input} parameters {@link setGroupCallParticipantIsSpeaking$Input}
 * @return {Ok} {@link Ok}
 */
export type setGroupCallParticipantIsSpeaking = (
  parameters: setGroupCallParticipantIsSpeaking$Input
) => Ok;

/**
 * Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
 */
export type toggleGroupCallParticipantIsMuted$Input = {
  readonly _: "toggleGroupCallParticipantIsMuted";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Pass true to mute the user; pass false to unmute them
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_muted?: Bool$Input;
};

/**
 * Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
 */
export type toggleGroupCallParticipantIsMuted$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Pass true to mute the user; pass false to unmute them
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_muted?: Bool$Input;
};

/**
 * Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
 *
 * @param {toggleGroupCallParticipantIsMuted$Input} parameters {@link toggleGroupCallParticipantIsMuted$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallParticipantIsMuted = (
  parameters: toggleGroupCallParticipantIsMuted$Input
) => Ok;

/**
 * Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
 */
export type setGroupCallParticipantVolumeLevel$Input = {
  readonly _: "setGroupCallParticipantVolumeLevel";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;
};

/**
 * Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
 */
export type setGroupCallParticipantVolumeLevel$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;
};

/**
 * Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
 *
 * @param {setGroupCallParticipantVolumeLevel$Input} parameters {@link setGroupCallParticipantVolumeLevel$Input}
 * @return {Ok} {@link Ok}
 */
export type setGroupCallParticipantVolumeLevel = (
  parameters: setGroupCallParticipantVolumeLevel$Input
) => Ok;

/**
 * Toggles whether a group call participant hand is rased
 */
export type toggleGroupCallParticipantIsHandRaised$Input = {
  readonly _: "toggleGroupCallParticipantIsHandRaised";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_hand_raised?: Bool$Input;
};

/**
 * Toggles whether a group call participant hand is rased
 */
export type toggleGroupCallParticipantIsHandRaised$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_hand_raised?: Bool$Input;
};

/**
 * Toggles whether a group call participant hand is rased
 *
 * @param {toggleGroupCallParticipantIsHandRaised$Input} parameters {@link toggleGroupCallParticipantIsHandRaised$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallParticipantIsHandRaised = (
  parameters: toggleGroupCallParticipantIsHandRaised$Input
) => Ok;

/**
 * Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
 */
export type loadGroupCallParticipants$Input = {
  readonly _: "loadGroupCallParticipants";

  /**
   * Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * The maximum number of participants to load; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
 */
export type loadGroupCallParticipants$DirectInput = {
  /**
   * Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * The maximum number of participants to load; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
 *
 * @param {loadGroupCallParticipants$Input} parameters {@link loadGroupCallParticipants$Input}
 * @return {Ok} {@link Ok}
 */
export type loadGroupCallParticipants = (
  parameters: loadGroupCallParticipants$Input
) => Ok;

/**
 * Leaves a group call
 */
export type leaveGroupCall$Input = {
  readonly _: "leaveGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Leaves a group call
 */
export type leaveGroupCall$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Leaves a group call
 *
 * @param {leaveGroupCall$Input} parameters {@link leaveGroupCall$Input}
 * @return {Ok} {@link Ok}
 */
export type leaveGroupCall = (parameters: leaveGroupCall$Input) => Ok;

/**
 * Ends a group call. Requires groupCall.can_be_managed
 */
export type endGroupCall$Input = {
  readonly _: "endGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends a group call. Requires groupCall.can_be_managed
 */
export type endGroupCall$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends a group call. Requires groupCall.can_be_managed
 *
 * @param {endGroupCall$Input} parameters {@link endGroupCall$Input}
 * @return {Ok} {@link Ok}
 */
export type endGroupCall = (parameters: endGroupCall$Input) => Ok;

/**
 * Returns information about available group call streams
 */
export type getGroupCallStreams$Input = {
  readonly _: "getGroupCallStreams";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Returns information about available group call streams
 */
export type getGroupCallStreams$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Returns information about available group call streams
 *
 * @param {getGroupCallStreams$Input} parameters {@link getGroupCallStreams$Input}
 * @return {GroupCallStreams} {@link GroupCallStreams}
 */
export type getGroupCallStreams = (
  parameters: getGroupCallStreams$Input
) => GroupCallStreams;

/**
 * Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
 */
export type getGroupCallStreamSegment$Input = {
  readonly _: "getGroupCallStreamSegment";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Point in time when the stream segment begins; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  readonly time_offset?: int53;

  /**
   * Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Identifier of an audio/video channel to get as received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly channel_id?: int32;

  /**
   * Video quality as received from tgcalls; pass null to get the worst available quality
   * @type {GroupCallVideoQuality$Input} {@link GroupCallVideoQuality}
   */
  readonly video_quality?: GroupCallVideoQuality$Input | null;
};

/**
 * Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
 */
export type getGroupCallStreamSegment$DirectInput = {
  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Point in time when the stream segment begins; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  readonly time_offset?: int53;

  /**
   * Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Identifier of an audio/video channel to get as received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly channel_id?: int32;

  /**
   * Video quality as received from tgcalls; pass null to get the worst available quality
   * @type {GroupCallVideoQuality$Input} {@link GroupCallVideoQuality}
   */
  readonly video_quality?: GroupCallVideoQuality$Input | null;
};

/**
 * Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
 *
 * @param {getGroupCallStreamSegment$Input} parameters {@link getGroupCallStreamSegment$Input}
 * @return {FilePart} {@link FilePart}
 */
export type getGroupCallStreamSegment = (
  parameters: getGroupCallStreamSegment$Input
) => FilePart;

/**
 * Changes the block list of a message sender. Currently, only users and supergroup chats can be blocked
 */
export type setMessageSenderBlockList$Input = {
  readonly _: "setMessageSenderBlockList";

  /**
   * Identifier of a message sender to block/unblock
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * New block list for the message sender; pass null to unblock the message sender
   * @type {BlockList$Input} {@link BlockList}
   */
  readonly block_list?: BlockList$Input | null;
};

/**
 * Changes the block list of a message sender. Currently, only users and supergroup chats can be blocked
 */
export type setMessageSenderBlockList$DirectInput = {
  /**
   * Identifier of a message sender to block/unblock
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * New block list for the message sender; pass null to unblock the message sender
   * @type {BlockList$Input} {@link BlockList}
   */
  readonly block_list?: BlockList$Input | null;
};

/**
 * Changes the block list of a message sender. Currently, only users and supergroup chats can be blocked
 *
 * @param {setMessageSenderBlockList$Input} parameters {@link setMessageSenderBlockList$Input}
 * @return {Ok} {@link Ok}
 */
export type setMessageSenderBlockList = (
  parameters: setMessageSenderBlockList$Input
) => Ok;

/**
 * Blocks an original sender of a message in the Replies chat
 */
export type blockMessageSenderFromReplies$Input = {
  readonly _: "blockMessageSenderFromReplies";

  /**
   * The identifier of an incoming message in the Replies chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to delete the message
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_message?: Bool$Input;

  /**
   * Pass true to delete all messages from the same sender
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_all_messages?: Bool$Input;

  /**
   * Pass true to report the sender to the Telegram moderators
   * @type {Bool$Input} {@link Bool}
   */
  readonly report_spam?: Bool$Input;
};

/**
 * Blocks an original sender of a message in the Replies chat
 */
export type blockMessageSenderFromReplies$DirectInput = {
  /**
   * The identifier of an incoming message in the Replies chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to delete the message
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_message?: Bool$Input;

  /**
   * Pass true to delete all messages from the same sender
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_all_messages?: Bool$Input;

  /**
   * Pass true to report the sender to the Telegram moderators
   * @type {Bool$Input} {@link Bool}
   */
  readonly report_spam?: Bool$Input;
};

/**
 * Blocks an original sender of a message in the Replies chat
 *
 * @param {blockMessageSenderFromReplies$Input} parameters {@link blockMessageSenderFromReplies$Input}
 * @return {Ok} {@link Ok}
 */
export type blockMessageSenderFromReplies = (
  parameters: blockMessageSenderFromReplies$Input
) => Ok;

/**
 * Returns users and chats that were blocked by the current user
 */
export type getBlockedMessageSenders$Input = {
  readonly _: "getBlockedMessageSenders";

  /**
   * Block list from which to return users
   * @type {BlockList$Input} {@link BlockList}
   */
  readonly block_list?: BlockList$Input;

  /**
   * Number of users and chats to skip in the result; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users and chats to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns users and chats that were blocked by the current user
 */
export type getBlockedMessageSenders$DirectInput = {
  /**
   * Block list from which to return users
   * @type {BlockList$Input} {@link BlockList}
   */
  readonly block_list?: BlockList$Input;

  /**
   * Number of users and chats to skip in the result; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users and chats to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns users and chats that were blocked by the current user
 *
 * @param {getBlockedMessageSenders$Input} parameters {@link getBlockedMessageSenders$Input}
 * @return {MessageSenders} {@link MessageSenders}
 */
export type getBlockedMessageSenders = (
  parameters: getBlockedMessageSenders$Input
) => MessageSenders;

/**
 * Adds a user to the contact list or edits an existing contact by their user identifier
 */
export type addContact$Input = {
  readonly _: "addContact";

  /**
   * The contact to add or edit; phone number may be empty and needs to be specified only if known, vCard is ignored
   * @type {contact$Input} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * Pass true to share the current user's phone number with the new contact. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed.
   *
   * - Use the field userFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number
   * @type {Bool$Input} {@link Bool}
   */
  readonly share_phone_number?: Bool$Input;
};

/**
 * Adds a user to the contact list or edits an existing contact by their user identifier
 */
export type addContact$DirectInput = {
  /**
   * The contact to add or edit; phone number may be empty and needs to be specified only if known, vCard is ignored
   * @type {contact$Input} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * Pass true to share the current user's phone number with the new contact. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed.
   *
   * - Use the field userFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number
   * @type {Bool$Input} {@link Bool}
   */
  readonly share_phone_number?: Bool$Input;
};

/**
 * Adds a user to the contact list or edits an existing contact by their user identifier
 *
 * @param {addContact$Input} parameters {@link addContact$Input}
 * @return {Ok} {@link Ok}
 */
export type addContact = (parameters: addContact$Input) => Ok;

/**
 * Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
 */
export type importContacts$Input = {
  readonly _: "importContacts";

  /**
   * The list of contacts to import or edit; contacts' vCard are ignored and are not imported
   * @type {vector$Input<contact$Input>} {@link vector<contact>}
   */
  readonly contacts?: vector$Input<contact$Input>;
};

/**
 * Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
 */
export type importContacts$DirectInput = {
  /**
   * The list of contacts to import or edit; contacts' vCard are ignored and are not imported
   * @type {vector$Input<contact$Input>} {@link vector<contact>}
   */
  readonly contacts?: vector$Input<contact$Input>;
};

/**
 * Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
 *
 * @param {importContacts$Input} parameters {@link importContacts$Input}
 * @return {ImportedContacts} {@link ImportedContacts}
 */
export type importContacts = (parameters: importContacts$Input) => ImportedContacts;

/**
 * Returns all contacts of the user
 */
export type getContacts$Input = {
  readonly _: "getContacts";
};

/**
 * Returns all contacts of the user
 */
export type getContacts$DirectInput = {};

/**
 * Returns all contacts of the user
 *
 * @param {getContacts$Input} parameters {@link getContacts$Input}
 * @return {Users} {@link Users}
 */
export type getContacts = (parameters: getContacts$Input) => Users;

/**
 * Searches for the specified query in the first names, last names and usernames of the known user contacts
 */
export type searchContacts$Input = {
  readonly _: "searchContacts";

  /**
   * Query to search for; may be empty to return all contacts
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of users to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the first names, last names and usernames of the known user contacts
 */
export type searchContacts$DirectInput = {
  /**
   * Query to search for; may be empty to return all contacts
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of users to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the first names, last names and usernames of the known user contacts
 *
 * @param {searchContacts$Input} parameters {@link searchContacts$Input}
 * @return {Users} {@link Users}
 */
export type searchContacts = (parameters: searchContacts$Input) => Users;

/**
 * Removes users from the contact list
 */
export type removeContacts$Input = {
  readonly _: "removeContacts";

  /**
   * Identifiers of users to be deleted
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Removes users from the contact list
 */
export type removeContacts$DirectInput = {
  /**
   * Identifiers of users to be deleted
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Removes users from the contact list
 *
 * @param {removeContacts$Input} parameters {@link removeContacts$Input}
 * @return {Ok} {@link Ok}
 */
export type removeContacts = (parameters: removeContacts$Input) => Ok;

/**
 * Returns the total number of imported contacts
 */
export type getImportedContactCount$Input = {
  readonly _: "getImportedContactCount";
};

/**
 * Returns the total number of imported contacts
 */
export type getImportedContactCount$DirectInput = {};

/**
 * Returns the total number of imported contacts
 *
 * @param {getImportedContactCount$Input} parameters {@link getImportedContactCount$Input}
 * @return {Count} {@link Count}
 */
export type getImportedContactCount = (
  parameters: getImportedContactCount$Input
) => Count;

/**
 * Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
 *
 * - Query result depends on the result of the previous query, so only one query is possible at the same time
 */
export type changeImportedContacts$Input = {
  readonly _: "changeImportedContacts";

  /**
   * The new list of contacts, contact's vCard are ignored and are not imported
   * @type {vector$Input<contact$Input>} {@link vector<contact>}
   */
  readonly contacts?: vector$Input<contact$Input>;
};

/**
 * Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
 *
 * - Query result depends on the result of the previous query, so only one query is possible at the same time
 */
export type changeImportedContacts$DirectInput = {
  /**
   * The new list of contacts, contact's vCard are ignored and are not imported
   * @type {vector$Input<contact$Input>} {@link vector<contact>}
   */
  readonly contacts?: vector$Input<contact$Input>;
};

/**
 * Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
 *
 * - Query result depends on the result of the previous query, so only one query is possible at the same time
 *
 * @param {changeImportedContacts$Input} parameters {@link changeImportedContacts$Input}
 * @return {ImportedContacts} {@link ImportedContacts}
 */
export type changeImportedContacts = (
  parameters: changeImportedContacts$Input
) => ImportedContacts;

/**
 * Clears all imported contacts, contact list remains unchanged
 */
export type clearImportedContacts$Input = {
  readonly _: "clearImportedContacts";
};

/**
 * Clears all imported contacts, contact list remains unchanged
 */
export type clearImportedContacts$DirectInput = {};

/**
 * Clears all imported contacts, contact list remains unchanged
 *
 * @param {clearImportedContacts$Input} parameters {@link clearImportedContacts$Input}
 * @return {Ok} {@link Ok}
 */
export type clearImportedContacts = (parameters: clearImportedContacts$Input) => Ok;

/**
 * Changes the list of close friends of the current user
 */
export type setCloseFriends$Input = {
  readonly _: "setCloseFriends";

  /**
   * User identifiers of close friends; the users must be contacts of the current user
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Changes the list of close friends of the current user
 */
export type setCloseFriends$DirectInput = {
  /**
   * User identifiers of close friends; the users must be contacts of the current user
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Changes the list of close friends of the current user
 *
 * @param {setCloseFriends$Input} parameters {@link setCloseFriends$Input}
 * @return {Ok} {@link Ok}
 */
export type setCloseFriends = (parameters: setCloseFriends$Input) => Ok;

/**
 * Returns all close friends of the current user
 */
export type getCloseFriends$Input = {
  readonly _: "getCloseFriends";
};

/**
 * Returns all close friends of the current user
 */
export type getCloseFriends$DirectInput = {};

/**
 * Returns all close friends of the current user
 *
 * @param {getCloseFriends$Input} parameters {@link getCloseFriends$Input}
 * @return {Users} {@link Users}
 */
export type getCloseFriends = (parameters: getCloseFriends$Input) => Users;

/**
 * Changes a personal profile photo of a contact user
 */
export type setUserPersonalProfilePhoto$Input = {
  readonly _: "setUserPersonalProfilePhoto";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Profile photo to set; pass null to delete the photo; inputChatPhotoPrevious isn't supported in this function
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input | null;
};

/**
 * Changes a personal profile photo of a contact user
 */
export type setUserPersonalProfilePhoto$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Profile photo to set; pass null to delete the photo; inputChatPhotoPrevious isn't supported in this function
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input | null;
};

/**
 * Changes a personal profile photo of a contact user
 *
 * @param {setUserPersonalProfilePhoto$Input} parameters {@link setUserPersonalProfilePhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type setUserPersonalProfilePhoto = (
  parameters: setUserPersonalProfilePhoto$Input
) => Ok;

/**
 * Suggests a profile photo to another regular user with common messages
 */
export type suggestUserProfilePhoto$Input = {
  readonly _: "suggestUserProfilePhoto";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Profile photo to suggest; inputChatPhotoPrevious isn't supported in this function
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input;
};

/**
 * Suggests a profile photo to another regular user with common messages
 */
export type suggestUserProfilePhoto$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Profile photo to suggest; inputChatPhotoPrevious isn't supported in this function
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input;
};

/**
 * Suggests a profile photo to another regular user with common messages
 *
 * @param {suggestUserProfilePhoto$Input} parameters {@link suggestUserProfilePhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type suggestUserProfilePhoto = (
  parameters: suggestUserProfilePhoto$Input
) => Ok;

/**
 * Searches a user by their phone number. Returns a 404 error if the user can't be found
 */
export type searchUserByPhoneNumber$Input = {
  readonly _: "searchUserByPhoneNumber";

  /**
   * Phone number to search for
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * Searches a user by their phone number. Returns a 404 error if the user can't be found
 */
export type searchUserByPhoneNumber$DirectInput = {
  /**
   * Phone number to search for
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * Searches a user by their phone number. Returns a 404 error if the user can't be found
 *
 * @param {searchUserByPhoneNumber$Input} parameters {@link searchUserByPhoneNumber$Input}
 * @return {User} {@link User}
 */
export type searchUserByPhoneNumber = (
  parameters: searchUserByPhoneNumber$Input
) => User;

/**
 * Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
 */
export type sharePhoneNumber$Input = {
  readonly _: "sharePhoneNumber";

  /**
   * Identifier of the user with whom to share the phone number. The user must be a mutual contact
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
 */
export type sharePhoneNumber$DirectInput = {
  /**
   * Identifier of the user with whom to share the phone number. The user must be a mutual contact
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
 *
 * @param {sharePhoneNumber$Input} parameters {@link sharePhoneNumber$Input}
 * @return {Ok} {@link Ok}
 */
export type sharePhoneNumber = (parameters: sharePhoneNumber$Input) => Ok;

/**
 * Returns the profile photos of a user. Personal and public photo aren't returned
 */
export type getUserProfilePhotos$Input = {
  readonly _: "getUserProfilePhotos";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The number of photos to skip; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of photos to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the profile photos of a user. Personal and public photo aren't returned
 */
export type getUserProfilePhotos$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The number of photos to skip; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of photos to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the profile photos of a user. Personal and public photo aren't returned
 *
 * @param {getUserProfilePhotos$Input} parameters {@link getUserProfilePhotos$Input}
 * @return {ChatPhotos} {@link ChatPhotos}
 */
export type getUserProfilePhotos = (
  parameters: getUserProfilePhotos$Input
) => ChatPhotos;

/**
 * Returns stickers from the installed sticker sets that correspond to any of the given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned
 */
export type getStickers$Input = {
  readonly _: "getStickers";

  /**
   * Type of the stickers to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Search query; a space-separated list of emoji or a keyword prefix. If empty, returns all known installed stickers
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of stickers to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Chat identifier for which to return stickers. Available custom emoji stickers may be different for different chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns stickers from the installed sticker sets that correspond to any of the given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned
 */
export type getStickers$DirectInput = {
  /**
   * Type of the stickers to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Search query; a space-separated list of emoji or a keyword prefix. If empty, returns all known installed stickers
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of stickers to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Chat identifier for which to return stickers. Available custom emoji stickers may be different for different chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns stickers from the installed sticker sets that correspond to any of the given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned
 *
 * @param {getStickers$Input} parameters {@link getStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getStickers = (parameters: getStickers$Input) => Stickers;

/**
 * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type, query, 1000000, chat_id)
 */
export type getAllStickerEmojis$Input = {
  readonly _: "getAllStickerEmojis";

  /**
   * Type of the stickers to search for
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Search query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Chat identifier for which to find stickers
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true if only main emoji for each found sticker must be included in the result
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_only_main_emoji?: Bool$Input;
};

/**
 * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type, query, 1000000, chat_id)
 */
export type getAllStickerEmojis$DirectInput = {
  /**
   * Type of the stickers to search for
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Search query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Chat identifier for which to find stickers
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true if only main emoji for each found sticker must be included in the result
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_only_main_emoji?: Bool$Input;
};

/**
 * Returns unique emoji that correspond to stickers to be found by the getStickers(sticker_type, query, 1000000, chat_id)
 *
 * @param {getAllStickerEmojis$Input} parameters {@link getAllStickerEmojis$Input}
 * @return {Emojis} {@link Emojis}
 */
export type getAllStickerEmojis = (parameters: getAllStickerEmojis$Input) => Emojis;

/**
 * Searches for stickers from public sticker sets that correspond to any of the given emoji
 */
export type searchStickers$Input = {
  readonly _: "searchStickers";

  /**
   * Type of the stickers to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Space-separated list of emoji to search for; must be non-empty
   * @type {string} {@link string}
   */
  readonly emojis?: string;

  /**
   * The maximum number of stickers to be returned; 0-100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for stickers from public sticker sets that correspond to any of the given emoji
 */
export type searchStickers$DirectInput = {
  /**
   * Type of the stickers to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Space-separated list of emoji to search for; must be non-empty
   * @type {string} {@link string}
   */
  readonly emojis?: string;

  /**
   * The maximum number of stickers to be returned; 0-100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for stickers from public sticker sets that correspond to any of the given emoji
 *
 * @param {searchStickers$Input} parameters {@link searchStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type searchStickers = (parameters: searchStickers$Input) => Stickers;

/**
 * Returns premium stickers from regular sticker sets
 */
export type getPremiumStickers$Input = {
  readonly _: "getPremiumStickers";

  /**
   * The maximum number of stickers to be returned; 0-100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns premium stickers from regular sticker sets
 */
export type getPremiumStickers$DirectInput = {
  /**
   * The maximum number of stickers to be returned; 0-100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns premium stickers from regular sticker sets
 *
 * @param {getPremiumStickers$Input} parameters {@link getPremiumStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getPremiumStickers = (parameters: getPremiumStickers$Input) => Stickers;

/**
 * Returns a list of installed sticker sets
 */
export type getInstalledStickerSets$Input = {
  readonly _: "getInstalledStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;
};

/**
 * Returns a list of installed sticker sets
 */
export type getInstalledStickerSets$DirectInput = {
  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;
};

/**
 * Returns a list of installed sticker sets
 *
 * @param {getInstalledStickerSets$Input} parameters {@link getInstalledStickerSets$Input}
 * @return {StickerSets} {@link StickerSets}
 */
export type getInstalledStickerSets = (
  parameters: getInstalledStickerSets$Input
) => StickerSets;

/**
 * Returns a list of archived sticker sets
 */
export type getArchivedStickerSets$Input = {
  readonly _: "getArchivedStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Identifier of the sticker set from which to return the result
   * @type {int64$Input} {@link int64}
   */
  readonly offset_sticker_set_id?: int64$Input;

  /**
   * The maximum number of sticker sets to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of archived sticker sets
 */
export type getArchivedStickerSets$DirectInput = {
  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Identifier of the sticker set from which to return the result
   * @type {int64$Input} {@link int64}
   */
  readonly offset_sticker_set_id?: int64$Input;

  /**
   * The maximum number of sticker sets to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of archived sticker sets
 *
 * @param {getArchivedStickerSets$Input} parameters {@link getArchivedStickerSets$Input}
 * @return {StickerSets} {@link StickerSets}
 */
export type getArchivedStickerSets = (
  parameters: getArchivedStickerSets$Input
) => StickerSets;

/**
 * Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
 */
export type getTrendingStickerSets$Input = {
  readonly _: "getTrendingStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The offset from which to return the sticker sets; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of sticker sets to be returned; up to 100. For optimal performance, the number of returned sticker sets is chosen by TDLib and can be smaller than the specified limit, even if the end of the list has not been reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
 */
export type getTrendingStickerSets$DirectInput = {
  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The offset from which to return the sticker sets; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of sticker sets to be returned; up to 100. For optimal performance, the number of returned sticker sets is chosen by TDLib and can be smaller than the specified limit, even if the end of the list has not been reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
 *
 * @param {getTrendingStickerSets$Input} parameters {@link getTrendingStickerSets$Input}
 * @return {TrendingStickerSets} {@link TrendingStickerSets}
 */
export type getTrendingStickerSets = (
  parameters: getTrendingStickerSets$Input
) => TrendingStickerSets;

/**
 * Returns a list of sticker sets attached to a file, including regular, mask, and emoji sticker sets. Currently, only animations, photos, and videos can have attached sticker sets
 */
export type getAttachedStickerSets$Input = {
  readonly _: "getAttachedStickerSets";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Returns a list of sticker sets attached to a file, including regular, mask, and emoji sticker sets. Currently, only animations, photos, and videos can have attached sticker sets
 */
export type getAttachedStickerSets$DirectInput = {
  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Returns a list of sticker sets attached to a file, including regular, mask, and emoji sticker sets. Currently, only animations, photos, and videos can have attached sticker sets
 *
 * @param {getAttachedStickerSets$Input} parameters {@link getAttachedStickerSets$Input}
 * @return {StickerSets} {@link StickerSets}
 */
export type getAttachedStickerSets = (
  parameters: getAttachedStickerSets$Input
) => StickerSets;

/**
 * Returns information about a sticker set by its identifier
 */
export type getStickerSet$Input = {
  readonly _: "getStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64$Input} {@link int64}
   */
  readonly set_id?: int64$Input;
};

/**
 * Returns information about a sticker set by its identifier
 */
export type getStickerSet$DirectInput = {
  /**
   * Identifier of the sticker set
   * @type {int64$Input} {@link int64}
   */
  readonly set_id?: int64$Input;
};

/**
 * Returns information about a sticker set by its identifier
 *
 * @param {getStickerSet$Input} parameters {@link getStickerSet$Input}
 * @return {StickerSet} {@link StickerSet}
 */
export type getStickerSet = (parameters: getStickerSet$Input) => StickerSet;

/**
 * Searches for a sticker set by its name
 */
export type searchStickerSet$Input = {
  readonly _: "searchStickerSet";

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Searches for a sticker set by its name
 */
export type searchStickerSet$DirectInput = {
  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Searches for a sticker set by its name
 *
 * @param {searchStickerSet$Input} parameters {@link searchStickerSet$Input}
 * @return {StickerSet} {@link StickerSet}
 */
export type searchStickerSet = (parameters: searchStickerSet$Input) => StickerSet;

/**
 * Searches for installed sticker sets by looking for specified query in their title and name
 */
export type searchInstalledStickerSets$Input = {
  readonly _: "searchInstalledStickerSets";

  /**
   * Type of the sticker sets to search for
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of sticker sets to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for installed sticker sets by looking for specified query in their title and name
 */
export type searchInstalledStickerSets$DirectInput = {
  /**
   * Type of the sticker sets to search for
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of sticker sets to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for installed sticker sets by looking for specified query in their title and name
 *
 * @param {searchInstalledStickerSets$Input} parameters {@link searchInstalledStickerSets$Input}
 * @return {StickerSets} {@link StickerSets}
 */
export type searchInstalledStickerSets = (
  parameters: searchInstalledStickerSets$Input
) => StickerSets;

/**
 * Searches for sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
 */
export type searchStickerSets$Input = {
  readonly _: "searchStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Searches for sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
 */
export type searchStickerSets$DirectInput = {
  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Searches for sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
 *
 * @param {searchStickerSets$Input} parameters {@link searchStickerSets$Input}
 * @return {StickerSets} {@link StickerSets}
 */
export type searchStickerSets = (parameters: searchStickerSets$Input) => StickerSets;

/**
 * Installs/uninstalls or activates/archives a sticker set
 */
export type changeStickerSet$Input = {
  readonly _: "changeStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64$Input} {@link int64}
   */
  readonly set_id?: int64$Input;

  /**
   * The new value of is_installed
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * The new value of is_archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_archived?: Bool$Input;
};

/**
 * Installs/uninstalls or activates/archives a sticker set
 */
export type changeStickerSet$DirectInput = {
  /**
   * Identifier of the sticker set
   * @type {int64$Input} {@link int64}
   */
  readonly set_id?: int64$Input;

  /**
   * The new value of is_installed
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * The new value of is_archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_archived?: Bool$Input;
};

/**
 * Installs/uninstalls or activates/archives a sticker set
 *
 * @param {changeStickerSet$Input} parameters {@link changeStickerSet$Input}
 * @return {Ok} {@link Ok}
 */
export type changeStickerSet = (parameters: changeStickerSet$Input) => Ok;

/**
 * Informs the server that some trending sticker sets have been viewed by the user
 */
export type viewTrendingStickerSets$Input = {
  readonly _: "viewTrendingStickerSets";

  /**
   * Identifiers of viewed trending sticker sets
   * @type {vector$Input<int64$Input>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64$Input>;
};

/**
 * Informs the server that some trending sticker sets have been viewed by the user
 */
export type viewTrendingStickerSets$DirectInput = {
  /**
   * Identifiers of viewed trending sticker sets
   * @type {vector$Input<int64$Input>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64$Input>;
};

/**
 * Informs the server that some trending sticker sets have been viewed by the user
 *
 * @param {viewTrendingStickerSets$Input} parameters {@link viewTrendingStickerSets$Input}
 * @return {Ok} {@link Ok}
 */
export type viewTrendingStickerSets = (
  parameters: viewTrendingStickerSets$Input
) => Ok;

/**
 * Changes the order of installed sticker sets
 */
export type reorderInstalledStickerSets$Input = {
  readonly _: "reorderInstalledStickerSets";

  /**
   * Type of the sticker sets to reorder
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Identifiers of installed sticker sets in the new correct order
   * @type {vector$Input<int64$Input>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64$Input>;
};

/**
 * Changes the order of installed sticker sets
 */
export type reorderInstalledStickerSets$DirectInput = {
  /**
   * Type of the sticker sets to reorder
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Identifiers of installed sticker sets in the new correct order
   * @type {vector$Input<int64$Input>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64$Input>;
};

/**
 * Changes the order of installed sticker sets
 *
 * @param {reorderInstalledStickerSets$Input} parameters {@link reorderInstalledStickerSets$Input}
 * @return {Ok} {@link Ok}
 */
export type reorderInstalledStickerSets = (
  parameters: reorderInstalledStickerSets$Input
) => Ok;

/**
 * Returns a list of recently used stickers
 */
export type getRecentStickers$Input = {
  readonly _: "getRecentStickers";

  /**
   * Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;
};

/**
 * Returns a list of recently used stickers
 */
export type getRecentStickers$DirectInput = {
  /**
   * Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;
};

/**
 * Returns a list of recently used stickers
 *
 * @param {getRecentStickers$Input} parameters {@link getRecentStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getRecentStickers = (parameters: getRecentStickers$Input) => Stickers;

/**
 * Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
 *
 * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to recent stickers
 */
export type addRecentSticker$Input = {
  readonly _: "addRecentSticker";

  /**
   * Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * Sticker file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
 *
 * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to recent stickers
 */
export type addRecentSticker$DirectInput = {
  /**
   * Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * Sticker file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
 *
 * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to recent stickers
 *
 * @param {addRecentSticker$Input} parameters {@link addRecentSticker$Input}
 * @return {Stickers} {@link Stickers}
 */
export type addRecentSticker = (parameters: addRecentSticker$Input) => Stickers;

/**
 * Removes a sticker from the list of recently used stickers
 */
export type removeRecentSticker$Input = {
  readonly _: "removeRecentSticker";

  /**
   * Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * Sticker file to delete
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the list of recently used stickers
 */
export type removeRecentSticker$DirectInput = {
  /**
   * Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * Sticker file to delete
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the list of recently used stickers
 *
 * @param {removeRecentSticker$Input} parameters {@link removeRecentSticker$Input}
 * @return {Ok} {@link Ok}
 */
export type removeRecentSticker = (parameters: removeRecentSticker$Input) => Ok;

/**
 * Clears the list of recently used stickers
 */
export type clearRecentStickers$Input = {
  readonly _: "clearRecentStickers";

  /**
   * Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;
};

/**
 * Clears the list of recently used stickers
 */
export type clearRecentStickers$DirectInput = {
  /**
   * Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;
};

/**
 * Clears the list of recently used stickers
 *
 * @param {clearRecentStickers$Input} parameters {@link clearRecentStickers$Input}
 * @return {Ok} {@link Ok}
 */
export type clearRecentStickers = (parameters: clearRecentStickers$Input) => Ok;

/**
 * Returns favorite stickers
 */
export type getFavoriteStickers$Input = {
  readonly _: "getFavoriteStickers";
};

/**
 * Returns favorite stickers
 */
export type getFavoriteStickers$DirectInput = {};

/**
 * Returns favorite stickers
 *
 * @param {getFavoriteStickers$Input} parameters {@link getFavoriteStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getFavoriteStickers = (
  parameters: getFavoriteStickers$Input
) => Stickers;

/**
 * Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
 *
 * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to favorite stickers
 */
export type addFavoriteSticker$Input = {
  readonly _: "addFavoriteSticker";

  /**
   * Sticker file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
 *
 * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to favorite stickers
 */
export type addFavoriteSticker$DirectInput = {
  /**
   * Sticker file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first.
 *
 * - Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to favorite stickers
 *
 * @param {addFavoriteSticker$Input} parameters {@link addFavoriteSticker$Input}
 * @return {Ok} {@link Ok}
 */
export type addFavoriteSticker = (parameters: addFavoriteSticker$Input) => Ok;

/**
 * Removes a sticker from the list of favorite stickers
 */
export type removeFavoriteSticker$Input = {
  readonly _: "removeFavoriteSticker";

  /**
   * Sticker file to delete from the list
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the list of favorite stickers
 */
export type removeFavoriteSticker$DirectInput = {
  /**
   * Sticker file to delete from the list
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the list of favorite stickers
 *
 * @param {removeFavoriteSticker$Input} parameters {@link removeFavoriteSticker$Input}
 * @return {Ok} {@link Ok}
 */
export type removeFavoriteSticker = (parameters: removeFavoriteSticker$Input) => Ok;

/**
 * Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
 */
export type getStickerEmojis$Input = {
  readonly _: "getStickerEmojis";

  /**
   * Sticker file identifier
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
 */
export type getStickerEmojis$DirectInput = {
  /**
   * Sticker file identifier
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
 *
 * @param {getStickerEmojis$Input} parameters {@link getStickerEmojis$Input}
 * @return {Emojis} {@link Emojis}
 */
export type getStickerEmojis = (parameters: getStickerEmojis$Input) => Emojis;

/**
 * Searches for emojis by keywords. Supported only if the file database is enabled
 */
export type searchEmojis$Input = {
  readonly _: "searchEmojis";

  /**
   * Text to search for
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Pass true if only emojis, which exactly match the text, needs to be returned
   * @type {Bool$Input} {@link Bool}
   */
  readonly exact_match?: Bool$Input;

  /**
   * List of possible IETF language tags of the user's input language; may be empty if unknown
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly input_language_codes?: vector$Input<string>;
};

/**
 * Searches for emojis by keywords. Supported only if the file database is enabled
 */
export type searchEmojis$DirectInput = {
  /**
   * Text to search for
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Pass true if only emojis, which exactly match the text, needs to be returned
   * @type {Bool$Input} {@link Bool}
   */
  readonly exact_match?: Bool$Input;

  /**
   * List of possible IETF language tags of the user's input language; may be empty if unknown
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly input_language_codes?: vector$Input<string>;
};

/**
 * Searches for emojis by keywords. Supported only if the file database is enabled
 *
 * @param {searchEmojis$Input} parameters {@link searchEmojis$Input}
 * @return {Emojis} {@link Emojis}
 */
export type searchEmojis = (parameters: searchEmojis$Input) => Emojis;

/**
 * Returns available emojis categories
 */
export type getEmojiCategories$Input = {
  readonly _: "getEmojiCategories";

  /**
   * Type of emoji categories to return; pass null to get default emoji categories
   * @type {EmojiCategoryType$Input} {@link EmojiCategoryType}
   */
  readonly type?: EmojiCategoryType$Input | null;
};

/**
 * Returns available emojis categories
 */
export type getEmojiCategories$DirectInput = {
  /**
   * Type of emoji categories to return; pass null to get default emoji categories
   * @type {EmojiCategoryType$Input} {@link EmojiCategoryType}
   */
  readonly type?: EmojiCategoryType$Input | null;
};

/**
 * Returns available emojis categories
 *
 * @param {getEmojiCategories$Input} parameters {@link getEmojiCategories$Input}
 * @return {EmojiCategories} {@link EmojiCategories}
 */
export type getEmojiCategories = (
  parameters: getEmojiCategories$Input
) => EmojiCategories;

/**
 * Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
 */
export type getAnimatedEmoji$Input = {
  readonly _: "getAnimatedEmoji";

  /**
   * The emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
 */
export type getAnimatedEmoji$DirectInput = {
  /**
   * The emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
 *
 * @param {getAnimatedEmoji$Input} parameters {@link getAnimatedEmoji$Input}
 * @return {AnimatedEmoji} {@link AnimatedEmoji}
 */
export type getAnimatedEmoji = (parameters: getAnimatedEmoji$Input) => AnimatedEmoji;

/**
 * Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
 */
export type getEmojiSuggestionsUrl$Input = {
  readonly _: "getEmojiSuggestionsUrl";

  /**
   * Language code for which the emoji replacements will be suggested
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
 */
export type getEmojiSuggestionsUrl$DirectInput = {
  /**
   * Language code for which the emoji replacements will be suggested
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
 *
 * @param {getEmojiSuggestionsUrl$Input} parameters {@link getEmojiSuggestionsUrl$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getEmojiSuggestionsUrl = (
  parameters: getEmojiSuggestionsUrl$Input
) => HttpUrl;

/**
 * Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned
 */
export type getCustomEmojiStickers$Input = {
  readonly _: "getCustomEmojiStickers";

  /**
   * Identifiers of custom emoji stickers. At most 200 custom emoji stickers can be received simultaneously
   * @type {vector$Input<int64$Input>} {@link vector<int64>}
   */
  readonly custom_emoji_ids?: vector$Input<int64$Input>;
};

/**
 * Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned
 */
export type getCustomEmojiStickers$DirectInput = {
  /**
   * Identifiers of custom emoji stickers. At most 200 custom emoji stickers can be received simultaneously
   * @type {vector$Input<int64$Input>} {@link vector<int64>}
   */
  readonly custom_emoji_ids?: vector$Input<int64$Input>;
};

/**
 * Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned
 *
 * @param {getCustomEmojiStickers$Input} parameters {@link getCustomEmojiStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getCustomEmojiStickers = (
  parameters: getCustomEmojiStickers$Input
) => Stickers;

/**
 * Returns default list of custom emoji stickers for placing on a chat photo
 */
export type getDefaultChatPhotoCustomEmojiStickers$Input = {
  readonly _: "getDefaultChatPhotoCustomEmojiStickers";
};

/**
 * Returns default list of custom emoji stickers for placing on a chat photo
 */
export type getDefaultChatPhotoCustomEmojiStickers$DirectInput = {};

/**
 * Returns default list of custom emoji stickers for placing on a chat photo
 *
 * @param {getDefaultChatPhotoCustomEmojiStickers$Input} parameters {@link getDefaultChatPhotoCustomEmojiStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getDefaultChatPhotoCustomEmojiStickers = (
  parameters: getDefaultChatPhotoCustomEmojiStickers$Input
) => Stickers;

/**
 * Returns default list of custom emoji stickers for placing on a profile photo
 */
export type getDefaultProfilePhotoCustomEmojiStickers$Input = {
  readonly _: "getDefaultProfilePhotoCustomEmojiStickers";
};

/**
 * Returns default list of custom emoji stickers for placing on a profile photo
 */
export type getDefaultProfilePhotoCustomEmojiStickers$DirectInput = {};

/**
 * Returns default list of custom emoji stickers for placing on a profile photo
 *
 * @param {getDefaultProfilePhotoCustomEmojiStickers$Input} parameters {@link getDefaultProfilePhotoCustomEmojiStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getDefaultProfilePhotoCustomEmojiStickers = (
  parameters: getDefaultProfilePhotoCustomEmojiStickers$Input
) => Stickers;

/**
 * Returns default list of custom emoji stickers for reply background
 */
export type getDefaultBackgroundCustomEmojiStickers$Input = {
  readonly _: "getDefaultBackgroundCustomEmojiStickers";
};

/**
 * Returns default list of custom emoji stickers for reply background
 */
export type getDefaultBackgroundCustomEmojiStickers$DirectInput = {};

/**
 * Returns default list of custom emoji stickers for reply background
 *
 * @param {getDefaultBackgroundCustomEmojiStickers$Input} parameters {@link getDefaultBackgroundCustomEmojiStickers$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getDefaultBackgroundCustomEmojiStickers = (
  parameters: getDefaultBackgroundCustomEmojiStickers$Input
) => Stickers;

/**
 * Returns saved animations
 */
export type getSavedAnimations$Input = {
  readonly _: "getSavedAnimations";
};

/**
 * Returns saved animations
 */
export type getSavedAnimations$DirectInput = {};

/**
 * Returns saved animations
 *
 * @param {getSavedAnimations$Input} parameters {@link getSavedAnimations$Input}
 * @return {Animations} {@link Animations}
 */
export type getSavedAnimations = (
  parameters: getSavedAnimations$Input
) => Animations;

/**
 * Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
 */
export type addSavedAnimation$Input = {
  readonly _: "addSavedAnimation";

  /**
   * The animation file to be added. Only animations known to the server (i.e., successfully sent via a message) can be added to the list
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly animation?: InputFile$Input;
};

/**
 * Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
 */
export type addSavedAnimation$DirectInput = {
  /**
   * The animation file to be added. Only animations known to the server (i.e., successfully sent via a message) can be added to the list
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly animation?: InputFile$Input;
};

/**
 * Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
 *
 * @param {addSavedAnimation$Input} parameters {@link addSavedAnimation$Input}
 * @return {Ok} {@link Ok}
 */
export type addSavedAnimation = (parameters: addSavedAnimation$Input) => Ok;

/**
 * Removes an animation from the list of saved animations
 */
export type removeSavedAnimation$Input = {
  readonly _: "removeSavedAnimation";

  /**
   * Animation file to be removed
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly animation?: InputFile$Input;
};

/**
 * Removes an animation from the list of saved animations
 */
export type removeSavedAnimation$DirectInput = {
  /**
   * Animation file to be removed
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly animation?: InputFile$Input;
};

/**
 * Removes an animation from the list of saved animations
 *
 * @param {removeSavedAnimation$Input} parameters {@link removeSavedAnimation$Input}
 * @return {Ok} {@link Ok}
 */
export type removeSavedAnimation = (parameters: removeSavedAnimation$Input) => Ok;

/**
 * Returns up to 20 recently used inline bots in the order of their last usage
 */
export type getRecentInlineBots$Input = {
  readonly _: "getRecentInlineBots";
};

/**
 * Returns up to 20 recently used inline bots in the order of their last usage
 */
export type getRecentInlineBots$DirectInput = {};

/**
 * Returns up to 20 recently used inline bots in the order of their last usage
 *
 * @param {getRecentInlineBots$Input} parameters {@link getRecentInlineBots$Input}
 * @return {Users} {@link Users}
 */
export type getRecentInlineBots = (parameters: getRecentInlineBots$Input) => Users;

/**
 * Searches for recently used hashtags by their prefix
 */
export type searchHashtags$Input = {
  readonly _: "searchHashtags";

  /**
   * Hashtag prefix to search for
   * @type {string} {@link string}
   */
  readonly prefix?: string;

  /**
   * The maximum number of hashtags to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for recently used hashtags by their prefix
 */
export type searchHashtags$DirectInput = {
  /**
   * Hashtag prefix to search for
   * @type {string} {@link string}
   */
  readonly prefix?: string;

  /**
   * The maximum number of hashtags to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for recently used hashtags by their prefix
 *
 * @param {searchHashtags$Input} parameters {@link searchHashtags$Input}
 * @return {Hashtags} {@link Hashtags}
 */
export type searchHashtags = (parameters: searchHashtags$Input) => Hashtags;

/**
 * Removes a hashtag from the list of recently used hashtags
 */
export type removeRecentHashtag$Input = {
  readonly _: "removeRecentHashtag";

  /**
   * Hashtag to delete
   * @type {string} {@link string}
   */
  readonly hashtag?: string;
};

/**
 * Removes a hashtag from the list of recently used hashtags
 */
export type removeRecentHashtag$DirectInput = {
  /**
   * Hashtag to delete
   * @type {string} {@link string}
   */
  readonly hashtag?: string;
};

/**
 * Removes a hashtag from the list of recently used hashtags
 *
 * @param {removeRecentHashtag$Input} parameters {@link removeRecentHashtag$Input}
 * @return {Ok} {@link Ok}
 */
export type removeRecentHashtag = (parameters: removeRecentHashtag$Input) => Ok;

/**
 * Returns a link preview by the text of a message. Do not call this function too often. Returns a 404 error if the text has no link preview
 */
export type getWebPagePreview$Input = {
  readonly _: "getWebPagePreview";

  /**
   * Message text with formatting
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Options to be used for generation of the link preview; pass null to use default link preview options
   * @type {linkPreviewOptions$Input} {@link linkPreviewOptions}
   */
  readonly link_preview_options?: linkPreviewOptions$Input | null;
};

/**
 * Returns a link preview by the text of a message. Do not call this function too often. Returns a 404 error if the text has no link preview
 */
export type getWebPagePreview$DirectInput = {
  /**
   * Message text with formatting
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Options to be used for generation of the link preview; pass null to use default link preview options
   * @type {linkPreviewOptions$Input} {@link linkPreviewOptions}
   */
  readonly link_preview_options?: linkPreviewOptions$Input | null;
};

/**
 * Returns a link preview by the text of a message. Do not call this function too often. Returns a 404 error if the text has no link preview
 *
 * @param {getWebPagePreview$Input} parameters {@link getWebPagePreview$Input}
 * @return {WebPage} {@link WebPage}
 */
export type getWebPagePreview = (parameters: getWebPagePreview$Input) => WebPage;

/**
 * Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
 */
export type getWebPageInstantView$Input = {
  readonly _: "getWebPageInstantView";

  /**
   * The web page URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Pass true to get full instant view for the web page
   * @type {Bool$Input} {@link Bool}
   */
  readonly force_full?: Bool$Input;
};

/**
 * Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
 */
export type getWebPageInstantView$DirectInput = {
  /**
   * The web page URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Pass true to get full instant view for the web page
   * @type {Bool$Input} {@link Bool}
   */
  readonly force_full?: Bool$Input;
};

/**
 * Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
 *
 * @param {getWebPageInstantView$Input} parameters {@link getWebPageInstantView$Input}
 * @return {WebPageInstantView} {@link WebPageInstantView}
 */
export type getWebPageInstantView = (
  parameters: getWebPageInstantView$Input
) => WebPageInstantView;

/**
 * Changes a profile photo for the current user
 */
export type setProfilePhoto$Input = {
  readonly _: "setProfilePhoto";

  /**
   * Profile photo to set
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input;

  /**
   * Pass true to set a public photo, which will be visible even the main photo is hidden by privacy settings
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_public?: Bool$Input;
};

/**
 * Changes a profile photo for the current user
 */
export type setProfilePhoto$DirectInput = {
  /**
   * Profile photo to set
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input;

  /**
   * Pass true to set a public photo, which will be visible even the main photo is hidden by privacy settings
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_public?: Bool$Input;
};

/**
 * Changes a profile photo for the current user
 *
 * @param {setProfilePhoto$Input} parameters {@link setProfilePhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type setProfilePhoto = (parameters: setProfilePhoto$Input) => Ok;

/**
 * Deletes a profile photo
 */
export type deleteProfilePhoto$Input = {
  readonly _: "deleteProfilePhoto";

  /**
   * Identifier of the profile photo to delete
   * @type {int64$Input} {@link int64}
   */
  readonly profile_photo_id?: int64$Input;
};

/**
 * Deletes a profile photo
 */
export type deleteProfilePhoto$DirectInput = {
  /**
   * Identifier of the profile photo to delete
   * @type {int64$Input} {@link int64}
   */
  readonly profile_photo_id?: int64$Input;
};

/**
 * Deletes a profile photo
 *
 * @param {deleteProfilePhoto$Input} parameters {@link deleteProfilePhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteProfilePhoto = (parameters: deleteProfilePhoto$Input) => Ok;

/**
 * Changes accent color and background custom emoji for the current user; for Telegram Premium users only
 */
export type setAccentColor$Input = {
  readonly _: "setAccentColor";

  /**
   * Identifier of the accent color to use
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
   * @type {int64$Input} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji for the current user; for Telegram Premium users only
 */
export type setAccentColor$DirectInput = {
  /**
   * Identifier of the accent color to use
   * @type {int32} {@link int32}
   */
  readonly accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the reply header and link preview background; 0 if none
   * @type {int64$Input} {@link int64}
   */
  readonly background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji for the current user; for Telegram Premium users only
 *
 * @param {setAccentColor$Input} parameters {@link setAccentColor$Input}
 * @return {Ok} {@link Ok}
 */
export type setAccentColor = (parameters: setAccentColor$Input) => Ok;

/**
 * Changes accent color and background custom emoji for profile of the current user; for Telegram Premium users only
 */
export type setProfileAccentColor$Input = {
  readonly _: "setProfileAccentColor";

  /**
   * Identifier of the accent color to use for profile; pass -1 if none
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the user's profile photo background; 0 if none
   * @type {int64$Input} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji for profile of the current user; for Telegram Premium users only
 */
export type setProfileAccentColor$DirectInput = {
  /**
   * Identifier of the accent color to use for profile; pass -1 if none
   * @type {int32} {@link int32}
   */
  readonly profile_accent_color_id?: int32;

  /**
   * Identifier of a custom emoji to be shown on the user's profile photo background; 0 if none
   * @type {int64$Input} {@link int64}
   */
  readonly profile_background_custom_emoji_id?: int64$Input;
};

/**
 * Changes accent color and background custom emoji for profile of the current user; for Telegram Premium users only
 *
 * @param {setProfileAccentColor$Input} parameters {@link setProfileAccentColor$Input}
 * @return {Ok} {@link Ok}
 */
export type setProfileAccentColor = (parameters: setProfileAccentColor$Input) => Ok;

/**
 * Changes the first and last name of the current user
 */
export type setName$Input = {
  readonly _: "setName";

  /**
   * The new value of the first name for the current user; 1-64 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * The new value of the optional last name for the current user; 0-64 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;
};

/**
 * Changes the first and last name of the current user
 */
export type setName$DirectInput = {
  /**
   * The new value of the first name for the current user; 1-64 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * The new value of the optional last name for the current user; 0-64 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;
};

/**
 * Changes the first and last name of the current user
 *
 * @param {setName$Input} parameters {@link setName$Input}
 * @return {Ok} {@link Ok}
 */
export type setName = (parameters: setName$Input) => Ok;

/**
 * Changes the bio of the current user
 */
export type setBio$Input = {
  readonly _: "setBio";

  /**
   * The new value of the user bio; 0-getOption("bio_length_max") characters without line feeds
   * @type {string} {@link string}
   */
  readonly bio?: string;
};

/**
 * Changes the bio of the current user
 */
export type setBio$DirectInput = {
  /**
   * The new value of the user bio; 0-getOption("bio_length_max") characters without line feeds
   * @type {string} {@link string}
   */
  readonly bio?: string;
};

/**
 * Changes the bio of the current user
 *
 * @param {setBio$Input} parameters {@link setBio$Input}
 * @return {Ok} {@link Ok}
 */
export type setBio = (parameters: setBio$Input) => Ok;

/**
 * Changes the editable username of the current user
 */
export type setUsername$Input = {
  readonly _: "setUsername";

  /**
   * The new value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Changes the editable username of the current user
 */
export type setUsername$DirectInput = {
  /**
   * The new value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Changes the editable username of the current user
 *
 * @param {setUsername$Input} parameters {@link setUsername$Input}
 * @return {Ok} {@link Ok}
 */
export type setUsername = (parameters: setUsername$Input) => Ok;

/**
 * Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 */
export type toggleUsernameIsActive$Input = {
  readonly _: "toggleUsernameIsActive";

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 */
export type toggleUsernameIsActive$DirectInput = {
  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 *
 * @param {toggleUsernameIsActive$Input} parameters {@link toggleUsernameIsActive$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleUsernameIsActive = (
  parameters: toggleUsernameIsActive$Input
) => Ok;

/**
 * Changes order of active usernames of the current user
 */
export type reorderActiveUsernames$Input = {
  readonly _: "reorderActiveUsernames";

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of the current user
 */
export type reorderActiveUsernames$DirectInput = {
  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of the current user
 *
 * @param {reorderActiveUsernames$Input} parameters {@link reorderActiveUsernames$Input}
 * @return {Ok} {@link Ok}
 */
export type reorderActiveUsernames = (
  parameters: reorderActiveUsernames$Input
) => Ok;

/**
 * Changes the emoji status of the current user; for Telegram Premium users only
 */
export type setEmojiStatus$Input = {
  readonly _: "setEmojiStatus";

  /**
   * New emoji status; pass null to switch to the default badge
   * @type {emojiStatus$Input} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;
};

/**
 * Changes the emoji status of the current user; for Telegram Premium users only
 */
export type setEmojiStatus$DirectInput = {
  /**
   * New emoji status; pass null to switch to the default badge
   * @type {emojiStatus$Input} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input | null;
};

/**
 * Changes the emoji status of the current user; for Telegram Premium users only
 *
 * @param {setEmojiStatus$Input} parameters {@link setEmojiStatus$Input}
 * @return {Ok} {@link Ok}
 */
export type setEmojiStatus = (parameters: setEmojiStatus$Input) => Ok;

/**
 * Changes the location of the current user. Needs to be called if getOption("is_location_visible") is true and location changes for more than 1 kilometer
 */
export type setLocation$Input = {
  readonly _: "setLocation";

  /**
   * The new location of the user
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * Changes the location of the current user. Needs to be called if getOption("is_location_visible") is true and location changes for more than 1 kilometer
 */
export type setLocation$DirectInput = {
  /**
   * The new location of the user
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * Changes the location of the current user. Needs to be called if getOption("is_location_visible") is true and location changes for more than 1 kilometer
 *
 * @param {setLocation$Input} parameters {@link setLocation$Input}
 * @return {Ok} {@link Ok}
 */
export type setLocation = (parameters: setLocation$Input) => Ok;

/**
 * Changes the phone number of the user and sends an authentication code to the user's new phone number; for official Android and iOS applications only. On success, returns information about the sent code
 */
export type changePhoneNumber$Input = {
  readonly _: "changePhoneNumber";

  /**
   * The new phone number of the user in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Changes the phone number of the user and sends an authentication code to the user's new phone number; for official Android and iOS applications only. On success, returns information about the sent code
 */
export type changePhoneNumber$DirectInput = {
  /**
   * The new phone number of the user in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Changes the phone number of the user and sends an authentication code to the user's new phone number; for official Android and iOS applications only. On success, returns information about the sent code
 *
 * @param {changePhoneNumber$Input} parameters {@link changePhoneNumber$Input}
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type changePhoneNumber = (
  parameters: changePhoneNumber$Input
) => AuthenticationCodeInfo;

/**
 * Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
 */
export type resendChangePhoneNumberCode$Input = {
  readonly _: "resendChangePhoneNumberCode";
};

/**
 * Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
 */
export type resendChangePhoneNumberCode$DirectInput = {};

/**
 * Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
 *
 * @param {resendChangePhoneNumberCode$Input} parameters {@link resendChangePhoneNumberCode$Input}
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type resendChangePhoneNumberCode = (
  parameters: resendChangePhoneNumberCode$Input
) => AuthenticationCodeInfo;

/**
 * Checks the authentication code sent to confirm a new phone number of the user
 */
export type checkChangePhoneNumberCode$Input = {
  readonly _: "checkChangePhoneNumberCode";

  /**
   * Authentication code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the authentication code sent to confirm a new phone number of the user
 */
export type checkChangePhoneNumberCode$DirectInput = {
  /**
   * Authentication code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the authentication code sent to confirm a new phone number of the user
 *
 * @param {checkChangePhoneNumberCode$Input} parameters {@link checkChangePhoneNumberCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkChangePhoneNumberCode = (
  parameters: checkChangePhoneNumberCode$Input
) => Ok;

/**
 * Returns an HTTPS link, which can be used to get information about the current user
 */
export type getUserLink$Input = {
  readonly _: "getUserLink";
};

/**
 * Returns an HTTPS link, which can be used to get information about the current user
 */
export type getUserLink$DirectInput = {};

/**
 * Returns an HTTPS link, which can be used to get information about the current user
 *
 * @param {getUserLink$Input} parameters {@link getUserLink$Input}
 * @return {UserLink} {@link UserLink}
 */
export type getUserLink = (parameters: getUserLink$Input) => UserLink;

/**
 * Searches a user by a token from the user's link
 */
export type searchUserByToken$Input = {
  readonly _: "searchUserByToken";

  /**
   * Token to search for
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Searches a user by a token from the user's link
 */
export type searchUserByToken$DirectInput = {
  /**
   * Token to search for
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Searches a user by a token from the user's link
 *
 * @param {searchUserByToken$Input} parameters {@link searchUserByToken$Input}
 * @return {User} {@link User}
 */
export type searchUserByToken = (parameters: searchUserByToken$Input) => User;

/**
 * Sets the list of commands supported by the bot for the given user scope and language; for bots only
 */
export type setCommands$Input = {
  readonly _: "setCommands";

  /**
   * The scope to which the commands are relevant; pass null to change commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input | null;

  /**
   * A two-letter ISO 639-1 language code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * List of the bot's commands
   * @type {vector$Input<botCommand$Input>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;
};

/**
 * Sets the list of commands supported by the bot for the given user scope and language; for bots only
 */
export type setCommands$DirectInput = {
  /**
   * The scope to which the commands are relevant; pass null to change commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input | null;

  /**
   * A two-letter ISO 639-1 language code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * List of the bot's commands
   * @type {vector$Input<botCommand$Input>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;
};

/**
 * Sets the list of commands supported by the bot for the given user scope and language; for bots only
 *
 * @param {setCommands$Input} parameters {@link setCommands$Input}
 * @return {Ok} {@link Ok}
 */
export type setCommands = (parameters: setCommands$Input) => Ok;

/**
 * Deletes commands supported by the bot for the given user scope and language; for bots only
 */
export type deleteCommands$Input = {
  readonly _: "deleteCommands";

  /**
   * The scope to which the commands are relevant; pass null to delete commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input | null;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Deletes commands supported by the bot for the given user scope and language; for bots only
 */
export type deleteCommands$DirectInput = {
  /**
   * The scope to which the commands are relevant; pass null to delete commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input | null;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Deletes commands supported by the bot for the given user scope and language; for bots only
 *
 * @param {deleteCommands$Input} parameters {@link deleteCommands$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteCommands = (parameters: deleteCommands$Input) => Ok;

/**
 * Returns list of commands supported by the bot for the given user scope and language; for bots only
 */
export type getCommands$Input = {
  readonly _: "getCommands";

  /**
   * The scope to which the commands are relevant; pass null to get commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input | null;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns list of commands supported by the bot for the given user scope and language; for bots only
 */
export type getCommands$DirectInput = {
  /**
   * The scope to which the commands are relevant; pass null to get commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input | null;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns list of commands supported by the bot for the given user scope and language; for bots only
 *
 * @param {getCommands$Input} parameters {@link getCommands$Input}
 * @return {BotCommands} {@link BotCommands}
 */
export type getCommands = (parameters: getCommands$Input) => BotCommands;

/**
 * Sets menu button for the given user or for all users; for bots only
 */
export type setMenuButton$Input = {
  readonly _: "setMenuButton";

  /**
   * Identifier of the user or 0 to set menu button for all users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New menu button
   * @type {botMenuButton$Input} {@link botMenuButton}
   */
  readonly menu_button?: botMenuButton$Input;
};

/**
 * Sets menu button for the given user or for all users; for bots only
 */
export type setMenuButton$DirectInput = {
  /**
   * Identifier of the user or 0 to set menu button for all users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New menu button
   * @type {botMenuButton$Input} {@link botMenuButton}
   */
  readonly menu_button?: botMenuButton$Input;
};

/**
 * Sets menu button for the given user or for all users; for bots only
 *
 * @param {setMenuButton$Input} parameters {@link setMenuButton$Input}
 * @return {Ok} {@link Ok}
 */
export type setMenuButton = (parameters: setMenuButton$Input) => Ok;

/**
 * Returns menu button set by the bot for the given user; for bots only
 */
export type getMenuButton$Input = {
  readonly _: "getMenuButton";

  /**
   * Identifier of the user or 0 to get the default menu button
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns menu button set by the bot for the given user; for bots only
 */
export type getMenuButton$DirectInput = {
  /**
   * Identifier of the user or 0 to get the default menu button
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns menu button set by the bot for the given user; for bots only
 *
 * @param {getMenuButton$Input} parameters {@link getMenuButton$Input}
 * @return {BotMenuButton} {@link BotMenuButton}
 */
export type getMenuButton = (parameters: getMenuButton$Input) => BotMenuButton;

/**
 * Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only
 */
export type setDefaultGroupAdministratorRights$Input = {
  readonly _: "setDefaultGroupAdministratorRights";

  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; pass null to remove default rights
   * @type {chatAdministratorRights$Input} {@link chatAdministratorRights}
   */
  readonly default_group_administrator_rights?: chatAdministratorRights$Input | null;
};

/**
 * Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only
 */
export type setDefaultGroupAdministratorRights$DirectInput = {
  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; pass null to remove default rights
   * @type {chatAdministratorRights$Input} {@link chatAdministratorRights}
   */
  readonly default_group_administrator_rights?: chatAdministratorRights$Input | null;
};

/**
 * Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only
 *
 * @param {setDefaultGroupAdministratorRights$Input} parameters {@link setDefaultGroupAdministratorRights$Input}
 * @return {Ok} {@link Ok}
 */
export type setDefaultGroupAdministratorRights = (
  parameters: setDefaultGroupAdministratorRights$Input
) => Ok;

/**
 * Sets default administrator rights for adding the bot to channel chats; for bots only
 */
export type setDefaultChannelAdministratorRights$Input = {
  readonly _: "setDefaultChannelAdministratorRights";

  /**
   * Default administrator rights for adding the bot to channels; pass null to remove default rights
   * @type {chatAdministratorRights$Input} {@link chatAdministratorRights}
   */
  readonly default_channel_administrator_rights?: chatAdministratorRights$Input | null;
};

/**
 * Sets default administrator rights for adding the bot to channel chats; for bots only
 */
export type setDefaultChannelAdministratorRights$DirectInput = {
  /**
   * Default administrator rights for adding the bot to channels; pass null to remove default rights
   * @type {chatAdministratorRights$Input} {@link chatAdministratorRights}
   */
  readonly default_channel_administrator_rights?: chatAdministratorRights$Input | null;
};

/**
 * Sets default administrator rights for adding the bot to channel chats; for bots only
 *
 * @param {setDefaultChannelAdministratorRights$Input} parameters {@link setDefaultChannelAdministratorRights$Input}
 * @return {Ok} {@link Ok}
 */
export type setDefaultChannelAdministratorRights = (
  parameters: setDefaultChannelAdministratorRights$Input
) => Ok;

/**
 * Checks whether the specified bot can send messages to the user. Returns a 404 error if can't and the access can be granted by call to allowBotToSendMessages
 */
export type canBotSendMessages$Input = {
  readonly _: "canBotSendMessages";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Checks whether the specified bot can send messages to the user. Returns a 404 error if can't and the access can be granted by call to allowBotToSendMessages
 */
export type canBotSendMessages$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Checks whether the specified bot can send messages to the user. Returns a 404 error if can't and the access can be granted by call to allowBotToSendMessages
 *
 * @param {canBotSendMessages$Input} parameters {@link canBotSendMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type canBotSendMessages = (parameters: canBotSendMessages$Input) => Ok;

/**
 * Allows the specified bot to send messages to the user
 */
export type allowBotToSendMessages$Input = {
  readonly _: "allowBotToSendMessages";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Allows the specified bot to send messages to the user
 */
export type allowBotToSendMessages$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Allows the specified bot to send messages to the user
 *
 * @param {allowBotToSendMessages$Input} parameters {@link allowBotToSendMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type allowBotToSendMessages = (
  parameters: allowBotToSendMessages$Input
) => Ok;

/**
 * Sends a custom request from a Web App
 */
export type sendWebAppCustomRequest$Input = {
  readonly _: "sendWebAppCustomRequest";

  /**
   * Identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The method name
   * @type {string} {@link string}
   */
  readonly method?: string;

  /**
   * JSON-serialized method parameters
   * @type {string} {@link string}
   */
  readonly parameters?: string;
};

/**
 * Sends a custom request from a Web App
 */
export type sendWebAppCustomRequest$DirectInput = {
  /**
   * Identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The method name
   * @type {string} {@link string}
   */
  readonly method?: string;

  /**
   * JSON-serialized method parameters
   * @type {string} {@link string}
   */
  readonly parameters?: string;
};

/**
 * Sends a custom request from a Web App
 *
 * @param {sendWebAppCustomRequest$Input} parameters {@link sendWebAppCustomRequest$Input}
 * @return {CustomRequestResult} {@link CustomRequestResult}
 */
export type sendWebAppCustomRequest = (
  parameters: sendWebAppCustomRequest$Input
) => CustomRequestResult;

/**
 * Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true
 */
export type setBotName$Input = {
  readonly _: "setBotName";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose languages there is no dedicated name
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * New bot's name on the specified language; 0-64 characters; must be non-empty if language code is empty
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true
 */
export type setBotName$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose languages there is no dedicated name
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * New bot's name on the specified language; 0-64 characters; must be non-empty if language code is empty
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Sets the name of a bot. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {setBotName$Input} parameters {@link setBotName$Input}
 * @return {Ok} {@link Ok}
 */
export type setBotName = (parameters: setBotName$Input) => Ok;

/**
 * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited == true
 */
export type getBotName$Input = {
  readonly _: "getBotName";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited == true
 */
export type getBotName$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the name of a bot in the given language. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {getBotName$Input} parameters {@link getBotName$Input}
 * @return {Text} {@link Text}
 */
export type getBotName = (parameters: getBotName$Input) => Text;

/**
 * Changes a profile photo for a bot
 */
export type setBotProfilePhoto$Input = {
  readonly _: "setBotProfilePhoto";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Profile photo to set; pass null to delete the chat photo
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input | null;
};

/**
 * Changes a profile photo for a bot
 */
export type setBotProfilePhoto$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Profile photo to set; pass null to delete the chat photo
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input | null;
};

/**
 * Changes a profile photo for a bot
 *
 * @param {setBotProfilePhoto$Input} parameters {@link setBotProfilePhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type setBotProfilePhoto = (parameters: setBotProfilePhoto$Input) => Ok;

/**
 * Changes active state for a username of a bot. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached. Can be called only if userTypeBot.can_be_edited == true
 */
export type toggleBotUsernameIsActive$Input = {
  readonly _: "toggleBotUsernameIsActive";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of a bot. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached. Can be called only if userTypeBot.can_be_edited == true
 */
export type toggleBotUsernameIsActive$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of a bot. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {toggleBotUsernameIsActive$Input} parameters {@link toggleBotUsernameIsActive$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleBotUsernameIsActive = (
  parameters: toggleBotUsernameIsActive$Input
) => Ok;

/**
 * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited == true
 */
export type reorderBotActiveUsernames$Input = {
  readonly _: "reorderBotActiveUsernames";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited == true
 */
export type reorderBotActiveUsernames$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of a bot. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {reorderBotActiveUsernames$Input} parameters {@link reorderBotActiveUsernames$Input}
 * @return {Ok} {@link Ok}
 */
export type reorderBotActiveUsernames = (
  parameters: reorderBotActiveUsernames$Input
) => Ok;

/**
 * Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
 */
export type setBotInfoDescription$Input = {
  readonly _: "setBotInfoDescription";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code. If empty, the description will be shown to all users for whose languages there is no dedicated description
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
 */
export type setBotInfoDescription$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code. If empty, the description will be shown to all users for whose languages there is no dedicated description
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Sets the text shown in the chat with a bot if the chat is empty. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {setBotInfoDescription$Input} parameters {@link setBotInfoDescription$Input}
 * @return {Ok} {@link Ok}
 */
export type setBotInfoDescription = (parameters: setBotInfoDescription$Input) => Ok;

/**
 * Returns the text shown in the chat with a bot if the chat is empty in the given language. Can be called only if userTypeBot.can_be_edited == true
 */
export type getBotInfoDescription$Input = {
  readonly _: "getBotInfoDescription";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the text shown in the chat with a bot if the chat is empty in the given language. Can be called only if userTypeBot.can_be_edited == true
 */
export type getBotInfoDescription$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the text shown in the chat with a bot if the chat is empty in the given language. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {getBotInfoDescription$Input} parameters {@link getBotInfoDescription$Input}
 * @return {Text} {@link Text}
 */
export type getBotInfoDescription = (
  parameters: getBotInfoDescription$Input
) => Text;

/**
 * Sets the text shown on a bot's profile page and sent together with the link when users share the bot. Can be called only if userTypeBot.can_be_edited == true
 */
export type setBotInfoShortDescription$Input = {
  readonly _: "setBotInfoShortDescription";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code. If empty, the short description will be shown to all users for whose languages there is no dedicated description
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * New bot's short description on the specified language
   * @type {string} {@link string}
   */
  readonly short_description?: string;
};

/**
 * Sets the text shown on a bot's profile page and sent together with the link when users share the bot. Can be called only if userTypeBot.can_be_edited == true
 */
export type setBotInfoShortDescription$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code. If empty, the short description will be shown to all users for whose languages there is no dedicated description
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * New bot's short description on the specified language
   * @type {string} {@link string}
   */
  readonly short_description?: string;
};

/**
 * Sets the text shown on a bot's profile page and sent together with the link when users share the bot. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {setBotInfoShortDescription$Input} parameters {@link setBotInfoShortDescription$Input}
 * @return {Ok} {@link Ok}
 */
export type setBotInfoShortDescription = (
  parameters: setBotInfoShortDescription$Input
) => Ok;

/**
 * Returns the text shown on a bot's profile page and sent together with the link when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited == true
 */
export type getBotInfoShortDescription$Input = {
  readonly _: "getBotInfoShortDescription";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the text shown on a bot's profile page and sent together with the link when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited == true
 */
export type getBotInfoShortDescription$DirectInput = {
  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the text shown on a bot's profile page and sent together with the link when users share the bot in the given language. Can be called only if userTypeBot.can_be_edited == true
 *
 * @param {getBotInfoShortDescription$Input} parameters {@link getBotInfoShortDescription$Input}
 * @return {Text} {@link Text}
 */
export type getBotInfoShortDescription = (
  parameters: getBotInfoShortDescription$Input
) => Text;

/**
 * Returns all active sessions of the current user
 */
export type getActiveSessions$Input = {
  readonly _: "getActiveSessions";
};

/**
 * Returns all active sessions of the current user
 */
export type getActiveSessions$DirectInput = {};

/**
 * Returns all active sessions of the current user
 *
 * @param {getActiveSessions$Input} parameters {@link getActiveSessions$Input}
 * @return {Sessions} {@link Sessions}
 */
export type getActiveSessions = (parameters: getActiveSessions$Input) => Sessions;

/**
 * Terminates a session of the current user
 */
export type terminateSession$Input = {
  readonly _: "terminateSession";

  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;
};

/**
 * Terminates a session of the current user
 */
export type terminateSession$DirectInput = {
  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;
};

/**
 * Terminates a session of the current user
 *
 * @param {terminateSession$Input} parameters {@link terminateSession$Input}
 * @return {Ok} {@link Ok}
 */
export type terminateSession = (parameters: terminateSession$Input) => Ok;

/**
 * Terminates all other sessions of the current user
 */
export type terminateAllOtherSessions$Input = {
  readonly _: "terminateAllOtherSessions";
};

/**
 * Terminates all other sessions of the current user
 */
export type terminateAllOtherSessions$DirectInput = {};

/**
 * Terminates all other sessions of the current user
 *
 * @param {terminateAllOtherSessions$Input} parameters {@link terminateAllOtherSessions$Input}
 * @return {Ok} {@link Ok}
 */
export type terminateAllOtherSessions = (
  parameters: terminateAllOtherSessions$Input
) => Ok;

/**
 * Confirms an unconfirmed session of the current user from another device
 */
export type confirmSession$Input = {
  readonly _: "confirmSession";

  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;
};

/**
 * Confirms an unconfirmed session of the current user from another device
 */
export type confirmSession$DirectInput = {
  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;
};

/**
 * Confirms an unconfirmed session of the current user from another device
 *
 * @param {confirmSession$Input} parameters {@link confirmSession$Input}
 * @return {Ok} {@link Ok}
 */
export type confirmSession = (parameters: confirmSession$Input) => Ok;

/**
 * Toggles whether a session can accept incoming calls
 */
export type toggleSessionCanAcceptCalls$Input = {
  readonly _: "toggleSessionCanAcceptCalls";

  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;

  /**
   * Pass true to allow accepting incoming calls by the session; pass false otherwise
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_accept_calls?: Bool$Input;
};

/**
 * Toggles whether a session can accept incoming calls
 */
export type toggleSessionCanAcceptCalls$DirectInput = {
  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;

  /**
   * Pass true to allow accepting incoming calls by the session; pass false otherwise
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_accept_calls?: Bool$Input;
};

/**
 * Toggles whether a session can accept incoming calls
 *
 * @param {toggleSessionCanAcceptCalls$Input} parameters {@link toggleSessionCanAcceptCalls$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSessionCanAcceptCalls = (
  parameters: toggleSessionCanAcceptCalls$Input
) => Ok;

/**
 * Toggles whether a session can accept incoming secret chats
 */
export type toggleSessionCanAcceptSecretChats$Input = {
  readonly _: "toggleSessionCanAcceptSecretChats";

  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;

  /**
   * Pass true to allow accepting secret chats by the session; pass false otherwise
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_accept_secret_chats?: Bool$Input;
};

/**
 * Toggles whether a session can accept incoming secret chats
 */
export type toggleSessionCanAcceptSecretChats$DirectInput = {
  /**
   * Session identifier
   * @type {int64$Input} {@link int64}
   */
  readonly session_id?: int64$Input;

  /**
   * Pass true to allow accepting secret chats by the session; pass false otherwise
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_accept_secret_chats?: Bool$Input;
};

/**
 * Toggles whether a session can accept incoming secret chats
 *
 * @param {toggleSessionCanAcceptSecretChats$Input} parameters {@link toggleSessionCanAcceptSecretChats$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSessionCanAcceptSecretChats = (
  parameters: toggleSessionCanAcceptSecretChats$Input
) => Ok;

/**
 * Changes the period of inactivity after which sessions will automatically be terminated
 */
export type setInactiveSessionTtl$Input = {
  readonly _: "setInactiveSessionTtl";

  /**
   * New number of days of inactivity before sessions will be automatically terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  readonly inactive_session_ttl_days?: int32;
};

/**
 * Changes the period of inactivity after which sessions will automatically be terminated
 */
export type setInactiveSessionTtl$DirectInput = {
  /**
   * New number of days of inactivity before sessions will be automatically terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  readonly inactive_session_ttl_days?: int32;
};

/**
 * Changes the period of inactivity after which sessions will automatically be terminated
 *
 * @param {setInactiveSessionTtl$Input} parameters {@link setInactiveSessionTtl$Input}
 * @return {Ok} {@link Ok}
 */
export type setInactiveSessionTtl = (parameters: setInactiveSessionTtl$Input) => Ok;

/**
 * Returns all website where the current user used Telegram to log in
 */
export type getConnectedWebsites$Input = {
  readonly _: "getConnectedWebsites";
};

/**
 * Returns all website where the current user used Telegram to log in
 */
export type getConnectedWebsites$DirectInput = {};

/**
 * Returns all website where the current user used Telegram to log in
 *
 * @param {getConnectedWebsites$Input} parameters {@link getConnectedWebsites$Input}
 * @return {ConnectedWebsites} {@link ConnectedWebsites}
 */
export type getConnectedWebsites = (
  parameters: getConnectedWebsites$Input
) => ConnectedWebsites;

/**
 * Disconnects website from the current user's Telegram account
 */
export type disconnectWebsite$Input = {
  readonly _: "disconnectWebsite";

  /**
   * Website identifier
   * @type {int64$Input} {@link int64}
   */
  readonly website_id?: int64$Input;
};

/**
 * Disconnects website from the current user's Telegram account
 */
export type disconnectWebsite$DirectInput = {
  /**
   * Website identifier
   * @type {int64$Input} {@link int64}
   */
  readonly website_id?: int64$Input;
};

/**
 * Disconnects website from the current user's Telegram account
 *
 * @param {disconnectWebsite$Input} parameters {@link disconnectWebsite$Input}
 * @return {Ok} {@link Ok}
 */
export type disconnectWebsite = (parameters: disconnectWebsite$Input) => Ok;

/**
 * Disconnects all websites from the current user's Telegram account
 */
export type disconnectAllWebsites$Input = {
  readonly _: "disconnectAllWebsites";
};

/**
 * Disconnects all websites from the current user's Telegram account
 */
export type disconnectAllWebsites$DirectInput = {};

/**
 * Disconnects all websites from the current user's Telegram account
 *
 * @param {disconnectAllWebsites$Input} parameters {@link disconnectAllWebsites$Input}
 * @return {Ok} {@link Ok}
 */
export type disconnectAllWebsites = (parameters: disconnectAllWebsites$Input) => Ok;

/**
 * Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel
 */
export type setSupergroupUsername$Input = {
  readonly _: "setSupergroupUsername";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel
 */
export type setSupergroupUsername$DirectInput = {
  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel
 *
 * @param {setSupergroupUsername$Input} parameters {@link setSupergroupUsername$Input}
 * @return {Ok} {@link Ok}
 */
export type setSupergroupUsername = (parameters: setSupergroupUsername$Input) => Ok;

/**
 * Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled.
 *
 * - May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 */
export type toggleSupergroupUsernameIsActive$Input = {
  readonly _: "toggleSupergroupUsernameIsActive";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled.
 *
 * - May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 */
export type toggleSupergroupUsernameIsActive$DirectInput = {
  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled.
 *
 * - May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 *
 * @param {toggleSupergroupUsernameIsActive$Input} parameters {@link toggleSupergroupUsernameIsActive$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupUsernameIsActive = (
  parameters: toggleSupergroupUsernameIsActive$Input
) => Ok;

/**
 * Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 */
export type disableAllSupergroupUsernames$Input = {
  readonly _: "disableAllSupergroupUsernames";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 */
export type disableAllSupergroupUsernames$DirectInput = {
  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 *
 * @param {disableAllSupergroupUsernames$Input} parameters {@link disableAllSupergroupUsernames$Input}
 * @return {Ok} {@link Ok}
 */
export type disableAllSupergroupUsernames = (
  parameters: disableAllSupergroupUsernames$Input
) => Ok;

/**
 * Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 */
export type reorderSupergroupActiveUsernames$Input = {
  readonly _: "reorderSupergroupActiveUsernames";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 */
export type reorderSupergroupActiveUsernames$DirectInput = {
  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 *
 * @param {reorderSupergroupActiveUsernames$Input} parameters {@link reorderSupergroupActiveUsernames$Input}
 * @return {Ok} {@link Ok}
 */
export type reorderSupergroupActiveUsernames = (
  parameters: reorderSupergroupActiveUsernames$Input
) => Ok;

/**
 * Changes the sticker set of a supergroup; requires can_change_info administrator right
 */
export type setSupergroupStickerSet$Input = {
  readonly _: "setSupergroupStickerSet";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set
   * @type {int64$Input} {@link int64}
   */
  readonly sticker_set_id?: int64$Input;
};

/**
 * Changes the sticker set of a supergroup; requires can_change_info administrator right
 */
export type setSupergroupStickerSet$DirectInput = {
  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set
   * @type {int64$Input} {@link int64}
   */
  readonly sticker_set_id?: int64$Input;
};

/**
 * Changes the sticker set of a supergroup; requires can_change_info administrator right
 *
 * @param {setSupergroupStickerSet$Input} parameters {@link setSupergroupStickerSet$Input}
 * @return {Ok} {@link Ok}
 */
export type setSupergroupStickerSet = (
  parameters: setSupergroupStickerSet$Input
) => Ok;

/**
 * Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right
 */
export type toggleSupergroupSignMessages$Input = {
  readonly _: "toggleSupergroupSignMessages";

  /**
   * Identifier of the channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of sign_messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;
};

/**
 * Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right
 */
export type toggleSupergroupSignMessages$DirectInput = {
  /**
   * Identifier of the channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of sign_messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;
};

/**
 * Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right
 *
 * @param {toggleSupergroupSignMessages$Input} parameters {@link toggleSupergroupSignMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupSignMessages = (
  parameters: toggleSupergroupSignMessages$Input
) => Ok;

/**
 * Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right
 */
export type toggleSupergroupJoinToSendMessages$Input = {
  readonly _: "toggleSupergroupJoinToSendMessages";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of join_to_send_messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly join_to_send_messages?: Bool$Input;
};

/**
 * Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right
 */
export type toggleSupergroupJoinToSendMessages$DirectInput = {
  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of join_to_send_messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly join_to_send_messages?: Bool$Input;
};

/**
 * Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right
 *
 * @param {toggleSupergroupJoinToSendMessages$Input} parameters {@link toggleSupergroupJoinToSendMessages$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupJoinToSendMessages = (
  parameters: toggleSupergroupJoinToSendMessages$Input
) => Ok;

/**
 * Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right
 */
export type toggleSupergroupJoinByRequest$Input = {
  readonly _: "toggleSupergroupJoinByRequest";

  /**
   * Identifier of the channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of join_by_request
   * @type {Bool$Input} {@link Bool}
   */
  readonly join_by_request?: Bool$Input;
};

/**
 * Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right
 */
export type toggleSupergroupJoinByRequest$DirectInput = {
  /**
   * Identifier of the channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of join_by_request
   * @type {Bool$Input} {@link Bool}
   */
  readonly join_by_request?: Bool$Input;
};

/**
 * Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right
 *
 * @param {toggleSupergroupJoinByRequest$Input} parameters {@link toggleSupergroupJoinByRequest$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupJoinByRequest = (
  parameters: toggleSupergroupJoinByRequest$Input
) => Ok;

/**
 * Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
 */
export type toggleSupergroupIsAllHistoryAvailable$Input = {
  readonly _: "toggleSupergroupIsAllHistoryAvailable";

  /**
   * The identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new value of is_all_history_available
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;
};

/**
 * Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
 */
export type toggleSupergroupIsAllHistoryAvailable$DirectInput = {
  /**
   * The identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new value of is_all_history_available
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;
};

/**
 * Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
 *
 * @param {toggleSupergroupIsAllHistoryAvailable$Input} parameters {@link toggleSupergroupIsAllHistoryAvailable$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupIsAllHistoryAvailable = (
  parameters: toggleSupergroupIsAllHistoryAvailable$Input
) => Ok;

/**
 * Toggles whether non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members == true
 */
export type toggleSupergroupHasHiddenMembers$Input = {
  readonly _: "toggleSupergroupHasHiddenMembers";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of has_hidden_members
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_hidden_members?: Bool$Input;
};

/**
 * Toggles whether non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members == true
 */
export type toggleSupergroupHasHiddenMembers$DirectInput = {
  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of has_hidden_members
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_hidden_members?: Bool$Input;
};

/**
 * Toggles whether non-administrators can receive only administrators and bots using getSupergroupMembers or searchChatMembers. Can be called only if supergroupFullInfo.can_hide_members == true
 *
 * @param {toggleSupergroupHasHiddenMembers$Input} parameters {@link toggleSupergroupHasHiddenMembers$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupHasHiddenMembers = (
  parameters: toggleSupergroupHasHiddenMembers$Input
) => Ok;

/**
 * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
 */
export type toggleSupergroupHasAggressiveAntiSpamEnabled$Input = {
  readonly _: "toggleSupergroupHasAggressiveAntiSpamEnabled";

  /**
   * The identifier of the supergroup, which isn't a broadcast group
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new value of has_aggressive_anti_spam_enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_aggressive_anti_spam_enabled?: Bool$Input;
};

/**
 * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
 */
export type toggleSupergroupHasAggressiveAntiSpamEnabled$DirectInput = {
  /**
   * The identifier of the supergroup, which isn't a broadcast group
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new value of has_aggressive_anti_spam_enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_aggressive_anti_spam_enabled?: Bool$Input;
};

/**
 * Toggles whether aggressive anti-spam checks are enabled in the supergroup. Can be called only if supergroupFullInfo.can_toggle_aggressive_anti_spam == true
 *
 * @param {toggleSupergroupHasAggressiveAntiSpamEnabled$Input} parameters {@link toggleSupergroupHasAggressiveAntiSpamEnabled$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupHasAggressiveAntiSpamEnabled = (
  parameters: toggleSupergroupHasAggressiveAntiSpamEnabled$Input
) => Ok;

/**
 * Toggles whether the supergroup is a forum; requires owner privileges in the supergroup. Discussion supergroups can't be converted to forums
 */
export type toggleSupergroupIsForum$Input = {
  readonly _: "toggleSupergroupIsForum";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of is_forum
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_forum?: Bool$Input;
};

/**
 * Toggles whether the supergroup is a forum; requires owner privileges in the supergroup. Discussion supergroups can't be converted to forums
 */
export type toggleSupergroupIsForum$DirectInput = {
  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of is_forum
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_forum?: Bool$Input;
};

/**
 * Toggles whether the supergroup is a forum; requires owner privileges in the supergroup. Discussion supergroups can't be converted to forums
 *
 * @param {toggleSupergroupIsForum$Input} parameters {@link toggleSupergroupIsForum$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupIsForum = (
  parameters: toggleSupergroupIsForum$Input
) => Ok;

/**
 * Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
 */
export type toggleSupergroupIsBroadcastGroup$Input = {
  readonly _: "toggleSupergroupIsBroadcastGroup";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
 */
export type toggleSupergroupIsBroadcastGroup$DirectInput = {
  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
 *
 * @param {toggleSupergroupIsBroadcastGroup$Input} parameters {@link toggleSupergroupIsBroadcastGroup$Input}
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupIsBroadcastGroup = (
  parameters: toggleSupergroupIsBroadcastGroup$Input
) => Ok;

/**
 * Reports messages in a supergroup as spam; requires administrator rights in the supergroup
 */
export type reportSupergroupSpam$Input = {
  readonly _: "reportSupergroupSpam";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Identifiers of messages to report
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Reports messages in a supergroup as spam; requires administrator rights in the supergroup
 */
export type reportSupergroupSpam$DirectInput = {
  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Identifiers of messages to report
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Reports messages in a supergroup as spam; requires administrator rights in the supergroup
 *
 * @param {reportSupergroupSpam$Input} parameters {@link reportSupergroupSpam$Input}
 * @return {Ok} {@link Ok}
 */
export type reportSupergroupSpam = (parameters: reportSupergroupSpam$Input) => Ok;

/**
 * Reports a false deletion of a message by aggressive anti-spam checks; requires administrator rights in the supergroup. Can be called only for messages from chatEventMessageDeleted with can_report_anti_spam_false_positive == true
 */
export type reportSupergroupAntiSpamFalsePositive$Input = {
  readonly _: "reportSupergroupAntiSpamFalsePositive";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Identifier of the erroneously deleted message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Reports a false deletion of a message by aggressive anti-spam checks; requires administrator rights in the supergroup. Can be called only for messages from chatEventMessageDeleted with can_report_anti_spam_false_positive == true
 */
export type reportSupergroupAntiSpamFalsePositive$DirectInput = {
  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Identifier of the erroneously deleted message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Reports a false deletion of a message by aggressive anti-spam checks; requires administrator rights in the supergroup. Can be called only for messages from chatEventMessageDeleted with can_report_anti_spam_false_positive == true
 *
 * @param {reportSupergroupAntiSpamFalsePositive$Input} parameters {@link reportSupergroupAntiSpamFalsePositive$Input}
 * @return {Ok} {@link Ok}
 */
export type reportSupergroupAntiSpamFalsePositive = (
  parameters: reportSupergroupAntiSpamFalsePositive$Input
) => Ok;

/**
 * Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
 */
export type getSupergroupMembers$Input = {
  readonly _: "getSupergroupMembers";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The type of users to return; pass null to use supergroupMembersFilterRecent
   * @type {SupergroupMembersFilter$Input} {@link SupergroupMembersFilter}
   */
  readonly filter?: SupergroupMembersFilter$Input | null;

  /**
   * Number of users to skip
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users be returned; up to 200
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
 */
export type getSupergroupMembers$DirectInput = {
  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The type of users to return; pass null to use supergroupMembersFilterRecent
   * @type {SupergroupMembersFilter$Input} {@link SupergroupMembersFilter}
   */
  readonly filter?: SupergroupMembersFilter$Input | null;

  /**
   * Number of users to skip
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users be returned; up to 200
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
 *
 * @param {getSupergroupMembers$Input} parameters {@link getSupergroupMembers$Input}
 * @return {ChatMembers} {@link ChatMembers}
 */
export type getSupergroupMembers = (
  parameters: getSupergroupMembers$Input
) => ChatMembers;

/**
 * Closes a secret chat, effectively transferring its state to secretChatStateClosed
 */
export type closeSecretChat$Input = {
  readonly _: "closeSecretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Closes a secret chat, effectively transferring its state to secretChatStateClosed
 */
export type closeSecretChat$DirectInput = {
  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Closes a secret chat, effectively transferring its state to secretChatStateClosed
 *
 * @param {closeSecretChat$Input} parameters {@link closeSecretChat$Input}
 * @return {Ok} {@link Ok}
 */
export type closeSecretChat = (parameters: closeSecretChat$Input) => Ok;

/**
 * Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id)
 */
export type getChatEventLog$Input = {
  readonly _: "getChatEventLog";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Search query by which to filter events
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of an event from which to return results. Use 0 to get results from the latest events
   * @type {int64$Input} {@link int64}
   */
  readonly from_event_id?: int64$Input;

  /**
   * The maximum number of events to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * The types of events to return; pass null to get chat events of all types
   * @type {chatEventLogFilters$Input} {@link chatEventLogFilters}
   */
  readonly filters?: chatEventLogFilters$Input | null;

  /**
   * User identifiers by which to filter events. By default, events relating to all users will be returned
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id)
 */
export type getChatEventLog$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Search query by which to filter events
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of an event from which to return results. Use 0 to get results from the latest events
   * @type {int64$Input} {@link int64}
   */
  readonly from_event_id?: int64$Input;

  /**
   * The maximum number of events to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * The types of events to return; pass null to get chat events of all types
   * @type {chatEventLogFilters$Input} {@link chatEventLogFilters}
   */
  readonly filters?: chatEventLogFilters$Input | null;

  /**
   * User identifiers by which to filter events. By default, events relating to all users will be returned
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id)
 *
 * @param {getChatEventLog$Input} parameters {@link getChatEventLog$Input}
 * @return {ChatEvents} {@link ChatEvents}
 */
export type getChatEventLog = (parameters: getChatEventLog$Input) => ChatEvents;

/**
 * Returns an invoice payment form. This method must be called when the user presses inline button of the type inlineKeyboardButtonTypeBuy
 */
export type getPaymentForm$Input = {
  readonly _: "getPaymentForm";

  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * Preferred payment form theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;
};

/**
 * Returns an invoice payment form. This method must be called when the user presses inline button of the type inlineKeyboardButtonTypeBuy
 */
export type getPaymentForm$DirectInput = {
  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * Preferred payment form theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input | null;
};

/**
 * Returns an invoice payment form. This method must be called when the user presses inline button of the type inlineKeyboardButtonTypeBuy
 *
 * @param {getPaymentForm$Input} parameters {@link getPaymentForm$Input}
 * @return {PaymentForm} {@link PaymentForm}
 */
export type getPaymentForm = (parameters: getPaymentForm$Input) => PaymentForm;

/**
 * Validates the order information provided by a user and returns the available shipping options for a flexible invoice
 */
export type validateOrderInfo$Input = {
  readonly _: "validateOrderInfo";

  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * The order information, provided by the user; pass null if empty
   * @type {orderInfo$Input} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input | null;

  /**
   * Pass true to save the order information
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_save?: Bool$Input;
};

/**
 * Validates the order information provided by a user and returns the available shipping options for a flexible invoice
 */
export type validateOrderInfo$DirectInput = {
  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * The order information, provided by the user; pass null if empty
   * @type {orderInfo$Input} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input | null;

  /**
   * Pass true to save the order information
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_save?: Bool$Input;
};

/**
 * Validates the order information provided by a user and returns the available shipping options for a flexible invoice
 *
 * @param {validateOrderInfo$Input} parameters {@link validateOrderInfo$Input}
 * @return {ValidatedOrderInfo} {@link ValidatedOrderInfo}
 */
export type validateOrderInfo = (
  parameters: validateOrderInfo$Input
) => ValidatedOrderInfo;

/**
 * Sends a filled-out payment form to the bot for final verification
 */
export type sendPaymentForm$Input = {
  readonly _: "sendPaymentForm";

  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * Payment form identifier returned by getPaymentForm
   * @type {int64$Input} {@link int64}
   */
  readonly payment_form_id?: int64$Input;

  /**
   * Identifier returned by validateOrderInfo, or an empty string
   * @type {string} {@link string}
   */
  readonly order_info_id?: string;

  /**
   * Identifier of a chosen shipping option, if applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * The credentials chosen by user for payment
   * @type {InputCredentials$Input} {@link InputCredentials}
   */
  readonly credentials?: InputCredentials$Input;

  /**
   * Chosen by the user amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly tip_amount?: int53;
};

/**
 * Sends a filled-out payment form to the bot for final verification
 */
export type sendPaymentForm$DirectInput = {
  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * Payment form identifier returned by getPaymentForm
   * @type {int64$Input} {@link int64}
   */
  readonly payment_form_id?: int64$Input;

  /**
   * Identifier returned by validateOrderInfo, or an empty string
   * @type {string} {@link string}
   */
  readonly order_info_id?: string;

  /**
   * Identifier of a chosen shipping option, if applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * The credentials chosen by user for payment
   * @type {InputCredentials$Input} {@link InputCredentials}
   */
  readonly credentials?: InputCredentials$Input;

  /**
   * Chosen by the user amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly tip_amount?: int53;
};

/**
 * Sends a filled-out payment form to the bot for final verification
 *
 * @param {sendPaymentForm$Input} parameters {@link sendPaymentForm$Input}
 * @return {PaymentResult} {@link PaymentResult}
 */
export type sendPaymentForm = (parameters: sendPaymentForm$Input) => PaymentResult;

/**
 * Returns information about a successful payment
 */
export type getPaymentReceipt$Input = {
  readonly _: "getPaymentReceipt";

  /**
   * Chat identifier of the messagePaymentSuccessful message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a successful payment
 */
export type getPaymentReceipt$DirectInput = {
  /**
   * Chat identifier of the messagePaymentSuccessful message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a successful payment
 *
 * @param {getPaymentReceipt$Input} parameters {@link getPaymentReceipt$Input}
 * @return {PaymentReceipt} {@link PaymentReceipt}
 */
export type getPaymentReceipt = (
  parameters: getPaymentReceipt$Input
) => PaymentReceipt;

/**
 * Returns saved order information. Returns a 404 error if there is no saved order information
 */
export type getSavedOrderInfo$Input = {
  readonly _: "getSavedOrderInfo";
};

/**
 * Returns saved order information. Returns a 404 error if there is no saved order information
 */
export type getSavedOrderInfo$DirectInput = {};

/**
 * Returns saved order information. Returns a 404 error if there is no saved order information
 *
 * @param {getSavedOrderInfo$Input} parameters {@link getSavedOrderInfo$Input}
 * @return {OrderInfo} {@link OrderInfo}
 */
export type getSavedOrderInfo = (parameters: getSavedOrderInfo$Input) => OrderInfo;

/**
 * Deletes saved order information
 */
export type deleteSavedOrderInfo$Input = {
  readonly _: "deleteSavedOrderInfo";
};

/**
 * Deletes saved order information
 */
export type deleteSavedOrderInfo$DirectInput = {};

/**
 * Deletes saved order information
 *
 * @param {deleteSavedOrderInfo$Input} parameters {@link deleteSavedOrderInfo$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteSavedOrderInfo = (parameters: deleteSavedOrderInfo$Input) => Ok;

/**
 * Deletes saved credentials for all payment provider bots
 */
export type deleteSavedCredentials$Input = {
  readonly _: "deleteSavedCredentials";
};

/**
 * Deletes saved credentials for all payment provider bots
 */
export type deleteSavedCredentials$DirectInput = {};

/**
 * Deletes saved credentials for all payment provider bots
 *
 * @param {deleteSavedCredentials$Input} parameters {@link deleteSavedCredentials$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteSavedCredentials = (
  parameters: deleteSavedCredentials$Input
) => Ok;

/**
 * Creates a link for the given invoice; for bots only
 */
export type createInvoiceLink$Input = {
  readonly _: "createInvoiceLink";

  /**
   * Information about the invoice of the type inputMessageInvoice
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly invoice?: InputMessageContent$Input;
};

/**
 * Creates a link for the given invoice; for bots only
 */
export type createInvoiceLink$DirectInput = {
  /**
   * Information about the invoice of the type inputMessageInvoice
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly invoice?: InputMessageContent$Input;
};

/**
 * Creates a link for the given invoice; for bots only
 *
 * @param {createInvoiceLink$Input} parameters {@link createInvoiceLink$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type createInvoiceLink = (parameters: createInvoiceLink$Input) => HttpUrl;

/**
 * Returns a user that can be contacted to get support
 */
export type getSupportUser$Input = {
  readonly _: "getSupportUser";
};

/**
 * Returns a user that can be contacted to get support
 */
export type getSupportUser$DirectInput = {};

/**
 * Returns a user that can be contacted to get support
 *
 * @param {getSupportUser$Input} parameters {@link getSupportUser$Input}
 * @return {User} {@link User}
 */
export type getSupportUser = (parameters: getSupportUser$Input) => User;

/**
 * Constructs a persistent HTTP URL for a background
 */
export type getBackgroundUrl$Input = {
  readonly _: "getBackgroundUrl";

  /**
   * Background name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Background type; backgroundTypeChatTheme isn't supported
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input;
};

/**
 * Constructs a persistent HTTP URL for a background
 */
export type getBackgroundUrl$DirectInput = {
  /**
   * Background name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Background type; backgroundTypeChatTheme isn't supported
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input;
};

/**
 * Constructs a persistent HTTP URL for a background
 *
 * @param {getBackgroundUrl$Input} parameters {@link getBackgroundUrl$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getBackgroundUrl = (parameters: getBackgroundUrl$Input) => HttpUrl;

/**
 * Searches for a background by its name
 */
export type searchBackground$Input = {
  readonly _: "searchBackground";

  /**
   * The name of the background
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Searches for a background by its name
 */
export type searchBackground$DirectInput = {
  /**
   * The name of the background
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Searches for a background by its name
 *
 * @param {searchBackground$Input} parameters {@link searchBackground$Input}
 * @return {Background} {@link Background}
 */
export type searchBackground = (parameters: searchBackground$Input) => Background;

/**
 * Sets default background for chats; adds the background to the list of installed backgrounds
 */
export type setDefaultBackground$Input = {
  readonly _: "setDefaultBackground";

  /**
   * The input background to use; pass null to create a new filled background
   * @type {InputBackground$Input} {@link InputBackground}
   */
  readonly background?: InputBackground$Input | null;

  /**
   * Background type; pass null to use the default type of the remote background; backgroundTypeChatTheme isn't supported
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input | null;

  /**
   * Pass true if the background is set for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Sets default background for chats; adds the background to the list of installed backgrounds
 */
export type setDefaultBackground$DirectInput = {
  /**
   * The input background to use; pass null to create a new filled background
   * @type {InputBackground$Input} {@link InputBackground}
   */
  readonly background?: InputBackground$Input | null;

  /**
   * Background type; pass null to use the default type of the remote background; backgroundTypeChatTheme isn't supported
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input | null;

  /**
   * Pass true if the background is set for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Sets default background for chats; adds the background to the list of installed backgrounds
 *
 * @param {setDefaultBackground$Input} parameters {@link setDefaultBackground$Input}
 * @return {Background} {@link Background}
 */
export type setDefaultBackground = (
  parameters: setDefaultBackground$Input
) => Background;

/**
 * Deletes default background for chats
 */
export type deleteDefaultBackground$Input = {
  readonly _: "deleteDefaultBackground";

  /**
   * Pass true if the background is deleted for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Deletes default background for chats
 */
export type deleteDefaultBackground$DirectInput = {
  /**
   * Pass true if the background is deleted for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Deletes default background for chats
 *
 * @param {deleteDefaultBackground$Input} parameters {@link deleteDefaultBackground$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteDefaultBackground = (
  parameters: deleteDefaultBackground$Input
) => Ok;

/**
 * Returns backgrounds installed by the user
 */
export type getInstalledBackgrounds$Input = {
  readonly _: "getInstalledBackgrounds";

  /**
   * Pass true to order returned backgrounds for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Returns backgrounds installed by the user
 */
export type getInstalledBackgrounds$DirectInput = {
  /**
   * Pass true to order returned backgrounds for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Returns backgrounds installed by the user
 *
 * @param {getInstalledBackgrounds$Input} parameters {@link getInstalledBackgrounds$Input}
 * @return {Backgrounds} {@link Backgrounds}
 */
export type getInstalledBackgrounds = (
  parameters: getInstalledBackgrounds$Input
) => Backgrounds;

/**
 * Removes background from the list of installed backgrounds
 */
export type removeInstalledBackground$Input = {
  readonly _: "removeInstalledBackground";

  /**
   * The background identifier
   * @type {int64$Input} {@link int64}
   */
  readonly background_id?: int64$Input;
};

/**
 * Removes background from the list of installed backgrounds
 */
export type removeInstalledBackground$DirectInput = {
  /**
   * The background identifier
   * @type {int64$Input} {@link int64}
   */
  readonly background_id?: int64$Input;
};

/**
 * Removes background from the list of installed backgrounds
 *
 * @param {removeInstalledBackground$Input} parameters {@link removeInstalledBackground$Input}
 * @return {Ok} {@link Ok}
 */
export type removeInstalledBackground = (
  parameters: removeInstalledBackground$Input
) => Ok;

/**
 * Resets list of installed backgrounds to its default value
 */
export type resetInstalledBackgrounds$Input = {
  readonly _: "resetInstalledBackgrounds";
};

/**
 * Resets list of installed backgrounds to its default value
 */
export type resetInstalledBackgrounds$DirectInput = {};

/**
 * Resets list of installed backgrounds to its default value
 *
 * @param {resetInstalledBackgrounds$Input} parameters {@link resetInstalledBackgrounds$Input}
 * @return {Ok} {@link Ok}
 */
export type resetInstalledBackgrounds = (
  parameters: resetInstalledBackgrounds$Input
) => Ok;

/**
 * Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
 */
export type getLocalizationTargetInfo$Input = {
  readonly _: "getLocalizationTargetInfo";

  /**
   * Pass true to get only locally available information without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
 */
export type getLocalizationTargetInfo$DirectInput = {
  /**
   * Pass true to get only locally available information without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
 *
 * @param {getLocalizationTargetInfo$Input} parameters {@link getLocalizationTargetInfo$Input}
 * @return {LocalizationTargetInfo} {@link LocalizationTargetInfo}
 */
export type getLocalizationTargetInfo = (
  parameters: getLocalizationTargetInfo$Input
) => LocalizationTargetInfo;

/**
 * Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
 */
export type getLanguagePackInfo$Input = {
  readonly _: "getLanguagePackInfo";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
 */
export type getLanguagePackInfo$DirectInput = {
  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
 *
 * @param {getLanguagePackInfo$Input} parameters {@link getLanguagePackInfo$Input}
 * @return {LanguagePackInfo} {@link LanguagePackInfo}
 */
export type getLanguagePackInfo = (
  parameters: getLanguagePackInfo$Input
) => LanguagePackInfo;

/**
 * Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
 */
export type getLanguagePackStrings$Input = {
  readonly _: "getLanguagePackStrings";

  /**
   * Language pack identifier of the strings to be returned
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * Language pack keys of the strings to be returned; leave empty to request all available strings
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly keys?: vector$Input<string>;
};

/**
 * Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
 */
export type getLanguagePackStrings$DirectInput = {
  /**
   * Language pack identifier of the strings to be returned
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * Language pack keys of the strings to be returned; leave empty to request all available strings
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly keys?: vector$Input<string>;
};

/**
 * Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
 *
 * @param {getLanguagePackStrings$Input} parameters {@link getLanguagePackStrings$Input}
 * @return {LanguagePackStrings} {@link LanguagePackStrings}
 */
export type getLanguagePackStrings = (
  parameters: getLanguagePackStrings$Input
) => LanguagePackStrings;

/**
 * Fetches the latest versions of all strings from a language pack in the current localization target from the server.
 *
 * - This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
 */
export type synchronizeLanguagePack$Input = {
  readonly _: "synchronizeLanguagePack";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Fetches the latest versions of all strings from a language pack in the current localization target from the server.
 *
 * - This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
 */
export type synchronizeLanguagePack$DirectInput = {
  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Fetches the latest versions of all strings from a language pack in the current localization target from the server.
 *
 * - This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
 *
 * @param {synchronizeLanguagePack$Input} parameters {@link synchronizeLanguagePack$Input}
 * @return {Ok} {@link Ok}
 */
export type synchronizeLanguagePack = (
  parameters: synchronizeLanguagePack$Input
) => Ok;

/**
 * Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
 */
export type addCustomServerLanguagePack$Input = {
  readonly _: "addCustomServerLanguagePack";

  /**
   * Identifier of a language pack to be added
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
 */
export type addCustomServerLanguagePack$DirectInput = {
  /**
   * Identifier of a language pack to be added
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
 *
 * @param {addCustomServerLanguagePack$Input} parameters {@link addCustomServerLanguagePack$Input}
 * @return {Ok} {@link Ok}
 */
export type addCustomServerLanguagePack = (
  parameters: addCustomServerLanguagePack$Input
) => Ok;

/**
 * Adds or changes a custom local language pack to the current localization target
 */
export type setCustomLanguagePack$Input = {
  readonly _: "setCustomLanguagePack";

  /**
   * Information about the language pack. Language pack identifier must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization
   * @type {languagePackInfo$Input} {@link languagePackInfo}
   */
  readonly info?: languagePackInfo$Input;

  /**
   * Strings of the new language pack
   * @type {vector$Input<languagePackString$Input>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/**
 * Adds or changes a custom local language pack to the current localization target
 */
export type setCustomLanguagePack$DirectInput = {
  /**
   * Information about the language pack. Language pack identifier must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization
   * @type {languagePackInfo$Input} {@link languagePackInfo}
   */
  readonly info?: languagePackInfo$Input;

  /**
   * Strings of the new language pack
   * @type {vector$Input<languagePackString$Input>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/**
 * Adds or changes a custom local language pack to the current localization target
 *
 * @param {setCustomLanguagePack$Input} parameters {@link setCustomLanguagePack$Input}
 * @return {Ok} {@link Ok}
 */
export type setCustomLanguagePack = (parameters: setCustomLanguagePack$Input) => Ok;

/**
 * Edits information about a custom local language pack in the current localization target. Can be called before authorization
 */
export type editCustomLanguagePackInfo$Input = {
  readonly _: "editCustomLanguagePackInfo";

  /**
   * New information about the custom local language pack
   * @type {languagePackInfo$Input} {@link languagePackInfo}
   */
  readonly info?: languagePackInfo$Input;
};

/**
 * Edits information about a custom local language pack in the current localization target. Can be called before authorization
 */
export type editCustomLanguagePackInfo$DirectInput = {
  /**
   * New information about the custom local language pack
   * @type {languagePackInfo$Input} {@link languagePackInfo}
   */
  readonly info?: languagePackInfo$Input;
};

/**
 * Edits information about a custom local language pack in the current localization target. Can be called before authorization
 *
 * @param {editCustomLanguagePackInfo$Input} parameters {@link editCustomLanguagePackInfo$Input}
 * @return {Ok} {@link Ok}
 */
export type editCustomLanguagePackInfo = (
  parameters: editCustomLanguagePackInfo$Input
) => Ok;

/**
 * Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
 */
export type setCustomLanguagePackString$Input = {
  readonly _: "setCustomLanguagePackString";

  /**
   * Identifier of a previously added custom local language pack in the current localization target
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * New language pack string
   * @type {languagePackString$Input} {@link languagePackString}
   */
  readonly new_string?: languagePackString$Input;
};

/**
 * Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
 */
export type setCustomLanguagePackString$DirectInput = {
  /**
   * Identifier of a previously added custom local language pack in the current localization target
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * New language pack string
   * @type {languagePackString$Input} {@link languagePackString}
   */
  readonly new_string?: languagePackString$Input;
};

/**
 * Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
 *
 * @param {setCustomLanguagePackString$Input} parameters {@link setCustomLanguagePackString$Input}
 * @return {Ok} {@link Ok}
 */
export type setCustomLanguagePackString = (
  parameters: setCustomLanguagePackString$Input
) => Ok;

/**
 * Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted.
 *
 * - Can be called before authorization
 */
export type deleteLanguagePack$Input = {
  readonly _: "deleteLanguagePack";

  /**
   * Identifier of the language pack to delete
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted.
 *
 * - Can be called before authorization
 */
export type deleteLanguagePack$DirectInput = {
  /**
   * Identifier of the language pack to delete
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted.
 *
 * - Can be called before authorization
 *
 * @param {deleteLanguagePack$Input} parameters {@link deleteLanguagePack$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteLanguagePack = (parameters: deleteLanguagePack$Input) => Ok;

/**
 * Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
 */
export type registerDevice$Input = {
  readonly _: "registerDevice";

  /**
   * Device token
   * @type {DeviceToken$Input} {@link DeviceToken}
   */
  readonly device_token?: DeviceToken$Input;

  /**
   * List of user identifiers of other users currently using the application
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly other_user_ids?: vector$Input<int53>;
};

/**
 * Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
 */
export type registerDevice$DirectInput = {
  /**
   * Device token
   * @type {DeviceToken$Input} {@link DeviceToken}
   */
  readonly device_token?: DeviceToken$Input;

  /**
   * List of user identifiers of other users currently using the application
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly other_user_ids?: vector$Input<int53>;
};

/**
 * Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
 *
 * @param {registerDevice$Input} parameters {@link registerDevice$Input}
 * @return {PushReceiverId} {@link PushReceiverId}
 */
export type registerDevice = (parameters: registerDevice$Input) => PushReceiverId;

/**
 * Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
 */
export type processPushNotification$Input = {
  readonly _: "processPushNotification";

  /**
   * JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
 */
export type processPushNotification$DirectInput = {
  /**
   * JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
 *
 * @param {processPushNotification$Input} parameters {@link processPushNotification$Input}
 * @return {Ok} {@link Ok}
 */
export type processPushNotification = (
  parameters: processPushNotification$Input
) => Ok;

/**
 * Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
 */
export type getPushReceiverId$Input = {
  readonly _: "getPushReceiverId";

  /**
   * JSON-encoded push notification payload
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
 */
export type getPushReceiverId$DirectInput = {
  /**
   * JSON-encoded push notification payload
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
 *
 * @param {getPushReceiverId$Input} parameters {@link getPushReceiverId$Input}
 * @return {PushReceiverId} {@link PushReceiverId}
 */
export type getPushReceiverId = (
  parameters: getPushReceiverId$Input
) => PushReceiverId;

/**
 * Returns t.me URLs recently visited by a newly registered user
 */
export type getRecentlyVisitedTMeUrls$Input = {
  readonly _: "getRecentlyVisitedTMeUrls";

  /**
   * Google Play referrer to identify the user
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/**
 * Returns t.me URLs recently visited by a newly registered user
 */
export type getRecentlyVisitedTMeUrls$DirectInput = {
  /**
   * Google Play referrer to identify the user
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/**
 * Returns t.me URLs recently visited by a newly registered user
 *
 * @param {getRecentlyVisitedTMeUrls$Input} parameters {@link getRecentlyVisitedTMeUrls$Input}
 * @return {TMeUrls} {@link TMeUrls}
 */
export type getRecentlyVisitedTMeUrls = (
  parameters: getRecentlyVisitedTMeUrls$Input
) => TMeUrls;

/**
 * Changes user privacy settings
 */
export type setUserPrivacySettingRules$Input = {
  readonly _: "setUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting$Input} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;

  /**
   * The new privacy rules
   * @type {userPrivacySettingRules$Input} {@link userPrivacySettingRules}
   */
  readonly rules?: userPrivacySettingRules$Input;
};

/**
 * Changes user privacy settings
 */
export type setUserPrivacySettingRules$DirectInput = {
  /**
   * The privacy setting
   * @type {UserPrivacySetting$Input} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;

  /**
   * The new privacy rules
   * @type {userPrivacySettingRules$Input} {@link userPrivacySettingRules}
   */
  readonly rules?: userPrivacySettingRules$Input;
};

/**
 * Changes user privacy settings
 *
 * @param {setUserPrivacySettingRules$Input} parameters {@link setUserPrivacySettingRules$Input}
 * @return {Ok} {@link Ok}
 */
export type setUserPrivacySettingRules = (
  parameters: setUserPrivacySettingRules$Input
) => Ok;

/**
 * Returns the current privacy settings
 */
export type getUserPrivacySettingRules$Input = {
  readonly _: "getUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting$Input} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;
};

/**
 * Returns the current privacy settings
 */
export type getUserPrivacySettingRules$DirectInput = {
  /**
   * The privacy setting
   * @type {UserPrivacySetting$Input} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;
};

/**
 * Returns the current privacy settings
 *
 * @param {getUserPrivacySettingRules$Input} parameters {@link getUserPrivacySettingRules$Input}
 * @return {UserPrivacySettingRules} {@link UserPrivacySettingRules}
 */
export type getUserPrivacySettingRules = (
  parameters: getUserPrivacySettingRules$Input
) => UserPrivacySettingRules;

/**
 * Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
 */
export type getOption$Input = {
  readonly _: "getOption";

  /**
   * The name of the option
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
 */
export type getOption$DirectInput = {
  /**
   * The name of the option
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
 *
 * @param {getOption$Input} parameters {@link getOption$Input}
 * @return {OptionValue} {@link OptionValue}
 */
export type getOption = (parameters: getOption$Input) => OptionValue;

/**
 * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
 */
export type setOption$Input = {
  readonly _: "setOption";

  /**
   * The name of the option
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * The new value of the option; pass null to reset option value to a default value
   * @type {OptionValue$Input} {@link OptionValue}
   */
  readonly value?: OptionValue$Input | null;
};

/**
 * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
 */
export type setOption$DirectInput = {
  /**
   * The name of the option
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * The new value of the option; pass null to reset option value to a default value
   * @type {OptionValue$Input} {@link OptionValue}
   */
  readonly value?: OptionValue$Input | null;
};

/**
 * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
 *
 * @param {setOption$Input} parameters {@link setOption$Input}
 * @return {Ok} {@link Ok}
 */
export type setOption = (parameters: setOption$Input) => Ok;

/**
 * Changes the period of inactivity after which the account of the current user will automatically be deleted
 */
export type setAccountTtl$Input = {
  readonly _: "setAccountTtl";

  /**
   * New account TTL
   * @type {accountTtl$Input} {@link accountTtl}
   */
  readonly ttl?: accountTtl$Input;
};

/**
 * Changes the period of inactivity after which the account of the current user will automatically be deleted
 */
export type setAccountTtl$DirectInput = {
  /**
   * New account TTL
   * @type {accountTtl$Input} {@link accountTtl}
   */
  readonly ttl?: accountTtl$Input;
};

/**
 * Changes the period of inactivity after which the account of the current user will automatically be deleted
 *
 * @param {setAccountTtl$Input} parameters {@link setAccountTtl$Input}
 * @return {Ok} {@link Ok}
 */
export type setAccountTtl = (parameters: setAccountTtl$Input) => Ok;

/**
 * Returns the period of inactivity after which the account of the current user will automatically be deleted
 */
export type getAccountTtl$Input = {
  readonly _: "getAccountTtl";
};

/**
 * Returns the period of inactivity after which the account of the current user will automatically be deleted
 */
export type getAccountTtl$DirectInput = {};

/**
 * Returns the period of inactivity after which the account of the current user will automatically be deleted
 *
 * @param {getAccountTtl$Input} parameters {@link getAccountTtl$Input}
 * @return {AccountTtl} {@link AccountTtl}
 */
export type getAccountTtl = (parameters: getAccountTtl$Input) => AccountTtl;

/**
 * Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account.
 *
 * - Can be called before authorization when the current authorization state is authorizationStateWaitPassword
 */
export type deleteAccount$Input = {
  readonly _: "deleteAccount";

  /**
   * The reason why the account was deleted; optional
   * @type {string} {@link string}
   */
  readonly reason?: string;

  /**
   * The 2-step verification password of the current user. If not specified, account deletion can be canceled within one week
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account.
 *
 * - Can be called before authorization when the current authorization state is authorizationStateWaitPassword
 */
export type deleteAccount$DirectInput = {
  /**
   * The reason why the account was deleted; optional
   * @type {string} {@link string}
   */
  readonly reason?: string;

  /**
   * The 2-step verification password of the current user. If not specified, account deletion can be canceled within one week
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account.
 *
 * - Can be called before authorization when the current authorization state is authorizationStateWaitPassword
 *
 * @param {deleteAccount$Input} parameters {@link deleteAccount$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteAccount = (parameters: deleteAccount$Input) => Ok;

/**
 * Changes the default message auto-delete time for new chats
 */
export type setDefaultMessageAutoDeleteTime$Input = {
  readonly _: "setDefaultMessageAutoDeleteTime";

  /**
   * New default message auto-delete time; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {messageAutoDeleteTime$Input} {@link messageAutoDeleteTime}
   */
  readonly message_auto_delete_time?: messageAutoDeleteTime$Input;
};

/**
 * Changes the default message auto-delete time for new chats
 */
export type setDefaultMessageAutoDeleteTime$DirectInput = {
  /**
   * New default message auto-delete time; must be from 0 up to 365 * 86400 and be divisible by 86400. If 0, then messages aren't deleted automatically
   * @type {messageAutoDeleteTime$Input} {@link messageAutoDeleteTime}
   */
  readonly message_auto_delete_time?: messageAutoDeleteTime$Input;
};

/**
 * Changes the default message auto-delete time for new chats
 *
 * @param {setDefaultMessageAutoDeleteTime$Input} parameters {@link setDefaultMessageAutoDeleteTime$Input}
 * @return {Ok} {@link Ok}
 */
export type setDefaultMessageAutoDeleteTime = (
  parameters: setDefaultMessageAutoDeleteTime$Input
) => Ok;

/**
 * Returns default message auto-delete time setting for new chats
 */
export type getDefaultMessageAutoDeleteTime$Input = {
  readonly _: "getDefaultMessageAutoDeleteTime";
};

/**
 * Returns default message auto-delete time setting for new chats
 */
export type getDefaultMessageAutoDeleteTime$DirectInput = {};

/**
 * Returns default message auto-delete time setting for new chats
 *
 * @param {getDefaultMessageAutoDeleteTime$Input} parameters {@link getDefaultMessageAutoDeleteTime$Input}
 * @return {MessageAutoDeleteTime} {@link MessageAutoDeleteTime}
 */
export type getDefaultMessageAutoDeleteTime = (
  parameters: getDefaultMessageAutoDeleteTime$Input
) => MessageAutoDeleteTime;

/**
 * Removes a chat action bar without any other action
 */
export type removeChatActionBar$Input = {
  readonly _: "removeChatActionBar";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat action bar without any other action
 */
export type removeChatActionBar$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat action bar without any other action
 *
 * @param {removeChatActionBar$Input} parameters {@link removeChatActionBar$Input}
 * @return {Ok} {@link Ok}
 */
export type removeChatActionBar = (parameters: removeChatActionBar$Input) => Ok;

/**
 * Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported
 */
export type reportChat$Input = {
  readonly _: "reportChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of reported messages; may be empty to report the whole chat
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * The reason for reporting the chat
   * @type {ReportReason$Input} {@link ReportReason}
   */
  readonly reason?: ReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported
 */
export type reportChat$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of reported messages; may be empty to report the whole chat
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * The reason for reporting the chat
   * @type {ReportReason$Input} {@link ReportReason}
   */
  readonly reason?: ReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported
 *
 * @param {reportChat$Input} parameters {@link reportChat$Input}
 * @return {Ok} {@link Ok}
 */
export type reportChat = (parameters: reportChat$Input) => Ok;

/**
 * Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported
 */
export type reportChatPhoto$Input = {
  readonly _: "reportChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the photo to report. Only full photos from chatPhoto can be reported
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The reason for reporting the chat photo
   * @type {ReportReason$Input} {@link ReportReason}
   */
  readonly reason?: ReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported
 */
export type reportChatPhoto$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the photo to report. Only full photos from chatPhoto can be reported
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The reason for reporting the chat photo
   * @type {ReportReason$Input} {@link ReportReason}
   */
  readonly reason?: ReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported
 *
 * @param {reportChatPhoto$Input} parameters {@link reportChatPhoto$Input}
 * @return {Ok} {@link Ok}
 */
export type reportChatPhoto = (parameters: reportChatPhoto$Input) => Ok;

/**
 * Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions
 */
export type reportMessageReactions$Input = {
  readonly _: "reportMessageReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the sender, which added the reaction
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/**
 * Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions
 */
export type reportMessageReactions$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the sender, which added the reaction
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/**
 * Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions
 *
 * @param {reportMessageReactions$Input} parameters {@link reportMessageReactions$Input}
 * @return {Ok} {@link Ok}
 */
export type reportMessageReactions = (
  parameters: reportMessageReactions$Input
) => Ok;

/**
 * Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
 */
export type getChatStatistics$Input = {
  readonly _: "getChatStatistics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
 */
export type getChatStatistics$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
 *
 * @param {getChatStatistics$Input} parameters {@link getChatStatistics$Input}
 * @return {ChatStatistics} {@link ChatStatistics}
 */
export type getChatStatistics = (
  parameters: getChatStatistics$Input
) => ChatStatistics;

/**
 * Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
 */
export type getMessageStatistics$Input = {
  readonly _: "getMessageStatistics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
 */
export type getMessageStatistics$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
 *
 * @param {getMessageStatistics$Input} parameters {@link getMessageStatistics$Input}
 * @return {MessageStatistics} {@link MessageStatistics}
 */
export type getMessageStatistics = (
  parameters: getMessageStatistics$Input
) => MessageStatistics;

/**
 * Returns forwarded copies of a channel message to different public channels and public reposts as a story. Can be used only if message.can_get_statistics == true. For optimal performance, the number of returned messages and stories is chosen by TDLib
 */
export type getMessagePublicForwards$Input = {
  readonly _: "getMessagePublicForwards";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages and stories to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned objects is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns forwarded copies of a channel message to different public channels and public reposts as a story. Can be used only if message.can_get_statistics == true. For optimal performance, the number of returned messages and stories is chosen by TDLib
 */
export type getMessagePublicForwards$DirectInput = {
  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages and stories to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned objects is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns forwarded copies of a channel message to different public channels and public reposts as a story. Can be used only if message.can_get_statistics == true. For optimal performance, the number of returned messages and stories is chosen by TDLib
 *
 * @param {getMessagePublicForwards$Input} parameters {@link getMessagePublicForwards$Input}
 * @return {PublicForwards} {@link PublicForwards}
 */
export type getMessagePublicForwards = (
  parameters: getMessagePublicForwards$Input
) => PublicForwards;

/**
 * Returns detailed statistics about a story. Can be used only if story.can_get_statistics == true
 */
export type getStoryStatistics$Input = {
  readonly _: "getStoryStatistics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a story. Can be used only if story.can_get_statistics == true
 */
export type getStoryStatistics$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Story identifier
   * @type {int32} {@link int32}
   */
  readonly story_id?: int32;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a story. Can be used only if story.can_get_statistics == true
 *
 * @param {getStoryStatistics$Input} parameters {@link getStoryStatistics$Input}
 * @return {StoryStatistics} {@link StoryStatistics}
 */
export type getStoryStatistics = (
  parameters: getStoryStatistics$Input
) => StoryStatistics;

/**
 * Loads an asynchronous or a zoomed in statistical graph
 */
export type getStatisticalGraph$Input = {
  readonly _: "getStatisticalGraph";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The token for graph loading
   * @type {string} {@link string}
   */
  readonly token?: string;

  /**
   * X-value for zoomed in graph or 0 otherwise
   * @type {int53} {@link int53}
   */
  readonly x?: int53;
};

/**
 * Loads an asynchronous or a zoomed in statistical graph
 */
export type getStatisticalGraph$DirectInput = {
  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The token for graph loading
   * @type {string} {@link string}
   */
  readonly token?: string;

  /**
   * X-value for zoomed in graph or 0 otherwise
   * @type {int53} {@link int53}
   */
  readonly x?: int53;
};

/**
 * Loads an asynchronous or a zoomed in statistical graph
 *
 * @param {getStatisticalGraph$Input} parameters {@link getStatisticalGraph$Input}
 * @return {StatisticalGraph} {@link StatisticalGraph}
 */
export type getStatisticalGraph = (
  parameters: getStatisticalGraph$Input
) => StatisticalGraph;

/**
 * Returns storage usage statistics. Can be called before authorization
 */
export type getStorageStatistics$Input = {
  readonly _: "getStorageStatistics";

  /**
   * The maximum number of chats with the largest storage usage for which separate statistics need to be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0
   * @type {int32} {@link int32}
   */
  readonly chat_limit?: int32;
};

/**
 * Returns storage usage statistics. Can be called before authorization
 */
export type getStorageStatistics$DirectInput = {
  /**
   * The maximum number of chats with the largest storage usage for which separate statistics need to be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0
   * @type {int32} {@link int32}
   */
  readonly chat_limit?: int32;
};

/**
 * Returns storage usage statistics. Can be called before authorization
 *
 * @param {getStorageStatistics$Input} parameters {@link getStorageStatistics$Input}
 * @return {StorageStatistics} {@link StorageStatistics}
 */
export type getStorageStatistics = (
  parameters: getStorageStatistics$Input
) => StorageStatistics;

/**
 * Quickly returns approximate storage usage statistics. Can be called before authorization
 */
export type getStorageStatisticsFast$Input = {
  readonly _: "getStorageStatisticsFast";
};

/**
 * Quickly returns approximate storage usage statistics. Can be called before authorization
 */
export type getStorageStatisticsFast$DirectInput = {};

/**
 * Quickly returns approximate storage usage statistics. Can be called before authorization
 *
 * @param {getStorageStatisticsFast$Input} parameters {@link getStorageStatisticsFast$Input}
 * @return {StorageStatisticsFast} {@link StorageStatisticsFast}
 */
export type getStorageStatisticsFast = (
  parameters: getStorageStatisticsFast$Input
) => StorageStatisticsFast;

/**
 * Returns database statistics
 */
export type getDatabaseStatistics$Input = {
  readonly _: "getDatabaseStatistics";
};

/**
 * Returns database statistics
 */
export type getDatabaseStatistics$DirectInput = {};

/**
 * Returns database statistics
 *
 * @param {getDatabaseStatistics$Input} parameters {@link getDatabaseStatistics$Input}
 * @return {DatabaseStatistics} {@link DatabaseStatistics}
 */
export type getDatabaseStatistics = (
  parameters: getDatabaseStatistics$Input
) => DatabaseStatistics;

/**
 * Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
 */
export type optimizeStorage$Input = {
  readonly _: "optimizeStorage";

  /**
   * Limit on the total size of files after deletion, in bytes. Pass -1 to use the default limit
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;

  /**
   * Limit on the total number of files after deletion. Pass -1 to use the default limit
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value
   * @type {int32} {@link int32}
   */
  readonly immunity_delay?: int32;

  /**
   * If non-empty, only files with the given types are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted
   * @type {vector$Input<FileType$Input>} {@link vector<FileType>}
   */
  readonly file_types?: vector$Input<FileType$Input>;

  /**
   * If non-empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;

  /**
   * If non-empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly exclude_chat_ids?: vector$Input<int53>;

  /**
   * Pass true if statistics about the files that were deleted must be returned instead of the whole storage usage statistics. Affects only returned statistics
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_deleted_file_statistics?: Bool$Input;

  /**
   * Same as in getStorageStatistics. Affects only returned statistics
   * @type {int32} {@link int32}
   */
  readonly chat_limit?: int32;
};

/**
 * Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
 */
export type optimizeStorage$DirectInput = {
  /**
   * Limit on the total size of files after deletion, in bytes. Pass -1 to use the default limit
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;

  /**
   * Limit on the total number of files after deletion. Pass -1 to use the default limit
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value
   * @type {int32} {@link int32}
   */
  readonly immunity_delay?: int32;

  /**
   * If non-empty, only files with the given types are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted
   * @type {vector$Input<FileType$Input>} {@link vector<FileType>}
   */
  readonly file_types?: vector$Input<FileType$Input>;

  /**
   * If non-empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;

  /**
   * If non-empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly exclude_chat_ids?: vector$Input<int53>;

  /**
   * Pass true if statistics about the files that were deleted must be returned instead of the whole storage usage statistics. Affects only returned statistics
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_deleted_file_statistics?: Bool$Input;

  /**
   * Same as in getStorageStatistics. Affects only returned statistics
   * @type {int32} {@link int32}
   */
  readonly chat_limit?: int32;
};

/**
 * Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
 *
 * @param {optimizeStorage$Input} parameters {@link optimizeStorage$Input}
 * @return {StorageStatistics} {@link StorageStatistics}
 */
export type optimizeStorage = (
  parameters: optimizeStorage$Input
) => StorageStatistics;

/**
 * Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks,
 *
 * - so it must be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
 */
export type setNetworkType$Input = {
  readonly _: "setNetworkType";

  /**
   * The new network type; pass null to set network type to networkTypeOther
   * @type {NetworkType$Input} {@link NetworkType}
   */
  readonly type?: NetworkType$Input | null;
};

/**
 * Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks,
 *
 * - so it must be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
 */
export type setNetworkType$DirectInput = {
  /**
   * The new network type; pass null to set network type to networkTypeOther
   * @type {NetworkType$Input} {@link NetworkType}
   */
  readonly type?: NetworkType$Input | null;
};

/**
 * Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks,
 *
 * - so it must be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
 *
 * @param {setNetworkType$Input} parameters {@link setNetworkType$Input}
 * @return {Ok} {@link Ok}
 */
export type setNetworkType = (parameters: setNetworkType$Input) => Ok;

/**
 * Returns network data usage statistics. Can be called before authorization
 */
export type getNetworkStatistics$Input = {
  readonly _: "getNetworkStatistics";

  /**
   * Pass true to get statistics only for the current library launch
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_current?: Bool$Input;
};

/**
 * Returns network data usage statistics. Can be called before authorization
 */
export type getNetworkStatistics$DirectInput = {
  /**
   * Pass true to get statistics only for the current library launch
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_current?: Bool$Input;
};

/**
 * Returns network data usage statistics. Can be called before authorization
 *
 * @param {getNetworkStatistics$Input} parameters {@link getNetworkStatistics$Input}
 * @return {NetworkStatistics} {@link NetworkStatistics}
 */
export type getNetworkStatistics = (
  parameters: getNetworkStatistics$Input
) => NetworkStatistics;

/**
 * Adds the specified data to data usage statistics. Can be called before authorization
 */
export type addNetworkStatistics$Input = {
  readonly _: "addNetworkStatistics";

  /**
   * The network statistics entry with the data to be added to statistics
   * @type {NetworkStatisticsEntry$Input} {@link NetworkStatisticsEntry}
   */
  readonly entry?: NetworkStatisticsEntry$Input;
};

/**
 * Adds the specified data to data usage statistics. Can be called before authorization
 */
export type addNetworkStatistics$DirectInput = {
  /**
   * The network statistics entry with the data to be added to statistics
   * @type {NetworkStatisticsEntry$Input} {@link NetworkStatisticsEntry}
   */
  readonly entry?: NetworkStatisticsEntry$Input;
};

/**
 * Adds the specified data to data usage statistics. Can be called before authorization
 *
 * @param {addNetworkStatistics$Input} parameters {@link addNetworkStatistics$Input}
 * @return {Ok} {@link Ok}
 */
export type addNetworkStatistics = (parameters: addNetworkStatistics$Input) => Ok;

/**
 * Resets all network data usage statistics to zero. Can be called before authorization
 */
export type resetNetworkStatistics$Input = {
  readonly _: "resetNetworkStatistics";
};

/**
 * Resets all network data usage statistics to zero. Can be called before authorization
 */
export type resetNetworkStatistics$DirectInput = {};

/**
 * Resets all network data usage statistics to zero. Can be called before authorization
 *
 * @param {resetNetworkStatistics$Input} parameters {@link resetNetworkStatistics$Input}
 * @return {Ok} {@link Ok}
 */
export type resetNetworkStatistics = (
  parameters: resetNetworkStatistics$Input
) => Ok;

/**
 * Returns auto-download settings presets for the current user
 */
export type getAutoDownloadSettingsPresets$Input = {
  readonly _: "getAutoDownloadSettingsPresets";
};

/**
 * Returns auto-download settings presets for the current user
 */
export type getAutoDownloadSettingsPresets$DirectInput = {};

/**
 * Returns auto-download settings presets for the current user
 *
 * @param {getAutoDownloadSettingsPresets$Input} parameters {@link getAutoDownloadSettingsPresets$Input}
 * @return {AutoDownloadSettingsPresets} {@link AutoDownloadSettingsPresets}
 */
export type getAutoDownloadSettingsPresets = (
  parameters: getAutoDownloadSettingsPresets$Input
) => AutoDownloadSettingsPresets;

/**
 * Sets auto-download settings
 */
export type setAutoDownloadSettings$Input = {
  readonly _: "setAutoDownloadSettings";

  /**
   * New user auto-download settings
   * @type {autoDownloadSettings$Input} {@link autoDownloadSettings}
   */
  readonly settings?: autoDownloadSettings$Input;

  /**
   * Type of the network for which the new settings are relevant
   * @type {NetworkType$Input} {@link NetworkType}
   */
  readonly type?: NetworkType$Input;
};

/**
 * Sets auto-download settings
 */
export type setAutoDownloadSettings$DirectInput = {
  /**
   * New user auto-download settings
   * @type {autoDownloadSettings$Input} {@link autoDownloadSettings}
   */
  readonly settings?: autoDownloadSettings$Input;

  /**
   * Type of the network for which the new settings are relevant
   * @type {NetworkType$Input} {@link NetworkType}
   */
  readonly type?: NetworkType$Input;
};

/**
 * Sets auto-download settings
 *
 * @param {setAutoDownloadSettings$Input} parameters {@link setAutoDownloadSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setAutoDownloadSettings = (
  parameters: setAutoDownloadSettings$Input
) => Ok;

/**
 * Returns autosave settings for the current user
 */
export type getAutosaveSettings$Input = {
  readonly _: "getAutosaveSettings";
};

/**
 * Returns autosave settings for the current user
 */
export type getAutosaveSettings$DirectInput = {};

/**
 * Returns autosave settings for the current user
 *
 * @param {getAutosaveSettings$Input} parameters {@link getAutosaveSettings$Input}
 * @return {AutosaveSettings} {@link AutosaveSettings}
 */
export type getAutosaveSettings = (
  parameters: getAutosaveSettings$Input
) => AutosaveSettings;

/**
 * Sets autosave settings for the given scope. The method is guaranteed to work only after at least one call to getAutosaveSettings
 */
export type setAutosaveSettings$Input = {
  readonly _: "setAutosaveSettings";

  /**
   * Autosave settings scope
   * @type {AutosaveSettingsScope$Input} {@link AutosaveSettingsScope}
   */
  readonly scope?: AutosaveSettingsScope$Input;

  /**
   * New autosave settings for the scope; pass null to set autosave settings to default
   * @type {scopeAutosaveSettings$Input} {@link scopeAutosaveSettings}
   */
  readonly settings?: scopeAutosaveSettings$Input | null;
};

/**
 * Sets autosave settings for the given scope. The method is guaranteed to work only after at least one call to getAutosaveSettings
 */
export type setAutosaveSettings$DirectInput = {
  /**
   * Autosave settings scope
   * @type {AutosaveSettingsScope$Input} {@link AutosaveSettingsScope}
   */
  readonly scope?: AutosaveSettingsScope$Input;

  /**
   * New autosave settings for the scope; pass null to set autosave settings to default
   * @type {scopeAutosaveSettings$Input} {@link scopeAutosaveSettings}
   */
  readonly settings?: scopeAutosaveSettings$Input | null;
};

/**
 * Sets autosave settings for the given scope. The method is guaranteed to work only after at least one call to getAutosaveSettings
 *
 * @param {setAutosaveSettings$Input} parameters {@link setAutosaveSettings$Input}
 * @return {Ok} {@link Ok}
 */
export type setAutosaveSettings = (parameters: setAutosaveSettings$Input) => Ok;

/**
 * Clears the list of all autosave settings exceptions. The method is guaranteed to work only after at least one call to getAutosaveSettings
 */
export type clearAutosaveSettingsExceptions$Input = {
  readonly _: "clearAutosaveSettingsExceptions";
};

/**
 * Clears the list of all autosave settings exceptions. The method is guaranteed to work only after at least one call to getAutosaveSettings
 */
export type clearAutosaveSettingsExceptions$DirectInput = {};

/**
 * Clears the list of all autosave settings exceptions. The method is guaranteed to work only after at least one call to getAutosaveSettings
 *
 * @param {clearAutosaveSettingsExceptions$Input} parameters {@link clearAutosaveSettingsExceptions$Input}
 * @return {Ok} {@link Ok}
 */
export type clearAutosaveSettingsExceptions = (
  parameters: clearAutosaveSettingsExceptions$Input
) => Ok;

/**
 * Returns information about a bank card
 */
export type getBankCardInfo$Input = {
  readonly _: "getBankCardInfo";

  /**
   * The bank card number
   * @type {string} {@link string}
   */
  readonly bank_card_number?: string;
};

/**
 * Returns information about a bank card
 */
export type getBankCardInfo$DirectInput = {
  /**
   * The bank card number
   * @type {string} {@link string}
   */
  readonly bank_card_number?: string;
};

/**
 * Returns information about a bank card
 *
 * @param {getBankCardInfo$Input} parameters {@link getBankCardInfo$Input}
 * @return {BankCardInfo} {@link BankCardInfo}
 */
export type getBankCardInfo = (parameters: getBankCardInfo$Input) => BankCardInfo;

/**
 * Returns one of the available Telegram Passport elements
 */
export type getPassportElement$Input = {
  readonly _: "getPassportElement";

  /**
   * Telegram Passport element type
   * @type {PassportElementType$Input} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns one of the available Telegram Passport elements
 */
export type getPassportElement$DirectInput = {
  /**
   * Telegram Passport element type
   * @type {PassportElementType$Input} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns one of the available Telegram Passport elements
 *
 * @param {getPassportElement$Input} parameters {@link getPassportElement$Input}
 * @return {PassportElement} {@link PassportElement}
 */
export type getPassportElement = (
  parameters: getPassportElement$Input
) => PassportElement;

/**
 * Returns all available Telegram Passport elements
 */
export type getAllPassportElements$Input = {
  readonly _: "getAllPassportElements";

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns all available Telegram Passport elements
 */
export type getAllPassportElements$DirectInput = {
  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns all available Telegram Passport elements
 *
 * @param {getAllPassportElements$Input} parameters {@link getAllPassportElements$Input}
 * @return {PassportElements} {@link PassportElements}
 */
export type getAllPassportElements = (
  parameters: getAllPassportElements$Input
) => PassportElements;

/**
 * Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
 */
export type setPassportElement$Input = {
  readonly _: "setPassportElement";

  /**
   * Input Telegram Passport element
   * @type {InputPassportElement$Input} {@link InputPassportElement}
   */
  readonly element?: InputPassportElement$Input;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
 */
export type setPassportElement$DirectInput = {
  /**
   * Input Telegram Passport element
   * @type {InputPassportElement$Input} {@link InputPassportElement}
   */
  readonly element?: InputPassportElement$Input;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
 *
 * @param {setPassportElement$Input} parameters {@link setPassportElement$Input}
 * @return {PassportElement} {@link PassportElement}
 */
export type setPassportElement = (
  parameters: setPassportElement$Input
) => PassportElement;

/**
 * Deletes a Telegram Passport element
 */
export type deletePassportElement$Input = {
  readonly _: "deletePassportElement";

  /**
   * Element type
   * @type {PassportElementType$Input} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;
};

/**
 * Deletes a Telegram Passport element
 */
export type deletePassportElement$DirectInput = {
  /**
   * Element type
   * @type {PassportElementType$Input} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;
};

/**
 * Deletes a Telegram Passport element
 *
 * @param {deletePassportElement$Input} parameters {@link deletePassportElement$Input}
 * @return {Ok} {@link Ok}
 */
export type deletePassportElement = (parameters: deletePassportElement$Input) => Ok;

/**
 * Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
 */
export type setPassportElementErrors$Input = {
  readonly _: "setPassportElementErrors";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The errors
   * @type {vector$Input<inputPassportElementError$Input>} {@link vector<inputPassportElementError>}
   */
  readonly errors?: vector$Input<inputPassportElementError$Input>;
};

/**
 * Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
 */
export type setPassportElementErrors$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The errors
   * @type {vector$Input<inputPassportElementError$Input>} {@link vector<inputPassportElementError>}
   */
  readonly errors?: vector$Input<inputPassportElementError$Input>;
};

/**
 * Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
 *
 * @param {setPassportElementErrors$Input} parameters {@link setPassportElementErrors$Input}
 * @return {Ok} {@link Ok}
 */
export type setPassportElementErrors = (
  parameters: setPassportElementErrors$Input
) => Ok;

/**
 * Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
 */
export type getPreferredCountryLanguage$Input = {
  readonly _: "getPreferredCountryLanguage";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;
};

/**
 * Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
 */
export type getPreferredCountryLanguage$DirectInput = {
  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;
};

/**
 * Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
 *
 * @param {getPreferredCountryLanguage$Input} parameters {@link getPreferredCountryLanguage$Input}
 * @return {Text} {@link Text}
 */
export type getPreferredCountryLanguage = (
  parameters: getPreferredCountryLanguage$Input
) => Text;

/**
 * Sends a code to verify a phone number to be added to a user's Telegram Passport
 */
export type sendPhoneNumberVerificationCode$Input = {
  readonly _: "sendPhoneNumberVerificationCode";

  /**
   * The phone number of the user, in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Sends a code to verify a phone number to be added to a user's Telegram Passport
 */
export type sendPhoneNumberVerificationCode$DirectInput = {
  /**
   * The phone number of the user, in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Sends a code to verify a phone number to be added to a user's Telegram Passport
 *
 * @param {sendPhoneNumberVerificationCode$Input} parameters {@link sendPhoneNumberVerificationCode$Input}
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type sendPhoneNumberVerificationCode = (
  parameters: sendPhoneNumberVerificationCode$Input
) => AuthenticationCodeInfo;

/**
 * Resends the code to verify a phone number to be added to a user's Telegram Passport
 */
export type resendPhoneNumberVerificationCode$Input = {
  readonly _: "resendPhoneNumberVerificationCode";
};

/**
 * Resends the code to verify a phone number to be added to a user's Telegram Passport
 */
export type resendPhoneNumberVerificationCode$DirectInput = {};

/**
 * Resends the code to verify a phone number to be added to a user's Telegram Passport
 *
 * @param {resendPhoneNumberVerificationCode$Input} parameters {@link resendPhoneNumberVerificationCode$Input}
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type resendPhoneNumberVerificationCode = (
  parameters: resendPhoneNumberVerificationCode$Input
) => AuthenticationCodeInfo;

/**
 * Checks the phone number verification code for Telegram Passport
 */
export type checkPhoneNumberVerificationCode$Input = {
  readonly _: "checkPhoneNumberVerificationCode";

  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the phone number verification code for Telegram Passport
 */
export type checkPhoneNumberVerificationCode$DirectInput = {
  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the phone number verification code for Telegram Passport
 *
 * @param {checkPhoneNumberVerificationCode$Input} parameters {@link checkPhoneNumberVerificationCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkPhoneNumberVerificationCode = (
  parameters: checkPhoneNumberVerificationCode$Input
) => Ok;

/**
 * Sends a code to verify an email address to be added to a user's Telegram Passport
 */
export type sendEmailAddressVerificationCode$Input = {
  readonly _: "sendEmailAddressVerificationCode";

  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Sends a code to verify an email address to be added to a user's Telegram Passport
 */
export type sendEmailAddressVerificationCode$DirectInput = {
  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Sends a code to verify an email address to be added to a user's Telegram Passport
 *
 * @param {sendEmailAddressVerificationCode$Input} parameters {@link sendEmailAddressVerificationCode$Input}
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type sendEmailAddressVerificationCode = (
  parameters: sendEmailAddressVerificationCode$Input
) => EmailAddressAuthenticationCodeInfo;

/**
 * Resends the code to verify an email address to be added to a user's Telegram Passport
 */
export type resendEmailAddressVerificationCode$Input = {
  readonly _: "resendEmailAddressVerificationCode";
};

/**
 * Resends the code to verify an email address to be added to a user's Telegram Passport
 */
export type resendEmailAddressVerificationCode$DirectInput = {};

/**
 * Resends the code to verify an email address to be added to a user's Telegram Passport
 *
 * @param {resendEmailAddressVerificationCode$Input} parameters {@link resendEmailAddressVerificationCode$Input}
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type resendEmailAddressVerificationCode = (
  parameters: resendEmailAddressVerificationCode$Input
) => EmailAddressAuthenticationCodeInfo;

/**
 * Checks the email address verification code for Telegram Passport
 */
export type checkEmailAddressVerificationCode$Input = {
  readonly _: "checkEmailAddressVerificationCode";

  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the email address verification code for Telegram Passport
 */
export type checkEmailAddressVerificationCode$DirectInput = {
  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the email address verification code for Telegram Passport
 *
 * @param {checkEmailAddressVerificationCode$Input} parameters {@link checkEmailAddressVerificationCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkEmailAddressVerificationCode = (
  parameters: checkEmailAddressVerificationCode$Input
) => Ok;

/**
 * Returns a Telegram Passport authorization form for sharing data with a service
 */
export type getPassportAuthorizationForm$Input = {
  readonly _: "getPassportAuthorizationForm";

  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  readonly scope?: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  readonly public_key?: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  readonly nonce?: string;
};

/**
 * Returns a Telegram Passport authorization form for sharing data with a service
 */
export type getPassportAuthorizationForm$DirectInput = {
  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  readonly scope?: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  readonly public_key?: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  readonly nonce?: string;
};

/**
 * Returns a Telegram Passport authorization form for sharing data with a service
 *
 * @param {getPassportAuthorizationForm$Input} parameters {@link getPassportAuthorizationForm$Input}
 * @return {PassportAuthorizationForm} {@link PassportAuthorizationForm}
 */
export type getPassportAuthorizationForm = (
  parameters: getPassportAuthorizationForm$Input
) => PassportAuthorizationForm;

/**
 * Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
 */
export type getPassportAuthorizationFormAvailableElements$Input = {
  readonly _: "getPassportAuthorizationFormAvailableElements";

  /**
   * Authorization form identifier
   * @type {int32} {@link int32}
   */
  readonly authorization_form_id?: int32;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
 */
export type getPassportAuthorizationFormAvailableElements$DirectInput = {
  /**
   * Authorization form identifier
   * @type {int32} {@link int32}
   */
  readonly authorization_form_id?: int32;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
 *
 * @param {getPassportAuthorizationFormAvailableElements$Input} parameters {@link getPassportAuthorizationFormAvailableElements$Input}
 * @return {PassportElementsWithErrors} {@link PassportElementsWithErrors}
 */
export type getPassportAuthorizationFormAvailableElements = (
  parameters: getPassportAuthorizationFormAvailableElements$Input
) => PassportElementsWithErrors;

/**
 * Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
 */
export type sendPassportAuthorizationForm$Input = {
  readonly _: "sendPassportAuthorizationForm";

  /**
   * Authorization form identifier
   * @type {int32} {@link int32}
   */
  readonly authorization_form_id?: int32;

  /**
   * Types of Telegram Passport elements chosen by user to complete the authorization form
   * @type {vector$Input<PassportElementType$Input>} {@link vector<PassportElementType>}
   */
  readonly types?: vector$Input<PassportElementType$Input>;
};

/**
 * Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
 */
export type sendPassportAuthorizationForm$DirectInput = {
  /**
   * Authorization form identifier
   * @type {int32} {@link int32}
   */
  readonly authorization_form_id?: int32;

  /**
   * Types of Telegram Passport elements chosen by user to complete the authorization form
   * @type {vector$Input<PassportElementType$Input>} {@link vector<PassportElementType>}
   */
  readonly types?: vector$Input<PassportElementType$Input>;
};

/**
 * Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
 *
 * @param {sendPassportAuthorizationForm$Input} parameters {@link sendPassportAuthorizationForm$Input}
 * @return {Ok} {@link Ok}
 */
export type sendPassportAuthorizationForm = (
  parameters: sendPassportAuthorizationForm$Input
) => Ok;

/**
 * Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
 */
export type sendPhoneNumberConfirmationCode$Input = {
  readonly _: "sendPhoneNumberConfirmationCode";

  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  readonly hash?: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
 */
export type sendPhoneNumberConfirmationCode$DirectInput = {
  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  readonly hash?: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input | null;
};

/**
 * Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
 *
 * @param {sendPhoneNumberConfirmationCode$Input} parameters {@link sendPhoneNumberConfirmationCode$Input}
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type sendPhoneNumberConfirmationCode = (
  parameters: sendPhoneNumberConfirmationCode$Input
) => AuthenticationCodeInfo;

/**
 * Resends phone number confirmation code
 */
export type resendPhoneNumberConfirmationCode$Input = {
  readonly _: "resendPhoneNumberConfirmationCode";
};

/**
 * Resends phone number confirmation code
 */
export type resendPhoneNumberConfirmationCode$DirectInput = {};

/**
 * Resends phone number confirmation code
 *
 * @param {resendPhoneNumberConfirmationCode$Input} parameters {@link resendPhoneNumberConfirmationCode$Input}
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type resendPhoneNumberConfirmationCode = (
  parameters: resendPhoneNumberConfirmationCode$Input
) => AuthenticationCodeInfo;

/**
 * Checks phone number confirmation code
 */
export type checkPhoneNumberConfirmationCode$Input = {
  readonly _: "checkPhoneNumberConfirmationCode";

  /**
   * Confirmation code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks phone number confirmation code
 */
export type checkPhoneNumberConfirmationCode$DirectInput = {
  /**
   * Confirmation code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks phone number confirmation code
 *
 * @param {checkPhoneNumberConfirmationCode$Input} parameters {@link checkPhoneNumberConfirmationCode$Input}
 * @return {Ok} {@link Ok}
 */
export type checkPhoneNumberConfirmationCode = (
  parameters: checkPhoneNumberConfirmationCode$Input
) => Ok;

/**
 * Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
 */
export type setBotUpdatesStatus$Input = {
  readonly _: "setBotUpdatesStatus";

  /**
   * The number of pending updates
   * @type {int32} {@link int32}
   */
  readonly pending_update_count?: int32;

  /**
   * The last error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
 */
export type setBotUpdatesStatus$DirectInput = {
  /**
   * The number of pending updates
   * @type {int32} {@link int32}
   */
  readonly pending_update_count?: int32;

  /**
   * The last error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
 *
 * @param {setBotUpdatesStatus$Input} parameters {@link setBotUpdatesStatus$Input}
 * @return {Ok} {@link Ok}
 */
export type setBotUpdatesStatus = (parameters: setBotUpdatesStatus$Input) => Ok;

/**
 * Uploads a file with a sticker; returns the uploaded file
 */
export type uploadStickerFile$Input = {
  readonly _: "uploadStickerFile";

  /**
   * Sticker file owner; ignored for regular users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker format
   * @type {StickerFormat$Input} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * File file to upload; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side.
   *
   * - See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Uploads a file with a sticker; returns the uploaded file
 */
export type uploadStickerFile$DirectInput = {
  /**
   * Sticker file owner; ignored for regular users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker format
   * @type {StickerFormat$Input} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * File file to upload; must fit in a 512x512 square. For WEBP stickers the file must be in WEBP or PNG format, which will be converted to WEBP server-side.
   *
   * - See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Uploads a file with a sticker; returns the uploaded file
 *
 * @param {uploadStickerFile$Input} parameters {@link uploadStickerFile$Input}
 * @return {File} {@link File}
 */
export type uploadStickerFile = (parameters: uploadStickerFile$Input) => File;

/**
 * Returns a suggested name for a new sticker set with a given title
 */
export type getSuggestedStickerSetName$Input = {
  readonly _: "getSuggestedStickerSetName";

  /**
   * Sticker set title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Returns a suggested name for a new sticker set with a given title
 */
export type getSuggestedStickerSetName$DirectInput = {
  /**
   * Sticker set title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Returns a suggested name for a new sticker set with a given title
 *
 * @param {getSuggestedStickerSetName$Input} parameters {@link getSuggestedStickerSetName$Input}
 * @return {Text} {@link Text}
 */
export type getSuggestedStickerSetName = (
  parameters: getSuggestedStickerSetName$Input
) => Text;

/**
 * Checks whether a name can be used for a new sticker set
 */
export type checkStickerSetName$Input = {
  readonly _: "checkStickerSetName";

  /**
   * Name to be checked
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Checks whether a name can be used for a new sticker set
 */
export type checkStickerSetName$DirectInput = {
  /**
   * Name to be checked
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Checks whether a name can be used for a new sticker set
 *
 * @param {checkStickerSetName$Input} parameters {@link checkStickerSetName$Input}
 * @return {CheckStickerSetNameResult} {@link CheckStickerSetNameResult}
 */
export type checkStickerSetName = (
  parameters: checkStickerSetName$Input
) => CheckStickerSetNameResult;

/**
 * Creates a new sticker set. Returns the newly created sticker set
 */
export type createNewStickerSet$Input = {
  readonly _: "createNewStickerSet";

  /**
   * Sticker set owner; ignored for regular users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive) for bots; 1-64 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat$Input} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * Type of the stickers in the set
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Pass true if stickers in the sticker set must be repainted; for custom emoji sticker sets only
   * @type {Bool$Input} {@link Bool}
   */
  readonly needs_repainting?: Bool$Input;

  /**
   * List of stickers to be added to the set; must be non-empty. All stickers must have the same format. For TGS stickers, uploadStickerFile must be used before the sticker is shown
   * @type {vector$Input<inputSticker$Input>} {@link vector<inputSticker>}
   */
  readonly stickers?: vector$Input<inputSticker$Input>;

  /**
   * Source of the sticker set; may be empty if unknown
   * @type {string} {@link string}
   */
  readonly source?: string;
};

/**
 * Creates a new sticker set. Returns the newly created sticker set
 */
export type createNewStickerSet$DirectInput = {
  /**
   * Sticker set owner; ignored for regular users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive) for bots; 1-64 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat$Input} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * Type of the stickers in the set
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Pass true if stickers in the sticker set must be repainted; for custom emoji sticker sets only
   * @type {Bool$Input} {@link Bool}
   */
  readonly needs_repainting?: Bool$Input;

  /**
   * List of stickers to be added to the set; must be non-empty. All stickers must have the same format. For TGS stickers, uploadStickerFile must be used before the sticker is shown
   * @type {vector$Input<inputSticker$Input>} {@link vector<inputSticker>}
   */
  readonly stickers?: vector$Input<inputSticker$Input>;

  /**
   * Source of the sticker set; may be empty if unknown
   * @type {string} {@link string}
   */
  readonly source?: string;
};

/**
 * Creates a new sticker set. Returns the newly created sticker set
 *
 * @param {createNewStickerSet$Input} parameters {@link createNewStickerSet$Input}
 * @return {StickerSet} {@link StickerSet}
 */
export type createNewStickerSet = (
  parameters: createNewStickerSet$Input
) => StickerSet;

/**
 * Adds a new sticker to a set; for bots only
 */
export type addStickerToSet$Input = {
  readonly _: "addStickerToSet";

  /**
   * Sticker set owner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker to add to the set
   * @type {inputSticker$Input} {@link inputSticker}
   */
  readonly sticker?: inputSticker$Input;
};

/**
 * Adds a new sticker to a set; for bots only
 */
export type addStickerToSet$DirectInput = {
  /**
   * Sticker set owner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker to add to the set
   * @type {inputSticker$Input} {@link inputSticker}
   */
  readonly sticker?: inputSticker$Input;
};

/**
 * Adds a new sticker to a set; for bots only
 *
 * @param {addStickerToSet$Input} parameters {@link addStickerToSet$Input}
 * @return {Ok} {@link Ok}
 */
export type addStickerToSet = (parameters: addStickerToSet$Input) => Ok;

/**
 * Sets a sticker set thumbnail; for bots only
 */
export type setStickerSetThumbnail$Input = {
  readonly _: "setStickerSetThumbnail";

  /**
   * Sticker set owner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Thumbnail to set in PNG, TGS, or WEBM format; pass null to remove the sticker set thumbnail. Thumbnail format must match the format of stickers in the set
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly thumbnail?: InputFile$Input | null;
};

/**
 * Sets a sticker set thumbnail; for bots only
 */
export type setStickerSetThumbnail$DirectInput = {
  /**
   * Sticker set owner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Thumbnail to set in PNG, TGS, or WEBM format; pass null to remove the sticker set thumbnail. Thumbnail format must match the format of stickers in the set
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly thumbnail?: InputFile$Input | null;
};

/**
 * Sets a sticker set thumbnail; for bots only
 *
 * @param {setStickerSetThumbnail$Input} parameters {@link setStickerSetThumbnail$Input}
 * @return {Ok} {@link Ok}
 */
export type setStickerSetThumbnail = (
  parameters: setStickerSetThumbnail$Input
) => Ok;

/**
 * Sets a custom emoji sticker set thumbnail; for bots only
 */
export type setCustomEmojiStickerSetThumbnail$Input = {
  readonly _: "setCustomEmojiStickerSetThumbnail";

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Identifier of the custom emoji from the sticker set, which will be set as sticker set thumbnail; pass 0 to remove the sticker set thumbnail
   * @type {int64$Input} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;
};

/**
 * Sets a custom emoji sticker set thumbnail; for bots only
 */
export type setCustomEmojiStickerSetThumbnail$DirectInput = {
  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Identifier of the custom emoji from the sticker set, which will be set as sticker set thumbnail; pass 0 to remove the sticker set thumbnail
   * @type {int64$Input} {@link int64}
   */
  readonly custom_emoji_id?: int64$Input;
};

/**
 * Sets a custom emoji sticker set thumbnail; for bots only
 *
 * @param {setCustomEmojiStickerSetThumbnail$Input} parameters {@link setCustomEmojiStickerSetThumbnail$Input}
 * @return {Ok} {@link Ok}
 */
export type setCustomEmojiStickerSetThumbnail = (
  parameters: setCustomEmojiStickerSetThumbnail$Input
) => Ok;

/**
 * Sets a sticker set title; for bots only
 */
export type setStickerSetTitle$Input = {
  readonly _: "setStickerSetTitle";

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * New sticker set title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Sets a sticker set title; for bots only
 */
export type setStickerSetTitle$DirectInput = {
  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * New sticker set title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Sets a sticker set title; for bots only
 *
 * @param {setStickerSetTitle$Input} parameters {@link setStickerSetTitle$Input}
 * @return {Ok} {@link Ok}
 */
export type setStickerSetTitle = (parameters: setStickerSetTitle$Input) => Ok;

/**
 * Deleted a sticker set; for bots only
 */
export type deleteStickerSet$Input = {
  readonly _: "deleteStickerSet";

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Deleted a sticker set; for bots only
 */
export type deleteStickerSet$DirectInput = {
  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Deleted a sticker set; for bots only
 *
 * @param {deleteStickerSet$Input} parameters {@link deleteStickerSet$Input}
 * @return {Ok} {@link Ok}
 */
export type deleteStickerSet = (parameters: deleteStickerSet$Input) => Ok;

/**
 * Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
 */
export type setStickerPositionInSet$Input = {
  readonly _: "setStickerPositionInSet";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * New position of the sticker in the set, 0-based
   * @type {int32} {@link int32}
   */
  readonly position?: int32;
};

/**
 * Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
 */
export type setStickerPositionInSet$DirectInput = {
  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * New position of the sticker in the set, 0-based
   * @type {int32} {@link int32}
   */
  readonly position?: int32;
};

/**
 * Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
 *
 * @param {setStickerPositionInSet$Input} parameters {@link setStickerPositionInSet$Input}
 * @return {Ok} {@link Ok}
 */
export type setStickerPositionInSet = (
  parameters: setStickerPositionInSet$Input
) => Ok;

/**
 * Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
 */
export type removeStickerFromSet$Input = {
  readonly _: "removeStickerFromSet";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
 */
export type removeStickerFromSet$DirectInput = {
  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
 *
 * @param {removeStickerFromSet$Input} parameters {@link removeStickerFromSet$Input}
 * @return {Ok} {@link Ok}
 */
export type removeStickerFromSet = (parameters: removeStickerFromSet$Input) => Ok;

/**
 * Changes the list of emoji corresponding to a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
 */
export type setStickerEmojis$Input = {
  readonly _: "setStickerEmojis";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * New string with 1-20 emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  readonly emojis?: string;
};

/**
 * Changes the list of emoji corresponding to a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
 */
export type setStickerEmojis$DirectInput = {
  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * New string with 1-20 emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  readonly emojis?: string;
};

/**
 * Changes the list of emoji corresponding to a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
 *
 * @param {setStickerEmojis$Input} parameters {@link setStickerEmojis$Input}
 * @return {Ok} {@link Ok}
 */
export type setStickerEmojis = (parameters: setStickerEmojis$Input) => Ok;

/**
 * Changes the list of keywords of a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
 */
export type setStickerKeywords$Input = {
  readonly _: "setStickerKeywords";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly keywords?: vector$Input<string>;
};

/**
 * Changes the list of keywords of a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
 */
export type setStickerKeywords$DirectInput = {
  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * List of up to 20 keywords with total length up to 64 characters, which can be used to find the sticker
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly keywords?: vector$Input<string>;
};

/**
 * Changes the list of keywords of a sticker; for bots only. The sticker must belong to a regular or custom emoji sticker set created by the bot
 *
 * @param {setStickerKeywords$Input} parameters {@link setStickerKeywords$Input}
 * @return {Ok} {@link Ok}
 */
export type setStickerKeywords = (parameters: setStickerKeywords$Input) => Ok;

/**
 * Changes the mask position of a mask sticker; for bots only. The sticker must belong to a mask sticker set created by the bot
 */
export type setStickerMaskPosition$Input = {
  readonly _: "setStickerMaskPosition";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * Position where the mask is placed; pass null to remove mask position
   * @type {maskPosition$Input} {@link maskPosition}
   */
  readonly mask_position?: maskPosition$Input | null;
};

/**
 * Changes the mask position of a mask sticker; for bots only. The sticker must belong to a mask sticker set created by the bot
 */
export type setStickerMaskPosition$DirectInput = {
  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * Position where the mask is placed; pass null to remove mask position
   * @type {maskPosition$Input} {@link maskPosition}
   */
  readonly mask_position?: maskPosition$Input | null;
};

/**
 * Changes the mask position of a mask sticker; for bots only. The sticker must belong to a mask sticker set created by the bot
 *
 * @param {setStickerMaskPosition$Input} parameters {@link setStickerMaskPosition$Input}
 * @return {Ok} {@link Ok}
 */
export type setStickerMaskPosition = (
  parameters: setStickerMaskPosition$Input
) => Ok;

/**
 * Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
 */
export type getMapThumbnailFile$Input = {
  readonly _: "getMapThumbnailFile";

  /**
   * Location of the map center
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Map zoom level; 13-20
   * @type {int32} {@link int32}
   */
  readonly zoom?: int32;

  /**
   * Map width in pixels before applying scale; 16-1024
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Map height in pixels before applying scale; 16-1024
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Map scale; 1-3
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
 */
export type getMapThumbnailFile$DirectInput = {
  /**
   * Location of the map center
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Map zoom level; 13-20
   * @type {int32} {@link int32}
   */
  readonly zoom?: int32;

  /**
   * Map width in pixels before applying scale; 16-1024
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Map height in pixels before applying scale; 16-1024
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Map scale; 1-3
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
 *
 * @param {getMapThumbnailFile$Input} parameters {@link getMapThumbnailFile$Input}
 * @return {File} {@link File}
 */
export type getMapThumbnailFile = (parameters: getMapThumbnailFile$Input) => File;

/**
 * Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown
 */
export type getPremiumLimit$Input = {
  readonly _: "getPremiumLimit";

  /**
   * Type of the limit
   * @type {PremiumLimitType$Input} {@link PremiumLimitType}
   */
  readonly limit_type?: PremiumLimitType$Input;
};

/**
 * Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown
 */
export type getPremiumLimit$DirectInput = {
  /**
   * Type of the limit
   * @type {PremiumLimitType$Input} {@link PremiumLimitType}
   */
  readonly limit_type?: PremiumLimitType$Input;
};

/**
 * Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown
 *
 * @param {getPremiumLimit$Input} parameters {@link getPremiumLimit$Input}
 * @return {PremiumLimit} {@link PremiumLimit}
 */
export type getPremiumLimit = (parameters: getPremiumLimit$Input) => PremiumLimit;

/**
 * Returns information about features, available to Premium users
 */
export type getPremiumFeatures$Input = {
  readonly _: "getPremiumFeatures";

  /**
   * Source of the request; pass null if the method is called from some non-standard source
   * @type {PremiumSource$Input} {@link PremiumSource}
   */
  readonly source?: PremiumSource$Input | null;
};

/**
 * Returns information about features, available to Premium users
 */
export type getPremiumFeatures$DirectInput = {
  /**
   * Source of the request; pass null if the method is called from some non-standard source
   * @type {PremiumSource$Input} {@link PremiumSource}
   */
  readonly source?: PremiumSource$Input | null;
};

/**
 * Returns information about features, available to Premium users
 *
 * @param {getPremiumFeatures$Input} parameters {@link getPremiumFeatures$Input}
 * @return {PremiumFeatures} {@link PremiumFeatures}
 */
export type getPremiumFeatures = (
  parameters: getPremiumFeatures$Input
) => PremiumFeatures;

/**
 * Returns examples of premium stickers for demonstration purposes
 */
export type getPremiumStickerExamples$Input = {
  readonly _: "getPremiumStickerExamples";
};

/**
 * Returns examples of premium stickers for demonstration purposes
 */
export type getPremiumStickerExamples$DirectInput = {};

/**
 * Returns examples of premium stickers for demonstration purposes
 *
 * @param {getPremiumStickerExamples$Input} parameters {@link getPremiumStickerExamples$Input}
 * @return {Stickers} {@link Stickers}
 */
export type getPremiumStickerExamples = (
  parameters: getPremiumStickerExamples$Input
) => Stickers;

/**
 * Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen
 */
export type viewPremiumFeature$Input = {
  readonly _: "viewPremiumFeature";

  /**
   * The viewed premium feature
   * @type {PremiumFeature$Input} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;
};

/**
 * Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen
 */
export type viewPremiumFeature$DirectInput = {
  /**
   * The viewed premium feature
   * @type {PremiumFeature$Input} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;
};

/**
 * Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen
 *
 * @param {viewPremiumFeature$Input} parameters {@link viewPremiumFeature$Input}
 * @return {Ok} {@link Ok}
 */
export type viewPremiumFeature = (parameters: viewPremiumFeature$Input) => Ok;

/**
 * Informs TDLib that the user clicked Premium subscription button on the Premium features screen
 */
export type clickPremiumSubscriptionButton$Input = {
  readonly _: "clickPremiumSubscriptionButton";
};

/**
 * Informs TDLib that the user clicked Premium subscription button on the Premium features screen
 */
export type clickPremiumSubscriptionButton$DirectInput = {};

/**
 * Informs TDLib that the user clicked Premium subscription button on the Premium features screen
 *
 * @param {clickPremiumSubscriptionButton$Input} parameters {@link clickPremiumSubscriptionButton$Input}
 * @return {Ok} {@link Ok}
 */
export type clickPremiumSubscriptionButton = (
  parameters: clickPremiumSubscriptionButton$Input
) => Ok;

/**
 * Returns state of Telegram Premium subscription and promotion videos for Premium features
 */
export type getPremiumState$Input = {
  readonly _: "getPremiumState";
};

/**
 * Returns state of Telegram Premium subscription and promotion videos for Premium features
 */
export type getPremiumState$DirectInput = {};

/**
 * Returns state of Telegram Premium subscription and promotion videos for Premium features
 *
 * @param {getPremiumState$Input} parameters {@link getPremiumState$Input}
 * @return {PremiumState} {@link PremiumState}
 */
export type getPremiumState = (parameters: getPremiumState$Input) => PremiumState;

/**
 * Returns available options for Telegram Premium gift code or giveaway creation
 */
export type getPremiumGiftCodePaymentOptions$Input = {
  readonly _: "getPremiumGiftCodePaymentOptions";

  /**
   * Identifier of the channel chat, which will be automatically boosted by receivers of the gift codes and which is administered by the user; 0 if none
   * @type {int53} {@link int53}
   */
  readonly boosted_chat_id?: int53;
};

/**
 * Returns available options for Telegram Premium gift code or giveaway creation
 */
export type getPremiumGiftCodePaymentOptions$DirectInput = {
  /**
   * Identifier of the channel chat, which will be automatically boosted by receivers of the gift codes and which is administered by the user; 0 if none
   * @type {int53} {@link int53}
   */
  readonly boosted_chat_id?: int53;
};

/**
 * Returns available options for Telegram Premium gift code or giveaway creation
 *
 * @param {getPremiumGiftCodePaymentOptions$Input} parameters {@link getPremiumGiftCodePaymentOptions$Input}
 * @return {PremiumGiftCodePaymentOptions} {@link PremiumGiftCodePaymentOptions}
 */
export type getPremiumGiftCodePaymentOptions = (
  parameters: getPremiumGiftCodePaymentOptions$Input
) => PremiumGiftCodePaymentOptions;

/**
 * Return information about a Telegram Premium gift code
 */
export type checkPremiumGiftCode$Input = {
  readonly _: "checkPremiumGiftCode";

  /**
   * The code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Return information about a Telegram Premium gift code
 */
export type checkPremiumGiftCode$DirectInput = {
  /**
   * The code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Return information about a Telegram Premium gift code
 *
 * @param {checkPremiumGiftCode$Input} parameters {@link checkPremiumGiftCode$Input}
 * @return {PremiumGiftCodeInfo} {@link PremiumGiftCodeInfo}
 */
export type checkPremiumGiftCode = (
  parameters: checkPremiumGiftCode$Input
) => PremiumGiftCodeInfo;

/**
 * Applies a Telegram Premium gift code
 */
export type applyPremiumGiftCode$Input = {
  readonly _: "applyPremiumGiftCode";

  /**
   * The code to apply
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Applies a Telegram Premium gift code
 */
export type applyPremiumGiftCode$DirectInput = {
  /**
   * The code to apply
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Applies a Telegram Premium gift code
 *
 * @param {applyPremiumGiftCode$Input} parameters {@link applyPremiumGiftCode$Input}
 * @return {Ok} {@link Ok}
 */
export type applyPremiumGiftCode = (parameters: applyPremiumGiftCode$Input) => Ok;

/**
 * Launches a prepaid Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 */
export type launchPrepaidPremiumGiveaway$Input = {
  readonly _: "launchPrepaidPremiumGiveaway";

  /**
   * Unique identifier of the prepaid giveaway
   * @type {int64$Input} {@link int64}
   */
  readonly giveaway_id?: int64$Input;

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters$Input} {@link premiumGiveawayParameters}
   */
  readonly parameters?: premiumGiveawayParameters$Input;
};

/**
 * Launches a prepaid Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 */
export type launchPrepaidPremiumGiveaway$DirectInput = {
  /**
   * Unique identifier of the prepaid giveaway
   * @type {int64$Input} {@link int64}
   */
  readonly giveaway_id?: int64$Input;

  /**
   * Giveaway parameters
   * @type {premiumGiveawayParameters$Input} {@link premiumGiveawayParameters}
   */
  readonly parameters?: premiumGiveawayParameters$Input;
};

/**
 * Launches a prepaid Telegram Premium giveaway for subscribers of channel chats; requires can_post_messages rights in the channels
 *
 * @param {launchPrepaidPremiumGiveaway$Input} parameters {@link launchPrepaidPremiumGiveaway$Input}
 * @return {Ok} {@link Ok}
 */
export type launchPrepaidPremiumGiveaway = (
  parameters: launchPrepaidPremiumGiveaway$Input
) => Ok;

/**
 * Returns information about a Telegram Premium giveaway
 */
export type getPremiumGiveawayInfo$Input = {
  readonly _: "getPremiumGiveawayInfo";

  /**
   * Identifier of the channel chat which started the giveaway
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the giveaway or a giveaway winners message in the chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a Telegram Premium giveaway
 */
export type getPremiumGiveawayInfo$DirectInput = {
  /**
   * Identifier of the channel chat which started the giveaway
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the giveaway or a giveaway winners message in the chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a Telegram Premium giveaway
 *
 * @param {getPremiumGiveawayInfo$Input} parameters {@link getPremiumGiveawayInfo$Input}
 * @return {PremiumGiveawayInfo} {@link PremiumGiveawayInfo}
 */
export type getPremiumGiveawayInfo = (
  parameters: getPremiumGiveawayInfo$Input
) => PremiumGiveawayInfo;

/**
 * Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase
 */
export type canPurchasePremium$Input = {
  readonly _: "canPurchasePremium";

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase
 */
export type canPurchasePremium$DirectInput = {
  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase
 *
 * @param {canPurchasePremium$Input} parameters {@link canPurchasePremium$Input}
 * @return {Ok} {@link Ok}
 */
export type canPurchasePremium = (parameters: canPurchasePremium$Input) => Ok;

/**
 * Informs server about a purchase through App Store. For official applications only
 */
export type assignAppStoreTransaction$Input = {
  readonly _: "assignAppStoreTransaction";

  /**
   * App Store receipt
   * @type {bytes$Input} {@link bytes}
   */
  readonly receipt?: bytes$Input;

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Informs server about a purchase through App Store. For official applications only
 */
export type assignAppStoreTransaction$DirectInput = {
  /**
   * App Store receipt
   * @type {bytes$Input} {@link bytes}
   */
  readonly receipt?: bytes$Input;

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Informs server about a purchase through App Store. For official applications only
 *
 * @param {assignAppStoreTransaction$Input} parameters {@link assignAppStoreTransaction$Input}
 * @return {Ok} {@link Ok}
 */
export type assignAppStoreTransaction = (
  parameters: assignAppStoreTransaction$Input
) => Ok;

/**
 * Informs server about a purchase through Google Play. For official applications only
 */
export type assignGooglePlayTransaction$Input = {
  readonly _: "assignGooglePlayTransaction";

  /**
   * Application package name
   * @type {string} {@link string}
   */
  readonly package_name?: string;

  /**
   * Identifier of the purchased store product
   * @type {string} {@link string}
   */
  readonly store_product_id?: string;

  /**
   * Google Play purchase token
   * @type {string} {@link string}
   */
  readonly purchase_token?: string;

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Informs server about a purchase through Google Play. For official applications only
 */
export type assignGooglePlayTransaction$DirectInput = {
  /**
   * Application package name
   * @type {string} {@link string}
   */
  readonly package_name?: string;

  /**
   * Identifier of the purchased store product
   * @type {string} {@link string}
   */
  readonly store_product_id?: string;

  /**
   * Google Play purchase token
   * @type {string} {@link string}
   */
  readonly purchase_token?: string;

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Informs server about a purchase through Google Play. For official applications only
 *
 * @param {assignGooglePlayTransaction$Input} parameters {@link assignGooglePlayTransaction$Input}
 * @return {Ok} {@link Ok}
 */
export type assignGooglePlayTransaction = (
  parameters: assignGooglePlayTransaction$Input
) => Ok;

/**
 * Accepts Telegram terms of services
 */
export type acceptTermsOfService$Input = {
  readonly _: "acceptTermsOfService";

  /**
   * Terms of service identifier
   * @type {string} {@link string}
   */
  readonly terms_of_service_id?: string;
};

/**
 * Accepts Telegram terms of services
 */
export type acceptTermsOfService$DirectInput = {
  /**
   * Terms of service identifier
   * @type {string} {@link string}
   */
  readonly terms_of_service_id?: string;
};

/**
 * Accepts Telegram terms of services
 *
 * @param {acceptTermsOfService$Input} parameters {@link acceptTermsOfService$Input}
 * @return {Ok} {@link Ok}
 */
export type acceptTermsOfService = (parameters: acceptTermsOfService$Input) => Ok;

/**
 * Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously
 */
export type searchStringsByPrefix$Input = {
  readonly _: "searchStringsByPrefix";

  /**
   * The strings to search in for the query
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly strings?: vector$Input<string>;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of objects to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to receive no results for an empty query
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_none_for_empty_query?: Bool$Input;
};

/**
 * Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously
 */
export type searchStringsByPrefix$DirectInput = {
  /**
   * The strings to search in for the query
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly strings?: vector$Input<string>;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of objects to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to receive no results for an empty query
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_none_for_empty_query?: Bool$Input;
};

/**
 * Searches specified query by word prefixes in the provided strings. Returns 0-based positions of strings that matched. Can be called synchronously
 *
 * @param {searchStringsByPrefix$Input} parameters {@link searchStringsByPrefix$Input}
 * @return {FoundPositions} {@link FoundPositions}
 */
export type searchStringsByPrefix = (
  parameters: searchStringsByPrefix$Input
) => FoundPositions;

/**
 * Sends a custom request; for bots only
 */
export type sendCustomRequest$Input = {
  readonly _: "sendCustomRequest";

  /**
   * The method name
   * @type {string} {@link string}
   */
  readonly method?: string;

  /**
   * JSON-serialized method parameters
   * @type {string} {@link string}
   */
  readonly parameters?: string;
};

/**
 * Sends a custom request; for bots only
 */
export type sendCustomRequest$DirectInput = {
  /**
   * The method name
   * @type {string} {@link string}
   */
  readonly method?: string;

  /**
   * JSON-serialized method parameters
   * @type {string} {@link string}
   */
  readonly parameters?: string;
};

/**
 * Sends a custom request; for bots only
 *
 * @param {sendCustomRequest$Input} parameters {@link sendCustomRequest$Input}
 * @return {CustomRequestResult} {@link CustomRequestResult}
 */
export type sendCustomRequest = (
  parameters: sendCustomRequest$Input
) => CustomRequestResult;

/**
 * Answers a custom query; for bots only
 */
export type answerCustomQuery$Input = {
  readonly _: "answerCustomQuery";

  /**
   * Identifier of a custom query
   * @type {int64$Input} {@link int64}
   */
  readonly custom_query_id?: int64$Input;

  /**
   * JSON-serialized answer to the query
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Answers a custom query; for bots only
 */
export type answerCustomQuery$DirectInput = {
  /**
   * Identifier of a custom query
   * @type {int64$Input} {@link int64}
   */
  readonly custom_query_id?: int64$Input;

  /**
   * JSON-serialized answer to the query
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Answers a custom query; for bots only
 *
 * @param {answerCustomQuery$Input} parameters {@link answerCustomQuery$Input}
 * @return {Ok} {@link Ok}
 */
export type answerCustomQuery = (parameters: answerCustomQuery$Input) => Ok;

/**
 * Succeeds after a specified amount of time has passed. Can be called before initialization
 */
export type setAlarm$Input = {
  readonly _: "setAlarm";

  /**
   * Number of seconds before the function returns
   * @type {double} {@link double}
   */
  readonly seconds?: double;
};

/**
 * Succeeds after a specified amount of time has passed. Can be called before initialization
 */
export type setAlarm$DirectInput = {
  /**
   * Number of seconds before the function returns
   * @type {double} {@link double}
   */
  readonly seconds?: double;
};

/**
 * Succeeds after a specified amount of time has passed. Can be called before initialization
 *
 * @param {setAlarm$Input} parameters {@link setAlarm$Input}
 * @return {Ok} {@link Ok}
 */
export type setAlarm = (parameters: setAlarm$Input) => Ok;

/**
 * Returns information about existing countries. Can be called before authorization
 */
export type getCountries$Input = {
  readonly _: "getCountries";
};

/**
 * Returns information about existing countries. Can be called before authorization
 */
export type getCountries$DirectInput = {};

/**
 * Returns information about existing countries. Can be called before authorization
 *
 * @param {getCountries$Input} parameters {@link getCountries$Input}
 * @return {Countries} {@link Countries}
 */
export type getCountries = (parameters: getCountries$Input) => Countries;

/**
 * Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
 */
export type getCountryCode$Input = {
  readonly _: "getCountryCode";
};

/**
 * Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
 */
export type getCountryCode$DirectInput = {};

/**
 * Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
 *
 * @param {getCountryCode$Input} parameters {@link getCountryCode$Input}
 * @return {Text} {@link Text}
 */
export type getCountryCode = (parameters: getCountryCode$Input) => Text;

/**
 * Returns information about a phone number by its prefix. Can be called before authorization
 */
export type getPhoneNumberInfo$Input = {
  readonly _: "getPhoneNumberInfo";

  /**
   * The phone number prefix
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;
};

/**
 * Returns information about a phone number by its prefix. Can be called before authorization
 */
export type getPhoneNumberInfo$DirectInput = {
  /**
   * The phone number prefix
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;
};

/**
 * Returns information about a phone number by its prefix. Can be called before authorization
 *
 * @param {getPhoneNumberInfo$Input} parameters {@link getPhoneNumberInfo$Input}
 * @return {PhoneNumberInfo} {@link PhoneNumberInfo}
 */
export type getPhoneNumberInfo = (
  parameters: getPhoneNumberInfo$Input
) => PhoneNumberInfo;

/**
 * Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
 */
export type getPhoneNumberInfoSync$Input = {
  readonly _: "getPhoneNumberInfoSync";

  /**
   * A two-letter ISO 639-1 language code for country information localization
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * The phone number prefix
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;
};

/**
 * Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
 */
export type getPhoneNumberInfoSync$DirectInput = {
  /**
   * A two-letter ISO 639-1 language code for country information localization
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * The phone number prefix
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;
};

/**
 * Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
 *
 * @param {getPhoneNumberInfoSync$Input} parameters {@link getPhoneNumberInfoSync$Input}
 * @return {PhoneNumberInfo} {@link PhoneNumberInfo}
 */
export type getPhoneNumberInfoSync = (
  parameters: getPhoneNumberInfoSync$Input
) => PhoneNumberInfo;

/**
 * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
 */
export type getDeepLinkInfo$Input = {
  readonly _: "getDeepLinkInfo";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
 */
export type getDeepLinkInfo$DirectInput = {
  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
 *
 * @param {getDeepLinkInfo$Input} parameters {@link getDeepLinkInfo$Input}
 * @return {DeepLinkInfo} {@link DeepLinkInfo}
 */
export type getDeepLinkInfo = (parameters: getDeepLinkInfo$Input) => DeepLinkInfo;

/**
 * Returns application config, provided by the server. Can be called before authorization
 */
export type getApplicationConfig$Input = {
  readonly _: "getApplicationConfig";
};

/**
 * Returns application config, provided by the server. Can be called before authorization
 */
export type getApplicationConfig$DirectInput = {};

/**
 * Returns application config, provided by the server. Can be called before authorization
 *
 * @param {getApplicationConfig$Input} parameters {@link getApplicationConfig$Input}
 * @return {JsonValue} {@link JsonValue}
 */
export type getApplicationConfig = (
  parameters: getApplicationConfig$Input
) => JsonValue;

/**
 * Saves application log event on the server. Can be called before authorization
 */
export type saveApplicationLogEvent$Input = {
  readonly _: "saveApplicationLogEvent";

  /**
   * Event type
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Optional chat identifier, associated with the event
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The log event data
   * @type {JsonValue$Input} {@link JsonValue}
   */
  readonly data?: JsonValue$Input;
};

/**
 * Saves application log event on the server. Can be called before authorization
 */
export type saveApplicationLogEvent$DirectInput = {
  /**
   * Event type
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Optional chat identifier, associated with the event
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The log event data
   * @type {JsonValue$Input} {@link JsonValue}
   */
  readonly data?: JsonValue$Input;
};

/**
 * Saves application log event on the server. Can be called before authorization
 *
 * @param {saveApplicationLogEvent$Input} parameters {@link saveApplicationLogEvent$Input}
 * @return {Ok} {@link Ok}
 */
export type saveApplicationLogEvent = (
  parameters: saveApplicationLogEvent$Input
) => Ok;

/**
 * Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
 */
export type getApplicationDownloadLink$Input = {
  readonly _: "getApplicationDownloadLink";
};

/**
 * Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
 */
export type getApplicationDownloadLink$DirectInput = {};

/**
 * Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
 *
 * @param {getApplicationDownloadLink$Input} parameters {@link getApplicationDownloadLink$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getApplicationDownloadLink = (
  parameters: getApplicationDownloadLink$Input
) => HttpUrl;

/**
 * Adds a proxy server for network requests. Can be called before authorization
 */
export type addProxy$Input = {
  readonly _: "addProxy";

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Pass true to immediately enable the proxy
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable?: Bool$Input;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Adds a proxy server for network requests. Can be called before authorization
 */
export type addProxy$DirectInput = {
  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Pass true to immediately enable the proxy
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable?: Bool$Input;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Adds a proxy server for network requests. Can be called before authorization
 *
 * @param {addProxy$Input} parameters {@link addProxy$Input}
 * @return {Proxy} {@link Proxy}
 */
export type addProxy = (parameters: addProxy$Input) => Proxy;

/**
 * Edits an existing proxy server for network requests. Can be called before authorization
 */
export type editProxy$Input = {
  readonly _: "editProxy";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Pass true to immediately enable the proxy
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable?: Bool$Input;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Edits an existing proxy server for network requests. Can be called before authorization
 */
export type editProxy$DirectInput = {
  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Pass true to immediately enable the proxy
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable?: Bool$Input;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Edits an existing proxy server for network requests. Can be called before authorization
 *
 * @param {editProxy$Input} parameters {@link editProxy$Input}
 * @return {Proxy} {@link Proxy}
 */
export type editProxy = (parameters: editProxy$Input) => Proxy;

/**
 * Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
 */
export type enableProxy$Input = {
  readonly _: "enableProxy";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
 */
export type enableProxy$DirectInput = {
  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
 *
 * @param {enableProxy$Input} parameters {@link enableProxy$Input}
 * @return {Ok} {@link Ok}
 */
export type enableProxy = (parameters: enableProxy$Input) => Ok;

/**
 * Disables the currently enabled proxy. Can be called before authorization
 */
export type disableProxy$Input = {
  readonly _: "disableProxy";
};

/**
 * Disables the currently enabled proxy. Can be called before authorization
 */
export type disableProxy$DirectInput = {};

/**
 * Disables the currently enabled proxy. Can be called before authorization
 *
 * @param {disableProxy$Input} parameters {@link disableProxy$Input}
 * @return {Ok} {@link Ok}
 */
export type disableProxy = (parameters: disableProxy$Input) => Ok;

/**
 * Removes a proxy server. Can be called before authorization
 */
export type removeProxy$Input = {
  readonly _: "removeProxy";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Removes a proxy server. Can be called before authorization
 */
export type removeProxy$DirectInput = {
  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Removes a proxy server. Can be called before authorization
 *
 * @param {removeProxy$Input} parameters {@link removeProxy$Input}
 * @return {Ok} {@link Ok}
 */
export type removeProxy = (parameters: removeProxy$Input) => Ok;

/**
 * Returns list of proxies that are currently set up. Can be called before authorization
 */
export type getProxies$Input = {
  readonly _: "getProxies";
};

/**
 * Returns list of proxies that are currently set up. Can be called before authorization
 */
export type getProxies$DirectInput = {};

/**
 * Returns list of proxies that are currently set up. Can be called before authorization
 *
 * @param {getProxies$Input} parameters {@link getProxies$Input}
 * @return {Proxies} {@link Proxies}
 */
export type getProxies = (parameters: getProxies$Input) => Proxies;

/**
 * Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
 */
export type getProxyLink$Input = {
  readonly _: "getProxyLink";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
 */
export type getProxyLink$DirectInput = {
  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
 *
 * @param {getProxyLink$Input} parameters {@link getProxyLink$Input}
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getProxyLink = (parameters: getProxyLink$Input) => HttpUrl;

/**
 * Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
 */
export type pingProxy$Input = {
  readonly _: "pingProxy";

  /**
   * Proxy identifier. Use 0 to ping a Telegram server without a proxy
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
 */
export type pingProxy$DirectInput = {
  /**
   * Proxy identifier. Use 0 to ping a Telegram server without a proxy
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
 *
 * @param {pingProxy$Input} parameters {@link pingProxy$Input}
 * @return {Seconds} {@link Seconds}
 */
export type pingProxy = (parameters: pingProxy$Input) => Seconds;

/**
 * Sets new log stream for internal logging of TDLib. Can be called synchronously
 */
export type setLogStream$Input = {
  readonly _: "setLogStream";

  /**
   * New log stream
   * @type {LogStream$Input} {@link LogStream}
   */
  readonly log_stream?: LogStream$Input;
};

/**
 * Sets new log stream for internal logging of TDLib. Can be called synchronously
 */
export type setLogStream$DirectInput = {
  /**
   * New log stream
   * @type {LogStream$Input} {@link LogStream}
   */
  readonly log_stream?: LogStream$Input;
};

/**
 * Sets new log stream for internal logging of TDLib. Can be called synchronously
 *
 * @param {setLogStream$Input} parameters {@link setLogStream$Input}
 * @return {Ok} {@link Ok}
 */
export type setLogStream = (parameters: setLogStream$Input) => Ok;

/**
 * Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
 */
export type getLogStream$Input = {
  readonly _: "getLogStream";
};

/**
 * Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
 */
export type getLogStream$DirectInput = {};

/**
 * Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
 *
 * @param {getLogStream$Input} parameters {@link getLogStream$Input}
 * @return {LogStream} {@link LogStream}
 */
export type getLogStream = (parameters: getLogStream$Input) => LogStream;

/**
 * Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
 */
export type setLogVerbosityLevel$Input = {
  readonly _: "setLogVerbosityLevel";

  /**
   * New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
   *
   * - value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging
   * @type {int32} {@link int32}
   */
  readonly new_verbosity_level?: int32;
};

/**
 * Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
 */
export type setLogVerbosityLevel$DirectInput = {
  /**
   * New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings,
   *
   * - value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging
   * @type {int32} {@link int32}
   */
  readonly new_verbosity_level?: int32;
};

/**
 * Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
 *
 * @param {setLogVerbosityLevel$Input} parameters {@link setLogVerbosityLevel$Input}
 * @return {Ok} {@link Ok}
 */
export type setLogVerbosityLevel = (parameters: setLogVerbosityLevel$Input) => Ok;

/**
 * Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
 */
export type getLogVerbosityLevel$Input = {
  readonly _: "getLogVerbosityLevel";
};

/**
 * Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
 */
export type getLogVerbosityLevel$DirectInput = {};

/**
 * Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
 *
 * @param {getLogVerbosityLevel$Input} parameters {@link getLogVerbosityLevel$Input}
 * @return {LogVerbosityLevel} {@link LogVerbosityLevel}
 */
export type getLogVerbosityLevel = (
  parameters: getLogVerbosityLevel$Input
) => LogVerbosityLevel;

/**
 * Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
 */
export type getLogTags$Input = {
  readonly _: "getLogTags";
};

/**
 * Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
 */
export type getLogTags$DirectInput = {};

/**
 * Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
 *
 * @param {getLogTags$Input} parameters {@link getLogTags$Input}
 * @return {LogTags} {@link LogTags}
 */
export type getLogTags = (parameters: getLogTags$Input) => LogTags;

/**
 * Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
 */
export type setLogTagVerbosityLevel$Input = {
  readonly _: "setLogTagVerbosityLevel";

  /**
   * Logging tag to change verbosity level
   * @type {string} {@link string}
   */
  readonly tag?: string;

  /**
   * New verbosity level; 1-1024
   * @type {int32} {@link int32}
   */
  readonly new_verbosity_level?: int32;
};

/**
 * Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
 */
export type setLogTagVerbosityLevel$DirectInput = {
  /**
   * Logging tag to change verbosity level
   * @type {string} {@link string}
   */
  readonly tag?: string;

  /**
   * New verbosity level; 1-1024
   * @type {int32} {@link int32}
   */
  readonly new_verbosity_level?: int32;
};

/**
 * Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
 *
 * @param {setLogTagVerbosityLevel$Input} parameters {@link setLogTagVerbosityLevel$Input}
 * @return {Ok} {@link Ok}
 */
export type setLogTagVerbosityLevel = (
  parameters: setLogTagVerbosityLevel$Input
) => Ok;

/**
 * Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
 */
export type getLogTagVerbosityLevel$Input = {
  readonly _: "getLogTagVerbosityLevel";

  /**
   * Logging tag to change verbosity level
   * @type {string} {@link string}
   */
  readonly tag?: string;
};

/**
 * Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
 */
export type getLogTagVerbosityLevel$DirectInput = {
  /**
   * Logging tag to change verbosity level
   * @type {string} {@link string}
   */
  readonly tag?: string;
};

/**
 * Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
 *
 * @param {getLogTagVerbosityLevel$Input} parameters {@link getLogTagVerbosityLevel$Input}
 * @return {LogVerbosityLevel} {@link LogVerbosityLevel}
 */
export type getLogTagVerbosityLevel = (
  parameters: getLogTagVerbosityLevel$Input
) => LogVerbosityLevel;

/**
 * Adds a message to TDLib internal log. Can be called synchronously
 */
export type addLogMessage$Input = {
  readonly _: "addLogMessage";

  /**
   * The minimum verbosity level needed for the message to be logged; 0-1023
   * @type {int32} {@link int32}
   */
  readonly verbosity_level?: int32;

  /**
   * Text of a message to log
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Adds a message to TDLib internal log. Can be called synchronously
 */
export type addLogMessage$DirectInput = {
  /**
   * The minimum verbosity level needed for the message to be logged; 0-1023
   * @type {int32} {@link int32}
   */
  readonly verbosity_level?: int32;

  /**
   * Text of a message to log
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Adds a message to TDLib internal log. Can be called synchronously
 *
 * @param {addLogMessage$Input} parameters {@link addLogMessage$Input}
 * @return {Ok} {@link Ok}
 */
export type addLogMessage = (parameters: addLogMessage$Input) => Ok;

/**
 * Returns support information for the given user; for Telegram support only
 */
export type getUserSupportInfo$Input = {
  readonly _: "getUserSupportInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns support information for the given user; for Telegram support only
 */
export type getUserSupportInfo$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns support information for the given user; for Telegram support only
 *
 * @param {getUserSupportInfo$Input} parameters {@link getUserSupportInfo$Input}
 * @return {UserSupportInfo} {@link UserSupportInfo}
 */
export type getUserSupportInfo = (
  parameters: getUserSupportInfo$Input
) => UserSupportInfo;

/**
 * Sets support information for the given user; for Telegram support only
 */
export type setUserSupportInfo$Input = {
  readonly _: "setUserSupportInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New information message
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly message?: formattedText$Input;
};

/**
 * Sets support information for the given user; for Telegram support only
 */
export type setUserSupportInfo$DirectInput = {
  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New information message
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly message?: formattedText$Input;
};

/**
 * Sets support information for the given user; for Telegram support only
 *
 * @param {setUserSupportInfo$Input} parameters {@link setUserSupportInfo$Input}
 * @return {UserSupportInfo} {@link UserSupportInfo}
 */
export type setUserSupportInfo = (
  parameters: setUserSupportInfo$Input
) => UserSupportInfo;

/**
 * Returns localized name of the Telegram support user; for Telegram support only
 */
export type getSupportName$Input = {
  readonly _: "getSupportName";
};

/**
 * Returns localized name of the Telegram support user; for Telegram support only
 */
export type getSupportName$DirectInput = {};

/**
 * Returns localized name of the Telegram support user; for Telegram support only
 *
 * @param {getSupportName$Input} parameters {@link getSupportName$Input}
 * @return {Text} {@link Text}
 */
export type getSupportName = (parameters: getSupportName$Input) => Text;

/**
 * Does nothing; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallEmpty$Input = {
  readonly _: "testCallEmpty";
};

/**
 * Does nothing; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallEmpty$DirectInput = {};

/**
 * Does nothing; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallEmpty$Input} parameters {@link testCallEmpty$Input}
 * @return {Ok} {@link Ok}
 */
export type testCallEmpty = (parameters: testCallEmpty$Input) => Ok;

/**
 * Returns the received string; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallString$Input = {
  readonly _: "testCallString";

  /**
   * String to return
   * @type {string} {@link string}
   */
  readonly x?: string;
};

/**
 * Returns the received string; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallString$DirectInput = {
  /**
   * String to return
   * @type {string} {@link string}
   */
  readonly x?: string;
};

/**
 * Returns the received string; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallString$Input} parameters {@link testCallString$Input}
 * @return {TestString} {@link TestString}
 */
export type testCallString = (parameters: testCallString$Input) => TestString;

/**
 * Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallBytes$Input = {
  readonly _: "testCallBytes";

  /**
   * Bytes to return
   * @type {bytes$Input} {@link bytes}
   */
  readonly x?: bytes$Input;
};

/**
 * Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallBytes$DirectInput = {
  /**
   * Bytes to return
   * @type {bytes$Input} {@link bytes}
   */
  readonly x?: bytes$Input;
};

/**
 * Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallBytes$Input} parameters {@link testCallBytes$Input}
 * @return {TestBytes} {@link TestBytes}
 */
export type testCallBytes = (parameters: testCallBytes$Input) => TestBytes;

/**
 * Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorInt$Input = {
  readonly _: "testCallVectorInt";

  /**
   * Vector of numbers to return
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly x?: vector$Input<int32>;
};

/**
 * Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorInt$DirectInput = {
  /**
   * Vector of numbers to return
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly x?: vector$Input<int32>;
};

/**
 * Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorInt$Input} parameters {@link testCallVectorInt$Input}
 * @return {TestVectorInt} {@link TestVectorInt}
 */
export type testCallVectorInt = (
  parameters: testCallVectorInt$Input
) => TestVectorInt;

/**
 * Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorIntObject$Input = {
  readonly _: "testCallVectorIntObject";

  /**
   * Vector of objects to return
   * @type {vector$Input<testInt$Input>} {@link vector<testInt>}
   */
  readonly x?: vector$Input<testInt$Input>;
};

/**
 * Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorIntObject$DirectInput = {
  /**
   * Vector of objects to return
   * @type {vector$Input<testInt$Input>} {@link vector<testInt>}
   */
  readonly x?: vector$Input<testInt$Input>;
};

/**
 * Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorIntObject$Input} parameters {@link testCallVectorIntObject$Input}
 * @return {TestVectorIntObject} {@link TestVectorIntObject}
 */
export type testCallVectorIntObject = (
  parameters: testCallVectorIntObject$Input
) => TestVectorIntObject;

/**
 * Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorString$Input = {
  readonly _: "testCallVectorString";

  /**
   * Vector of strings to return
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly x?: vector$Input<string>;
};

/**
 * Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorString$DirectInput = {
  /**
   * Vector of strings to return
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly x?: vector$Input<string>;
};

/**
 * Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorString$Input} parameters {@link testCallVectorString$Input}
 * @return {TestVectorString} {@link TestVectorString}
 */
export type testCallVectorString = (
  parameters: testCallVectorString$Input
) => TestVectorString;

/**
 * Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorStringObject$Input = {
  readonly _: "testCallVectorStringObject";

  /**
   * Vector of objects to return
   * @type {vector$Input<testString$Input>} {@link vector<testString>}
   */
  readonly x?: vector$Input<testString$Input>;
};

/**
 * Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
 */
export type testCallVectorStringObject$DirectInput = {
  /**
   * Vector of objects to return
   * @type {vector$Input<testString$Input>} {@link vector<testString>}
   */
  readonly x?: vector$Input<testString$Input>;
};

/**
 * Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorStringObject$Input} parameters {@link testCallVectorStringObject$Input}
 * @return {TestVectorStringObject} {@link TestVectorStringObject}
 */
export type testCallVectorStringObject = (
  parameters: testCallVectorStringObject$Input
) => TestVectorStringObject;

/**
 * Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
 */
export type testSquareInt$Input = {
  readonly _: "testSquareInt";

  /**
   * Number to square
   * @type {int32} {@link int32}
   */
  readonly x?: int32;
};

/**
 * Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
 */
export type testSquareInt$DirectInput = {
  /**
   * Number to square
   * @type {int32} {@link int32}
   */
  readonly x?: int32;
};

/**
 * Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testSquareInt$Input} parameters {@link testSquareInt$Input}
 * @return {TestInt} {@link TestInt}
 */
export type testSquareInt = (parameters: testSquareInt$Input) => TestInt;

/**
 * Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
 */
export type testNetwork$Input = {
  readonly _: "testNetwork";
};

/**
 * Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
 */
export type testNetwork$DirectInput = {};

/**
 * Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
 *
 * @param {testNetwork$Input} parameters {@link testNetwork$Input}
 * @return {Ok} {@link Ok}
 */
export type testNetwork = (parameters: testNetwork$Input) => Ok;

/**
 * Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
 */
export type testProxy$Input = {
  readonly _: "testProxy";

  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;

  /**
   * Identifier of a datacenter with which to test connection
   * @type {int32} {@link int32}
   */
  readonly dc_id?: int32;

  /**
   * The maximum overall timeout for the request
   * @type {double} {@link double}
   */
  readonly timeout?: double;
};

/**
 * Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
 */
export type testProxy$DirectInput = {
  /**
   * Proxy server domain or IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;

  /**
   * Identifier of a datacenter with which to test connection
   * @type {int32} {@link int32}
   */
  readonly dc_id?: int32;

  /**
   * The maximum overall timeout for the request
   * @type {double} {@link double}
   */
  readonly timeout?: double;
};

/**
 * Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
 *
 * @param {testProxy$Input} parameters {@link testProxy$Input}
 * @return {Ok} {@link Ok}
 */
export type testProxy = (parameters: testProxy$Input) => Ok;

/**
 * Forces an updates.getDifference call to the Telegram servers; for testing only
 */
export type testGetDifference$Input = {
  readonly _: "testGetDifference";
};

/**
 * Forces an updates.getDifference call to the Telegram servers; for testing only
 */
export type testGetDifference$DirectInput = {};

/**
 * Forces an updates.getDifference call to the Telegram servers; for testing only
 *
 * @param {testGetDifference$Input} parameters {@link testGetDifference$Input}
 * @return {Ok} {@link Ok}
 */
export type testGetDifference = (parameters: testGetDifference$Input) => Ok;

/**
 * Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
 */
export type testUseUpdate$Input = {
  readonly _: "testUseUpdate";
};

/**
 * Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
 */
export type testUseUpdate$DirectInput = {};

/**
 * Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testUseUpdate$Input} parameters {@link testUseUpdate$Input}
 * @return {Update} {@link Update}
 */
export type testUseUpdate = (parameters: testUseUpdate$Input) => Update;

/**
 * Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
 */
export type testReturnError$Input = {
  readonly _: "testReturnError";

  /**
   * The error to be returned
   * @type {error$Input} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
 */
export type testReturnError$DirectInput = {
  /**
   * The error to be returned
   * @type {error$Input} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
 *
 * @param {testReturnError$Input} parameters {@link testReturnError$Input}
 * @return {Error} {@link Error}
 */
export type testReturnError = (parameters: testReturnError$Input) => Error;
