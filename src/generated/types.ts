/** String of bytes in HEX or Base64 */
export type bytes = string;

/** (float64) */
export type double = number;

/** (float64) Number ranging from Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER */
export type int53 = number;

/** (int32) Number ranging from -2147483648 to 2147483647 */
export type int32 = number;

/** String digits. Use BigInt for handling this */
export type int64 = string;

export type boolTrue = true;

export type boolFalse = false;

export type vector$Input<T> = ReadonlyArray<T>;

export type vector<T> = Array<T>;

/** An object of this type can be returned on every function call, in case of an error */
export type error = {
  _: "error";

  /**
   * Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
   * @type {int32} {@link int32}
   */
  code: int32;

  /**
   * Error message; subject to future changes
   * @type {string} {@link string}
   */
  message: string;
};

export type error$Input = {
  readonly _: "error";

  /**
   * Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
   * @type {int32} {@link int32}
   */
  readonly code?: int32;

  /**
   * Error message; subject to future changes
   * @type {string} {@link string}
   */
  readonly message?: string;
};

/** An object of this type is returned on a successful function call for certain functions */
export type ok = {
  _: "ok";
};

export type ok$Input = {
  readonly _: "ok";
};

/** An authentication code is delivered via a private Telegram message, which can be viewed from another active session */
export type authenticationCodeTypeTelegramMessage = {
  _: "authenticationCodeTypeTelegramMessage";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

export type authenticationCodeTypeTelegramMessage$Input = {
  readonly _: "authenticationCodeTypeTelegramMessage";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/** An authentication code is delivered via an SMS message to the specified phone number */
export type authenticationCodeTypeSms = {
  _: "authenticationCodeTypeSms";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

export type authenticationCodeTypeSms$Input = {
  readonly _: "authenticationCodeTypeSms";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/** An authentication code is delivered via a phone call to the specified phone number */
export type authenticationCodeTypeCall = {
  _: "authenticationCodeTypeCall";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  length: int32;
};

export type authenticationCodeTypeCall$Input = {
  readonly _: "authenticationCodeTypeCall";

  /**
   * Length of the code
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/** An authentication code is delivered by an immediately canceled call to the specified phone number. The phone number that calls is the code that must be entered automatically */
export type authenticationCodeTypeFlashCall = {
  _: "authenticationCodeTypeFlashCall";

  /**
   * Pattern of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  pattern: string;
};

export type authenticationCodeTypeFlashCall$Input = {
  readonly _: "authenticationCodeTypeFlashCall";

  /**
   * Pattern of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  readonly pattern?: string;
};

/** An authentication code is delivered by an immediately canceled call to the specified phone number. The last digits of the phone number that calls are the code that must be entered manually by the user */
export type authenticationCodeTypeMissedCall = {
  _: "authenticationCodeTypeMissedCall";

  /**
   * Prefix of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  phone_number_prefix: string;

  /**
   * Number of digits in the code, excluding the prefix
   * @type {int32} {@link int32}
   */
  length: int32;
};

export type authenticationCodeTypeMissedCall$Input = {
  readonly _: "authenticationCodeTypeMissedCall";

  /**
   * Prefix of the phone number from which the call will be made
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;

  /**
   * Number of digits in the code, excluding the prefix
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/** Information about the authentication code that was sent */
export type authenticationCodeInfo = {
  _: "authenticationCodeInfo";

  /**
   * A phone number that is being authenticated
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * The way the code was sent to the user
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  type: AuthenticationCodeType;

  /**
   * The way the next code will be sent to the user; may be null
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  next_type: AuthenticationCodeType;

  /**
   * Timeout before the code can be re-sent, in seconds
   * @type {int32} {@link int32}
   */
  timeout: int32;
};

export type authenticationCodeInfo$Input = {
  readonly _: "authenticationCodeInfo";

  /**
   * A phone number that is being authenticated
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * The way the code was sent to the user
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  readonly type?: AuthenticationCodeType$Input;

  /**
   * The way the next code will be sent to the user; may be null
   * @type {AuthenticationCodeType} {@link AuthenticationCodeType}
   */
  readonly next_type?: AuthenticationCodeType$Input;

  /**
   * Timeout before the code can be re-sent, in seconds
   * @type {int32} {@link int32}
   */
  readonly timeout?: int32;
};

/** Information about the email address authentication code that was sent */
export type emailAddressAuthenticationCodeInfo = {
  _: "emailAddressAuthenticationCodeInfo";

  /**
   * Pattern of the email address to which an authentication code was sent
   * @type {string} {@link string}
   */
  email_address_pattern: string;

  /**
   * Length of the code; 0 if unknown
   * @type {int32} {@link int32}
   */
  length: int32;
};

export type emailAddressAuthenticationCodeInfo$Input = {
  readonly _: "emailAddressAuthenticationCodeInfo";

  /**
   * Pattern of the email address to which an authentication code was sent
   * @type {string} {@link string}
   */
  readonly email_address_pattern?: string;

  /**
   * Length of the code; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/** An authentication code delivered to a user's email address */
export type emailAddressAuthenticationCode = {
  _: "emailAddressAuthenticationCode";

  /**
   * The code
   * @type {string} {@link string}
   */
  code: string;
};

export type emailAddressAuthenticationCode$Input = {
  readonly _: "emailAddressAuthenticationCode";

  /**
   * The code
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/** An authentication token received through Apple ID */
export type emailAddressAuthenticationAppleId = {
  _: "emailAddressAuthenticationAppleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  token: string;
};

export type emailAddressAuthenticationAppleId$Input = {
  readonly _: "emailAddressAuthenticationAppleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/** An authentication token received through Google ID */
export type emailAddressAuthenticationGoogleId = {
  _: "emailAddressAuthenticationGoogleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  token: string;
};

export type emailAddressAuthenticationGoogleId$Input = {
  readonly _: "emailAddressAuthenticationGoogleId";

  /**
   * The token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/** Represents a part of the text that needs to be formatted in some unusual way */
export type textEntity = {
  _: "textEntity";

  /**
   * Offset of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  offset: int32;

  /**
   * Length of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  length: int32;

  /**
   * Type of the entity
   * @type {TextEntityType} {@link TextEntityType}
   */
  type: TextEntityType;
};

export type textEntity$Input = {
  readonly _: "textEntity";

  /**
   * Offset of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * Length of the entity, in UTF-16 code units
   * @type {int32} {@link int32}
   */
  readonly length?: int32;

  /**
   * Type of the entity
   * @type {TextEntityType} {@link TextEntityType}
   */
  readonly type?: TextEntityType$Input;
};

/** Contains a list of text entities */
export type textEntities = {
  _: "textEntities";

  /**
   * List of text entities
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  entities: vector<textEntity>;
};

export type textEntities$Input = {
  readonly _: "textEntities";

  /**
   * List of text entities
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  readonly entities?: vector$Input<textEntity$Input>;
};

/** A text with some entities */
export type formattedText = {
  _: "formattedText";

  /**
   * The text
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Entities contained in the text. Entities can be nested, but must not mutually intersect with each other.
   *
   * -Pre, Code and PreCode entities can't contain other entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  entities: vector<textEntity>;
};

export type formattedText$Input = {
  readonly _: "formattedText";

  /**
   * The text
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Entities contained in the text. Entities can be nested, but must not mutually intersect with each other.
   *
   * -Pre, Code and PreCode entities can't contain other entities. Bold, Italic, Underline, Strikethrough, and Spoiler entities can contain and can be part of any other entities. All other entities can't contain each other
   * @type {vector<textEntity>} {@link vector<textEntity>}
   */
  readonly entities?: vector$Input<textEntity$Input>;
};

/** Contains Telegram terms of service */
export type termsOfService = {
  _: "termsOfService";

  /**
   * Text of the terms of service
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
   * @type {int32} {@link int32}
   */
  min_user_age: int32;

  /**
   * True, if a blocking popup with terms of service must be shown to the user
   * @type {Bool} {@link Bool}
   */
  show_popup: Bool;
};

export type termsOfService$Input = {
  readonly _: "termsOfService";

  /**
   * Text of the terms of service
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * The minimum age of a user to be able to accept the terms; 0 if age isn't restricted
   * @type {int32} {@link int32}
   */
  readonly min_user_age?: int32;

  /**
   * True, if a blocking popup with terms of service must be shown to the user
   * @type {Bool} {@link Bool}
   */
  readonly show_popup?: Bool$Input;
};

/** Initializetion parameters are needed. Call `setTdlibParameters` to provide them */
export type authorizationStateWaitTdlibParameters = {
  _: "authorizationStateWaitTdlibParameters";
};

export type authorizationStateWaitTdlibParameters$Input = {
  readonly _: "authorizationStateWaitTdlibParameters";
};

/** TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber` to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken` for other authentication options */
export type authorizationStateWaitPhoneNumber = {
  _: "authorizationStateWaitPhoneNumber";
};

export type authorizationStateWaitPhoneNumber$Input = {
  readonly _: "authorizationStateWaitPhoneNumber";
};

/** TDLib needs the user's email address to authorize. Call `setAuthenticationEmailAddress` to provide the email address, or directly call `checkAuthenticationEmailCode` with Apple ID/Google ID token if allowed */
export type authorizationStateWaitEmailAddress = {
  _: "authorizationStateWaitEmailAddress";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_apple_id: Bool;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_google_id: Bool;
};

export type authorizationStateWaitEmailAddress$Input = {
  readonly _: "authorizationStateWaitEmailAddress";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_apple_id?: Bool$Input;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_google_id?: Bool$Input;
};

/** TDLib needs the user's authentication code sent to an email address to authorize. Call `checkAuthenticationEmailCode` to provide the code */
export type authorizationStateWaitEmailCode = {
  _: "authorizationStateWaitEmailCode";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_apple_id: Bool;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  allow_google_id: Bool;

  /**
   * Information about the sent authentication code
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  code_info: emailAddressAuthenticationCodeInfo;

  /**
   * Point in time (Unix timestamp) when the user will be able to authorize with a code sent to the user's phone number; 0 if unknown
   * @type {int32} {@link int32}
   */
  next_phone_number_authorization_date: int32;
};

export type authorizationStateWaitEmailCode$Input = {
  readonly _: "authorizationStateWaitEmailCode";

  /**
   * True, if authorization through Apple ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_apple_id?: Bool$Input;

  /**
   * True, if authorization through Google ID is allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_google_id?: Bool$Input;

  /**
   * Information about the sent authentication code
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  readonly code_info?: emailAddressAuthenticationCodeInfo$Input;

  /**
   * Point in time (Unix timestamp) when the user will be able to authorize with a code sent to the user's phone number; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly next_phone_number_authorization_date?: int32;
};

/** TDLib needs the user's authentication code to authorize */
export type authorizationStateWaitCode = {
  _: "authorizationStateWaitCode";

  /**
   * Information about the authorization code that was sent
   * @type {authenticationCodeInfo} {@link authenticationCodeInfo}
   */
  code_info: authenticationCodeInfo;
};

export type authorizationStateWaitCode$Input = {
  readonly _: "authorizationStateWaitCode";

  /**
   * Information about the authorization code that was sent
   * @type {authenticationCodeInfo} {@link authenticationCodeInfo}
   */
  readonly code_info?: authenticationCodeInfo$Input;
};

/** The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link */
export type authorizationStateWaitOtherDeviceConfirmation = {
  _: "authorizationStateWaitOtherDeviceConfirmation";

  /**
   * A tg:// URL for the QR code. The link will be updated frequently
   * @type {string} {@link string}
   */
  link: string;
};

export type authorizationStateWaitOtherDeviceConfirmation$Input = {
  readonly _: "authorizationStateWaitOtherDeviceConfirmation";

  /**
   * A tg:// URL for the QR code. The link will be updated frequently
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/** The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration */
export type authorizationStateWaitRegistration = {
  _: "authorizationStateWaitRegistration";

  /**
   * Telegram terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  terms_of_service: termsOfService;
};

export type authorizationStateWaitRegistration$Input = {
  readonly _: "authorizationStateWaitRegistration";

  /**
   * Telegram terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  readonly terms_of_service?: termsOfService$Input;
};

/** The user has been authorized, but needs to enter a 2-step verification password to start using the application */
export type authorizationStateWaitPassword = {
  _: "authorizationStateWaitPassword";

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  password_hint: string;

  /**
   * True, if a recovery email address has been set up
   * @type {Bool} {@link Bool}
   */
  has_recovery_email_address: Bool;

  /**
   * Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
   * @type {string} {@link string}
   */
  recovery_email_address_pattern: string;
};

export type authorizationStateWaitPassword$Input = {
  readonly _: "authorizationStateWaitPassword";

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  readonly password_hint?: string;

  /**
   * True, if a recovery email address has been set up
   * @type {Bool} {@link Bool}
   */
  readonly has_recovery_email_address?: Bool$Input;

  /**
   * Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
   * @type {string} {@link string}
   */
  readonly recovery_email_address_pattern?: string;
};

/** The user has been successfully authorized. TDLib is now ready to answer queries */
export type authorizationStateReady = {
  _: "authorizationStateReady";
};

export type authorizationStateReady$Input = {
  readonly _: "authorizationStateReady";
};

/** The user is currently logging out */
export type authorizationStateLoggingOut = {
  _: "authorizationStateLoggingOut";
};

export type authorizationStateLoggingOut$Input = {
  readonly _: "authorizationStateLoggingOut";
};

/** TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received */
export type authorizationStateClosing = {
  _: "authorizationStateClosing";
};

export type authorizationStateClosing$Input = {
  readonly _: "authorizationStateClosing";
};

/** TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to
-with error code 500. To continue working, one must create a new instance of the TDLib client */
export type authorizationStateClosed = {
  _: "authorizationStateClosed";
};

export type authorizationStateClosed$Input = {
  readonly _: "authorizationStateClosed";
};

/** Represents the current state of 2-step verification */
export type passwordState = {
  _: "passwordState";

  /**
   * True, if a 2-step verification password is set
   * @type {Bool} {@link Bool}
   */
  has_password: Bool;

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  password_hint: string;

  /**
   * True, if a recovery email is set
   * @type {Bool} {@link Bool}
   */
  has_recovery_email_address: Bool;

  /**
   * True, if some Telegram Passport elements were saved
   * @type {Bool} {@link Bool}
   */
  has_passport_data: Bool;

  /**
   * Information about the recovery email address to which the confirmation email was sent; may be null
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  recovery_email_address_code_info: emailAddressAuthenticationCodeInfo;

  /**
   * Pattern of the email address set up for logging in
   * @type {string} {@link string}
   */
  login_email_address_pattern: string;

  /**
   * If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  pending_reset_date: int32;
};

export type passwordState$Input = {
  readonly _: "passwordState";

  /**
   * True, if a 2-step verification password is set
   * @type {Bool} {@link Bool}
   */
  readonly has_password?: Bool$Input;

  /**
   * Hint for the password; may be empty
   * @type {string} {@link string}
   */
  readonly password_hint?: string;

  /**
   * True, if a recovery email is set
   * @type {Bool} {@link Bool}
   */
  readonly has_recovery_email_address?: Bool$Input;

  /**
   * True, if some Telegram Passport elements were saved
   * @type {Bool} {@link Bool}
   */
  readonly has_passport_data?: Bool$Input;

  /**
   * Information about the recovery email address to which the confirmation email was sent; may be null
   * @type {emailAddressAuthenticationCodeInfo} {@link emailAddressAuthenticationCodeInfo}
   */
  readonly recovery_email_address_code_info?: emailAddressAuthenticationCodeInfo$Input;

  /**
   * Pattern of the email address set up for logging in
   * @type {string} {@link string}
   */
  readonly login_email_address_pattern?: string;

  /**
   * If not 0, point in time (Unix timestamp) after which the 2-step verification password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  readonly pending_reset_date?: int32;
};

/** Contains information about the current recovery email address */
export type recoveryEmailAddress = {
  _: "recoveryEmailAddress";

  /**
   * Recovery email address
   * @type {string} {@link string}
   */
  recovery_email_address: string;
};

export type recoveryEmailAddress$Input = {
  readonly _: "recoveryEmailAddress";

  /**
   * Recovery email address
   * @type {string} {@link string}
   */
  readonly recovery_email_address?: string;
};

/** Returns information about the availability of a temporary password, which can be used for payments */
export type temporaryPasswordState = {
  _: "temporaryPasswordState";

  /**
   * True, if a temporary password is available
   * @type {Bool} {@link Bool}
   */
  has_password: Bool;

  /**
   * Time left before the temporary password expires, in seconds
   * @type {int32} {@link int32}
   */
  valid_for: int32;
};

export type temporaryPasswordState$Input = {
  readonly _: "temporaryPasswordState";

  /**
   * True, if a temporary password is available
   * @type {Bool} {@link Bool}
   */
  readonly has_password?: Bool$Input;

  /**
   * Time left before the temporary password expires, in seconds
   * @type {int32} {@link int32}
   */
  readonly valid_for?: int32;
};

/** Represents a local file */
export type localFile = {
  _: "localFile";

  /**
   * Local path to the locally available file part; may be empty
   * @type {string} {@link string}
   */
  path: string;

  /**
   * True, if it is possible to download or generate the file
   * @type {Bool} {@link Bool}
   */
  can_be_downloaded: Bool;

  /**
   * True, if the file can be deleted
   * @type {Bool} {@link Bool}
   */
  can_be_deleted: Bool;

  /**
   * True, if the file is currently being downloaded (or a local copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  is_downloading_active: Bool;

  /**
   * True, if the local copy is fully available
   * @type {Bool} {@link Bool}
   */
  is_downloading_completed: Bool;

  /**
   * Download will be started from this offset. downloaded_prefix_size is calculated from this offset
   * @type {int53} {@link int53}
   */
  download_offset: int53;

  /**
   * If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
   * @type {int53} {@link int53}
   */
  downloaded_prefix_size: int53;

  /**
   * Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
   * @type {int53} {@link int53}
   */
  downloaded_size: int53;
};

export type localFile$Input = {
  readonly _: "localFile";

  /**
   * Local path to the locally available file part; may be empty
   * @type {string} {@link string}
   */
  readonly path?: string;

  /**
   * True, if it is possible to download or generate the file
   * @type {Bool} {@link Bool}
   */
  readonly can_be_downloaded?: Bool$Input;

  /**
   * True, if the file can be deleted
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted?: Bool$Input;

  /**
   * True, if the file is currently being downloaded (or a local copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  readonly is_downloading_active?: Bool$Input;

  /**
   * True, if the local copy is fully available
   * @type {Bool} {@link Bool}
   */
  readonly is_downloading_completed?: Bool$Input;

  /**
   * Download will be started from this offset. downloaded_prefix_size is calculated from this offset
   * @type {int53} {@link int53}
   */
  readonly download_offset?: int53;

  /**
   * If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
   * @type {int53} {@link int53}
   */
  readonly downloaded_prefix_size?: int53;

  /**
   * Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
   * @type {int53} {@link int53}
   */
  readonly downloaded_size?: int53;
};

/** Represents a remote file */
export type remoteFile = {
  _: "remoteFile";

  /**
   * Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
   *
   * -If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
   *
   * -If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
   * @type {string} {@link string}
   */
  unique_id: string;

  /**
   * True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  is_uploading_active: Bool;

  /**
   * True, if a remote copy is fully available
   * @type {Bool} {@link Bool}
   */
  is_uploading_completed: Bool;

  /**
   * Size of the remote available part of the file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  uploaded_size: int53;
};

export type remoteFile$Input = {
  readonly _: "remoteFile";

  /**
   * Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
   *
   * -If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
   *
   * -If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
   * @type {string} {@link string}
   */
  readonly unique_id?: string;

  /**
   * True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
   * @type {Bool} {@link Bool}
   */
  readonly is_uploading_active?: Bool$Input;

  /**
   * True, if a remote copy is fully available
   * @type {Bool} {@link Bool}
   */
  readonly is_uploading_completed?: Bool$Input;

  /**
   * Size of the remote available part of the file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly uploaded_size?: int53;
};

/** Represents a file */
export type file = {
  _: "file";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * File size, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
   * @type {int53} {@link int53}
   */
  expected_size: int53;

  /**
   * Information about the local copy of the file
   * @type {localFile} {@link localFile}
   */
  local: localFile;

  /**
   * Information about the remote copy of the file
   * @type {remoteFile} {@link remoteFile}
   */
  remote: remoteFile;
};

export type file$Input = {
  readonly _: "file";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * File size, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;

  /**
   * Information about the local copy of the file
   * @type {localFile} {@link localFile}
   */
  readonly local?: localFile$Input;

  /**
   * Information about the remote copy of the file
   * @type {remoteFile} {@link remoteFile}
   */
  readonly remote?: remoteFile$Input;
};

/** A file defined by its unique ID */
export type inputFileId = {
  _: "inputFileId";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  id: int32;
};

export type inputFileId$Input = {
  readonly _: "inputFileId";

  /**
   * Unique file identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;
};

/** A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib.
-For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application */
export type inputFileRemote = {
  _: "inputFileRemote";

  /**
   * Remote file identifier
   * @type {string} {@link string}
   */
  id: string;
};

export type inputFileRemote$Input = {
  readonly _: "inputFileRemote";

  /**
   * Remote file identifier
   * @type {string} {@link string}
   */
  readonly id?: string;
};

/** A file defined by a local path */
export type inputFileLocal = {
  _: "inputFileLocal";

  /**
   * Local path to the file
   * @type {string} {@link string}
   */
  path: string;
};

export type inputFileLocal$Input = {
  readonly _: "inputFileLocal";

  /**
   * Local path to the file
   * @type {string} {@link string}
   */
  readonly path?: string;
};

/** A file generated by the application */
export type inputFileGenerated = {
  _: "inputFileGenerated";

  /**
   * Local path to a file from which the file is generated; may be empty if there is no such file
   * @type {string} {@link string}
   */
  original_path: string;

  /**
   * String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
   * @type {string} {@link string}
   */
  conversion: string;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  expected_size: int53;
};

export type inputFileGenerated$Input = {
  readonly _: "inputFileGenerated";

  /**
   * Local path to a file from which the file is generated; may be empty if there is no such file
   * @type {string} {@link string}
   */
  readonly original_path?: string;

  /**
   * String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
   * @type {string} {@link string}
   */
  readonly conversion?: string;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;
};

/** Describes an image in JPEG format */
export type photoSize = {
  _: "photoSize";

  /**
   * Image type (see https://core.telegram.org/constructor/photoSize)
   * @type {string} {@link string}
   */
  type: string;

  /**
   * Information about the image file
   * @type {file} {@link file}
   */
  photo: file;

  /**
   * Image width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Image height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
   * @type {vector<int32>} {@link vector<int32>}
   */
  progressive_sizes: vector<int32>;
};

export type photoSize$Input = {
  readonly _: "photoSize";

  /**
   * Image type (see https://core.telegram.org/constructor/photoSize)
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Information about the image file
   * @type {file} {@link file}
   */
  readonly photo?: file$Input;

  /**
   * Image width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Image height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly progressive_sizes?: vector$Input<int32>;
};

/** Thumbnail image of a very poor quality and low resolution */
export type minithumbnail = {
  _: "minithumbnail";

  /**
   * Thumbnail width, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Thumbnail height, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * The thumbnail in JPEG format
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type minithumbnail$Input = {
  readonly _: "minithumbnail";

  /**
   * Thumbnail width, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Thumbnail height, usually doesn't exceed 40
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * The thumbnail in JPEG format
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** The thumbnail is in JPEG format */
export type thumbnailFormatJpeg = {
  _: "thumbnailFormatJpeg";
};

export type thumbnailFormatJpeg$Input = {
  readonly _: "thumbnailFormatJpeg";
};

/** The thumbnail is in static GIF format. It will be used only for some bot inline results */
export type thumbnailFormatGif = {
  _: "thumbnailFormatGif";
};

export type thumbnailFormatGif$Input = {
  readonly _: "thumbnailFormatGif";
};

/** The thumbnail is in MPEG4 format. It will be used only for some animations and videos */
export type thumbnailFormatMpeg4 = {
  _: "thumbnailFormatMpeg4";
};

export type thumbnailFormatMpeg4$Input = {
  readonly _: "thumbnailFormatMpeg4";
};

/** The thumbnail is in PNG format. It will be used only for background patterns */
export type thumbnailFormatPng = {
  _: "thumbnailFormatPng";
};

export type thumbnailFormatPng$Input = {
  readonly _: "thumbnailFormatPng";
};

/** The thumbnail is in TGS format. It will be used only for TGS sticker sets */
export type thumbnailFormatTgs = {
  _: "thumbnailFormatTgs";
};

export type thumbnailFormatTgs$Input = {
  readonly _: "thumbnailFormatTgs";
};

/** The thumbnail is in WEBM format. It will be used only for WEBM sticker sets */
export type thumbnailFormatWebm = {
  _: "thumbnailFormatWebm";
};

export type thumbnailFormatWebm$Input = {
  readonly _: "thumbnailFormatWebm";
};

/** The thumbnail is in WEBP format. It will be used only for some stickers */
export type thumbnailFormatWebp = {
  _: "thumbnailFormatWebp";
};

export type thumbnailFormatWebp$Input = {
  readonly _: "thumbnailFormatWebp";
};

/** Represents a thumbnail */
export type thumbnail = {
  _: "thumbnail";

  /**
   * Thumbnail format
   * @type {ThumbnailFormat} {@link ThumbnailFormat}
   */
  format: ThumbnailFormat;

  /**
   * Thumbnail width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Thumbnail height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * The thumbnail
   * @type {file} {@link file}
   */
  file: file;
};

export type thumbnail$Input = {
  readonly _: "thumbnail";

  /**
   * Thumbnail format
   * @type {ThumbnailFormat} {@link ThumbnailFormat}
   */
  readonly format?: ThumbnailFormat$Input;

  /**
   * Thumbnail width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Thumbnail height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * The thumbnail
   * @type {file} {@link file}
   */
  readonly file?: file$Input;
};

/** The mask is placed relatively to the forehead */
export type maskPointForehead = {
  _: "maskPointForehead";
};

export type maskPointForehead$Input = {
  readonly _: "maskPointForehead";
};

/** The mask is placed relatively to the eyes */
export type maskPointEyes = {
  _: "maskPointEyes";
};

export type maskPointEyes$Input = {
  readonly _: "maskPointEyes";
};

/** The mask is placed relatively to the mouth */
export type maskPointMouth = {
  _: "maskPointMouth";
};

export type maskPointMouth$Input = {
  readonly _: "maskPointMouth";
};

/** The mask is placed relatively to the chin */
export type maskPointChin = {
  _: "maskPointChin";
};

export type maskPointChin$Input = {
  readonly _: "maskPointChin";
};

/** Position on a photo where a mask is placed */
export type maskPosition = {
  _: "maskPosition";

  /**
   * Part of the face, relative to which the mask is placed
   * @type {MaskPoint} {@link MaskPoint}
   */
  point: MaskPoint;

  /**
   * Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
   * @type {double} {@link double}
   */
  x_shift: double;

  /**
   * Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
   * @type {double} {@link double}
   */
  y_shift: double;

  /**
   * Mask scaling coefficient. (For example, 2.0 means a doubled size)
   * @type {double} {@link double}
   */
  scale: double;
};

export type maskPosition$Input = {
  readonly _: "maskPosition";

  /**
   * Part of the face, relative to which the mask is placed
   * @type {MaskPoint} {@link MaskPoint}
   */
  readonly point?: MaskPoint$Input;

  /**
   * Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
   * @type {double} {@link double}
   */
  readonly x_shift?: double;

  /**
   * Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
   * @type {double} {@link double}
   */
  readonly y_shift?: double;

  /**
   * Mask scaling coefficient. (For example, 2.0 means a doubled size)
   * @type {double} {@link double}
   */
  readonly scale?: double;
};

/** The sticker is an image in WEBP format */
export type stickerFormatWebp = {
  _: "stickerFormatWebp";
};

export type stickerFormatWebp$Input = {
  readonly _: "stickerFormatWebp";
};

/** The sticker is an animation in TGS format */
export type stickerFormatTgs = {
  _: "stickerFormatTgs";
};

export type stickerFormatTgs$Input = {
  readonly _: "stickerFormatTgs";
};

/** The sticker is a video in WEBM format */
export type stickerFormatWebm = {
  _: "stickerFormatWebm";
};

export type stickerFormatWebm$Input = {
  readonly _: "stickerFormatWebm";
};

/** The sticker is a regular sticker */
export type stickerTypeRegular = {
  _: "stickerTypeRegular";
};

export type stickerTypeRegular$Input = {
  readonly _: "stickerTypeRegular";
};

/** The sticker is a mask in WEBP format to be placed on photos or videos */
export type stickerTypeMask = {
  _: "stickerTypeMask";
};

export type stickerTypeMask$Input = {
  readonly _: "stickerTypeMask";
};

/** The sticker is a custom emoji to be used inside message text and caption */
export type stickerTypeCustomEmoji = {
  _: "stickerTypeCustomEmoji";
};

export type stickerTypeCustomEmoji$Input = {
  readonly _: "stickerTypeCustomEmoji";
};

/** Represents a closed vector path. The path begins at the end point of the last command */
export type closedVectorPath = {
  _: "closedVectorPath";

  /**
   * List of vector path commands
   * @type {vector<VectorPathCommand>} {@link vector<VectorPathCommand>}
   */
  commands: vector<VectorPathCommand>;
};

export type closedVectorPath$Input = {
  readonly _: "closedVectorPath";

  /**
   * List of vector path commands
   * @type {vector<VectorPathCommand>} {@link vector<VectorPathCommand>}
   */
  readonly commands?: vector$Input<VectorPathCommand$Input>;
};

/** Describes one answer option of a poll */
export type pollOption = {
  _: "pollOption";

  /**
   * Option text; 1-100 characters
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Number of voters for this option, available only for closed or voted polls
   * @type {int32} {@link int32}
   */
  voter_count: int32;

  /**
   * The percentage of votes for this option; 0-100
   * @type {int32} {@link int32}
   */
  vote_percentage: int32;

  /**
   * True, if the option was chosen by the user
   * @type {Bool} {@link Bool}
   */
  is_chosen: Bool;

  /**
   * True, if the option is being chosen by a pending setPollAnswer request
   * @type {Bool} {@link Bool}
   */
  is_being_chosen: Bool;
};

export type pollOption$Input = {
  readonly _: "pollOption";

  /**
   * Option text; 1-100 characters
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Number of voters for this option, available only for closed or voted polls
   * @type {int32} {@link int32}
   */
  readonly voter_count?: int32;

  /**
   * The percentage of votes for this option; 0-100
   * @type {int32} {@link int32}
   */
  readonly vote_percentage?: int32;

  /**
   * True, if the option was chosen by the user
   * @type {Bool} {@link Bool}
   */
  readonly is_chosen?: Bool$Input;

  /**
   * True, if the option is being chosen by a pending setPollAnswer request
   * @type {Bool} {@link Bool}
   */
  readonly is_being_chosen?: Bool$Input;
};

/** A regular poll */
export type pollTypeRegular = {
  _: "pollTypeRegular";

  /**
   * True, if multiple answer options can be chosen simultaneously
   * @type {Bool} {@link Bool}
   */
  allow_multiple_answers: Bool;
};

export type pollTypeRegular$Input = {
  readonly _: "pollTypeRegular";

  /**
   * True, if multiple answer options can be chosen simultaneously
   * @type {Bool} {@link Bool}
   */
  readonly allow_multiple_answers?: Bool$Input;
};

/** A poll in quiz mode, which has exactly one correct answer option and can be answered only once */
export type pollTypeQuiz = {
  _: "pollTypeQuiz";

  /**
   * 0-based identifier of the correct answer option; -1 for a yet unanswered poll
   * @type {int32} {@link int32}
   */
  correct_option_id: int32;

  /**
   * Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
   * @type {formattedText} {@link formattedText}
   */
  explanation: formattedText;
};

export type pollTypeQuiz$Input = {
  readonly _: "pollTypeQuiz";

  /**
   * 0-based identifier of the correct answer option; -1 for a yet unanswered poll
   * @type {int32} {@link int32}
   */
  readonly correct_option_id?: int32;

  /**
   * Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
   * @type {formattedText} {@link formattedText}
   */
  readonly explanation?: formattedText$Input;
};

/** Describes an animation file. The animation must be encoded in GIF or MPEG4 format */
export type animation = {
  _: "animation";

  /**
   * Duration of the animation, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Width of the animation
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Height of the animation
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * MIME type of the file, usually "image/gif" or "video/mp4"
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * Animation minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Animation thumbnail in JPEG or MPEG4 format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * File containing the animation
   * @type {file} {@link file}
   */
  animation: file;
};

export type animation$Input = {
  readonly _: "animation";

  /**
   * Duration of the animation, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Width of the animation
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Height of the animation
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * MIME type of the file, usually "image/gif" or "video/mp4"
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * Animation minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Animation thumbnail in JPEG or MPEG4 format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * File containing the animation
   * @type {file} {@link file}
   */
  readonly animation?: file$Input;
};

/** Describes an audio file. Audio is usually in MP3 or M4A format */
export type audio = {
  _: "audio";

  /**
   * Duration of the audio, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Title of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Performer of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  performer: string;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * The MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * The minithumbnail of the album cover; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  album_cover_minithumbnail: minithumbnail;

  /**
   * The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  album_cover_thumbnail: thumbnail;

  /**
   * Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
   * @type {vector<thumbnail>} {@link vector<thumbnail>}
   */
  external_album_covers: vector<thumbnail>;

  /**
   * File containing the audio
   * @type {file} {@link file}
   */
  audio: file;
};

export type audio$Input = {
  readonly _: "audio";

  /**
   * Duration of the audio, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Title of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Performer of the audio; as defined by the sender
   * @type {string} {@link string}
   */
  readonly performer?: string;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * The MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * The minithumbnail of the album cover; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly album_cover_minithumbnail?: minithumbnail$Input;

  /**
   * The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded audio file; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly album_cover_thumbnail?: thumbnail$Input;

  /**
   * Album cover variants to use if the downloaded audio file contains no album cover. Provided thumbnail dimensions are approximate
   * @type {vector<thumbnail>} {@link vector<thumbnail>}
   */
  readonly external_album_covers?: vector$Input<thumbnail$Input>;

  /**
   * File containing the audio
   * @type {file} {@link file}
   */
  readonly audio?: file$Input;
};

/** Describes a document of any type */
export type document = {
  _: "document";

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * Document minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * File containing the document
   * @type {file} {@link file}
   */
  document: file;
};

export type document$Input = {
  readonly _: "document";

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * Document minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * File containing the document
   * @type {file} {@link file}
   */
  readonly document?: file$Input;
};

/** Describes a photo */
export type photo = {
  _: "photo";

  /**
   * True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Available variants of the photo, in different sizes
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  sizes: vector<photoSize>;
};

export type photo$Input = {
  readonly _: "photo";

  /**
   * True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Available variants of the photo, in different sizes
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  readonly sizes?: vector$Input<photoSize$Input>;
};

/** Describes a sticker */
export type sticker = {
  _: "sticker";

  /**
   * The identifier of the sticker set to which the sticker belongs; 0 if none
   * @type {int64} {@link int64}
   */
  set_id: int64;

  /**
   * Sticker width; as defined by the sender
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Sticker height; as defined by the sender
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * Sticker format
   * @type {StickerFormat} {@link StickerFormat}
   */
  format: StickerFormat;

  /**
   * Sticker type
   * @type {StickerType} {@link StickerType}
   */
  type: StickerType;

  /**
   * Position where the mask is placed; may be null even the sticker is a mask
   * @type {maskPosition} {@link maskPosition}
   */
  mask_position: maskPosition;

  /**
   * Identifier of the emoji if the sticker is a custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;

  /**
   * Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  outline: vector<closedVectorPath>;

  /**
   * Sticker thumbnail in WEBP or JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * True, if only Premium users can use the sticker
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;

  /**
   * Premium animation of the sticker; may be null
   * @type {file} {@link file}
   */
  premium_animation: file;

  /**
   * File containing the sticker
   * @type {file} {@link file}
   */
  sticker: file;
};

export type sticker$Input = {
  readonly _: "sticker";

  /**
   * The identifier of the sticker set to which the sticker belongs; 0 if none
   * @type {int64} {@link int64}
   */
  readonly set_id?: int64;

  /**
   * Sticker width; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Sticker height; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Emoji corresponding to the sticker
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * Sticker format
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly format?: StickerFormat$Input;

  /**
   * Sticker type
   * @type {StickerType} {@link StickerType}
   */
  readonly type?: StickerType$Input;

  /**
   * Position where the mask is placed; may be null even the sticker is a mask
   * @type {maskPosition} {@link maskPosition}
   */
  readonly mask_position?: maskPosition$Input;

  /**
   * Identifier of the emoji if the sticker is a custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64;

  /**
   * Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  readonly outline?: vector$Input<closedVectorPath$Input>;

  /**
   * Sticker thumbnail in WEBP or JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * True, if only Premium users can use the sticker
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;

  /**
   * Premium animation of the sticker; may be null
   * @type {file} {@link file}
   */
  readonly premium_animation?: file$Input;

  /**
   * File containing the sticker
   * @type {file} {@link file}
   */
  readonly sticker?: file$Input;
};

/** Describes a video file */
export type video = {
  _: "video";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Video width; as defined by the sender
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Video height; as defined by the sender
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  file_name: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  has_stickers: Bool;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  supports_streaming: Bool;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  video: file;
};

export type video$Input = {
  readonly _: "video";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Video width; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Video height; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Original name of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly file_name?: string;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
   * @type {Bool} {@link Bool}
   */
  readonly has_stickers?: Bool$Input;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  readonly supports_streaming?: Bool$Input;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  readonly video?: file$Input;
};

/** Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format */
export type videoNote = {
  _: "videoNote";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
   * @type {bytes} {@link bytes}
   */
  waveform: bytes;

  /**
   * Video width and height; as defined by the sender
   * @type {int32} {@link int32}
   */
  length: int32;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Video thumbnail in JPEG format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * Result of speech recognition in the video note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  speech_recognition_result: SpeechRecognitionResult;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  video: file;
};

export type videoNote$Input = {
  readonly _: "videoNote";

  /**
   * Duration of the video, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * A waveform representation of the video note's audio in 5-bit format; may be empty if unknown
   * @type {bytes} {@link bytes}
   */
  readonly waveform?: bytes;

  /**
   * Video width and height; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly length?: int32;

  /**
   * Video minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Video thumbnail in JPEG format; as defined by the sender; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * Result of speech recognition in the video note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  readonly speech_recognition_result?: SpeechRecognitionResult$Input;

  /**
   * File containing the video
   * @type {file} {@link file}
   */
  readonly video?: file$Input;
};

/** Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel */
export type voiceNote = {
  _: "voiceNote";

  /**
   * Duration of the voice note, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * A waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  waveform: bytes;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * Result of speech recognition in the voice note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  speech_recognition_result: SpeechRecognitionResult;

  /**
   * File containing the voice note
   * @type {file} {@link file}
   */
  voice: file;
};

export type voiceNote$Input = {
  readonly _: "voiceNote";

  /**
   * Duration of the voice note, in seconds; as defined by the sender
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * A waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  readonly waveform?: bytes;

  /**
   * MIME type of the file; as defined by the sender
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * Result of speech recognition in the voice note; may be null
   * @type {SpeechRecognitionResult} {@link SpeechRecognitionResult}
   */
  readonly speech_recognition_result?: SpeechRecognitionResult$Input;

  /**
   * File containing the voice note
   * @type {file} {@link file}
   */
  readonly voice?: file$Input;
};

/** Describes an animated or custom representation of an emoji */
export type animatedEmoji = {
  _: "animatedEmoji";

  /**
   * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;

  /**
   * Expected width of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  sticker_width: int32;

  /**
   * Expected height of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  sticker_height: int32;

  /**
   * Emoji modifier fitzpatrick type; 0-6; 0 if none
   * @type {int32} {@link int32}
   */
  fitzpatrick_type: int32;

  /**
   * File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
   * @type {file} {@link file}
   */
  sound: file;
};

export type animatedEmoji$Input = {
  readonly _: "animatedEmoji";

  /**
   * Sticker for the emoji; may be null if yet unknown for a custom emoji. If the sticker is a custom emoji, it can have arbitrary format different from stickerFormatTgs
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;

  /**
   * Expected width of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  readonly sticker_width?: int32;

  /**
   * Expected height of the sticker, which can be used if the sticker is null
   * @type {int32} {@link int32}
   */
  readonly sticker_height?: int32;

  /**
   * Emoji modifier fitzpatrick type; 0-6; 0 if none
   * @type {int32} {@link int32}
   */
  readonly fitzpatrick_type?: int32;

  /**
   * File containing the sound to be played when the sticker is clicked; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
   * @type {file} {@link file}
   */
  readonly sound?: file$Input;
};

/** Describes a user contact */
export type contact = {
  _: "contact";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * First name of the user; 1-255 characters in length
   * @type {string} {@link string}
   */
  first_name: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  last_name: string;

  /**
   * Additional data about the user in a form of vCard; 0-2048 bytes in length
   * @type {string} {@link string}
   */
  vcard: string;

  /**
   * Identifier of the user, if known; otherwise 0
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type contact$Input = {
  readonly _: "contact";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * First name of the user; 1-255 characters in length
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  readonly last_name?: string;

  /**
   * Additional data about the user in a form of vCard; 0-2048 bytes in length
   * @type {string} {@link string}
   */
  readonly vcard?: string;

  /**
   * Identifier of the user, if known; otherwise 0
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** Describes a location on planet Earth */
export type location = {
  _: "location";

  /**
   * Latitude of the location in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  latitude: double;

  /**
   * Longitude of the location, in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  longitude: double;

  /**
   * The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
   * @type {double} {@link double}
   */
  horizontal_accuracy: double;
};

export type location$Input = {
  readonly _: "location";

  /**
   * Latitude of the location in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  readonly latitude?: double;

  /**
   * Longitude of the location, in degrees; as defined by the sender
   * @type {double} {@link double}
   */
  readonly longitude?: double;

  /**
   * The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
   * @type {double} {@link double}
   */
  readonly horizontal_accuracy?: double;
};

/** Describes a venue */
export type venue = {
  _: "venue";

  /**
   * Venue location; as defined by the sender
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Venue name; as defined by the sender
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Venue address; as defined by the sender
   * @type {string} {@link string}
   */
  address: string;

  /**
   * Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
   * @type {string} {@link string}
   */
  provider: string;

  /**
   * Identifier of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Type of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  type: string;
};

export type venue$Input = {
  readonly _: "venue";

  /**
   * Venue location; as defined by the sender
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Venue name; as defined by the sender
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Venue address; as defined by the sender
   * @type {string} {@link string}
   */
  readonly address?: string;

  /**
   * Provider of the venue database; as defined by the sender. Currently, only "foursquare" and "gplaces" (Google Places) need to be supported
   * @type {string} {@link string}
   */
  readonly provider?: string;

  /**
   * Identifier of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Type of the venue in the provider database; as defined by the sender
   * @type {string} {@link string}
   */
  readonly type?: string;
};

/** Describes a game */
export type game = {
  _: "game";

  /**
   * Game ID
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}
   * @type {string} {@link string}
   */
  short_name: string;

  /**
   * Game title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Game text, usually containing scoreboards for a game
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * Describes a game
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Game photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Game animation; may be null
   * @type {animation} {@link animation}
   */
  animation: animation;
};

export type game$Input = {
  readonly _: "game";

  /**
   * Game ID
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}
   * @type {string} {@link string}
   */
  readonly short_name?: string;

  /**
   * Game title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Game text, usually containing scoreboards for a game
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * Describes a game
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Game photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Game animation; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;
};

/** Describes a poll */
export type poll = {
  _: "poll";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Poll question; 1-300 characters
   * @type {string} {@link string}
   */
  question: string;

  /**
   * List of poll answer options
   * @type {vector<pollOption>} {@link vector<pollOption>}
   */
  options: vector<pollOption>;

  /**
   * Total number of voters, participating in the poll
   * @type {int32} {@link int32}
   */
  total_voter_count: int32;

  /**
   * User identifiers of recent voters, if the poll is non-anonymous
   * @type {vector<int53>} {@link vector<int53>}
   */
  recent_voter_user_ids: vector<int53>;

  /**
   * True, if the poll is anonymous
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  type: PollType;

  /**
   * Amount of time the poll will be active after creation, in seconds
   * @type {int32} {@link int32}
   */
  open_period: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed
   * @type {int32} {@link int32}
   */
  close_date: int32;

  /**
   * True, if the poll is closed
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

export type poll$Input = {
  readonly _: "poll";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Poll question; 1-300 characters
   * @type {string} {@link string}
   */
  readonly question?: string;

  /**
   * List of poll answer options
   * @type {vector<pollOption>} {@link vector<pollOption>}
   */
  readonly options?: vector$Input<pollOption$Input>;

  /**
   * Total number of voters, participating in the poll
   * @type {int32} {@link int32}
   */
  readonly total_voter_count?: int32;

  /**
   * User identifiers of recent voters, if the poll is non-anonymous
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly recent_voter_user_ids?: vector$Input<int53>;

  /**
   * True, if the poll is anonymous
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  readonly type?: PollType$Input;

  /**
   * Amount of time the poll will be active after creation, in seconds
   * @type {int32} {@link int32}
   */
  readonly open_period?: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed
   * @type {int32} {@link int32}
   */
  readonly close_date?: int32;

  /**
   * True, if the poll is closed
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/** Describes a user profile photo */
export type profilePhoto = {
  _: "profilePhoto";

  /**
   * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  small: file;

  /**
   * A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  big: file;

  /**
   * User profile photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  has_animation: Bool;
};

export type profilePhoto$Input = {
  readonly _: "profilePhoto";

  /**
   * Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly small?: file$Input;

  /**
   * A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly big?: file$Input;

  /**
   * User profile photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  readonly has_animation?: Bool$Input;
};

/** Contains basic information about the photo of a chat */
export type chatPhotoInfo = {
  _: "chatPhotoInfo";

  /**
   * A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  small: file;

  /**
   * A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  big: file;

  /**
   * Chat photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  has_animation: Bool;
};

export type chatPhotoInfo$Input = {
  readonly _: "chatPhotoInfo";

  /**
   * A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly small?: file$Input;

  /**
   * A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
   * @type {file} {@link file}
   */
  readonly big?: file$Input;

  /**
   * Chat photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * True, if the photo has animated variant
   * @type {Bool} {@link Bool}
   */
  readonly has_animation?: Bool$Input;
};

/** A regular user */
export type userTypeRegular = {
  _: "userTypeRegular";
};

export type userTypeRegular$Input = {
  readonly _: "userTypeRegular";
};

/** A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user */
export type userTypeDeleted = {
  _: "userTypeDeleted";
};

export type userTypeDeleted$Input = {
  readonly _: "userTypeDeleted";
};

/** A bot (see https://core.telegram.org/bots) */
export type userTypeBot = {
  _: "userTypeBot";

  /**
   * True, if the bot can be invited to basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  can_join_groups: Bool;

  /**
   * True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
   * @type {Bool} {@link Bool}
   */
  can_read_all_group_messages: Bool;

  /**
   * True, if the bot supports inline queries
   * @type {Bool} {@link Bool}
   */
  is_inline: Bool;

  /**
   * Placeholder for inline queries (displayed on the application input field)
   * @type {string} {@link string}
   */
  inline_query_placeholder: string;

  /**
   * True, if the location of the user is expected to be sent with every inline query to this bot
   * @type {Bool} {@link Bool}
   */
  need_location: Bool;

  /**
   * True, if the bot can be added to attachment menu
   * @type {Bool} {@link Bool}
   */
  can_be_added_to_attachment_menu: Bool;
};

export type userTypeBot$Input = {
  readonly _: "userTypeBot";

  /**
   * True, if the bot can be invited to basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  readonly can_join_groups?: Bool$Input;

  /**
   * True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
   * @type {Bool} {@link Bool}
   */
  readonly can_read_all_group_messages?: Bool$Input;

  /**
   * True, if the bot supports inline queries
   * @type {Bool} {@link Bool}
   */
  readonly is_inline?: Bool$Input;

  /**
   * Placeholder for inline queries (displayed on the application input field)
   * @type {string} {@link string}
   */
  readonly inline_query_placeholder?: string;

  /**
   * True, if the location of the user is expected to be sent with every inline query to this bot
   * @type {Bool} {@link Bool}
   */
  readonly need_location?: Bool$Input;

  /**
   * True, if the bot can be added to attachment menu
   * @type {Bool} {@link Bool}
   */
  readonly can_be_added_to_attachment_menu?: Bool$Input;
};

/** No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type */
export type userTypeUnknown = {
  _: "userTypeUnknown";
};

export type userTypeUnknown$Input = {
  readonly _: "userTypeUnknown";
};

/** Represents a command supported by a bot */
export type botCommand = {
  _: "botCommand";

  /**
   * Text of the bot command
   * @type {string} {@link string}
   */
  command: string;

  /**
   * Represents a command supported by a bot
   * @type {string} {@link string}
   */
  description: string;
};

export type botCommand$Input = {
  readonly _: "botCommand";

  /**
   * Text of the bot command
   * @type {string} {@link string}
   */
  readonly command?: string;

  /**
   * Represents a command supported by a bot
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/** Contains a list of bot commands */
export type botCommands = {
  _: "botCommands";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * List of bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  commands: vector<botCommand>;
};

export type botCommands$Input = {
  readonly _: "botCommands";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * List of bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;
};

/** Describes a button to be shown instead of bot commands menu button */
export type botMenuButton = {
  _: "botMenuButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  url: string;
};

export type botMenuButton$Input = {
  readonly _: "botMenuButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Represents a location to which a chat is connected */
export type chatLocation = {
  _: "chatLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Location address; 1-64 characters, as defined by the chat owner
   * @type {string} {@link string}
   */
  address: string;
};

export type chatLocation$Input = {
  readonly _: "chatLocation";

  /**
   * The location
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Location address; 1-64 characters, as defined by the chat owner
   * @type {string} {@link string}
   */
  readonly address?: string;
};

/** Animated variant of a chat photo in MPEG4 format */
export type animatedChatPhoto = {
  _: "animatedChatPhoto";

  /**
   * Animation width and height
   * @type {int32} {@link int32}
   */
  length: int32;

  /**
   * Information about the animation file
   * @type {file} {@link file}
   */
  file: file;

  /**
   * Timestamp of the frame, used as a static chat photo
   * @type {double} {@link double}
   */
  main_frame_timestamp: double;
};

export type animatedChatPhoto$Input = {
  readonly _: "animatedChatPhoto";

  /**
   * Animation width and height
   * @type {int32} {@link int32}
   */
  readonly length?: int32;

  /**
   * Information about the animation file
   * @type {file} {@link file}
   */
  readonly file?: file$Input;

  /**
   * Timestamp of the frame, used as a static chat photo
   * @type {double} {@link double}
   */
  readonly main_frame_timestamp?: double;
};

/** Describes a chat or user profile photo */
export type chatPhoto = {
  _: "chatPhoto";

  /**
   * Unique photo identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Point in time (Unix timestamp) when the photo has been added
   * @type {int32} {@link int32}
   */
  added_date: int32;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Available variants of the photo in JPEG format, in different size
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  sizes: vector<photoSize>;

  /**
   * A big (640x640) animated variant of the photo in MPEG4 format; may be null
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  animation: animatedChatPhoto;

  /**
   * A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  small_animation: animatedChatPhoto;
};

export type chatPhoto$Input = {
  readonly _: "chatPhoto";

  /**
   * Unique photo identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Point in time (Unix timestamp) when the photo has been added
   * @type {int32} {@link int32}
   */
  readonly added_date?: int32;

  /**
   * Photo minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Available variants of the photo in JPEG format, in different size
   * @type {vector<photoSize>} {@link vector<photoSize>}
   */
  readonly sizes?: vector$Input<photoSize$Input>;

  /**
   * A big (640x640) animated variant of the photo in MPEG4 format; may be null
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  readonly animation?: animatedChatPhoto$Input;

  /**
   * A small (160x160) animated variant of the photo in MPEG4 format; may be null even the big animation is available
   * @type {animatedChatPhoto} {@link animatedChatPhoto}
   */
  readonly small_animation?: animatedChatPhoto$Input;
};

/** Contains a list of chat or user profile photos */
export type chatPhotos = {
  _: "chatPhotos";

  /**
   * Total number of photos
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of photos
   * @type {vector<chatPhoto>} {@link vector<chatPhoto>}
   */
  photos: vector<chatPhoto>;
};

export type chatPhotos$Input = {
  readonly _: "chatPhotos";

  /**
   * Total number of photos
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of photos
   * @type {vector<chatPhoto>} {@link vector<chatPhoto>}
   */
  readonly photos?: vector$Input<chatPhoto$Input>;
};

/** A previously used profile photo of the current user */
export type inputChatPhotoPrevious = {
  _: "inputChatPhotoPrevious";

  /**
   * Identifier of the current user's profile photo to reuse
   * @type {int64} {@link int64}
   */
  chat_photo_id: int64;
};

export type inputChatPhotoPrevious$Input = {
  readonly _: "inputChatPhotoPrevious";

  /**
   * Identifier of the current user's profile photo to reuse
   * @type {int64} {@link int64}
   */
  readonly chat_photo_id?: int64;
};

/** A static photo in JPEG format */
export type inputChatPhotoStatic = {
  _: "inputChatPhotoStatic";

  /**
   * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  photo: InputFile;
};

export type inputChatPhotoStatic$Input = {
  readonly _: "inputChatPhotoStatic";

  /**
   * Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  readonly photo?: InputFile$Input;
};

/** An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 800 and be at most 2MB in size */
export type inputChatPhotoAnimation = {
  _: "inputChatPhotoAnimation";

  /**
   * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  animation: InputFile;

  /**
   * Timestamp of the frame, which will be used as static chat photo
   * @type {double} {@link double}
   */
  main_frame_timestamp: double;
};

export type inputChatPhotoAnimation$Input = {
  readonly _: "inputChatPhotoAnimation";

  /**
   * Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
   * @type {InputFile} {@link InputFile}
   */
  readonly animation?: InputFile$Input;

  /**
   * Timestamp of the frame, which will be used as static chat photo
   * @type {double} {@link double}
   */
  readonly main_frame_timestamp?: double;
};

/** Describes actions that a user is allowed to take in a chat */
export type chatPermissions = {
  _: "chatPermissions";

  /**
   * True, if the user can send text messages, contacts, locations, and venues
   * @type {Bool} {@link Bool}
   */
  can_send_messages: Bool;

  /**
   * True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  can_send_media_messages: Bool;

  /**
   * True, if the user can send polls. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  can_send_polls: Bool;

  /**
   * True, if the user can send animations, games, stickers, and dice and use inline bots. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  can_send_other_messages: Bool;

  /**
   * True, if the user may add a web page preview to their messages. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  can_add_web_page_previews: Bool;

  /**
   * True, if the user can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  can_change_info: Bool;

  /**
   * True, if the user can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  can_invite_users: Bool;

  /**
   * True, if the user can pin messages
   * @type {Bool} {@link Bool}
   */
  can_pin_messages: Bool;

  /**
   * True, if the user can manage topics
   * @type {Bool} {@link Bool}
   */
  can_manage_topics: Bool;
};

export type chatPermissions$Input = {
  readonly _: "chatPermissions";

  /**
   * True, if the user can send text messages, contacts, locations, and venues
   * @type {Bool} {@link Bool}
   */
  readonly can_send_messages?: Bool$Input;

  /**
   * True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  readonly can_send_media_messages?: Bool$Input;

  /**
   * True, if the user can send polls. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  readonly can_send_polls?: Bool$Input;

  /**
   * True, if the user can send animations, games, stickers, and dice and use inline bots. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  readonly can_send_other_messages?: Bool$Input;

  /**
   * True, if the user may add a web page preview to their messages. Implies can_send_messages permissions
   * @type {Bool} {@link Bool}
   */
  readonly can_add_web_page_previews?: Bool$Input;

  /**
   * True, if the user can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  readonly can_change_info?: Bool$Input;

  /**
   * True, if the user can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  readonly can_invite_users?: Bool$Input;

  /**
   * True, if the user can pin messages
   * @type {Bool} {@link Bool}
   */
  readonly can_pin_messages?: Bool$Input;

  /**
   * True, if the user can manage topics
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_topics?: Bool$Input;
};

/** Describes rights of the administrator */
export type chatAdministratorRights = {
  _: "chatAdministratorRights";

  /**
   * True, if the administrator can get chat event log, get chat statistics, get message statistics in channels, get channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
   * @type {Bool} {@link Bool}
   */
  can_manage_chat: Bool;

  /**
   * True, if the administrator can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  can_change_info: Bool;

  /**
   * True, if the administrator can create channel posts; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_post_messages: Bool;

  /**
   * True, if the administrator can edit messages of other users and pin messages; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  can_edit_messages: Bool;

  /**
   * True, if the administrator can delete messages of other users
   * @type {Bool} {@link Bool}
   */
  can_delete_messages: Bool;

  /**
   * True, if the administrator can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  can_invite_users: Bool;

  /**
   * True, if the administrator can restrict, ban, or unban chat members; always true for channels
   * @type {Bool} {@link Bool}
   */
  can_restrict_members: Bool;

  /**
   * True, if the administrator can pin messages; applicable to basic groups and supergroups only
   * @type {Bool} {@link Bool}
   */
  can_pin_messages: Bool;

  /**
   * True, if the administrator can manage topics; applicable to forum supergroups only
   * @type {Bool} {@link Bool}
   */
  can_manage_topics: Bool;

  /**
   * True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
   * @type {Bool} {@link Bool}
   */
  can_promote_members: Bool;

  /**
   * True, if the administrator can manage video chats
   * @type {Bool} {@link Bool}
   */
  can_manage_video_chats: Bool;

  /**
   * True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;
};

export type chatAdministratorRights$Input = {
  readonly _: "chatAdministratorRights";

  /**
   * True, if the administrator can get chat event log, get chat statistics, get message statistics in channels, get channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_chat?: Bool$Input;

  /**
   * True, if the administrator can change the chat title, photo, and other settings
   * @type {Bool} {@link Bool}
   */
  readonly can_change_info?: Bool$Input;

  /**
   * True, if the administrator can create channel posts; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_post_messages?: Bool$Input;

  /**
   * True, if the administrator can edit messages of other users and pin messages; applicable to channels only
   * @type {Bool} {@link Bool}
   */
  readonly can_edit_messages?: Bool$Input;

  /**
   * True, if the administrator can delete messages of other users
   * @type {Bool} {@link Bool}
   */
  readonly can_delete_messages?: Bool$Input;

  /**
   * True, if the administrator can invite new users to the chat
   * @type {Bool} {@link Bool}
   */
  readonly can_invite_users?: Bool$Input;

  /**
   * True, if the administrator can restrict, ban, or unban chat members; always true for channels
   * @type {Bool} {@link Bool}
   */
  readonly can_restrict_members?: Bool$Input;

  /**
   * True, if the administrator can pin messages; applicable to basic groups and supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly can_pin_messages?: Bool$Input;

  /**
   * True, if the administrator can manage topics; applicable to forum supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_topics?: Bool$Input;

  /**
   * True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
   * @type {Bool} {@link Bool}
   */
  readonly can_promote_members?: Bool$Input;

  /**
   * True, if the administrator can manage video chats
   * @type {Bool} {@link Bool}
   */
  readonly can_manage_video_chats?: Bool$Input;

  /**
   * True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;
};

/** Describes an option for buying Telegram Premium to a user */
export type premiumPaymentOption = {
  _: "premiumPaymentOption";

  /**
   * ISO 4217 currency code for Telegram Premium subscription payment
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * The amount to pay, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * The discount associated with this option, as a percentage
   * @type {int32} {@link int32}
   */
  discount_percentage: int32;

  /**
   * Number of month the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * Identifier of the store product associated with the option
   * @type {string} {@link string}
   */
  store_product_id: string;

  /**
   * An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  payment_link: InternalLinkType;
};

export type premiumPaymentOption$Input = {
  readonly _: "premiumPaymentOption";

  /**
   * ISO 4217 currency code for Telegram Premium subscription payment
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * The amount to pay, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * The discount associated with this option, as a percentage
   * @type {int32} {@link int32}
   */
  readonly discount_percentage?: int32;

  /**
   * Number of month the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * Identifier of the store product associated with the option
   * @type {string} {@link string}
   */
  readonly store_product_id?: string;

  /**
   * An internal link to be opened for buying Telegram Premium to the user if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly payment_link?: InternalLinkType$Input;
};

/** Describes a custom emoji to be shown instead of the Telegram Premium badge */
export type emojiStatus = {
  _: "emojiStatus";

  /**
   * Identifier of the custom emoji in stickerFormatTgs format. If the custom emoji belongs to the sticker set GetOption("themed_emoji_statuses_sticker_set_id"), then it's color must be changed to the color of the Telegram Premium badge
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

export type emojiStatus$Input = {
  readonly _: "emojiStatus";

  /**
   * Identifier of the custom emoji in stickerFormatTgs format. If the custom emoji belongs to the sticker set GetOption("themed_emoji_statuses_sticker_set_id"), then it's color must be changed to the color of the Telegram Premium badge
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64;
};

/** Contains a list of emoji statuses */
export type emojiStatuses = {
  _: "emojiStatuses";

  /**
   * The list of emoji statuses
   * @type {vector<emojiStatus>} {@link vector<emojiStatus>}
   */
  emoji_statuses: vector<emojiStatus>;
};

export type emojiStatuses$Input = {
  readonly _: "emojiStatuses";

  /**
   * The list of emoji statuses
   * @type {vector<emojiStatus>} {@link vector<emojiStatus>}
   */
  readonly emoji_statuses?: vector$Input<emojiStatus$Input>;
};

/** Describes usernames assigned to a user, a supergroup, or a channel */
export type usernames = {
  _: "usernames";

  /**
   * List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames or reorderSupergroupActiveUsernames
   * @type {vector<string>} {@link vector<string>}
   */
  active_usernames: vector<string>;

  /**
   * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive/toggleSupergroupUsernameIsActive
   * @type {vector<string>} {@link vector<string>}
   */
  disabled_usernames: vector<string>;

  /**
   * The active username, which can be changed with setUsername/setSupergroupUsername
   * @type {string} {@link string}
   */
  editable_username: string;
};

export type usernames$Input = {
  readonly _: "usernames";

  /**
   * List of active usernames; the first one must be shown as the primary username. The order of active usernames can be changed with reorderActiveUsernames or reorderSupergroupActiveUsernames
   * @type {vector<string>} {@link vector<string>}
   */
  readonly active_usernames?: vector$Input<string>;

  /**
   * List of currently disabled usernames; the username can be activated with toggleUsernameIsActive/toggleSupergroupUsernameIsActive
   * @type {vector<string>} {@link vector<string>}
   */
  readonly disabled_usernames?: vector$Input<string>;

  /**
   * The active username, which can be changed with setUsername/setSupergroupUsername
   * @type {string} {@link string}
   */
  readonly editable_username?: string;
};

/** Represents a user */
export type user = {
  _: "user";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * First name of the user
   * @type {string} {@link string}
   */
  first_name: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  last_name: string;

  /**
   * Usernames of the user; may be null
   * @type {usernames} {@link usernames}
   */
  usernames: usernames;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * Current online status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  status: UserStatus;

  /**
   * Profile photo of the user; may be null
   * @type {profilePhoto} {@link profilePhoto}
   */
  profile_photo: profilePhoto;

  /**
   * Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
   * @type {emojiStatus} {@link emojiStatus}
   */
  emoji_status: emojiStatus;

  /**
   * The user is a contact of the current user
   * @type {Bool} {@link Bool}
   */
  is_contact: Bool;

  /**
   * The user is a contact of the current user and the current user is a contact of the user
   * @type {Bool} {@link Bool}
   */
  is_mutual_contact: Bool;

  /**
   * True, if the user is verified
   * @type {Bool} {@link Bool}
   */
  is_verified: Bool;

  /**
   * True, if the user is a Telegram Premium user
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;

  /**
   * True, if the user is Telegram support account
   * @type {Bool} {@link Bool}
   */
  is_support: Bool;

  /**
   * If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
   * @type {string} {@link string}
   */
  restriction_reason: string;

  /**
   * True, if many users reported this user as a scam
   * @type {Bool} {@link Bool}
   */
  is_scam: Bool;

  /**
   * True, if many users reported this user as a fake account
   * @type {Bool} {@link Bool}
   */
  is_fake: Bool;

  /**
   * If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method except GetUser
   * @type {Bool} {@link Bool}
   */
  have_access: Bool;

  /**
   * Type of the user
   * @type {UserType} {@link UserType}
   */
  type: UserType;

  /**
   * IETF language tag of the user's language; only available to bots
   * @type {string} {@link string}
   */
  language_code: string;

  /**
   * True, if the user added the current bot to attachment menu; only available to bots
   * @type {Bool} {@link Bool}
   */
  added_to_attachment_menu: Bool;
};

export type user$Input = {
  readonly _: "user";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * First name of the user
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * Last name of the user
   * @type {string} {@link string}
   */
  readonly last_name?: string;

  /**
   * Usernames of the user; may be null
   * @type {usernames} {@link usernames}
   */
  readonly usernames?: usernames$Input;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Current online status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  readonly status?: UserStatus$Input;

  /**
   * Profile photo of the user; may be null
   * @type {profilePhoto} {@link profilePhoto}
   */
  readonly profile_photo?: profilePhoto$Input;

  /**
   * Emoji status to be shown instead of the default Telegram Premium badge; may be null. For Telegram Premium users only
   * @type {emojiStatus} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input;

  /**
   * The user is a contact of the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_contact?: Bool$Input;

  /**
   * The user is a contact of the current user and the current user is a contact of the user
   * @type {Bool} {@link Bool}
   */
  readonly is_mutual_contact?: Bool$Input;

  /**
   * True, if the user is verified
   * @type {Bool} {@link Bool}
   */
  readonly is_verified?: Bool$Input;

  /**
   * True, if the user is a Telegram Premium user
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;

  /**
   * True, if the user is Telegram support account
   * @type {Bool} {@link Bool}
   */
  readonly is_support?: Bool$Input;

  /**
   * If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
   * @type {string} {@link string}
   */
  readonly restriction_reason?: string;

  /**
   * True, if many users reported this user as a scam
   * @type {Bool} {@link Bool}
   */
  readonly is_scam?: Bool$Input;

  /**
   * True, if many users reported this user as a fake account
   * @type {Bool} {@link Bool}
   */
  readonly is_fake?: Bool$Input;

  /**
   * If false, the user is inaccessible, and the only information known about the user is inside this class. Identifier of the user can't be passed to any method except GetUser
   * @type {Bool} {@link Bool}
   */
  readonly have_access?: Bool$Input;

  /**
   * Type of the user
   * @type {UserType} {@link UserType}
   */
  readonly type?: UserType$Input;

  /**
   * IETF language tag of the user's language; only available to bots
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * True, if the user added the current bot to attachment menu; only available to bots
   * @type {Bool} {@link Bool}
   */
  readonly added_to_attachment_menu?: Bool$Input;
};

/** Contains information about a bot */
export type botInfo = {
  _: "botInfo";

  /**
   * The text that is shown on the bot's profile page and is sent together with the link when users share the bot
   * @type {string} {@link string}
   */
  share_text: string;

  /**
   * Contains information about a bot
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Photo shown in the chat with the bot if the chat is empty; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Animation shown in the chat with the bot if the chat is empty; may be null
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
   * @type {botMenuButton} {@link botMenuButton}
   */
  menu_button: botMenuButton;

  /**
   * List of the bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  commands: vector<botCommand>;

  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  default_group_administrator_rights: chatAdministratorRights;

  /**
   * Default administrator rights for adding the bot to channels; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  default_channel_administrator_rights: chatAdministratorRights;
};

export type botInfo$Input = {
  readonly _: "botInfo";

  /**
   * The text that is shown on the bot's profile page and is sent together with the link when users share the bot
   * @type {string} {@link string}
   */
  readonly share_text?: string;

  /**
   * Contains information about a bot
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Photo shown in the chat with the bot if the chat is empty; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Animation shown in the chat with the bot if the chat is empty; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Information about a button to show instead of the bot commands menu button; may be null if ordinary bot commands menu must be shown
   * @type {botMenuButton} {@link botMenuButton}
   */
  readonly menu_button?: botMenuButton$Input;

  /**
   * List of the bot commands
   * @type {vector<botCommand>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;

  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly default_group_administrator_rights?: chatAdministratorRights$Input;

  /**
   * Default administrator rights for adding the bot to channels; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly default_channel_administrator_rights?: chatAdministratorRights$Input;
};

/** Contains full information about a user */
export type userFullInfo = {
  _: "userFullInfo";

  /**
   * User profile photo; may be null if empty or unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto;

  /**
   * True, if the user is blocked by the current user
   * @type {Bool} {@link Bool}
   */
  is_blocked: Bool;

  /**
   * True, if the user can be called
   * @type {Bool} {@link Bool}
   */
  can_be_called: Bool;

  /**
   * True, if a video call can be created with the user
   * @type {Bool} {@link Bool}
   */
  supports_video_calls: Bool;

  /**
   * True, if the user can't be called due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  has_private_calls: Bool;

  /**
   * True, if the user can't be linked in forwarded messages due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  has_private_forwards: Bool;

  /**
   * True, if voice and video notes can't be sent or forwarded to the user
   * @type {Bool} {@link Bool}
   */
  has_restricted_voice_and_video_note_messages: Bool;

  /**
   * True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
   * @type {Bool} {@link Bool}
   */
  need_phone_number_privacy_exception: Bool;

  /**
   * A short user bio; may be null for bots
   * @type {formattedText} {@link formattedText}
   */
  bio: formattedText;

  /**
   * The list of available options for gifting Telegram Premium to the user
   * @type {vector<premiumPaymentOption>} {@link vector<premiumPaymentOption>}
   */
  premium_gift_options: vector<premiumPaymentOption>;

  /**
   * Number of group chats where both the other user and the current user are a member; 0 for the current user
   * @type {int32} {@link int32}
   */
  group_in_common_count: int32;

  /**
   * For bots, information about the bot; may be null
   * @type {botInfo} {@link botInfo}
   */
  bot_info: botInfo;
};

export type userFullInfo$Input = {
  readonly _: "userFullInfo";

  /**
   * User profile photo; may be null if empty or unknown. If non-null, then it is the same photo as in user.profile_photo and chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input;

  /**
   * True, if the user is blocked by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_blocked?: Bool$Input;

  /**
   * True, if the user can be called
   * @type {Bool} {@link Bool}
   */
  readonly can_be_called?: Bool$Input;

  /**
   * True, if a video call can be created with the user
   * @type {Bool} {@link Bool}
   */
  readonly supports_video_calls?: Bool$Input;

  /**
   * True, if the user can't be called due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  readonly has_private_calls?: Bool$Input;

  /**
   * True, if the user can't be linked in forwarded messages due to their privacy settings
   * @type {Bool} {@link Bool}
   */
  readonly has_private_forwards?: Bool$Input;

  /**
   * True, if voice and video notes can't be sent or forwarded to the user
   * @type {Bool} {@link Bool}
   */
  readonly has_restricted_voice_and_video_note_messages?: Bool$Input;

  /**
   * True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
   * @type {Bool} {@link Bool}
   */
  readonly need_phone_number_privacy_exception?: Bool$Input;

  /**
   * A short user bio; may be null for bots
   * @type {formattedText} {@link formattedText}
   */
  readonly bio?: formattedText$Input;

  /**
   * The list of available options for gifting Telegram Premium to the user
   * @type {vector<premiumPaymentOption>} {@link vector<premiumPaymentOption>}
   */
  readonly premium_gift_options?: vector$Input<premiumPaymentOption$Input>;

  /**
   * Number of group chats where both the other user and the current user are a member; 0 for the current user
   * @type {int32} {@link int32}
   */
  readonly group_in_common_count?: int32;

  /**
   * For bots, information about the bot; may be null
   * @type {botInfo} {@link botInfo}
   */
  readonly bot_info?: botInfo$Input;
};

/** Represents a list of users */
export type users = {
  _: "users";

  /**
   * Approximate total number of users found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * A list of user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

export type users$Input = {
  readonly _: "users";

  /**
   * Approximate total number of users found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * A list of user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/** Contains information about a chat administrator */
export type chatAdministrator = {
  _: "chatAdministrator";

  /**
   * User identifier of the administrator
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Custom title of the administrator
   * @type {string} {@link string}
   */
  custom_title: string;

  /**
   * True, if the user is the owner of the chat
   * @type {Bool} {@link Bool}
   */
  is_owner: Bool;
};

export type chatAdministrator$Input = {
  readonly _: "chatAdministrator";

  /**
   * User identifier of the administrator
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Custom title of the administrator
   * @type {string} {@link string}
   */
  readonly custom_title?: string;

  /**
   * True, if the user is the owner of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_owner?: Bool$Input;
};

/** Represents a list of chat administrators */
export type chatAdministrators = {
  _: "chatAdministrators";

  /**
   * A list of chat administrators
   * @type {vector<chatAdministrator>} {@link vector<chatAdministrator>}
   */
  administrators: vector<chatAdministrator>;
};

export type chatAdministrators$Input = {
  readonly _: "chatAdministrators";

  /**
   * A list of chat administrators
   * @type {vector<chatAdministrator>} {@link vector<chatAdministrator>}
   */
  readonly administrators?: vector$Input<chatAdministrator$Input>;
};

/** The user is the owner of the chat and has all the administrator privileges */
export type chatMemberStatusCreator = {
  _: "chatMemberStatusCreator";

  /**
   * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  custom_title: string;

  /**
   * True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  is_member: Bool;
};

export type chatMemberStatusCreator$Input = {
  readonly _: "chatMemberStatusCreator";

  /**
   * A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  readonly custom_title?: string;

  /**
   * True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_member?: Bool$Input;
};

/** The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats. In supergroups and channels, there are more detailed options for administrator privileges */
export type chatMemberStatusAdministrator = {
  _: "chatMemberStatusAdministrator";

  /**
   * A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  custom_title: string;

  /**
   * True, if the current user can edit the administrator privileges for the called user
   * @type {Bool} {@link Bool}
   */
  can_be_edited: Bool;

  /**
   * Rights of the administrator
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  rights: chatAdministratorRights;
};

export type chatMemberStatusAdministrator$Input = {
  readonly _: "chatMemberStatusAdministrator";

  /**
   * A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
   * @type {string} {@link string}
   */
  readonly custom_title?: string;

  /**
   * True, if the current user can edit the administrator privileges for the called user
   * @type {Bool} {@link Bool}
   */
  readonly can_be_edited?: Bool$Input;

  /**
   * Rights of the administrator
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly rights?: chatAdministratorRights$Input;
};

/** The user is a member of the chat, without any additional privileges or restrictions */
export type chatMemberStatusMember = {
  _: "chatMemberStatusMember";
};

export type chatMemberStatusMember$Input = {
  readonly _: "chatMemberStatusMember";
};

/** The user is under certain restrictions in the chat. Not supported in basic groups and channels */
export type chatMemberStatusRestricted = {
  _: "chatMemberStatusRestricted";

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  is_member: Bool;

  /**
   * Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
   * @type {int32} {@link int32}
   */
  restricted_until_date: int32;

  /**
   * User permissions in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  permissions: chatPermissions;
};

export type chatMemberStatusRestricted$Input = {
  readonly _: "chatMemberStatusRestricted";

  /**
   * True, if the user is a member of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_member?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
   * @type {int32} {@link int32}
   */
  readonly restricted_until_date?: int32;

  /**
   * User permissions in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/** The user or the chat is not a chat member */
export type chatMemberStatusLeft = {
  _: "chatMemberStatusLeft";
};

export type chatMemberStatusLeft$Input = {
  readonly _: "chatMemberStatusLeft";
};

/** The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat */
export type chatMemberStatusBanned = {
  _: "chatMemberStatusBanned";

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
   * @type {int32} {@link int32}
   */
  banned_until_date: int32;
};

export type chatMemberStatusBanned$Input = {
  readonly _: "chatMemberStatusBanned";

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
   * @type {int32} {@link int32}
   */
  readonly banned_until_date?: int32;
};

/** Describes a user or a chat as a member of another chat */
export type chatMember = {
  _: "chatMember";

  /**
   * Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
   * @type {MessageSender} {@link MessageSender}
   */
  member_id: MessageSender;

  /**
   * Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
   * @type {int53} {@link int53}
   */
  inviter_user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  joined_chat_date: int32;

  /**
   * Status of the member in the chat
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;
};

export type chatMember$Input = {
  readonly _: "chatMember";

  /**
   * Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
   * @type {MessageSender} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly inviter_user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  readonly joined_chat_date?: int32;

  /**
   * Status of the member in the chat
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/** Contains a list of chat members */
export type chatMembers = {
  _: "chatMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * A list of chat members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  members: vector<chatMember>;
};

export type chatMembers$Input = {
  readonly _: "chatMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * A list of chat members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  readonly members?: vector$Input<chatMember$Input>;
};

/** Returns contacts of the user */
export type chatMembersFilterContacts = {
  _: "chatMembersFilterContacts";
};

export type chatMembersFilterContacts$Input = {
  readonly _: "chatMembersFilterContacts";
};

/** Returns the owner and administrators */
export type chatMembersFilterAdministrators = {
  _: "chatMembersFilterAdministrators";
};

export type chatMembersFilterAdministrators$Input = {
  readonly _: "chatMembersFilterAdministrators";
};

/** Returns all chat members, including restricted chat members */
export type chatMembersFilterMembers = {
  _: "chatMembersFilterMembers";
};

export type chatMembersFilterMembers$Input = {
  readonly _: "chatMembersFilterMembers";
};

/** Returns users which can be mentioned in the chat */
export type chatMembersFilterMention = {
  _: "chatMembersFilterMention";

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;
};

export type chatMembersFilterMention$Input = {
  readonly _: "chatMembersFilterMention";

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/** Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup */
export type chatMembersFilterRestricted = {
  _: "chatMembersFilterRestricted";
};

export type chatMembersFilterRestricted$Input = {
  readonly _: "chatMembersFilterRestricted";
};

/** Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel */
export type chatMembersFilterBanned = {
  _: "chatMembersFilterBanned";
};

export type chatMembersFilterBanned$Input = {
  readonly _: "chatMembersFilterBanned";
};

/** Returns bot members of the chat */
export type chatMembersFilterBots = {
  _: "chatMembersFilterBots";
};

export type chatMembersFilterBots$Input = {
  readonly _: "chatMembersFilterBots";
};

/** Returns recently active users in reverse chronological order */
export type supergroupMembersFilterRecent = {
  _: "supergroupMembersFilterRecent";
};

export type supergroupMembersFilterRecent$Input = {
  readonly _: "supergroupMembersFilterRecent";
};

/** Returns contacts of the user, which are members of the supergroup or channel */
export type supergroupMembersFilterContacts = {
  _: "supergroupMembersFilterContacts";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

export type supergroupMembersFilterContacts$Input = {
  readonly _: "supergroupMembersFilterContacts";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/** Returns the owner and administrators */
export type supergroupMembersFilterAdministrators = {
  _: "supergroupMembersFilterAdministrators";
};

export type supergroupMembersFilterAdministrators$Input = {
  readonly _: "supergroupMembersFilterAdministrators";
};

/** Used to search for supergroup or channel members via a (string) query */
export type supergroupMembersFilterSearch = {
  _: "supergroupMembersFilterSearch";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

export type supergroupMembersFilterSearch$Input = {
  readonly _: "supergroupMembersFilterSearch";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/** Returns restricted supergroup members; can be used only by administrators */
export type supergroupMembersFilterRestricted = {
  _: "supergroupMembersFilterRestricted";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

export type supergroupMembersFilterRestricted$Input = {
  readonly _: "supergroupMembersFilterRestricted";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/** Returns users banned from the supergroup or channel; can be used only by administrators */
export type supergroupMembersFilterBanned = {
  _: "supergroupMembersFilterBanned";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;
};

export type supergroupMembersFilterBanned$Input = {
  readonly _: "supergroupMembersFilterBanned";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/** Returns users which can be mentioned in the supergroup */
export type supergroupMembersFilterMention = {
  _: "supergroupMembersFilterMention";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  query: string;

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;
};

export type supergroupMembersFilterMention$Input = {
  readonly _: "supergroupMembersFilterMention";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * If non-zero, the identifier of the current message thread
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/** Returns bot members of the supergroup or channel */
export type supergroupMembersFilterBots = {
  _: "supergroupMembersFilterBots";
};

export type supergroupMembersFilterBots$Input = {
  readonly _: "supergroupMembersFilterBots";
};

/** Contains a chat invite link */
export type chatInviteLink = {
  _: "chatInviteLink";

  /**
   * Chat invite link
   * @type {string} {@link string}
   */
  invite_link: string;

  /**
   * Name of the link
   * @type {string} {@link string}
   */
  name: string;

  /**
   * User identifier of an administrator created the link
   * @type {int53} {@link int53}
   */
  creator_user_id: int53;

  /**
   * Point in time (Unix timestamp) when the link was created
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
   * @type {int32} {@link int32}
   */
  edit_date: int32;

  /**
   * Point in time (Unix timestamp) when the link will expire; 0 if never
   * @type {int32} {@link int32}
   */
  expiration_date: int32;

  /**
   * The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
   * @type {int32} {@link int32}
   */
  member_limit: int32;

  /**
   * Number of chat members, which joined the chat using the link
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Number of pending join requests created using this link
   * @type {int32} {@link int32}
   */
  pending_join_request_count: int32;

  /**
   * True, if the link only creates join request. If true, total number of joining members will be unlimited
   * @type {Bool} {@link Bool}
   */
  creates_join_request: Bool;

  /**
   * True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
   * @type {Bool} {@link Bool}
   */
  is_primary: Bool;

  /**
   * True, if the link was revoked
   * @type {Bool} {@link Bool}
   */
  is_revoked: Bool;
};

export type chatInviteLink$Input = {
  readonly _: "chatInviteLink";

  /**
   * Chat invite link
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Name of the link
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * User identifier of an administrator created the link
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the link was created
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
   * @type {int32} {@link int32}
   */
  readonly edit_date?: int32;

  /**
   * Point in time (Unix timestamp) when the link will expire; 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Number of chat members, which joined the chat using the link
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Number of pending join requests created using this link
   * @type {int32} {@link int32}
   */
  readonly pending_join_request_count?: int32;

  /**
   * True, if the link only creates join request. If true, total number of joining members will be unlimited
   * @type {Bool} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;

  /**
   * True, if the link is primary. Primary invite link can't have name, expiration date, or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
   * @type {Bool} {@link Bool}
   */
  readonly is_primary?: Bool$Input;

  /**
   * True, if the link was revoked
   * @type {Bool} {@link Bool}
   */
  readonly is_revoked?: Bool$Input;
};

/** Contains a list of chat invite links */
export type chatInviteLinks = {
  _: "chatInviteLinks";

  /**
   * Approximate total number of chat invite links found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of invite links
   * @type {vector<chatInviteLink>} {@link vector<chatInviteLink>}
   */
  invite_links: vector<chatInviteLink>;
};

export type chatInviteLinks$Input = {
  readonly _: "chatInviteLinks";

  /**
   * Approximate total number of chat invite links found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of invite links
   * @type {vector<chatInviteLink>} {@link vector<chatInviteLink>}
   */
  readonly invite_links?: vector$Input<chatInviteLink$Input>;
};

/** Describes a chat administrator with a number of active and revoked chat invite links */
export type chatInviteLinkCount = {
  _: "chatInviteLinkCount";

  /**
   * Administrator's user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of active invite links
   * @type {int32} {@link int32}
   */
  invite_link_count: int32;

  /**
   * Number of revoked invite links
   * @type {int32} {@link int32}
   */
  revoked_invite_link_count: int32;
};

export type chatInviteLinkCount$Input = {
  readonly _: "chatInviteLinkCount";

  /**
   * Administrator's user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of active invite links
   * @type {int32} {@link int32}
   */
  readonly invite_link_count?: int32;

  /**
   * Number of revoked invite links
   * @type {int32} {@link int32}
   */
  readonly revoked_invite_link_count?: int32;
};

/** Contains a list of chat invite link counts */
export type chatInviteLinkCounts = {
  _: "chatInviteLinkCounts";

  /**
   * List of invite link counts
   * @type {vector<chatInviteLinkCount>} {@link vector<chatInviteLinkCount>}
   */
  invite_link_counts: vector<chatInviteLinkCount>;
};

export type chatInviteLinkCounts$Input = {
  readonly _: "chatInviteLinkCounts";

  /**
   * List of invite link counts
   * @type {vector<chatInviteLinkCount>} {@link vector<chatInviteLinkCount>}
   */
  readonly invite_link_counts?: vector$Input<chatInviteLinkCount$Input>;
};

/** Describes a chat member joined a chat via an invite link */
export type chatInviteLinkMember = {
  _: "chatInviteLinkMember";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  joined_chat_date: int32;

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  approver_user_id: int53;
};

export type chatInviteLinkMember$Input = {
  readonly _: "chatInviteLinkMember";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user joined the chat
   * @type {int32} {@link int32}
   */
  readonly joined_chat_date?: int32;

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  readonly approver_user_id?: int53;
};

/** Contains a list of chat members joined a chat via an invite link */
export type chatInviteLinkMembers = {
  _: "chatInviteLinkMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of chat members, joined a chat via an invite link
   * @type {vector<chatInviteLinkMember>} {@link vector<chatInviteLinkMember>}
   */
  members: vector<chatInviteLinkMember>;
};

export type chatInviteLinkMembers$Input = {
  readonly _: "chatInviteLinkMembers";

  /**
   * Approximate total number of chat members found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of chat members, joined a chat via an invite link
   * @type {vector<chatInviteLinkMember>} {@link vector<chatInviteLinkMember>}
   */
  readonly members?: vector$Input<chatInviteLinkMember$Input>;
};

/** Contains information about a chat invite link */
export type chatInviteLinkInfo = {
  _: "chatInviteLinkInfo";

  /**
   * Chat identifier of the invite link; 0 if the user has no access to the chat before joining
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * If non-zero, the amount of time for which read access to the chat will remain available, in seconds
   * @type {int32} {@link int32}
   */
  accessible_for: int32;

  /**
   * Type of the chat
   * @type {ChatType} {@link ChatType}
   */
  type: ChatType;

  /**
   * Title of the chat
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo;

  /**
   * Contains information about a chat invite link
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Number of members in the chat
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * User identifiers of some chat members that may be known to the current user
   * @type {vector<int53>} {@link vector<int53>}
   */
  member_user_ids: vector<int53>;

  /**
   * True, if the link only creates join request
   * @type {Bool} {@link Bool}
   */
  creates_join_request: Bool;

  /**
   * True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;
};

export type chatInviteLinkInfo$Input = {
  readonly _: "chatInviteLinkInfo";

  /**
   * Chat identifier of the invite link; 0 if the user has no access to the chat before joining
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If non-zero, the amount of time for which read access to the chat will remain available, in seconds
   * @type {int32} {@link int32}
   */
  readonly accessible_for?: int32;

  /**
   * Type of the chat
   * @type {ChatType} {@link ChatType}
   */
  readonly type?: ChatType$Input;

  /**
   * Title of the chat
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input;

  /**
   * Contains information about a chat invite link
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Number of members in the chat
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * User identifiers of some chat members that may be known to the current user
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly member_user_ids?: vector$Input<int53>;

  /**
   * True, if the link only creates join request
   * @type {Bool} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;

  /**
   * True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;
};

/** Describes a user that sent a join request and waits for administrator approval */
export type chatJoinRequest = {
  _: "chatJoinRequest";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user sent the join request
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * A short bio of the user
   * @type {string} {@link string}
   */
  bio: string;
};

export type chatJoinRequest$Input = {
  readonly _: "chatJoinRequest";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user sent the join request
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * A short bio of the user
   * @type {string} {@link string}
   */
  readonly bio?: string;
};

/** Contains a list of requests to join a chat */
export type chatJoinRequests = {
  _: "chatJoinRequests";

  /**
   * Approximate total number of requests found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of the requests
   * @type {vector<chatJoinRequest>} {@link vector<chatJoinRequest>}
   */
  requests: vector<chatJoinRequest>;
};

export type chatJoinRequests$Input = {
  readonly _: "chatJoinRequests";

  /**
   * Approximate total number of requests found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of the requests
   * @type {vector<chatJoinRequest>} {@link vector<chatJoinRequest>}
   */
  readonly requests?: vector$Input<chatJoinRequest$Input>;
};

/** Contains information about pending join requests for a chat */
export type chatJoinRequestsInfo = {
  _: "chatJoinRequestsInfo";

  /**
   * Total number of pending join requests
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Identifiers of at most 3 users sent the newest pending join requests
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

export type chatJoinRequestsInfo$Input = {
  readonly _: "chatJoinRequestsInfo";

  /**
   * Total number of pending join requests
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Identifiers of at most 3 users sent the newest pending join requests
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/** Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users) */
export type basicGroup = {
  _: "basicGroup";

  /**
   * Group identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Number of members in the group
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Status of the current user in the group
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;

  /**
   * True, if the group is active
   * @type {Bool} {@link Bool}
   */
  is_active: Bool;

  /**
   * Identifier of the supergroup to which this group was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  upgraded_to_supergroup_id: int53;
};

export type basicGroup$Input = {
  readonly _: "basicGroup";

  /**
   * Group identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Number of members in the group
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Status of the current user in the group
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;

  /**
   * True, if the group is active
   * @type {Bool} {@link Bool}
   */
  readonly is_active?: Bool$Input;

  /**
   * Identifier of the supergroup to which this group was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  readonly upgraded_to_supergroup_id?: int53;
};

/** Contains full information about a basic group */
export type basicGroupFullInfo = {
  _: "basicGroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto;

  /**
   * Contains full information about a basic group
   * @type {string} {@link string}
   */
  description: string;

  /**
   * User identifier of the creator of the group; 0 if unknown
   * @type {int53} {@link int53}
   */
  creator_user_id: int53;

  /**
   * Group members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  members: vector<chatMember>;

  /**
   * Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  bot_commands: vector<botCommands>;
};

export type basicGroupFullInfo$Input = {
  readonly _: "basicGroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input;

  /**
   * Contains full information about a basic group
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * User identifier of the creator of the group; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Group members
   * @type {vector<chatMember>} {@link vector<chatMember>}
   */
  readonly members?: vector$Input<chatMember$Input>;

  /**
   * Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  readonly bot_commands?: vector$Input<botCommands$Input>;
};

/** Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers */
export type supergroup = {
  _: "supergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Usernames of the supergroup or channel; may be null
   * @type {usernames} {@link usernames}
   */
  usernames: usernames;

  /**
   * Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Status of the current user in the supergroup or channel; custom title will always be empty
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;

  /**
   * Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon, or getUserPrivacySettingRules
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
   * @type {Bool} {@link Bool}
   */
  has_linked_chat: Bool;

  /**
   * True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  has_location: Bool;

  /**
   * True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels
   * @type {Bool} {@link Bool}
   */
  sign_messages: Bool;

  /**
   * True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
   * @type {Bool} {@link Bool}
   */
  join_to_send_messages: Bool;

  /**
   * True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
   * @type {Bool} {@link Bool}
   */
  join_by_request: Bool;

  /**
   * True, if the slow mode is enabled in the supergroup
   * @type {Bool} {@link Bool}
   */
  is_slow_mode_enabled: Bool;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  is_channel: Bool;

  /**
   * True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
   * @type {Bool} {@link Bool}
   */
  is_broadcast_group: Bool;

  /**
   * True, if the supergroup must be shown as a forum by default
   * @type {Bool} {@link Bool}
   */
  is_forum: Bool;

  /**
   * True, if the supergroup or channel is verified
   * @type {Bool} {@link Bool}
   */
  is_verified: Bool;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
   * @type {string} {@link string}
   */
  restriction_reason: string;

  /**
   * True, if many users reported this supergroup or channel as a scam
   * @type {Bool} {@link Bool}
   */
  is_scam: Bool;

  /**
   * True, if many users reported this supergroup or channel as a fake account
   * @type {Bool} {@link Bool}
   */
  is_fake: Bool;
};

export type supergroup$Input = {
  readonly _: "supergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Usernames of the supergroup or channel; may be null
   * @type {usernames} {@link usernames}
   */
  readonly usernames?: usernames$Input;

  /**
   * Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Status of the current user in the supergroup or channel; custom title will always be empty
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;

  /**
   * Number of members in the supergroup or channel; 0 if unknown. Currently, it is guaranteed to be known only if the supergroup or channel was received through searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon, or getUserPrivacySettingRules
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
   * @type {Bool} {@link Bool}
   */
  readonly has_linked_chat?: Bool$Input;

  /**
   * True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
   * @type {Bool} {@link Bool}
   */
  readonly has_location?: Bool$Input;

  /**
   * True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels
   * @type {Bool} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;

  /**
   * True, if users need to join the supergroup before they can send messages. Always true for channels and non-discussion supergroups
   * @type {Bool} {@link Bool}
   */
  readonly join_to_send_messages?: Bool$Input;

  /**
   * True, if all users directly joining the supergroup need to be approved by supergroup administrators. Always false for channels and supergroups without username, location, or a linked chat
   * @type {Bool} {@link Bool}
   */
  readonly join_by_request?: Bool$Input;

  /**
   * True, if the slow mode is enabled in the supergroup
   * @type {Bool} {@link Bool}
   */
  readonly is_slow_mode_enabled?: Bool$Input;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on the number of members
   * @type {Bool} {@link Bool}
   */
  readonly is_broadcast_group?: Bool$Input;

  /**
   * True, if the supergroup must be shown as a forum by default
   * @type {Bool} {@link Bool}
   */
  readonly is_forum?: Bool$Input;

  /**
   * True, if the supergroup or channel is verified
   * @type {Bool} {@link Bool}
   */
  readonly is_verified?: Bool$Input;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
   * @type {string} {@link string}
   */
  readonly restriction_reason?: string;

  /**
   * True, if many users reported this supergroup or channel as a scam
   * @type {Bool} {@link Bool}
   */
  readonly is_scam?: Bool$Input;

  /**
   * True, if many users reported this supergroup or channel as a fake account
   * @type {Bool} {@link Bool}
   */
  readonly is_fake?: Bool$Input;
};

/** Contains full information about a supergroup or channel */
export type supergroupFullInfo = {
  _: "supergroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto;

  /**
   * Contains full information about a supergroup or channel
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Number of members in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  member_count: int32;

  /**
   * Number of privileged users in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  administrator_count: int32;

  /**
   * Number of restricted users in the supergroup; 0 if unknown
   * @type {int32} {@link int32}
   */
  restricted_count: int32;

  /**
   * Number of users banned from chat; 0 if unknown
   * @type {int32} {@link int32}
   */
  banned_count: int32;

  /**
   * Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
   * @type {int53} {@link int53}
   */
  linked_chat_id: int53;

  /**
   * Delay between consecutive sent messages for non-administrator supergroup members, in seconds
   * @type {int32} {@link int32}
   */
  slow_mode_delay: int32;

  /**
   * Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
   * @type {double} {@link double}
   */
  slow_mode_delay_expires_in: double;

  /**
   * True, if members of the chat can be retrieved
   * @type {Bool} {@link Bool}
   */
  can_get_members: Bool;

  /**
   * True, if the chat username can be changed
   * @type {Bool} {@link Bool}
   */
  can_set_username: Bool;

  /**
   * True, if the supergroup sticker set can be changed
   * @type {Bool} {@link Bool}
   */
  can_set_sticker_set: Bool;

  /**
   * True, if the supergroup location can be changed
   * @type {Bool} {@link Bool}
   */
  can_set_location: Bool;

  /**
   * True, if the supergroup or channel statistics are available
   * @type {Bool} {@link Bool}
   */
  can_get_statistics: Bool;

  /**
   * True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available for chat administrators
   * @type {Bool} {@link Bool}
   */
  is_all_history_available: Bool;

  /**
   * Identifier of the supergroup sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  sticker_set_id: int64;

  /**
   * Location to which the supergroup is connected; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  location: chatLocation;

  /**
   * Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  bot_commands: vector<botCommands>;

  /**
   * Identifier of the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  upgraded_from_basic_group_id: int53;

  /**
   * Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  upgraded_from_max_message_id: int53;
};

export type supergroupFullInfo$Input = {
  readonly _: "supergroupFullInfo";

  /**
   * Chat photo; may be null if empty or unknown. If non-null, then it is the same photo as in chat.photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input;

  /**
   * Contains full information about a supergroup or channel
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Number of members in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly member_count?: int32;

  /**
   * Number of privileged users in the supergroup or channel; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly administrator_count?: int32;

  /**
   * Number of restricted users in the supergroup; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly restricted_count?: int32;

  /**
   * Number of users banned from chat; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly banned_count?: int32;

  /**
   * Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
   * @type {int53} {@link int53}
   */
  readonly linked_chat_id?: int53;

  /**
   * Delay between consecutive sent messages for non-administrator supergroup members, in seconds
   * @type {int32} {@link int32}
   */
  readonly slow_mode_delay?: int32;

  /**
   * Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
   * @type {double} {@link double}
   */
  readonly slow_mode_delay_expires_in?: double;

  /**
   * True, if members of the chat can be retrieved
   * @type {Bool} {@link Bool}
   */
  readonly can_get_members?: Bool$Input;

  /**
   * True, if the chat username can be changed
   * @type {Bool} {@link Bool}
   */
  readonly can_set_username?: Bool$Input;

  /**
   * True, if the supergroup sticker set can be changed
   * @type {Bool} {@link Bool}
   */
  readonly can_set_sticker_set?: Bool$Input;

  /**
   * True, if the supergroup location can be changed
   * @type {Bool} {@link Bool}
   */
  readonly can_set_location?: Bool$Input;

  /**
   * True, if the supergroup or channel statistics are available
   * @type {Bool} {@link Bool}
   */
  readonly can_get_statistics?: Bool$Input;

  /**
   * True, if new chat members will have access to old messages. In public, discussion, of forum groups and all channels, old messages are always available, so this option affects only private non-forum supergroups without a linked chat. The value of this field is only available for chat administrators
   * @type {Bool} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;

  /**
   * Identifier of the supergroup sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly sticker_set_id?: int64;

  /**
   * Location to which the supergroup is connected; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  readonly location?: chatLocation$Input;

  /**
   * Primary invite link for the chat; may be null. For chat administrators with can_invite_users right only
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;

  /**
   * List of commands of bots in the group
   * @type {vector<botCommands>} {@link vector<botCommands>}
   */
  readonly bot_commands?: vector$Input<botCommands$Input>;

  /**
   * Identifier of the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  readonly upgraded_from_basic_group_id?: int53;

  /**
   * Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
   * @type {int53} {@link int53}
   */
  readonly upgraded_from_max_message_id?: int53;
};

/** The secret chat is not yet created; waiting for the other user to get online */
export type secretChatStatePending = {
  _: "secretChatStatePending";
};

export type secretChatStatePending$Input = {
  readonly _: "secretChatStatePending";
};

/** The secret chat is ready to use */
export type secretChatStateReady = {
  _: "secretChatStateReady";
};

export type secretChatStateReady$Input = {
  readonly _: "secretChatStateReady";
};

/** The secret chat is closed */
export type secretChatStateClosed = {
  _: "secretChatStateClosed";
};

export type secretChatStateClosed$Input = {
  readonly _: "secretChatStateClosed";
};

/** Represents a secret chat */
export type secretChat = {
  _: "secretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Identifier of the chat partner
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * State of the secret chat
   * @type {SecretChatState} {@link SecretChatState}
   */
  state: SecretChatState;

  /**
   * True, if the chat was created by the current user; otherwise false
   * @type {Bool} {@link Bool}
   */
  is_outbound: Bool;

  /**
   * Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9.
   *
   * -The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
   * @type {bytes} {@link bytes}
   */
  key_hash: bytes;

  /**
   * Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
   * @type {int32} {@link int32}
   */
  layer: int32;
};

export type secretChat$Input = {
  readonly _: "secretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Identifier of the chat partner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * State of the secret chat
   * @type {SecretChatState} {@link SecretChatState}
   */
  readonly state?: SecretChatState$Input;

  /**
   * True, if the chat was created by the current user; otherwise false
   * @type {Bool} {@link Bool}
   */
  readonly is_outbound?: Bool$Input;

  /**
   * Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9.
   *
   * -The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
   * @type {bytes} {@link bytes}
   */
  readonly key_hash?: bytes;

  /**
   * Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer >= 101, files bigger than 2000MB are supported if the layer >= 143, spoiler and custom emoji text entities are supported if the layer >= 144
   * @type {int32} {@link int32}
   */
  readonly layer?: int32;
};

/** The message was sent by a known user */
export type messageSenderUser = {
  _: "messageSenderUser";

  /**
   * Identifier of the user that sent the message
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type messageSenderUser$Input = {
  readonly _: "messageSenderUser";

  /**
   * Identifier of the user that sent the message
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** The message was sent on behalf of a chat */
export type messageSenderChat = {
  _: "messageSenderChat";

  /**
   * Identifier of the chat that sent the message
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

export type messageSenderChat$Input = {
  readonly _: "messageSenderChat";

  /**
   * Identifier of the chat that sent the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/** Represents a list of message senders */
export type messageSenders = {
  _: "messageSenders";

  /**
   * Approximate total number of messages senders found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of message senders
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  senders: vector<MessageSender>;
};

export type messageSenders$Input = {
  readonly _: "messageSenders";

  /**
   * Approximate total number of messages senders found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of message senders
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly senders?: vector$Input<MessageSender$Input>;
};

/** Represents a message sender, which can be used to send messages in a chat */
export type chatMessageSender = {
  _: "chatMessageSender";

  /**
   * Available message senders
   * @type {MessageSender} {@link MessageSender}
   */
  sender: MessageSender;

  /**
   * True, if Telegram Premium is needed to use the message sender
   * @type {Bool} {@link Bool}
   */
  needs_premium: Bool;
};

export type chatMessageSender$Input = {
  readonly _: "chatMessageSender";

  /**
   * Available message senders
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender?: MessageSender$Input;

  /**
   * True, if Telegram Premium is needed to use the message sender
   * @type {Bool} {@link Bool}
   */
  readonly needs_premium?: Bool$Input;
};

/** Represents a list of message senders, which can be used to send messages in a chat */
export type chatMessageSenders = {
  _: "chatMessageSenders";

  /**
   * List of available message senders
   * @type {vector<chatMessageSender>} {@link vector<chatMessageSender>}
   */
  senders: vector<chatMessageSender>;
};

export type chatMessageSenders$Input = {
  readonly _: "chatMessageSenders";

  /**
   * List of available message senders
   * @type {vector<chatMessageSender>} {@link vector<chatMessageSender>}
   */
  readonly senders?: vector$Input<chatMessageSender$Input>;
};

/** The message was originally sent by a known user */
export type messageForwardOriginUser = {
  _: "messageForwardOriginUser";

  /**
   * Identifier of the user that originally sent the message
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;
};

export type messageForwardOriginUser$Input = {
  readonly _: "messageForwardOriginUser";

  /**
   * Identifier of the user that originally sent the message
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;
};

/** The message was originally sent on behalf of a chat */
export type messageForwardOriginChat = {
  _: "messageForwardOriginChat";

  /**
   * Identifier of the chat that originally sent the message
   * @type {int53} {@link int53}
   */
  sender_chat_id: int53;

  /**
   * For messages originally sent by an anonymous chat administrator, original message author signature
   * @type {string} {@link string}
   */
  author_signature: string;
};

export type messageForwardOriginChat$Input = {
  readonly _: "messageForwardOriginChat";

  /**
   * Identifier of the chat that originally sent the message
   * @type {int53} {@link int53}
   */
  readonly sender_chat_id?: int53;

  /**
   * For messages originally sent by an anonymous chat administrator, original message author signature
   * @type {string} {@link string}
   */
  readonly author_signature?: string;
};

/** The message was originally sent by a user, which is hidden by their privacy settings */
export type messageForwardOriginHiddenUser = {
  _: "messageForwardOriginHiddenUser";

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  sender_name: string;
};

export type messageForwardOriginHiddenUser$Input = {
  readonly _: "messageForwardOriginHiddenUser";

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;
};

/** The message was originally a post in a channel */
export type messageForwardOriginChannel = {
  _: "messageForwardOriginChannel";

  /**
   * Identifier of the chat from which the message was originally forwarded
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier of the original message
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Original post author signature
   * @type {string} {@link string}
   */
  author_signature: string;
};

export type messageForwardOriginChannel$Input = {
  readonly _: "messageForwardOriginChannel";

  /**
   * Identifier of the chat from which the message was originally forwarded
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the original message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Original post author signature
   * @type {string} {@link string}
   */
  readonly author_signature?: string;
};

/** The message was imported from an exported message history */
export type messageForwardOriginMessageImport = {
  _: "messageForwardOriginMessageImport";

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  sender_name: string;
};

export type messageForwardOriginMessageImport$Input = {
  readonly _: "messageForwardOriginMessageImport";

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;
};

/** A reaction with an emoji */
export type reactionTypeEmoji = {
  _: "reactionTypeEmoji";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  emoji: string;
};

export type reactionTypeEmoji$Input = {
  readonly _: "reactionTypeEmoji";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/** A reaction with a custom emoji */
export type reactionTypeCustomEmoji = {
  _: "reactionTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

export type reactionTypeCustomEmoji$Input = {
  readonly _: "reactionTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64;
};

/** Contains information about a forwarded message */
export type messageForwardInfo = {
  _: "messageForwardInfo";

  /**
   * Origin of a forwarded message
   * @type {MessageForwardOrigin} {@link MessageForwardOrigin}
   */
  origin: MessageForwardOrigin;

  /**
   * Point in time (Unix timestamp) when the message was originally sent
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * The type of a public service announcement for the forwarded message
   * @type {string} {@link string}
   */
  public_service_announcement_type: string;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  from_chat_id: int53;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  from_message_id: int53;
};

export type messageForwardInfo$Input = {
  readonly _: "messageForwardInfo";

  /**
   * Origin of a forwarded message
   * @type {MessageForwardOrigin} {@link MessageForwardOrigin}
   */
  readonly origin?: MessageForwardOrigin$Input;

  /**
   * Point in time (Unix timestamp) when the message was originally sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * The type of a public service announcement for the forwarded message
   * @type {string} {@link string}
   */
  readonly public_service_announcement_type?: string;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;
};

/** Contains information about replies to a message */
export type messageReplyInfo = {
  _: "messageReplyInfo";

  /**
   * Number of times the message was directly or indirectly replied
   * @type {int32} {@link int32}
   */
  reply_count: int32;

  /**
   * Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  recent_replier_ids: vector<MessageSender>;

  /**
   * Identifier of the last read incoming reply to the message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * Identifier of the last read outgoing reply to the message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;

  /**
   * Identifier of the last reply to the message
   * @type {int53} {@link int53}
   */
  last_message_id: int53;
};

export type messageReplyInfo$Input = {
  readonly _: "messageReplyInfo";

  /**
   * Number of times the message was directly or indirectly replied
   * @type {int32} {@link int32}
   */
  readonly reply_count?: int32;

  /**
   * Identifiers of at most 3 recent repliers to the message; available in channels with a discussion supergroup. The users and chats are expected to be inaccessible: only their photo and name will be available
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly recent_replier_ids?: vector$Input<MessageSender$Input>;

  /**
   * Identifier of the last read incoming reply to the message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * Identifier of the last read outgoing reply to the message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;

  /**
   * Identifier of the last reply to the message
   * @type {int53} {@link int53}
   */
  readonly last_message_id?: int53;
};

/** Contains information about a reaction to a message */
export type messageReaction = {
  _: "messageReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * Number of times the reaction was added
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * True, if the reaction is chosen by the current user
   * @type {Bool} {@link Bool}
   */
  is_chosen: Bool;

  /**
   * Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  recent_sender_ids: vector<MessageSender>;
};

export type messageReaction$Input = {
  readonly _: "messageReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * Number of times the reaction was added
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * True, if the reaction is chosen by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_chosen?: Bool$Input;

  /**
   * Identifiers of at most 3 recent message senders, added the reaction; available in private, basic group and supergroup chats
   * @type {vector<MessageSender>} {@link vector<MessageSender>}
   */
  readonly recent_sender_ids?: vector$Input<MessageSender$Input>;
};

/** Contains information about interactions with a message */
export type messageInteractionInfo = {
  _: "messageInteractionInfo";

  /**
   * Number of times the message was viewed
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Number of times the message was forwarded
   * @type {int32} {@link int32}
   */
  forward_count: int32;

  /**
   * Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  reply_info: messageReplyInfo;

  /**
   * The list of reactions added to the message
   * @type {vector<messageReaction>} {@link vector<messageReaction>}
   */
  reactions: vector<messageReaction>;
};

export type messageInteractionInfo$Input = {
  readonly _: "messageInteractionInfo";

  /**
   * Number of times the message was viewed
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Number of times the message was forwarded
   * @type {int32} {@link int32}
   */
  readonly forward_count?: int32;

  /**
   * Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  readonly reply_info?: messageReplyInfo$Input;

  /**
   * The list of reactions added to the message
   * @type {vector<messageReaction>} {@link vector<messageReaction>}
   */
  readonly reactions?: vector$Input<messageReaction$Input>;
};

/** Contains information about an unread reaction to a message */
export type unreadReaction = {
  _: "unreadReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * Identifier of the sender, added the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * True, if the reaction was added with a big animation
   * @type {Bool} {@link Bool}
   */
  is_big: Bool;
};

export type unreadReaction$Input = {
  readonly _: "unreadReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * Identifier of the sender, added the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * True, if the reaction was added with a big animation
   * @type {Bool} {@link Bool}
   */
  readonly is_big?: Bool$Input;
};

/** The message is being sent now, but has not yet been delivered to the server */
export type messageSendingStatePending = {
  _: "messageSendingStatePending";
};

export type messageSendingStatePending$Input = {
  readonly _: "messageSendingStatePending";
};

/** The message failed to be sent */
export type messageSendingStateFailed = {
  _: "messageSendingStateFailed";

  /**
   * An error code; 0 if unknown
   * @type {int32} {@link int32}
   */
  error_code: int32;

  /**
   * Error message
   * @type {string} {@link string}
   */
  error_message: string;

  /**
   * True, if the message can be re-sent
   * @type {Bool} {@link Bool}
   */
  can_retry: Bool;

  /**
   * True, if the message can be re-sent only on behalf of a different sender
   * @type {Bool} {@link Bool}
   */
  need_another_sender: Bool;

  /**
   * Time left before the message can be re-sent, in seconds. No update is sent when this field changes
   * @type {double} {@link double}
   */
  retry_after: double;
};

export type messageSendingStateFailed$Input = {
  readonly _: "messageSendingStateFailed";

  /**
   * An error code; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly error_code?: int32;

  /**
   * Error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;

  /**
   * True, if the message can be re-sent
   * @type {Bool} {@link Bool}
   */
  readonly can_retry?: Bool$Input;

  /**
   * True, if the message can be re-sent only on behalf of a different sender
   * @type {Bool} {@link Bool}
   */
  readonly need_another_sender?: Bool$Input;

  /**
   * Time left before the message can be re-sent, in seconds. No update is sent when this field changes
   * @type {double} {@link double}
   */
  readonly retry_after?: double;
};

/** Describes a message */
export type message = {
  _: "message";

  /**
   * Message identifier; unique for the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The sending state of the message; may be null
   * @type {MessageSendingState} {@link MessageSendingState}
   */
  sending_state: MessageSendingState;

  /**
   * The scheduling state of the message; may be null
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  scheduling_state: MessageSchedulingState;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
   * @type {Bool} {@link Bool}
   */
  can_be_edited: Bool;

  /**
   * True, if the message can be forwarded
   * @type {Bool} {@link Bool}
   */
  can_be_forwarded: Bool;

  /**
   * True, if content of the message can be saved locally or copied
   * @type {Bool} {@link Bool}
   */
  can_be_saved: Bool;

  /**
   * True, if the message can be deleted only for the current user while other users will continue to see it
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_only_for_self: Bool;

  /**
   * True, if the message can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_for_all_users: Bool;

  /**
   * True, if the list of added reactions is available through getMessageAddedReactions
   * @type {Bool} {@link Bool}
   */
  can_get_added_reactions: Bool;

  /**
   * True, if the message statistics are available through getMessageStatistics
   * @type {Bool} {@link Bool}
   */
  can_get_statistics: Bool;

  /**
   * True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
   * @type {Bool} {@link Bool}
   */
  can_get_message_thread: Bool;

  /**
   * True, if chat members already viewed the message can be received through getMessageViewers
   * @type {Bool} {@link Bool}
   */
  can_get_viewers: Bool;

  /**
   * True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink
   * @type {Bool} {@link Bool}
   */
  can_get_media_timestamp_links: Bool;

  /**
   * True, if reactions on the message can be reported through reportMessageReactions
   * @type {Bool} {@link Bool}
   */
  can_report_reactions: Bool;

  /**
   * True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
   * @type {Bool} {@link Bool}
   */
  has_timestamped_media: Bool;

  /**
   * True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
   * @type {Bool} {@link Bool}
   */
  is_channel_post: Bool;

  /**
   * True, if the message is a forum topic message
   * @type {Bool} {@link Bool}
   */
  is_topic_message: Bool;

  /**
   * True, if the message contains an unread mention for the current user
   * @type {Bool} {@link Bool}
   */
  contains_unread_mention: Bool;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Point in time (Unix timestamp) when the message was last edited
   * @type {int32} {@link int32}
   */
  edit_date: int32;

  /**
   * Information about the initial message sender; may be null
   * @type {messageForwardInfo} {@link messageForwardInfo}
   */
  forward_info: messageForwardInfo;

  /**
   * Information about interactions with the message; may be null
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  interaction_info: messageInteractionInfo;

  /**
   * Information about unread reactions added to the message
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  unread_reactions: vector<unreadReaction>;

  /**
   * If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
   * @type {int53} {@link int53}
   */
  reply_in_chat_id: int53;

  /**
   * If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
   * @type {int53} {@link int53}
   */
  reply_to_message_id: int53;

  /**
   * If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
   * @type {int32} {@link int32}
   */
  ttl: int32;

  /**
   * Time left before the message expires, in seconds. If the TTL timer isn't started yet, equals to the value of the ttl field
   * @type {double} {@link double}
   */
  ttl_expires_in: double;

  /**
   * If non-zero, the user identifier of the bot through which this message was sent
   * @type {int53} {@link int53}
   */
  via_bot_user_id: int53;

  /**
   * For channel posts and anonymous group messages, optional author signature
   * @type {string} {@link string}
   */
  author_signature: string;

  /**
   * Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
   * @type {int64} {@link int64}
   */
  media_album_id: int64;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this message must be restricted
   * @type {string} {@link string}
   */
  restriction_reason: string;

  /**
   * Content of the message
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent;

  /**
   * Reply markup for the message; may be null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;
};

export type message$Input = {
  readonly _: "message";

  /**
   * Message identifier; unique for the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The sending state of the message; may be null
   * @type {MessageSendingState} {@link MessageSendingState}
   */
  readonly sending_state?: MessageSendingState$Input;

  /**
   * The scheduling state of the message; may be null
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
   * @type {Bool} {@link Bool}
   */
  readonly can_be_edited?: Bool$Input;

  /**
   * True, if the message can be forwarded
   * @type {Bool} {@link Bool}
   */
  readonly can_be_forwarded?: Bool$Input;

  /**
   * True, if content of the message can be saved locally or copied
   * @type {Bool} {@link Bool}
   */
  readonly can_be_saved?: Bool$Input;

  /**
   * True, if the message can be deleted only for the current user while other users will continue to see it
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_only_for_self?: Bool$Input;

  /**
   * True, if the message can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_for_all_users?: Bool$Input;

  /**
   * True, if the list of added reactions is available through getMessageAddedReactions
   * @type {Bool} {@link Bool}
   */
  readonly can_get_added_reactions?: Bool$Input;

  /**
   * True, if the message statistics are available through getMessageStatistics
   * @type {Bool} {@link Bool}
   */
  readonly can_get_statistics?: Bool$Input;

  /**
   * True, if information about the message thread is available through getMessageThread and getMessageThreadHistory
   * @type {Bool} {@link Bool}
   */
  readonly can_get_message_thread?: Bool$Input;

  /**
   * True, if chat members already viewed the message can be received through getMessageViewers
   * @type {Bool} {@link Bool}
   */
  readonly can_get_viewers?: Bool$Input;

  /**
   * True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description through getMessageLink
   * @type {Bool} {@link Bool}
   */
  readonly can_get_media_timestamp_links?: Bool$Input;

  /**
   * True, if reactions on the message can be reported through reportMessageReactions
   * @type {Bool} {@link Bool}
   */
  readonly can_report_reactions?: Bool$Input;

  /**
   * True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
   * @type {Bool} {@link Bool}
   */
  readonly has_timestamped_media?: Bool$Input;

  /**
   * True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
   * @type {Bool} {@link Bool}
   */
  readonly is_channel_post?: Bool$Input;

  /**
   * True, if the message is a forum topic message
   * @type {Bool} {@link Bool}
   */
  readonly is_topic_message?: Bool$Input;

  /**
   * True, if the message contains an unread mention for the current user
   * @type {Bool} {@link Bool}
   */
  readonly contains_unread_mention?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Point in time (Unix timestamp) when the message was last edited
   * @type {int32} {@link int32}
   */
  readonly edit_date?: int32;

  /**
   * Information about the initial message sender; may be null
   * @type {messageForwardInfo} {@link messageForwardInfo}
   */
  readonly forward_info?: messageForwardInfo$Input;

  /**
   * Information about interactions with the message; may be null
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  readonly interaction_info?: messageInteractionInfo$Input;

  /**
   * Information about unread reactions added to the message
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  readonly unread_reactions?: vector$Input<unreadReaction$Input>;

  /**
   * If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
   * @type {int53} {@link int53}
   */
  readonly reply_in_chat_id?: int53;

  /**
   * If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;

  /**
   * If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;

  /**
   * Time left before the message expires, in seconds. If the TTL timer isn't started yet, equals to the value of the ttl field
   * @type {double} {@link double}
   */
  readonly ttl_expires_in?: double;

  /**
   * If non-zero, the user identifier of the bot through which this message was sent
   * @type {int53} {@link int53}
   */
  readonly via_bot_user_id?: int53;

  /**
   * For channel posts and anonymous group messages, optional author signature
   * @type {string} {@link string}
   */
  readonly author_signature?: string;

  /**
   * Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
   * @type {int64} {@link int64}
   */
  readonly media_album_id?: int64;

  /**
   * If non-empty, contains a human-readable description of the reason why access to this message must be restricted
   * @type {string} {@link string}
   */
  readonly restriction_reason?: string;

  /**
   * Content of the message
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input;

  /**
   * Reply markup for the message; may be null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;
};

/** Contains a list of messages */
export type messages = {
  _: "messages";

  /**
   * Approximate total number of messages found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of messages; messages may be null
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message>;
};

export type messages$Input = {
  readonly _: "messages";

  /**
   * Approximate total number of messages found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of messages; messages may be null
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input>;
};

/** Contains a list of messages found by a search */
export type foundMessages = {
  _: "foundMessages";

  /**
   * Approximate total number of messages found; -1 if unknown
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of messages
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message>;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

export type foundMessages$Input = {
  readonly _: "foundMessages";

  /**
   * Approximate total number of messages found; -1 if unknown
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of messages
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input>;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/** Contains information about a message in a specific position */
export type messagePosition = {
  _: "messagePosition";

  /**
   * 0-based message position in the full list of suitable messages
   * @type {int32} {@link int32}
   */
  position: int32;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  date: int32;
};

export type messagePosition$Input = {
  readonly _: "messagePosition";

  /**
   * 0-based message position in the full list of suitable messages
   * @type {int32} {@link int32}
   */
  readonly position?: int32;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Point in time (Unix timestamp) when the message was sent
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/** Contains a list of message positions */
export type messagePositions = {
  _: "messagePositions";

  /**
   * Total number of messages found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of message positions
   * @type {vector<messagePosition>} {@link vector<messagePosition>}
   */
  positions: vector<messagePosition>;
};

export type messagePositions$Input = {
  readonly _: "messagePositions";

  /**
   * Total number of messages found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of message positions
   * @type {vector<messagePosition>} {@link vector<messagePosition>}
   */
  readonly positions?: vector$Input<messagePosition$Input>;
};

/** Contains information about found messages sent on a specific day */
export type messageCalendarDay = {
  _: "messageCalendarDay";

  /**
   * Total number of found messages sent on the day
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * First message sent on the day
   * @type {message} {@link message}
   */
  message: message;
};

export type messageCalendarDay$Input = {
  readonly _: "messageCalendarDay";

  /**
   * Total number of found messages sent on the day
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * First message sent on the day
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/** Contains information about found messages, split by days according to the option "utc_time_offset" */
export type messageCalendar = {
  _: "messageCalendar";

  /**
   * Total number of found messages
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Information about messages sent
   * @type {vector<messageCalendarDay>} {@link vector<messageCalendarDay>}
   */
  days: vector<messageCalendarDay>;
};

export type messageCalendar$Input = {
  readonly _: "messageCalendar";

  /**
   * Total number of found messages
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Information about messages sent
   * @type {vector<messageCalendarDay>} {@link vector<messageCalendarDay>}
   */
  readonly days?: vector$Input<messageCalendarDay$Input>;
};

/** Describes a sponsored message */
export type sponsoredMessage = {
  _: "sponsoredMessage";

  /**
   * Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * True, if the message needs to be labeled as "recommended" instead of "sponsored"
   * @type {Bool} {@link Bool}
   */
  is_recommended: Bool;

  /**
   * Sponsor chat identifier; 0 if the sponsor chat is accessible through an invite link
   * @type {int53} {@link int53}
   */
  sponsor_chat_id: int53;

  /**
   * Information about the sponsor chat; may be null unless sponsor_chat_id == 0
   * @type {chatInviteLinkInfo} {@link chatInviteLinkInfo}
   */
  sponsor_chat_info: chatInviteLinkInfo;

  /**
   * True, if the sponsor's chat photo must be shown
   * @type {Bool} {@link Bool}
   */
  show_chat_photo: Bool;

  /**
   * An internal link to be opened when the sponsored message is clicked; may be null if the sponsor chat needs to be opened instead
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  link: InternalLinkType;

  /**
   * Content of the message. Currently, can be only of the type messageText
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent;
};

export type sponsoredMessage$Input = {
  readonly _: "sponsoredMessage";

  /**
   * Message identifier; unique for the chat to which the sponsored message belongs among both ordinary and sponsored messages
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * True, if the message needs to be labeled as "recommended" instead of "sponsored"
   * @type {Bool} {@link Bool}
   */
  readonly is_recommended?: Bool$Input;

  /**
   * Sponsor chat identifier; 0 if the sponsor chat is accessible through an invite link
   * @type {int53} {@link int53}
   */
  readonly sponsor_chat_id?: int53;

  /**
   * Information about the sponsor chat; may be null unless sponsor_chat_id == 0
   * @type {chatInviteLinkInfo} {@link chatInviteLinkInfo}
   */
  readonly sponsor_chat_info?: chatInviteLinkInfo$Input;

  /**
   * True, if the sponsor's chat photo must be shown
   * @type {Bool} {@link Bool}
   */
  readonly show_chat_photo?: Bool$Input;

  /**
   * An internal link to be opened when the sponsored message is clicked; may be null if the sponsor chat needs to be opened instead
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly link?: InternalLinkType$Input;

  /**
   * Content of the message. Currently, can be only of the type messageText
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input;
};

/** Contains a list of sponsored messages */
export type sponsoredMessages = {
  _: "sponsoredMessages";

  /**
   * List of sponsored messages
   * @type {vector<sponsoredMessage>} {@link vector<sponsoredMessage>}
   */
  messages: vector<sponsoredMessage>;

  /**
   * The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
   * @type {int32} {@link int32}
   */
  messages_between: int32;
};

export type sponsoredMessages$Input = {
  readonly _: "sponsoredMessages";

  /**
   * List of sponsored messages
   * @type {vector<sponsoredMessage>} {@link vector<sponsoredMessage>}
   */
  readonly messages?: vector$Input<sponsoredMessage$Input>;

  /**
   * The minimum number of messages between shown sponsored messages, or 0 if only one sponsored message must be shown after all ordinary messages
   * @type {int32} {@link int32}
   */
  readonly messages_between?: int32;
};

/** Describes a file added to file download list */
export type fileDownload = {
  _: "fileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  file_id: int32;

  /**
   * The message with the file
   * @type {message} {@link message}
   */
  message: message;

  /**
   * Point in time (Unix timestamp) when the file was added to the download list
   * @type {int32} {@link int32}
   */
  add_date: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  complete_date: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  is_paused: Bool;
};

export type fileDownload$Input = {
  readonly _: "fileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The message with the file
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * Point in time (Unix timestamp) when the file was added to the download list
   * @type {int32} {@link int32}
   */
  readonly add_date?: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  readonly complete_date?: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/** Contains number of being downloaded and recently downloaded files found */
export type downloadedFileCounts = {
  _: "downloadedFileCounts";

  /**
   * Number of active file downloads found, including paused
   * @type {int32} {@link int32}
   */
  active_count: int32;

  /**
   * Number of paused file downloads found
   * @type {int32} {@link int32}
   */
  paused_count: int32;

  /**
   * Number of completed file downloads found
   * @type {int32} {@link int32}
   */
  completed_count: int32;
};

export type downloadedFileCounts$Input = {
  readonly _: "downloadedFileCounts";

  /**
   * Number of active file downloads found, including paused
   * @type {int32} {@link int32}
   */
  readonly active_count?: int32;

  /**
   * Number of paused file downloads found
   * @type {int32} {@link int32}
   */
  readonly paused_count?: int32;

  /**
   * Number of completed file downloads found
   * @type {int32} {@link int32}
   */
  readonly completed_count?: int32;
};

/** Contains a list of downloaded files, found by a search */
export type foundFileDownloads = {
  _: "foundFileDownloads";

  /**
   * Total number of suitable files, ignoring offset
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  total_counts: downloadedFileCounts;

  /**
   * The list of files
   * @type {vector<fileDownload>} {@link vector<fileDownload>}
   */
  files: vector<fileDownload>;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

export type foundFileDownloads$Input = {
  readonly _: "foundFileDownloads";

  /**
   * Total number of suitable files, ignoring offset
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly total_counts?: downloadedFileCounts$Input;

  /**
   * The list of files
   * @type {vector<fileDownload>} {@link vector<fileDownload>}
   */
  readonly files?: vector$Input<fileDownload$Input>;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/** Notification settings applied to all private and secret chats when the corresponding chat setting has a default value */
export type notificationSettingsScopePrivateChats = {
  _: "notificationSettingsScopePrivateChats";
};

export type notificationSettingsScopePrivateChats$Input = {
  readonly _: "notificationSettingsScopePrivateChats";
};

/** Notification settings applied to all basic group and supergroup chats when the corresponding chat setting has a default value */
export type notificationSettingsScopeGroupChats = {
  _: "notificationSettingsScopeGroupChats";
};

export type notificationSettingsScopeGroupChats$Input = {
  readonly _: "notificationSettingsScopeGroupChats";
};

/** Notification settings applied to all channel chats when the corresponding chat setting has a default value */
export type notificationSettingsScopeChannelChats = {
  _: "notificationSettingsScopeChannelChats";
};

export type notificationSettingsScopeChannelChats$Input = {
  readonly _: "notificationSettingsScopeChannelChats";
};

/** Contains information about notification settings for a chat */
export type chatNotificationSettings = {
  _: "chatNotificationSettings";

  /**
   * If true, mute_for is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  use_default_mute_for: Bool;

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  mute_for: int32;

  /**
   * If true, the value for the relevant type of chat is used instead of sound_id
   * @type {Bool} {@link Bool}
   */
  use_default_sound: Bool;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  sound_id: int64;

  /**
   * If true, show_preview is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  use_default_show_preview: Bool;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_preview: Bool;

  /**
   * If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  use_default_disable_pinned_message_notifications: Bool;

  /**
   * If true, notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_pinned_message_notifications: Bool;

  /**
   * If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  use_default_disable_mention_notifications: Bool;

  /**
   * If true, notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_mention_notifications: Bool;
};

export type chatNotificationSettings$Input = {
  readonly _: "chatNotificationSettings";

  /**
   * If true, mute_for is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  readonly use_default_mute_for?: Bool$Input;

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  readonly mute_for?: int32;

  /**
   * If true, the value for the relevant type of chat is used instead of sound_id
   * @type {Bool} {@link Bool}
   */
  readonly use_default_sound?: Bool$Input;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly sound_id?: int64;

  /**
   * If true, show_preview is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  readonly use_default_show_preview?: Bool$Input;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_preview?: Bool$Input;

  /**
   * If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  readonly use_default_disable_pinned_message_notifications?: Bool$Input;

  /**
   * If true, notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_pinned_message_notifications?: Bool$Input;

  /**
   * If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead
   * @type {Bool} {@link Bool}
   */
  readonly use_default_disable_mention_notifications?: Bool$Input;

  /**
   * If true, notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_mention_notifications?: Bool$Input;
};

/** Contains information about notification settings for several chats */
export type scopeNotificationSettings = {
  _: "scopeNotificationSettings";

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  mute_for: int32;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  sound_id: int64;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_preview: Bool;

  /**
   * True, if notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_pinned_message_notifications: Bool;

  /**
   * True, if notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  disable_mention_notifications: Bool;
};

export type scopeNotificationSettings$Input = {
  readonly _: "scopeNotificationSettings";

  /**
   * Time left before notifications will be unmuted, in seconds
   * @type {int32} {@link int32}
   */
  readonly mute_for?: int32;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly sound_id?: int64;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_preview?: Bool$Input;

  /**
   * True, if notifications for incoming pinned messages will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_pinned_message_notifications?: Bool$Input;

  /**
   * True, if notifications for messages with mentions will be created as for an ordinary unread message
   * @type {Bool} {@link Bool}
   */
  readonly disable_mention_notifications?: Bool$Input;
};

/** Contains information about a message draft */
export type draftMessage = {
  _: "draftMessage";

  /**
   * Identifier of the replied message; 0 if none
   * @type {int53} {@link int53}
   */
  reply_to_message_id: int53;

  /**
   * Point in time (Unix timestamp) when the draft was created
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Content of the message draft; must be of the type inputMessageText
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_text: InputMessageContent;
};

export type draftMessage$Input = {
  readonly _: "draftMessage";

  /**
   * Identifier of the replied message; 0 if none
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;

  /**
   * Point in time (Unix timestamp) when the draft was created
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Content of the message draft; must be of the type inputMessageText
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_text?: InputMessageContent$Input;
};

/** An ordinary chat with a user */
export type chatTypePrivate = {
  _: "chatTypePrivate";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type chatTypePrivate$Input = {
  readonly _: "chatTypePrivate";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** A basic group (a chat with 0-200 other users) */
export type chatTypeBasicGroup = {
  _: "chatTypeBasicGroup";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  basic_group_id: int53;
};

export type chatTypeBasicGroup$Input = {
  readonly _: "chatTypeBasicGroup";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/** A supergroup or channel (with unlimited members) */
export type chatTypeSupergroup = {
  _: "chatTypeSupergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  is_channel: Bool;
};

export type chatTypeSupergroup$Input = {
  readonly _: "chatTypeSupergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * True, if the supergroup is a channel
   * @type {Bool} {@link Bool}
   */
  readonly is_channel?: Bool$Input;
};

/** A secret chat with a user */
export type chatTypeSecret = {
  _: "chatTypeSecret";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  secret_chat_id: int32;

  /**
   * User identifier of the secret chat peer
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type chatTypeSecret$Input = {
  readonly _: "chatTypeSecret";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;

  /**
   * User identifier of the secret chat peer
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** Represents a filter of user chats */
export type chatFilter = {
  _: "chatFilter";

  /**
   * The title of the filter; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The chosen icon name for short filter representation. If non-empty, must be one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette".
   *
   * -If empty, use getChatFilterDefaultIconName to get default icon name for the filter
   * @type {string} {@link string}
   */
  icon_name: string;

  /**
   * The chat identifiers of pinned chats in the filtered chat list. There can be up to GetOption("chat_filter_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  pinned_chat_ids: vector<int53>;

  /**
   * The chat identifiers of always included chats in the filtered chat list. There can be up to GetOption("chat_filter_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  included_chat_ids: vector<int53>;

  /**
   * The chat identifiers of always excluded chats in the filtered chat list. There can be up to GetOption("chat_filter_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  excluded_chat_ids: vector<int53>;

  /**
   * True, if muted chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  exclude_muted: Bool;

  /**
   * True, if read chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  exclude_read: Bool;

  /**
   * True, if archived chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  exclude_archived: Bool;

  /**
   * True, if contacts need to be included
   * @type {Bool} {@link Bool}
   */
  include_contacts: Bool;

  /**
   * True, if non-contact users need to be included
   * @type {Bool} {@link Bool}
   */
  include_non_contacts: Bool;

  /**
   * True, if bots need to be included
   * @type {Bool} {@link Bool}
   */
  include_bots: Bool;

  /**
   * True, if basic groups and supergroups need to be included
   * @type {Bool} {@link Bool}
   */
  include_groups: Bool;

  /**
   * True, if channels need to be included
   * @type {Bool} {@link Bool}
   */
  include_channels: Bool;
};

export type chatFilter$Input = {
  readonly _: "chatFilter";

  /**
   * The title of the filter; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The chosen icon name for short filter representation. If non-empty, must be one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette".
   *
   * -If empty, use getChatFilterDefaultIconName to get default icon name for the filter
   * @type {string} {@link string}
   */
  readonly icon_name?: string;

  /**
   * The chat identifiers of pinned chats in the filtered chat list. There can be up to GetOption("chat_filter_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly pinned_chat_ids?: vector$Input<int53>;

  /**
   * The chat identifiers of always included chats in the filtered chat list. There can be up to GetOption("chat_filter_chosen_chat_count_max") pinned and always included non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly included_chat_ids?: vector$Input<int53>;

  /**
   * The chat identifiers of always excluded chats in the filtered chat list. There can be up to GetOption("chat_filter_chosen_chat_count_max") always excluded non-secret chats and the same number of secret chats, but the limit can be increased with Telegram Premium
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly excluded_chat_ids?: vector$Input<int53>;

  /**
   * True, if muted chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  readonly exclude_muted?: Bool$Input;

  /**
   * True, if read chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  readonly exclude_read?: Bool$Input;

  /**
   * True, if archived chats need to be excluded
   * @type {Bool} {@link Bool}
   */
  readonly exclude_archived?: Bool$Input;

  /**
   * True, if contacts need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_contacts?: Bool$Input;

  /**
   * True, if non-contact users need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_non_contacts?: Bool$Input;

  /**
   * True, if bots need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_bots?: Bool$Input;

  /**
   * True, if basic groups and supergroups need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_groups?: Bool$Input;

  /**
   * True, if channels need to be included
   * @type {Bool} {@link Bool}
   */
  readonly include_channels?: Bool$Input;
};

/** Contains basic information about a chat filter */
export type chatFilterInfo = {
  _: "chatFilterInfo";

  /**
   * Unique chat filter identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * The title of the filter; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The chosen or default icon name for short filter representation. One of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
   * @type {string} {@link string}
   */
  icon_name: string;
};

export type chatFilterInfo$Input = {
  readonly _: "chatFilterInfo";

  /**
   * Unique chat filter identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * The title of the filter; 1-12 characters without line feeds
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The chosen or default icon name for short filter representation. One of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work", "Airplane", "Book", "Light", "Like", "Money", "Note", "Palette"
   * @type {string} {@link string}
   */
  readonly icon_name?: string;
};

/** Describes a recommended chat filter */
export type recommendedChatFilter = {
  _: "recommendedChatFilter";

  /**
   * The chat filter
   * @type {chatFilter} {@link chatFilter}
   */
  filter: chatFilter;

  /**
   * Describes a recommended chat filter
   * @type {string} {@link string}
   */
  description: string;
};

export type recommendedChatFilter$Input = {
  readonly _: "recommendedChatFilter";

  /**
   * The chat filter
   * @type {chatFilter} {@link chatFilter}
   */
  readonly filter?: chatFilter$Input;

  /**
   * Describes a recommended chat filter
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/** Contains a list of recommended chat filters */
export type recommendedChatFilters = {
  _: "recommendedChatFilters";

  /**
   * List of recommended chat filters
   * @type {vector<recommendedChatFilter>} {@link vector<recommendedChatFilter>}
   */
  chat_filters: vector<recommendedChatFilter>;
};

export type recommendedChatFilters$Input = {
  readonly _: "recommendedChatFilters";

  /**
   * List of recommended chat filters
   * @type {vector<recommendedChatFilter>} {@link vector<recommendedChatFilter>}
   */
  readonly chat_filters?: vector$Input<recommendedChatFilter$Input>;
};

/** A main list of chats */
export type chatListMain = {
  _: "chatListMain";
};

export type chatListMain$Input = {
  readonly _: "chatListMain";
};

/** A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives */
export type chatListArchive = {
  _: "chatListArchive";
};

export type chatListArchive$Input = {
  readonly _: "chatListArchive";
};

/** A list of chats belonging to a chat filter */
export type chatListFilter = {
  _: "chatListFilter";

  /**
   * Chat filter identifier
   * @type {int32} {@link int32}
   */
  chat_filter_id: int32;
};

export type chatListFilter$Input = {
  readonly _: "chatListFilter";

  /**
   * Chat filter identifier
   * @type {int32} {@link int32}
   */
  readonly chat_filter_id?: int32;
};

/** Contains a list of chat lists */
export type chatLists = {
  _: "chatLists";

  /**
   * List of chat lists
   * @type {vector<ChatList>} {@link vector<ChatList>}
   */
  chat_lists: vector<ChatList>;
};

export type chatLists$Input = {
  readonly _: "chatLists";

  /**
   * List of chat lists
   * @type {vector<ChatList>} {@link vector<ChatList>}
   */
  readonly chat_lists?: vector$Input<ChatList$Input>;
};

/** The chat is sponsored by the user's MTProxy server */
export type chatSourceMtprotoProxy = {
  _: "chatSourceMtprotoProxy";
};

export type chatSourceMtprotoProxy$Input = {
  readonly _: "chatSourceMtprotoProxy";
};

/** The chat contains a public service announcement */
export type chatSourcePublicServiceAnnouncement = {
  _: "chatSourcePublicServiceAnnouncement";

  /**
   * The type of the announcement
   * @type {string} {@link string}
   */
  type: string;

  /**
   * The text of the announcement
   * @type {string} {@link string}
   */
  text: string;
};

export type chatSourcePublicServiceAnnouncement$Input = {
  readonly _: "chatSourcePublicServiceAnnouncement";

  /**
   * The type of the announcement
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * The text of the announcement
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/** Describes a position of a chat in a chat list */
export type chatPosition = {
  _: "chatPosition";

  /**
   * The chat list
   * @type {ChatList} {@link ChatList}
   */
  list: ChatList;

  /**
   * A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
   * @type {int64} {@link int64}
   */
  order: int64;

  /**
   * True, if the chat is pinned in the chat list
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * Source of the chat in the chat list; may be null
   * @type {ChatSource} {@link ChatSource}
   */
  source: ChatSource;
};

export type chatPosition$Input = {
  readonly _: "chatPosition";

  /**
   * The chat list
   * @type {ChatList} {@link ChatList}
   */
  readonly list?: ChatList$Input;

  /**
   * A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
   * @type {int64} {@link int64}
   */
  readonly order?: int64;

  /**
   * True, if the chat is pinned in the chat list
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * Source of the chat in the chat list; may be null
   * @type {ChatSource} {@link ChatSource}
   */
  readonly source?: ChatSource$Input;
};

/** All reactions are available in the chat */
export type chatAvailableReactionsAll = {
  _: "chatAvailableReactionsAll";
};

export type chatAvailableReactionsAll$Input = {
  readonly _: "chatAvailableReactionsAll";
};

/** Only specific reactions are available in the chat */
export type chatAvailableReactionsSome = {
  _: "chatAvailableReactionsSome";

  /**
   * The list of reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  reactions: vector<ReactionType>;
};

export type chatAvailableReactionsSome$Input = {
  readonly _: "chatAvailableReactionsSome";

  /**
   * The list of reactions
   * @type {vector<ReactionType>} {@link vector<ReactionType>}
   */
  readonly reactions?: vector$Input<ReactionType$Input>;
};

/** Describes a video chat */
export type videoChat = {
  _: "videoChat";

  /**
   * Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * True, if the video chat has participants
   * @type {Bool} {@link Bool}
   */
  has_participants: Bool;

  /**
   * Default group call participant identifier to join the video chat; may be null
   * @type {MessageSender} {@link MessageSender}
   */
  default_participant_id: MessageSender;
};

export type videoChat$Input = {
  readonly _: "videoChat";

  /**
   * Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * True, if the video chat has participants
   * @type {Bool} {@link Bool}
   */
  readonly has_participants?: Bool$Input;

  /**
   * Default group call participant identifier to join the video chat; may be null
   * @type {MessageSender} {@link MessageSender}
   */
  readonly default_participant_id?: MessageSender$Input;
};

/** A chat. (Can be a private chat, basic group, supergroup, or secret chat) */
export type chat = {
  _: "chat";

  /**
   * Chat unique identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * Type of the chat
   * @type {ChatType} {@link ChatType}
   */
  type: ChatType;

  /**
   * Chat title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo;

  /**
   * Actions that non-administrator chat members are allowed to take in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  permissions: chatPermissions;

  /**
   * Last message in the chat; may be null
   * @type {message} {@link message}
   */
  last_message: message;

  /**
   * Positions of the chat in chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  positions: vector<chatPosition>;

  /**
   * Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  message_sender_id: MessageSender;

  /**
   * True, if chat content can't be saved locally, forwarded, or copied
   * @type {Bool} {@link Bool}
   */
  has_protected_content: Bool;

  /**
   * True, if the chat is marked as unread
   * @type {Bool} {@link Bool}
   */
  is_marked_as_unread: Bool;

  /**
   * True, if the chat is blocked by the current user and private messages from the chat can't be received
   * @type {Bool} {@link Bool}
   */
  is_blocked: Bool;

  /**
   * True, if the chat has scheduled messages
   * @type {Bool} {@link Bool}
   */
  has_scheduled_messages: Bool;

  /**
   * True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_only_for_self: Bool;

  /**
   * True, if the chat messages can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  can_be_deleted_for_all_users: Bool;

  /**
   * True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
   * @type {Bool} {@link Bool}
   */
  can_be_reported: Bool;

  /**
   * Default value of the disable_notification parameter, used when a message is sent to the chat
   * @type {Bool} {@link Bool}
   */
  default_disable_notification: Bool;

  /**
   * Number of unread messages in the chat
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;

  /**
   * Number of unread messages with a mention/reply in the chat
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;

  /**
   * Number of messages with unread reactions in the chat
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;

  /**
   * Notification settings for the chat
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  notification_settings: chatNotificationSettings;

  /**
   * Types of reaction, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  available_reactions: ChatAvailableReactions;

  /**
   * Current message Time To Live setting (self-destruct timer) for the chat; 0 if not defined. TTL is counted from the time message or its content is viewed in secret chats and from the send date in other chats
   * @type {int32} {@link int32}
   */
  message_ttl: int32;

  /**
   * If non-empty, name of a theme, set for the chat
   * @type {string} {@link string}
   */
  theme_name: string;

  /**
   * Information about actions which must be possible to do through the chat action bar; may be null
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  action_bar: ChatActionBar;

  /**
   * Information about video chat of the chat
   * @type {videoChat} {@link videoChat}
   */
  video_chat: videoChat;

  /**
   * Information about pending join requests; may be null
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  pending_join_requests: chatJoinRequestsInfo;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  reply_markup_message_id: int53;

  /**
   * A draft of a message in the chat; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage;

  /**
   * Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
   * @type {string} {@link string}
   */
  client_data: string;
};

export type chat$Input = {
  readonly _: "chat";

  /**
   * Chat unique identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * Type of the chat
   * @type {ChatType} {@link ChatType}
   */
  readonly type?: ChatType$Input;

  /**
   * Chat title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input;

  /**
   * Actions that non-administrator chat members are allowed to take in the chat
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;

  /**
   * Last message in the chat; may be null
   * @type {message} {@link message}
   */
  readonly last_message?: message$Input;

  /**
   * Positions of the chat in chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  readonly positions?: vector$Input<chatPosition$Input>;

  /**
   * Identifier of a user or chat that is selected to send messages in the chat; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input;

  /**
   * True, if chat content can't be saved locally, forwarded, or copied
   * @type {Bool} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;

  /**
   * True, if the chat is marked as unread
   * @type {Bool} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;

  /**
   * True, if the chat is blocked by the current user and private messages from the chat can't be received
   * @type {Bool} {@link Bool}
   */
  readonly is_blocked?: Bool$Input;

  /**
   * True, if the chat has scheduled messages
   * @type {Bool} {@link Bool}
   */
  readonly has_scheduled_messages?: Bool$Input;

  /**
   * True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_only_for_self?: Bool$Input;

  /**
   * True, if the chat messages can be deleted for all users
   * @type {Bool} {@link Bool}
   */
  readonly can_be_deleted_for_all_users?: Bool$Input;

  /**
   * True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
   * @type {Bool} {@link Bool}
   */
  readonly can_be_reported?: Bool$Input;

  /**
   * Default value of the disable_notification parameter, used when a message is sent to the chat
   * @type {Bool} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;

  /**
   * Number of unread messages in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;

  /**
   * Number of unread messages with a mention/reply in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;

  /**
   * Number of messages with unread reactions in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;

  /**
   * Notification settings for the chat
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;

  /**
   * Types of reaction, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;

  /**
   * Current message Time To Live setting (self-destruct timer) for the chat; 0 if not defined. TTL is counted from the time message or its content is viewed in secret chats and from the send date in other chats
   * @type {int32} {@link int32}
   */
  readonly message_ttl?: int32;

  /**
   * If non-empty, name of a theme, set for the chat
   * @type {string} {@link string}
   */
  readonly theme_name?: string;

  /**
   * Information about actions which must be possible to do through the chat action bar; may be null
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  readonly action_bar?: ChatActionBar$Input;

  /**
   * Information about video chat of the chat
   * @type {videoChat} {@link videoChat}
   */
  readonly video_chat?: videoChat$Input;

  /**
   * Information about pending join requests; may be null
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  readonly pending_join_requests?: chatJoinRequestsInfo$Input;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  readonly reply_markup_message_id?: int53;

  /**
   * A draft of a message in the chat; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input;

  /**
   * Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
   * @type {string} {@link string}
   */
  readonly client_data?: string;
};

/** Represents a list of chats */
export type chats = {
  _: "chats";

  /**
   * Approximate total number of chats found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of chat identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

export type chats$Input = {
  readonly _: "chats";

  /**
   * Approximate total number of chats found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of chat identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/** Describes a chat located nearby */
export type chatNearby = {
  _: "chatNearby";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Distance to the chat location, in meters
   * @type {int32} {@link int32}
   */
  distance: int32;
};

export type chatNearby$Input = {
  readonly _: "chatNearby";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Distance to the chat location, in meters
   * @type {int32} {@link int32}
   */
  readonly distance?: int32;
};

/** Represents a list of chats located nearby */
export type chatsNearby = {
  _: "chatsNearby";

  /**
   * List of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  users_nearby: vector<chatNearby>;

  /**
   * List of location-based supergroups nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  supergroups_nearby: vector<chatNearby>;
};

export type chatsNearby$Input = {
  readonly _: "chatsNearby";

  /**
   * List of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  readonly users_nearby?: vector$Input<chatNearby$Input>;

  /**
   * List of location-based supergroups nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  readonly supergroups_nearby?: vector$Input<chatNearby$Input>;
};

/** The chat is public, because it has an active username */
export type publicChatTypeHasUsername = {
  _: "publicChatTypeHasUsername";
};

export type publicChatTypeHasUsername$Input = {
  readonly _: "publicChatTypeHasUsername";
};

/** The chat is public, because it is a location-based supergroup */
export type publicChatTypeIsLocationBased = {
  _: "publicChatTypeIsLocationBased";
};

export type publicChatTypeIsLocationBased$Input = {
  readonly _: "publicChatTypeIsLocationBased";
};

/** The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown */
export type chatActionBarReportSpam = {
  _: "chatActionBarReportSpam";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  can_unarchive: Bool;
};

export type chatActionBarReportSpam$Input = {
  readonly _: "chatActionBarReportSpam";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  readonly can_unarchive?: Bool$Input;
};

/** The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason chatReportReasonUnrelatedLocation */
export type chatActionBarReportUnrelatedLocation = {
  _: "chatActionBarReportUnrelatedLocation";
};

export type chatActionBarReportUnrelatedLocation$Input = {
  readonly _: "chatActionBarReportUnrelatedLocation";
};

/** The chat is a recently created group chat to which new members can be invited */
export type chatActionBarInviteMembers = {
  _: "chatActionBarInviteMembers";
};

export type chatActionBarInviteMembers$Input = {
  readonly _: "chatActionBarInviteMembers";
};

/** The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method toggleMessageSenderIsBlocked, or the other user can be added to the contact list using the method addContact. If the chat is a private chat with a user with an emoji status, then a notice about emoji status usage must be shown */
export type chatActionBarReportAddBlock = {
  _: "chatActionBarReportAddBlock";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  can_unarchive: Bool;

  /**
   * If non-negative, the current user was found by the peer through searchChatsNearby and this is the distance between the users
   * @type {int32} {@link int32}
   */
  distance: int32;
};

export type chatActionBarReportAddBlock$Input = {
  readonly _: "chatActionBarReportAddBlock";

  /**
   * If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
   * @type {Bool} {@link Bool}
   */
  readonly can_unarchive?: Bool$Input;

  /**
   * If non-negative, the current user was found by the peer through searchChatsNearby and this is the distance between the users
   * @type {int32} {@link int32}
   */
  readonly distance?: int32;
};

/** The chat is a private or secret chat and the other user can be added to the contact list using the method addContact */
export type chatActionBarAddContact = {
  _: "chatActionBarAddContact";
};

export type chatActionBarAddContact$Input = {
  readonly _: "chatActionBarAddContact";
};

/** The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber */
export type chatActionBarSharePhoneNumber = {
  _: "chatActionBarSharePhoneNumber";
};

export type chatActionBarSharePhoneNumber$Input = {
  readonly _: "chatActionBarSharePhoneNumber";
};

/** The chat is a private chat with an administrator of a chat to which the user sent join request */
export type chatActionBarJoinRequest = {
  _: "chatActionBarJoinRequest";

  /**
   * Title of the chat to which the join request was sent
   * @type {string} {@link string}
   */
  title: string;

  /**
   * True, if the join request was sent to a channel chat
   * @type {Bool} {@link Bool}
   */
  is_channel: Bool;

  /**
   * Point in time (Unix timestamp) when the join request was sent
   * @type {int32} {@link int32}
   */
  request_date: int32;
};

export type chatActionBarJoinRequest$Input = {
  readonly _: "chatActionBarJoinRequest";

  /**
   * Title of the chat to which the join request was sent
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * True, if the join request was sent to a channel chat
   * @type {Bool} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * Point in time (Unix timestamp) when the join request was sent
   * @type {int32} {@link int32}
   */
  readonly request_date?: int32;
};

/** A simple button, with text that must be sent when the button is pressed */
export type keyboardButtonTypeText = {
  _: "keyboardButtonTypeText";
};

export type keyboardButtonTypeText$Input = {
  readonly _: "keyboardButtonTypeText";
};

/** A button that sends the user's phone number when pressed; available only in private chats */
export type keyboardButtonTypeRequestPhoneNumber = {
  _: "keyboardButtonTypeRequestPhoneNumber";
};

export type keyboardButtonTypeRequestPhoneNumber$Input = {
  readonly _: "keyboardButtonTypeRequestPhoneNumber";
};

/** A button that sends the user's location when pressed; available only in private chats */
export type keyboardButtonTypeRequestLocation = {
  _: "keyboardButtonTypeRequestLocation";
};

export type keyboardButtonTypeRequestLocation$Input = {
  readonly _: "keyboardButtonTypeRequestLocation";
};

/** A button that allows the user to create and send a poll when pressed; available only in private chats */
export type keyboardButtonTypeRequestPoll = {
  _: "keyboardButtonTypeRequestPoll";

  /**
   * If true, only regular polls must be allowed to create
   * @type {Bool} {@link Bool}
   */
  force_regular: Bool;

  /**
   * If true, only polls in quiz mode must be allowed to create
   * @type {Bool} {@link Bool}
   */
  force_quiz: Bool;
};

export type keyboardButtonTypeRequestPoll$Input = {
  readonly _: "keyboardButtonTypeRequestPoll";

  /**
   * If true, only regular polls must be allowed to create
   * @type {Bool} {@link Bool}
   */
  readonly force_regular?: Bool$Input;

  /**
   * If true, only polls in quiz mode must be allowed to create
   * @type {Bool} {@link Bool}
   */
  readonly force_quiz?: Bool$Input;
};

/** A button that opens a Web App by calling getWebAppUrl */
export type keyboardButtonTypeWebApp = {
  _: "keyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to getWebAppUrl
   * @type {string} {@link string}
   */
  url: string;
};

export type keyboardButtonTypeWebApp$Input = {
  readonly _: "keyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to getWebAppUrl
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Represents a single button in a bot keyboard */
export type keyboardButton = {
  _: "keyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Type of the button
   * @type {KeyboardButtonType} {@link KeyboardButtonType}
   */
  type: KeyboardButtonType;
};

export type keyboardButton$Input = {
  readonly _: "keyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Type of the button
   * @type {KeyboardButtonType} {@link KeyboardButtonType}
   */
  readonly type?: KeyboardButtonType$Input;
};

/** A button that opens a specified URL */
export type inlineKeyboardButtonTypeUrl = {
  _: "inlineKeyboardButtonTypeUrl";

  /**
   * HTTP or tg:// URL to open
   * @type {string} {@link string}
   */
  url: string;
};

export type inlineKeyboardButtonTypeUrl$Input = {
  readonly _: "inlineKeyboardButtonTypeUrl";

  /**
   * HTTP or tg:// URL to open
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** A button that opens a specified URL and automatically authorize the current user by calling getLoginUrlInfo */
export type inlineKeyboardButtonTypeLoginUrl = {
  _: "inlineKeyboardButtonTypeLoginUrl";

  /**
   * An HTTP URL to pass to getLoginUrlInfo
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Unique button identifier
   * @type {int53} {@link int53}
   */
  id: int53;

  /**
   * If non-empty, new text of the button in forwarded messages
   * @type {string} {@link string}
   */
  forward_text: string;
};

export type inlineKeyboardButtonTypeLoginUrl$Input = {
  readonly _: "inlineKeyboardButtonTypeLoginUrl";

  /**
   * An HTTP URL to pass to getLoginUrlInfo
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Unique button identifier
   * @type {int53} {@link int53}
   */
  readonly id?: int53;

  /**
   * If non-empty, new text of the button in forwarded messages
   * @type {string} {@link string}
   */
  readonly forward_text?: string;
};

/** A button that opens a Web App by calling openWebApp */
export type inlineKeyboardButtonTypeWebApp = {
  _: "inlineKeyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to openWebApp
   * @type {string} {@link string}
   */
  url: string;
};

export type inlineKeyboardButtonTypeWebApp$Input = {
  readonly _: "inlineKeyboardButtonTypeWebApp";

  /**
   * An HTTP URL to pass to openWebApp
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** A button that sends a callback query to a bot */
export type inlineKeyboardButtonTypeCallback = {
  _: "inlineKeyboardButtonTypeCallback";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type inlineKeyboardButtonTypeCallback$Input = {
  readonly _: "inlineKeyboardButtonTypeCallback";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** A button that asks for the 2-step verification password of the current user and then sends a callback query to a bot */
export type inlineKeyboardButtonTypeCallbackWithPassword = {
  _: "inlineKeyboardButtonTypeCallbackWithPassword";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type inlineKeyboardButtonTypeCallbackWithPassword$Input = {
  readonly _: "inlineKeyboardButtonTypeCallbackWithPassword";

  /**
   * Data to be sent to the bot via a callback query
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame */
export type inlineKeyboardButtonTypeCallbackGame = {
  _: "inlineKeyboardButtonTypeCallbackGame";
};

export type inlineKeyboardButtonTypeCallbackGame$Input = {
  readonly _: "inlineKeyboardButtonTypeCallbackGame";
};

/** A button that forces an inline query to the bot to be inserted in the input field */
export type inlineKeyboardButtonTypeSwitchInline = {
  _: "inlineKeyboardButtonTypeSwitchInline";

  /**
   * Inline query to be sent to the bot
   * @type {string} {@link string}
   */
  query: string;

  /**
   * True, if the inline query must be sent from the current chat
   * @type {Bool} {@link Bool}
   */
  in_current_chat: Bool;
};

export type inlineKeyboardButtonTypeSwitchInline$Input = {
  readonly _: "inlineKeyboardButtonTypeSwitchInline";

  /**
   * Inline query to be sent to the bot
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * True, if the inline query must be sent from the current chat
   * @type {Bool} {@link Bool}
   */
  readonly in_current_chat?: Bool$Input;
};

/** A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice */
export type inlineKeyboardButtonTypeBuy = {
  _: "inlineKeyboardButtonTypeBuy";
};

export type inlineKeyboardButtonTypeBuy$Input = {
  readonly _: "inlineKeyboardButtonTypeBuy";
};

/** A button with a user reference to be handled in the same way as textEntityTypeMentionName entities */
export type inlineKeyboardButtonTypeUser = {
  _: "inlineKeyboardButtonTypeUser";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type inlineKeyboardButtonTypeUser$Input = {
  readonly _: "inlineKeyboardButtonTypeUser";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** Represents a single button in an inline keyboard */
export type inlineKeyboardButton = {
  _: "inlineKeyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  text: string;

  /**
   * Type of the button
   * @type {InlineKeyboardButtonType} {@link InlineKeyboardButtonType}
   */
  type: InlineKeyboardButtonType;
};

export type inlineKeyboardButton$Input = {
  readonly _: "inlineKeyboardButton";

  /**
   * Text of the button
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Type of the button
   * @type {InlineKeyboardButtonType} {@link InlineKeyboardButtonType}
   */
  readonly type?: InlineKeyboardButtonType$Input;
};

/** Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent */
export type replyMarkupRemoveKeyboard = {
  _: "replyMarkupRemoveKeyboard";

  /**
   * True, if the keyboard is removed only for the mentioned users or the target user of a reply
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;
};

export type replyMarkupRemoveKeyboard$Input = {
  readonly _: "replyMarkupRemoveKeyboard";

  /**
   * True, if the keyboard is removed only for the mentioned users or the target user of a reply
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;
};

/** Instructs application to force a reply to this message */
export type replyMarkupForceReply = {
  _: "replyMarkupForceReply";

  /**
   * True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;

  /**
   * If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
   * @type {string} {@link string}
   */
  input_field_placeholder: string;
};

export type replyMarkupForceReply$Input = {
  readonly _: "replyMarkupForceReply";

  /**
   * True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
   * @type {string} {@link string}
   */
  readonly input_field_placeholder?: string;
};

/** Contains a custom keyboard layout to quickly reply to bots */
export type replyMarkupShowKeyboard = {
  _: "replyMarkupShowKeyboard";

  /**
   * A list of rows of bot keyboard buttons
   * @type {vector<vector<keyboardButton>>} {@link vector<vector<keyboardButton>>}
   */
  rows: vector<vector<keyboardButton>>;

  /**
   * True, if the application needs to resize the keyboard vertically
   * @type {Bool} {@link Bool}
   */
  resize_keyboard: Bool;

  /**
   * True, if the application needs to hide the keyboard after use
   * @type {Bool} {@link Bool}
   */
  one_time: Bool;

  /**
   * True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  is_personal: Bool;

  /**
   * If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
   * @type {string} {@link string}
   */
  input_field_placeholder: string;
};

export type replyMarkupShowKeyboard$Input = {
  readonly _: "replyMarkupShowKeyboard";

  /**
   * A list of rows of bot keyboard buttons
   * @type {vector<vector<keyboardButton>>} {@link vector<vector<keyboardButton>>}
   */
  readonly rows?: vector$Input<vector$Input<keyboardButton$Input>>;

  /**
   * True, if the application needs to resize the keyboard vertically
   * @type {Bool} {@link Bool}
   */
  readonly resize_keyboard?: Bool$Input;

  /**
   * True, if the application needs to hide the keyboard after use
   * @type {Bool} {@link Bool}
   */
  readonly one_time?: Bool$Input;

  /**
   * True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
   * @type {Bool} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
   * @type {string} {@link string}
   */
  readonly input_field_placeholder?: string;
};

/** Contains an inline keyboard layout */
export type replyMarkupInlineKeyboard = {
  _: "replyMarkupInlineKeyboard";

  /**
   * A list of rows of inline keyboard buttons
   * @type {vector<vector<inlineKeyboardButton>>} {@link vector<vector<inlineKeyboardButton>>}
   */
  rows: vector<vector<inlineKeyboardButton>>;
};

export type replyMarkupInlineKeyboard$Input = {
  readonly _: "replyMarkupInlineKeyboard";

  /**
   * A list of rows of inline keyboard buttons
   * @type {vector<vector<inlineKeyboardButton>>} {@link vector<vector<inlineKeyboardButton>>}
   */
  readonly rows?: vector$Input<vector$Input<inlineKeyboardButton$Input>>;
};

/** An HTTP url needs to be open */
export type loginUrlInfoOpen = {
  _: "loginUrlInfoOpen";

  /**
   * The URL to open
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if there is no need to show an ordinary open URL confirm
   * @type {Bool} {@link Bool}
   */
  skip_confirm: Bool;
};

export type loginUrlInfoOpen$Input = {
  readonly _: "loginUrlInfoOpen";

  /**
   * The URL to open
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if there is no need to show an ordinary open URL confirm
   * @type {Bool} {@link Bool}
   */
  readonly skip_confirm?: Bool$Input;
};

/** An authorization confirmation dialog needs to be shown to the user */
export type loginUrlInfoRequestConfirmation = {
  _: "loginUrlInfoRequestConfirmation";

  /**
   * An HTTP URL to be opened
   * @type {string} {@link string}
   */
  url: string;

  /**
   * A domain of the URL
   * @type {string} {@link string}
   */
  domain: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * True, if the user needs to be requested to give the permission to the bot to send them messages
   * @type {Bool} {@link Bool}
   */
  request_write_access: Bool;
};

export type loginUrlInfoRequestConfirmation$Input = {
  readonly _: "loginUrlInfoRequestConfirmation";

  /**
   * An HTTP URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * A domain of the URL
   * @type {string} {@link string}
   */
  readonly domain?: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * True, if the user needs to be requested to give the permission to the bot to send them messages
   * @type {Bool} {@link Bool}
   */
  readonly request_write_access?: Bool$Input;
};

/** Contains information about a Web App */
export type webAppInfo = {
  _: "webAppInfo";

  /**
   * Unique identifier for the Web App launch
   * @type {int64} {@link int64}
   */
  launch_id: int64;

  /**
   * A Web App URL to open in a web view
   * @type {string} {@link string}
   */
  url: string;
};

export type webAppInfo$Input = {
  readonly _: "webAppInfo";

  /**
   * Unique identifier for the Web App launch
   * @type {int64} {@link int64}
   */
  readonly launch_id?: int64;

  /**
   * A Web App URL to open in a web view
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Contains information about a message thread */
export type messageThreadInfo = {
  _: "messageThreadInfo";

  /**
   * Identifier of the chat to which the message thread belongs
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message thread identifier, unique within the chat
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * Information about the message thread; may be null for forum topic threads
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  reply_info: messageReplyInfo;

  /**
   * Approximate number of unread messages in the message thread
   * @type {int32} {@link int32}
   */
  unread_message_count: int32;

  /**
   * The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
   * @type {vector<message>} {@link vector<message>}
   */
  messages: vector<message>;

  /**
   * A draft of a message in the message thread; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage;
};

export type messageThreadInfo$Input = {
  readonly _: "messageThreadInfo";

  /**
   * Identifier of the chat to which the message thread belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier, unique within the chat
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Information about the message thread; may be null for forum topic threads
   * @type {messageReplyInfo} {@link messageReplyInfo}
   */
  readonly reply_info?: messageReplyInfo$Input;

  /**
   * Approximate number of unread messages in the message thread
   * @type {int32} {@link int32}
   */
  readonly unread_message_count?: int32;

  /**
   * The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
   * @type {vector<message>} {@link vector<message>}
   */
  readonly messages?: vector$Input<message$Input>;

  /**
   * A draft of a message in the message thread; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input;
};

/** Describes a forum topic icon */
export type forumTopicIcon = {
  _: "forumTopicIcon";

  /**
   * Color of the topic icon in RGB format
   * @type {int32} {@link int32}
   */
  color: int32;

  /**
   * Unique identifier of the custom emoji shown on the topic icon; 0 if none
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

export type forumTopicIcon$Input = {
  readonly _: "forumTopicIcon";

  /**
   * Color of the topic icon in RGB format
   * @type {int32} {@link int32}
   */
  readonly color?: int32;

  /**
   * Unique identifier of the custom emoji shown on the topic icon; 0 if none
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64;
};

/** Contains basic information about a forum topic */
export type forumTopicInfo = {
  _: "forumTopicInfo";

  /**
   * Message thread identifier of the topic
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  icon: forumTopicIcon;

  /**
   * Date the topic was created
   * @type {int32} {@link int32}
   */
  creation_date: int32;

  /**
   * Identifier of the creator of the topic
   * @type {MessageSender} {@link MessageSender}
   */
  creator_id: MessageSender;

  /**
   * True, if the topic was created by the current user
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * True, if the topic is closed
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

export type forumTopicInfo$Input = {
  readonly _: "forumTopicInfo";

  /**
   * Message thread identifier of the topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;

  /**
   * Date the topic was created
   * @type {int32} {@link int32}
   */
  readonly creation_date?: int32;

  /**
   * Identifier of the creator of the topic
   * @type {MessageSender} {@link MessageSender}
   */
  readonly creator_id?: MessageSender$Input;

  /**
   * True, if the topic was created by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * True, if the topic is closed
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/** Describes a forum topic */
export type forumTopic = {
  _: "forumTopic";

  /**
   * Basic information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  info: forumTopicInfo;

  /**
   * Last message in the topic; may be null
   * @type {message} {@link message}
   */
  last_message: message;

  /**
   * True, if the topic is pinned in the topic list
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;

  /**
   * Number of unread messages in the topic
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;

  /**
   * Number of unread messages with a mention/reply in the topic
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;

  /**
   * Number of messages with unread reactions in the topic
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;

  /**
   * Notification settings for the topic
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  notification_settings: chatNotificationSettings;

  /**
   * A draft of a message in the topic; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage;
};

export type forumTopic$Input = {
  readonly _: "forumTopic";

  /**
   * Basic information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly info?: forumTopicInfo$Input;

  /**
   * Last message in the topic; may be null
   * @type {message} {@link message}
   */
  readonly last_message?: message$Input;

  /**
   * True, if the topic is pinned in the topic list
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;

  /**
   * Number of unread messages in the topic
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * Identifier of the last read outgoing message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;

  /**
   * Number of unread messages with a mention/reply in the topic
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;

  /**
   * Number of messages with unread reactions in the topic
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;

  /**
   * Notification settings for the topic
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;

  /**
   * A draft of a message in the topic; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input;
};

/** A plain text */
export type richTextPlain = {
  _: "richTextPlain";

  /**
   * Text
   * @type {string} {@link string}
   */
  text: string;
};

export type richTextPlain$Input = {
  readonly _: "richTextPlain";

  /**
   * Text
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/** A bold rich text */
export type richTextBold = {
  _: "richTextBold";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextBold$Input = {
  readonly _: "richTextBold";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** An italicized rich text */
export type richTextItalic = {
  _: "richTextItalic";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextItalic$Input = {
  readonly _: "richTextItalic";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** An underlined rich text */
export type richTextUnderline = {
  _: "richTextUnderline";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextUnderline$Input = {
  readonly _: "richTextUnderline";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A strikethrough rich text */
export type richTextStrikethrough = {
  _: "richTextStrikethrough";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextStrikethrough$Input = {
  readonly _: "richTextStrikethrough";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A fixed-width rich text */
export type richTextFixed = {
  _: "richTextFixed";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextFixed$Input = {
  readonly _: "richTextFixed";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A rich text URL link */
export type richTextUrl = {
  _: "richTextUrl";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if the URL has cached instant view server-side
   * @type {Bool} {@link Bool}
   */
  is_cached: Bool;
};

export type richTextUrl$Input = {
  readonly _: "richTextUrl";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if the URL has cached instant view server-side
   * @type {Bool} {@link Bool}
   */
  readonly is_cached?: Bool$Input;
};

/** A rich text email link */
export type richTextEmailAddress = {
  _: "richTextEmailAddress";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Email address
   * @type {string} {@link string}
   */
  email_address: string;
};

export type richTextEmailAddress$Input = {
  readonly _: "richTextEmailAddress";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/** A subscript rich text */
export type richTextSubscript = {
  _: "richTextSubscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextSubscript$Input = {
  readonly _: "richTextSubscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A superscript rich text */
export type richTextSuperscript = {
  _: "richTextSuperscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextSuperscript$Input = {
  readonly _: "richTextSuperscript";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A marked rich text */
export type richTextMarked = {
  _: "richTextMarked";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type richTextMarked$Input = {
  readonly _: "richTextMarked";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A rich text phone number */
export type richTextPhoneNumber = {
  _: "richTextPhoneNumber";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Phone number
   * @type {string} {@link string}
   */
  phone_number: string;
};

export type richTextPhoneNumber$Input = {
  readonly _: "richTextPhoneNumber";

  /**
   * Text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Phone number
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/** A small image inside the text */
export type richTextIcon = {
  _: "richTextIcon";

  /**
   * The image represented as a document. The image can be in GIF, JPEG or PNG format
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Width of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Height of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;
};

export type richTextIcon$Input = {
  readonly _: "richTextIcon";

  /**
   * The image represented as a document. The image can be in GIF, JPEG or PNG format
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Width of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Height of a bounding box in which the image must be shown; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;
};

/** A reference to a richTexts object on the same web page */
export type richTextReference = {
  _: "richTextReference";

  /**
   * The text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * The name of a richTextAnchor object, which is the first element of the target richTexts object
   * @type {string} {@link string}
   */
  anchor_name: string;

  /**
   * An HTTP URL, opening the reference
   * @type {string} {@link string}
   */
  url: string;
};

export type richTextReference$Input = {
  readonly _: "richTextReference";

  /**
   * The text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * The name of a richTextAnchor object, which is the first element of the target richTexts object
   * @type {string} {@link string}
   */
  readonly anchor_name?: string;

  /**
   * An HTTP URL, opening the reference
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** An anchor */
export type richTextAnchor = {
  _: "richTextAnchor";

  /**
   * Anchor name
   * @type {string} {@link string}
   */
  name: string;
};

export type richTextAnchor$Input = {
  readonly _: "richTextAnchor";

  /**
   * Anchor name
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/** A link to an anchor on the same web page */
export type richTextAnchorLink = {
  _: "richTextAnchorLink";

  /**
   * The link text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * The anchor name. If the name is empty, the link must bring back to top
   * @type {string} {@link string}
   */
  anchor_name: string;

  /**
   * An HTTP URL, opening the anchor
   * @type {string} {@link string}
   */
  url: string;
};

export type richTextAnchorLink$Input = {
  readonly _: "richTextAnchorLink";

  /**
   * The link text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * The anchor name. If the name is empty, the link must bring back to top
   * @type {string} {@link string}
   */
  readonly anchor_name?: string;

  /**
   * An HTTP URL, opening the anchor
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** A concatenation of rich texts */
export type richTexts = {
  _: "richTexts";

  /**
   * Texts
   * @type {vector<RichText>} {@link vector<RichText>}
   */
  texts: vector<RichText>;
};

export type richTexts$Input = {
  readonly _: "richTexts";

  /**
   * Texts
   * @type {vector<RichText>} {@link vector<RichText>}
   */
  readonly texts?: vector$Input<RichText$Input>;
};

/** Contains a caption of an instant view web page block, consisting of a text and a trailing credit */
export type pageBlockCaption = {
  _: "pageBlockCaption";

  /**
   * Content of the caption
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Block credit (like HTML tag <cite>)
   * @type {RichText} {@link RichText}
   */
  credit: RichText;
};

export type pageBlockCaption$Input = {
  readonly _: "pageBlockCaption";

  /**
   * Content of the caption
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Block credit (like HTML tag <cite>)
   * @type {RichText} {@link RichText}
   */
  readonly credit?: RichText$Input;
};

/** Describes an item of a list page block */
export type pageBlockListItem = {
  _: "pageBlockListItem";

  /**
   * Item label
   * @type {string} {@link string}
   */
  label: string;

  /**
   * Item blocks
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;
};

export type pageBlockListItem$Input = {
  readonly _: "pageBlockListItem";

  /**
   * Item label
   * @type {string} {@link string}
   */
  readonly label?: string;

  /**
   * Item blocks
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;
};

/** The content must be left-aligned */
export type pageBlockHorizontalAlignmentLeft = {
  _: "pageBlockHorizontalAlignmentLeft";
};

export type pageBlockHorizontalAlignmentLeft$Input = {
  readonly _: "pageBlockHorizontalAlignmentLeft";
};

/** The content must be center-aligned */
export type pageBlockHorizontalAlignmentCenter = {
  _: "pageBlockHorizontalAlignmentCenter";
};

export type pageBlockHorizontalAlignmentCenter$Input = {
  readonly _: "pageBlockHorizontalAlignmentCenter";
};

/** The content must be right-aligned */
export type pageBlockHorizontalAlignmentRight = {
  _: "pageBlockHorizontalAlignmentRight";
};

export type pageBlockHorizontalAlignmentRight$Input = {
  readonly _: "pageBlockHorizontalAlignmentRight";
};

/** The content must be top-aligned */
export type pageBlockVerticalAlignmentTop = {
  _: "pageBlockVerticalAlignmentTop";
};

export type pageBlockVerticalAlignmentTop$Input = {
  readonly _: "pageBlockVerticalAlignmentTop";
};

/** The content must be middle-aligned */
export type pageBlockVerticalAlignmentMiddle = {
  _: "pageBlockVerticalAlignmentMiddle";
};

export type pageBlockVerticalAlignmentMiddle$Input = {
  readonly _: "pageBlockVerticalAlignmentMiddle";
};

/** The content must be bottom-aligned */
export type pageBlockVerticalAlignmentBottom = {
  _: "pageBlockVerticalAlignmentBottom";
};

export type pageBlockVerticalAlignmentBottom$Input = {
  readonly _: "pageBlockVerticalAlignmentBottom";
};

/** Represents a cell of a table */
export type pageBlockTableCell = {
  _: "pageBlockTableCell";

  /**
   * Cell text; may be null. If the text is null, then the cell must be invisible
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * True, if it is a header cell
   * @type {Bool} {@link Bool}
   */
  is_header: Bool;

  /**
   * The number of columns the cell spans
   * @type {int32} {@link int32}
   */
  colspan: int32;

  /**
   * The number of rows the cell spans
   * @type {int32} {@link int32}
   */
  rowspan: int32;

  /**
   * Horizontal cell content alignment
   * @type {PageBlockHorizontalAlignment} {@link PageBlockHorizontalAlignment}
   */
  align: PageBlockHorizontalAlignment;

  /**
   * Vertical cell content alignment
   * @type {PageBlockVerticalAlignment} {@link PageBlockVerticalAlignment}
   */
  valign: PageBlockVerticalAlignment;
};

export type pageBlockTableCell$Input = {
  readonly _: "pageBlockTableCell";

  /**
   * Cell text; may be null. If the text is null, then the cell must be invisible
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * True, if it is a header cell
   * @type {Bool} {@link Bool}
   */
  readonly is_header?: Bool$Input;

  /**
   * The number of columns the cell spans
   * @type {int32} {@link int32}
   */
  readonly colspan?: int32;

  /**
   * The number of rows the cell spans
   * @type {int32} {@link int32}
   */
  readonly rowspan?: int32;

  /**
   * Horizontal cell content alignment
   * @type {PageBlockHorizontalAlignment} {@link PageBlockHorizontalAlignment}
   */
  readonly align?: PageBlockHorizontalAlignment$Input;

  /**
   * Vertical cell content alignment
   * @type {PageBlockVerticalAlignment} {@link PageBlockVerticalAlignment}
   */
  readonly valign?: PageBlockVerticalAlignment$Input;
};

/** Contains information about a related article */
export type pageBlockRelatedArticle = {
  _: "pageBlockRelatedArticle";

  /**
   * Related article URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Article title; may be empty
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Contains information about a related article
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Article photo; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Article author; may be empty
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  publish_date: int32;
};

export type pageBlockRelatedArticle$Input = {
  readonly _: "pageBlockRelatedArticle";

  /**
   * Related article URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Article title; may be empty
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Contains information about a related article
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Article photo; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Article author; may be empty
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly publish_date?: int32;
};

/** The title of a page */
export type pageBlockTitle = {
  _: "pageBlockTitle";

  /**
   * Title
   * @type {RichText} {@link RichText}
   */
  title: RichText;
};

export type pageBlockTitle$Input = {
  readonly _: "pageBlockTitle";

  /**
   * Title
   * @type {RichText} {@link RichText}
   */
  readonly title?: RichText$Input;
};

/** The subtitle of a page */
export type pageBlockSubtitle = {
  _: "pageBlockSubtitle";

  /**
   * Subtitle
   * @type {RichText} {@link RichText}
   */
  subtitle: RichText;
};

export type pageBlockSubtitle$Input = {
  readonly _: "pageBlockSubtitle";

  /**
   * Subtitle
   * @type {RichText} {@link RichText}
   */
  readonly subtitle?: RichText$Input;
};

/** The author and publishing date of a page */
export type pageBlockAuthorDate = {
  _: "pageBlockAuthorDate";

  /**
   * Author
   * @type {RichText} {@link RichText}
   */
  author: RichText;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  publish_date: int32;
};

export type pageBlockAuthorDate$Input = {
  readonly _: "pageBlockAuthorDate";

  /**
   * Author
   * @type {RichText} {@link RichText}
   */
  readonly author?: RichText$Input;

  /**
   * Point in time (Unix timestamp) when the article was published; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly publish_date?: int32;
};

/** A header */
export type pageBlockHeader = {
  _: "pageBlockHeader";

  /**
   * Header
   * @type {RichText} {@link RichText}
   */
  header: RichText;
};

export type pageBlockHeader$Input = {
  readonly _: "pageBlockHeader";

  /**
   * Header
   * @type {RichText} {@link RichText}
   */
  readonly header?: RichText$Input;
};

/** A subheader */
export type pageBlockSubheader = {
  _: "pageBlockSubheader";

  /**
   * Subheader
   * @type {RichText} {@link RichText}
   */
  subheader: RichText;
};

export type pageBlockSubheader$Input = {
  readonly _: "pageBlockSubheader";

  /**
   * Subheader
   * @type {RichText} {@link RichText}
   */
  readonly subheader?: RichText$Input;
};

/** A kicker */
export type pageBlockKicker = {
  _: "pageBlockKicker";

  /**
   * Kicker
   * @type {RichText} {@link RichText}
   */
  kicker: RichText;
};

export type pageBlockKicker$Input = {
  readonly _: "pageBlockKicker";

  /**
   * Kicker
   * @type {RichText} {@link RichText}
   */
  readonly kicker?: RichText$Input;
};

/** A text paragraph */
export type pageBlockParagraph = {
  _: "pageBlockParagraph";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  text: RichText;
};

export type pageBlockParagraph$Input = {
  readonly _: "pageBlockParagraph";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;
};

/** A preformatted text paragraph */
export type pageBlockPreformatted = {
  _: "pageBlockPreformatted";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Programming language for which the text needs to be formatted
   * @type {string} {@link string}
   */
  language: string;
};

export type pageBlockPreformatted$Input = {
  readonly _: "pageBlockPreformatted";

  /**
   * Paragraph text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Programming language for which the text needs to be formatted
   * @type {string} {@link string}
   */
  readonly language?: string;
};

/** The footer of a page */
export type pageBlockFooter = {
  _: "pageBlockFooter";

  /**
   * Footer
   * @type {RichText} {@link RichText}
   */
  footer: RichText;
};

export type pageBlockFooter$Input = {
  readonly _: "pageBlockFooter";

  /**
   * Footer
   * @type {RichText} {@link RichText}
   */
  readonly footer?: RichText$Input;
};

/** An empty block separating a page */
export type pageBlockDivider = {
  _: "pageBlockDivider";
};

export type pageBlockDivider$Input = {
  readonly _: "pageBlockDivider";
};

/** An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor */
export type pageBlockAnchor = {
  _: "pageBlockAnchor";

  /**
   * Name of the anchor
   * @type {string} {@link string}
   */
  name: string;
};

export type pageBlockAnchor$Input = {
  readonly _: "pageBlockAnchor";

  /**
   * Name of the anchor
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/** A list of data blocks */
export type pageBlockList = {
  _: "pageBlockList";

  /**
   * The items of the list
   * @type {vector<pageBlockListItem>} {@link vector<pageBlockListItem>}
   */
  items: vector<pageBlockListItem>;
};

export type pageBlockList$Input = {
  readonly _: "pageBlockList";

  /**
   * The items of the list
   * @type {vector<pageBlockListItem>} {@link vector<pageBlockListItem>}
   */
  readonly items?: vector$Input<pageBlockListItem$Input>;
};

/** A block quote */
export type pageBlockBlockQuote = {
  _: "pageBlockBlockQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  credit: RichText;
};

export type pageBlockBlockQuote$Input = {
  readonly _: "pageBlockBlockQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  readonly credit?: RichText$Input;
};

/** A pull quote */
export type pageBlockPullQuote = {
  _: "pageBlockPullQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  text: RichText;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  credit: RichText;
};

export type pageBlockPullQuote$Input = {
  readonly _: "pageBlockPullQuote";

  /**
   * Quote text
   * @type {RichText} {@link RichText}
   */
  readonly text?: RichText$Input;

  /**
   * Quote credit
   * @type {RichText} {@link RichText}
   */
  readonly credit?: RichText$Input;
};

/** An animation */
export type pageBlockAnimation = {
  _: "pageBlockAnimation";

  /**
   * Animation file; may be null
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Animation caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * True, if the animation must be played automatically
   * @type {Bool} {@link Bool}
   */
  need_autoplay: Bool;
};

export type pageBlockAnimation$Input = {
  readonly _: "pageBlockAnimation";

  /**
   * Animation file; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Animation caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * True, if the animation must be played automatically
   * @type {Bool} {@link Bool}
   */
  readonly need_autoplay?: Bool$Input;
};

/** An audio file */
export type pageBlockAudio = {
  _: "pageBlockAudio";

  /**
   * Audio file; may be null
   * @type {audio} {@link audio}
   */
  audio: audio;

  /**
   * Audio file caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

export type pageBlockAudio$Input = {
  readonly _: "pageBlockAudio";

  /**
   * Audio file; may be null
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;

  /**
   * Audio file caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/** A photo */
export type pageBlockPhoto = {
  _: "pageBlockPhoto";

  /**
   * Photo file; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Photo caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * URL that needs to be opened when the photo is clicked
   * @type {string} {@link string}
   */
  url: string;
};

export type pageBlockPhoto$Input = {
  readonly _: "pageBlockPhoto";

  /**
   * Photo file; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Photo caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * URL that needs to be opened when the photo is clicked
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** A video */
export type pageBlockVideo = {
  _: "pageBlockVideo";

  /**
   * Video file; may be null
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Video caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * True, if the video must be played automatically
   * @type {Bool} {@link Bool}
   */
  need_autoplay: Bool;

  /**
   * True, if the video must be looped
   * @type {Bool} {@link Bool}
   */
  is_looped: Bool;
};

export type pageBlockVideo$Input = {
  readonly _: "pageBlockVideo";

  /**
   * Video file; may be null
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Video caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * True, if the video must be played automatically
   * @type {Bool} {@link Bool}
   */
  readonly need_autoplay?: Bool$Input;

  /**
   * True, if the video must be looped
   * @type {Bool} {@link Bool}
   */
  readonly is_looped?: Bool$Input;
};

/** A voice note */
export type pageBlockVoiceNote = {
  _: "pageBlockVoiceNote";

  /**
   * Voice note; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * Voice note caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

export type pageBlockVoiceNote$Input = {
  readonly _: "pageBlockVoiceNote";

  /**
   * Voice note; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * Voice note caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/** A page cover */
export type pageBlockCover = {
  _: "pageBlockCover";

  /**
   * Cover
   * @type {PageBlock} {@link PageBlock}
   */
  cover: PageBlock;
};

export type pageBlockCover$Input = {
  readonly _: "pageBlockCover";

  /**
   * Cover
   * @type {PageBlock} {@link PageBlock}
   */
  readonly cover?: PageBlock$Input;
};

/** An embedded web page */
export type pageBlockEmbedded = {
  _: "pageBlockEmbedded";

  /**
   * Web page URL, if available
   * @type {string} {@link string}
   */
  url: string;

  /**
   * HTML-markup of the embedded page
   * @type {string} {@link string}
   */
  html: string;

  /**
   * Poster photo, if available; may be null
   * @type {photo} {@link photo}
   */
  poster_photo: photo;

  /**
   * Block width; 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Block height; 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;

  /**
   * True, if the block must be full width
   * @type {Bool} {@link Bool}
   */
  is_full_width: Bool;

  /**
   * True, if scrolling needs to be allowed
   * @type {Bool} {@link Bool}
   */
  allow_scrolling: Bool;
};

export type pageBlockEmbedded$Input = {
  readonly _: "pageBlockEmbedded";

  /**
   * Web page URL, if available
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * HTML-markup of the embedded page
   * @type {string} {@link string}
   */
  readonly html?: string;

  /**
   * Poster photo, if available; may be null
   * @type {photo} {@link photo}
   */
  readonly poster_photo?: photo$Input;

  /**
   * Block width; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Block height; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;

  /**
   * True, if the block must be full width
   * @type {Bool} {@link Bool}
   */
  readonly is_full_width?: Bool$Input;

  /**
   * True, if scrolling needs to be allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_scrolling?: Bool$Input;
};

/** An embedded post */
export type pageBlockEmbeddedPost = {
  _: "pageBlockEmbeddedPost";

  /**
   * Web page URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Post author
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Post author photo; may be null
   * @type {photo} {@link photo}
   */
  author_photo: photo;

  /**
   * Point in time (Unix timestamp) when the post was created; 0 if unknown
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Post content
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Post caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

export type pageBlockEmbeddedPost$Input = {
  readonly _: "pageBlockEmbeddedPost";

  /**
   * Web page URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Post author
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Post author photo; may be null
   * @type {photo} {@link photo}
   */
  readonly author_photo?: photo$Input;

  /**
   * Point in time (Unix timestamp) when the post was created; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Post content
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Post caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/** A collage */
export type pageBlockCollage = {
  _: "pageBlockCollage";

  /**
   * Collage item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

export type pageBlockCollage$Input = {
  readonly _: "pageBlockCollage";

  /**
   * Collage item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/** A slideshow */
export type pageBlockSlideshow = {
  _: "pageBlockSlideshow";

  /**
   * Slideshow item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

export type pageBlockSlideshow$Input = {
  readonly _: "pageBlockSlideshow";

  /**
   * Slideshow item contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/** A link to a chat */
export type pageBlockChatLink = {
  _: "pageBlockChatLink";

  /**
   * Chat title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo;

  /**
   * Chat username by which all other information about the chat can be resolved
   * @type {string} {@link string}
   */
  username: string;
};

export type pageBlockChatLink$Input = {
  readonly _: "pageBlockChatLink";

  /**
   * Chat title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input;

  /**
   * Chat username by which all other information about the chat can be resolved
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/** A table */
export type pageBlockTable = {
  _: "pageBlockTable";

  /**
   * Table caption
   * @type {RichText} {@link RichText}
   */
  caption: RichText;

  /**
   * Table cells
   * @type {vector<vector<pageBlockTableCell>>} {@link vector<vector<pageBlockTableCell>>}
   */
  cells: vector<vector<pageBlockTableCell>>;

  /**
   * True, if the table is bordered
   * @type {Bool} {@link Bool}
   */
  is_bordered: Bool;

  /**
   * True, if the table is striped
   * @type {Bool} {@link Bool}
   */
  is_striped: Bool;
};

export type pageBlockTable$Input = {
  readonly _: "pageBlockTable";

  /**
   * Table caption
   * @type {RichText} {@link RichText}
   */
  readonly caption?: RichText$Input;

  /**
   * Table cells
   * @type {vector<vector<pageBlockTableCell>>} {@link vector<vector<pageBlockTableCell>>}
   */
  readonly cells?: vector$Input<vector$Input<pageBlockTableCell$Input>>;

  /**
   * True, if the table is bordered
   * @type {Bool} {@link Bool}
   */
  readonly is_bordered?: Bool$Input;

  /**
   * True, if the table is striped
   * @type {Bool} {@link Bool}
   */
  readonly is_striped?: Bool$Input;
};

/** A collapsible block */
export type pageBlockDetails = {
  _: "pageBlockDetails";

  /**
   * Always visible heading for the block
   * @type {RichText} {@link RichText}
   */
  header: RichText;

  /**
   * Block contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * True, if the block is open by default
   * @type {Bool} {@link Bool}
   */
  is_open: Bool;
};

export type pageBlockDetails$Input = {
  readonly _: "pageBlockDetails";

  /**
   * Always visible heading for the block
   * @type {RichText} {@link RichText}
   */
  readonly header?: RichText$Input;

  /**
   * Block contents
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * True, if the block is open by default
   * @type {Bool} {@link Bool}
   */
  readonly is_open?: Bool$Input;
};

/** Related articles */
export type pageBlockRelatedArticles = {
  _: "pageBlockRelatedArticles";

  /**
   * Block header
   * @type {RichText} {@link RichText}
   */
  header: RichText;

  /**
   * List of related articles
   * @type {vector<pageBlockRelatedArticle>} {@link vector<pageBlockRelatedArticle>}
   */
  articles: vector<pageBlockRelatedArticle>;
};

export type pageBlockRelatedArticles$Input = {
  readonly _: "pageBlockRelatedArticles";

  /**
   * Block header
   * @type {RichText} {@link RichText}
   */
  readonly header?: RichText$Input;

  /**
   * List of related articles
   * @type {vector<pageBlockRelatedArticle>} {@link vector<pageBlockRelatedArticle>}
   */
  readonly articles?: vector$Input<pageBlockRelatedArticle$Input>;
};

/** A map */
export type pageBlockMap = {
  _: "pageBlockMap";

  /**
   * Location of the map center
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Map zoom level
   * @type {int32} {@link int32}
   */
  zoom: int32;

  /**
   * Map width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Map height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  caption: pageBlockCaption;
};

export type pageBlockMap$Input = {
  readonly _: "pageBlockMap";

  /**
   * Location of the map center
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Map zoom level
   * @type {int32} {@link int32}
   */
  readonly zoom?: int32;

  /**
   * Map width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Map height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Block caption
   * @type {pageBlockCaption} {@link pageBlockCaption}
   */
  readonly caption?: pageBlockCaption$Input;
};

/** Describes an instant view page for a web page */
export type webPageInstantView = {
  _: "webPageInstantView";

  /**
   * Content of the web page
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  page_blocks: vector<PageBlock>;

  /**
   * Number of the instant view views; 0 if unknown
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Version of the instant view; currently, can be 1 or 2
   * @type {int32} {@link int32}
   */
  version: int32;

  /**
   * True, if the instant view must be shown from right to left
   * @type {Bool} {@link Bool}
   */
  is_rtl: Bool;

  /**
   * True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
   * @type {Bool} {@link Bool}
   */
  is_full: Bool;

  /**
   * An internal link to be opened to leave feedback about the instant view
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  feedback_link: InternalLinkType;
};

export type webPageInstantView$Input = {
  readonly _: "webPageInstantView";

  /**
   * Content of the web page
   * @type {vector<PageBlock>} {@link vector<PageBlock>}
   */
  readonly page_blocks?: vector$Input<PageBlock$Input>;

  /**
   * Number of the instant view views; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Version of the instant view; currently, can be 1 or 2
   * @type {int32} {@link int32}
   */
  readonly version?: int32;

  /**
   * True, if the instant view must be shown from right to left
   * @type {Bool} {@link Bool}
   */
  readonly is_rtl?: Bool$Input;

  /**
   * True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
   * @type {Bool} {@link Bool}
   */
  readonly is_full?: Bool$Input;

  /**
   * An internal link to be opened to leave feedback about the instant view
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly feedback_link?: InternalLinkType$Input;
};

/** Describes a web page preview */
export type webPage = {
  _: "webPage";

  /**
   * Original URL of the link
   * @type {string} {@link string}
   */
  url: string;

  /**
   * URL to display
   * @type {string} {@link string}
   */
  display_url: string;

  /**
   * Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
   * @type {string} {@link string}
   */
  type: string;

  /**
   * Short name of the site (e.g., Google Docs, App Store)
   * @type {string} {@link string}
   */
  site_name: string;

  /**
   * Title of the content
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Describes a web page preview
   * @type {formattedText} {@link formattedText}
   */
  description: formattedText;

  /**
   * Image representing the content; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * URL to show in the embedded preview
   * @type {string} {@link string}
   */
  embed_url: string;

  /**
   * MIME type of the embedded preview, (e.g., text/html or video/mp4)
   * @type {string} {@link string}
   */
  embed_type: string;

  /**
   * Width of the embedded preview
   * @type {int32} {@link int32}
   */
  embed_width: int32;

  /**
   * Height of the embedded preview
   * @type {int32} {@link int32}
   */
  embed_height: int32;

  /**
   * Duration of the content, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Author of the content
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Preview of the content as an animation, if available; may be null
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Preview of the content as an audio file, if available; may be null
   * @type {audio} {@link audio}
   */
  audio: audio;

  /**
   * Preview of the content as a document, if available; may be null
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Preview of the content as a sticker for small WEBP files, if available; may be null
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;

  /**
   * Preview of the content as a video, if available; may be null
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Preview of the content as a video note, if available; may be null
   * @type {videoNote} {@link videoNote}
   */
  video_note: videoNote;

  /**
   * Preview of the content as a voice note, if available; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * Version of instant view, available for the web page (currently, can be 1 or 2), 0 if none
   * @type {int32} {@link int32}
   */
  instant_view_version: int32;
};

export type webPage$Input = {
  readonly _: "webPage";

  /**
   * Original URL of the link
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * URL to display
   * @type {string} {@link string}
   */
  readonly display_url?: string;

  /**
   * Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Short name of the site (e.g., Google Docs, App Store)
   * @type {string} {@link string}
   */
  readonly site_name?: string;

  /**
   * Title of the content
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Describes a web page preview
   * @type {formattedText} {@link formattedText}
   */
  readonly description?: formattedText$Input;

  /**
   * Image representing the content; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * URL to show in the embedded preview
   * @type {string} {@link string}
   */
  readonly embed_url?: string;

  /**
   * MIME type of the embedded preview, (e.g., text/html or video/mp4)
   * @type {string} {@link string}
   */
  readonly embed_type?: string;

  /**
   * Width of the embedded preview
   * @type {int32} {@link int32}
   */
  readonly embed_width?: int32;

  /**
   * Height of the embedded preview
   * @type {int32} {@link int32}
   */
  readonly embed_height?: int32;

  /**
   * Duration of the content, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Author of the content
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Preview of the content as an animation, if available; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Preview of the content as an audio file, if available; may be null
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;

  /**
   * Preview of the content as a document, if available; may be null
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Preview of the content as a sticker for small WEBP files, if available; may be null
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;

  /**
   * Preview of the content as a video, if available; may be null
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Preview of the content as a video note, if available; may be null
   * @type {videoNote} {@link videoNote}
   */
  readonly video_note?: videoNote$Input;

  /**
   * Preview of the content as a voice note, if available; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * Version of instant view, available for the web page (currently, can be 1 or 2), 0 if none
   * @type {int32} {@link int32}
   */
  readonly instant_view_version?: int32;
};

/** Contains information about a country */
export type countryInfo = {
  _: "countryInfo";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  country_code: string;

  /**
   * Native name of the country
   * @type {string} {@link string}
   */
  name: string;

  /**
   * English name of the country
   * @type {string} {@link string}
   */
  english_name: string;

  /**
   * True, if the country must be hidden from the list of all countries
   * @type {Bool} {@link Bool}
   */
  is_hidden: Bool;

  /**
   * List of country calling codes
   * @type {vector<string>} {@link vector<string>}
   */
  calling_codes: vector<string>;
};

export type countryInfo$Input = {
  readonly _: "countryInfo";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;

  /**
   * Native name of the country
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * English name of the country
   * @type {string} {@link string}
   */
  readonly english_name?: string;

  /**
   * True, if the country must be hidden from the list of all countries
   * @type {Bool} {@link Bool}
   */
  readonly is_hidden?: Bool$Input;

  /**
   * List of country calling codes
   * @type {vector<string>} {@link vector<string>}
   */
  readonly calling_codes?: vector$Input<string>;
};

/** Contains information about countries */
export type countries = {
  _: "countries";

  /**
   * The list of countries
   * @type {vector<countryInfo>} {@link vector<countryInfo>}
   */
  countries: vector<countryInfo>;
};

export type countries$Input = {
  readonly _: "countries";

  /**
   * The list of countries
   * @type {vector<countryInfo>} {@link vector<countryInfo>}
   */
  readonly countries?: vector$Input<countryInfo$Input>;
};

/** Contains information about a phone number */
export type phoneNumberInfo = {
  _: "phoneNumberInfo";

  /**
   * Information about the country to which the phone number belongs; may be null
   * @type {countryInfo} {@link countryInfo}
   */
  country: countryInfo;

  /**
   * The part of the phone number denoting country calling code or its part
   * @type {string} {@link string}
   */
  country_calling_code: string;

  /**
   * The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
   * @type {string} {@link string}
   */
  formatted_phone_number: string;
};

export type phoneNumberInfo$Input = {
  readonly _: "phoneNumberInfo";

  /**
   * Information about the country to which the phone number belongs; may be null
   * @type {countryInfo} {@link countryInfo}
   */
  readonly country?: countryInfo$Input;

  /**
   * The part of the phone number denoting country calling code or its part
   * @type {string} {@link string}
   */
  readonly country_calling_code?: string;

  /**
   * The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
   * @type {string} {@link string}
   */
  readonly formatted_phone_number?: string;
};

/** Describes an action associated with a bank card number */
export type bankCardActionOpenUrl = {
  _: "bankCardActionOpenUrl";

  /**
   * Action text
   * @type {string} {@link string}
   */
  text: string;

  /**
   * The URL to be opened
   * @type {string} {@link string}
   */
  url: string;
};

export type bankCardActionOpenUrl$Input = {
  readonly _: "bankCardActionOpenUrl";

  /**
   * Action text
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * The URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Information about a bank card */
export type bankCardInfo = {
  _: "bankCardInfo";

  /**
   * Title of the bank card description
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Actions that can be done with the bank card number
   * @type {vector<bankCardActionOpenUrl>} {@link vector<bankCardActionOpenUrl>}
   */
  actions: vector<bankCardActionOpenUrl>;
};

export type bankCardInfo$Input = {
  readonly _: "bankCardInfo";

  /**
   * Title of the bank card description
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Actions that can be done with the bank card number
   * @type {vector<bankCardActionOpenUrl>} {@link vector<bankCardActionOpenUrl>}
   */
  readonly actions?: vector$Input<bankCardActionOpenUrl$Input>;
};

/** Describes an address */
export type address = {
  _: "address";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  country_code: string;

  /**
   * State, if applicable
   * @type {string} {@link string}
   */
  state: string;

  /**
   * City
   * @type {string} {@link string}
   */
  city: string;

  /**
   * First line of the address
   * @type {string} {@link string}
   */
  street_line1: string;

  /**
   * Second line of the address
   * @type {string} {@link string}
   */
  street_line2: string;

  /**
   * Address postal code
   * @type {string} {@link string}
   */
  postal_code: string;
};

export type address$Input = {
  readonly _: "address";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;

  /**
   * State, if applicable
   * @type {string} {@link string}
   */
  readonly state?: string;

  /**
   * City
   * @type {string} {@link string}
   */
  readonly city?: string;

  /**
   * First line of the address
   * @type {string} {@link string}
   */
  readonly street_line1?: string;

  /**
   * Second line of the address
   * @type {string} {@link string}
   */
  readonly street_line2?: string;

  /**
   * Address postal code
   * @type {string} {@link string}
   */
  readonly postal_code?: string;
};

/** Contains parameters of the application theme */
export type themeParameters = {
  _: "themeParameters";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  background_color: int32;

  /**
   * A secondary color for the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  secondary_background_color: int32;

  /**
   * A color of text in the RGB24 format
   * @type {int32} {@link int32}
   */
  text_color: int32;

  /**
   * A color of hints in the RGB24 format
   * @type {int32} {@link int32}
   */
  hint_color: int32;

  /**
   * A color of links in the RGB24 format
   * @type {int32} {@link int32}
   */
  link_color: int32;

  /**
   * A color of the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  button_color: int32;

  /**
   * A color of text on the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  button_text_color: int32;
};

export type themeParameters$Input = {
  readonly _: "themeParameters";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly background_color?: int32;

  /**
   * A secondary color for the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly secondary_background_color?: int32;

  /**
   * A color of text in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly text_color?: int32;

  /**
   * A color of hints in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly hint_color?: int32;

  /**
   * A color of links in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly link_color?: int32;

  /**
   * A color of the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly button_color?: int32;

  /**
   * A color of text on the buttons in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly button_text_color?: int32;
};

/** Portion of the price of a product (e.g., "delivery cost", "tax amount") */
export type labeledPricePart = {
  _: "labeledPricePart";

  /**
   * Label for this portion of the product price
   * @type {string} {@link string}
   */
  label: string;

  /**
   * Currency amount in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;
};

export type labeledPricePart$Input = {
  readonly _: "labeledPricePart";

  /**
   * Label for this portion of the product price
   * @type {string} {@link string}
   */
  readonly label?: string;

  /**
   * Currency amount in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;
};

/** Product invoice */
export type invoice = {
  _: "invoice";

  /**
   * ISO 4217 currency code
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * A list of objects used to calculate the total price of the product
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  price_parts: vector<labeledPricePart>;

  /**
   * The maximum allowed amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  max_tip_amount: int53;

  /**
   * Suggested amounts of tip in the smallest units of the currency
   * @type {vector<int53>} {@link vector<int53>}
   */
  suggested_tip_amounts: vector<int53>;

  /**
   * An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
   * @type {string} {@link string}
   */
  recurring_payment_terms_of_service_url: string;

  /**
   * True, if the payment is a test payment
   * @type {Bool} {@link Bool}
   */
  is_test: Bool;

  /**
   * True, if the user's name is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_name: Bool;

  /**
   * True, if the user's phone number is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_phone_number: Bool;

  /**
   * True, if the user's email address is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_email_address: Bool;

  /**
   * True, if the user's shipping address is needed for payment
   * @type {Bool} {@link Bool}
   */
  need_shipping_address: Bool;

  /**
   * True, if the user's phone number will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  send_phone_number_to_provider: Bool;

  /**
   * True, if the user's email address will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  send_email_address_to_provider: Bool;

  /**
   * True, if the total price depends on the shipping method
   * @type {Bool} {@link Bool}
   */
  is_flexible: Bool;
};

export type invoice$Input = {
  readonly _: "invoice";

  /**
   * ISO 4217 currency code
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * A list of objects used to calculate the total price of the product
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  readonly price_parts?: vector$Input<labeledPricePart$Input>;

  /**
   * The maximum allowed amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly max_tip_amount?: int53;

  /**
   * Suggested amounts of tip in the smallest units of the currency
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly suggested_tip_amounts?: vector$Input<int53>;

  /**
   * An HTTP URL with terms of service for recurring payments. If non-empty, the invoice payment will result in recurring payments and the user must accept the terms of service before allowed to pay
   * @type {string} {@link string}
   */
  readonly recurring_payment_terms_of_service_url?: string;

  /**
   * True, if the payment is a test payment
   * @type {Bool} {@link Bool}
   */
  readonly is_test?: Bool$Input;

  /**
   * True, if the user's name is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_name?: Bool$Input;

  /**
   * True, if the user's phone number is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_phone_number?: Bool$Input;

  /**
   * True, if the user's email address is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_email_address?: Bool$Input;

  /**
   * True, if the user's shipping address is needed for payment
   * @type {Bool} {@link Bool}
   */
  readonly need_shipping_address?: Bool$Input;

  /**
   * True, if the user's phone number will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  readonly send_phone_number_to_provider?: Bool$Input;

  /**
   * True, if the user's email address will be sent to the provider
   * @type {Bool} {@link Bool}
   */
  readonly send_email_address_to_provider?: Bool$Input;

  /**
   * True, if the total price depends on the shipping method
   * @type {Bool} {@link Bool}
   */
  readonly is_flexible?: Bool$Input;
};

/** Order information */
export type orderInfo = {
  _: "orderInfo";

  /**
   * Name of the user
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;

  /**
   * Email address of the user
   * @type {string} {@link string}
   */
  email_address: string;

  /**
   * Shipping address for this order; may be null
   * @type {address} {@link address}
   */
  shipping_address: address;
};

export type orderInfo$Input = {
  readonly _: "orderInfo";

  /**
   * Name of the user
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Email address of the user
   * @type {string} {@link string}
   */
  readonly email_address?: string;

  /**
   * Shipping address for this order; may be null
   * @type {address} {@link address}
   */
  readonly shipping_address?: address$Input;
};

/** One shipping option */
export type shippingOption = {
  _: "shippingOption";

  /**
   * Shipping option identifier
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Option title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * A list of objects used to calculate the total shipping costs
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  price_parts: vector<labeledPricePart>;
};

export type shippingOption$Input = {
  readonly _: "shippingOption";

  /**
   * Shipping option identifier
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Option title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * A list of objects used to calculate the total shipping costs
   * @type {vector<labeledPricePart>} {@link vector<labeledPricePart>}
   */
  readonly price_parts?: vector$Input<labeledPricePart$Input>;
};

/** Contains information about saved payment credentials */
export type savedCredentials = {
  _: "savedCredentials";

  /**
   * Unique identifier of the saved credentials
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the saved credentials
   * @type {string} {@link string}
   */
  title: string;
};

export type savedCredentials$Input = {
  readonly _: "savedCredentials";

  /**
   * Unique identifier of the saved credentials
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the saved credentials
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password */
export type inputCredentialsSaved = {
  _: "inputCredentialsSaved";

  /**
   * Identifier of the saved credentials
   * @type {string} {@link string}
   */
  saved_credentials_id: string;
};

export type inputCredentialsSaved$Input = {
  readonly _: "inputCredentialsSaved";

  /**
   * Identifier of the saved credentials
   * @type {string} {@link string}
   */
  readonly saved_credentials_id?: string;
};

/** Applies if a user enters new credentials on a payment provider website */
export type inputCredentialsNew = {
  _: "inputCredentialsNew";

  /**
   * JSON-encoded data with the credential identifier from the payment provider
   * @type {string} {@link string}
   */
  data: string;

  /**
   * True, if the credential identifier can be saved on the server side
   * @type {Bool} {@link Bool}
   */
  allow_save: Bool;
};

export type inputCredentialsNew$Input = {
  readonly _: "inputCredentialsNew";

  /**
   * JSON-encoded data with the credential identifier from the payment provider
   * @type {string} {@link string}
   */
  readonly data?: string;

  /**
   * True, if the credential identifier can be saved on the server side
   * @type {Bool} {@link Bool}
   */
  readonly allow_save?: Bool$Input;
};

/** Applies if a user enters new credentials using Apple Pay */
export type inputCredentialsApplePay = {
  _: "inputCredentialsApplePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  data: string;
};

export type inputCredentialsApplePay$Input = {
  readonly _: "inputCredentialsApplePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/** Applies if a user enters new credentials using Google Pay */
export type inputCredentialsGooglePay = {
  _: "inputCredentialsGooglePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  data: string;
};

export type inputCredentialsGooglePay$Input = {
  readonly _: "inputCredentialsGooglePay";

  /**
   * JSON-encoded data with the credential identifier
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/** Smart Glocal payment provider */
export type paymentProviderSmartGlocal = {
  _: "paymentProviderSmartGlocal";

  /**
   * Public payment token
   * @type {string} {@link string}
   */
  public_token: string;
};

export type paymentProviderSmartGlocal$Input = {
  readonly _: "paymentProviderSmartGlocal";

  /**
   * Public payment token
   * @type {string} {@link string}
   */
  readonly public_token?: string;
};

/** Stripe payment provider */
export type paymentProviderStripe = {
  _: "paymentProviderStripe";

  /**
   * Stripe API publishable key
   * @type {string} {@link string}
   */
  publishable_key: string;

  /**
   * True, if the user country must be provided
   * @type {Bool} {@link Bool}
   */
  need_country: Bool;

  /**
   * True, if the user ZIP/postal code must be provided
   * @type {Bool} {@link Bool}
   */
  need_postal_code: Bool;

  /**
   * True, if the cardholder name must be provided
   * @type {Bool} {@link Bool}
   */
  need_cardholder_name: Bool;
};

export type paymentProviderStripe$Input = {
  readonly _: "paymentProviderStripe";

  /**
   * Stripe API publishable key
   * @type {string} {@link string}
   */
  readonly publishable_key?: string;

  /**
   * True, if the user country must be provided
   * @type {Bool} {@link Bool}
   */
  readonly need_country?: Bool$Input;

  /**
   * True, if the user ZIP/postal code must be provided
   * @type {Bool} {@link Bool}
   */
  readonly need_postal_code?: Bool$Input;

  /**
   * True, if the cardholder name must be provided
   * @type {Bool} {@link Bool}
   */
  readonly need_cardholder_name?: Bool$Input;
};

/** Some other payment provider, for which a web payment form must be shown */
export type paymentProviderOther = {
  _: "paymentProviderOther";

  /**
   * Payment form URL
   * @type {string} {@link string}
   */
  url: string;
};

export type paymentProviderOther$Input = {
  readonly _: "paymentProviderOther";

  /**
   * Payment form URL
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Describes an additional payment option */
export type paymentOption = {
  _: "paymentOption";

  /**
   * Title for the payment option
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Payment form URL to be opened in a web view
   * @type {string} {@link string}
   */
  url: string;
};

export type paymentOption$Input = {
  readonly _: "paymentOption";

  /**
   * Title for the payment option
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Payment form URL to be opened in a web view
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Contains information about an invoice payment form */
export type paymentForm = {
  _: "paymentForm";

  /**
   * The payment form identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Full information about the invoice
   * @type {invoice} {@link invoice}
   */
  invoice: invoice;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  seller_bot_user_id: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  payment_provider_user_id: int53;

  /**
   * Information about the payment provider
   * @type {PaymentProvider} {@link PaymentProvider}
   */
  payment_provider: PaymentProvider;

  /**
   * The list of additional payment options
   * @type {vector<paymentOption>} {@link vector<paymentOption>}
   */
  additional_payment_options: vector<paymentOption>;

  /**
   * Saved server-side order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  saved_order_info: orderInfo;

  /**
   * The list of saved payment credentials
   * @type {vector<savedCredentials>} {@link vector<savedCredentials>}
   */
  saved_credentials: vector<savedCredentials>;

  /**
   * True, if the user can choose to save credentials
   * @type {Bool} {@link Bool}
   */
  can_save_credentials: Bool;

  /**
   * True, if the user will be able to save credentials, if sets up a 2-step verification password
   * @type {Bool} {@link Bool}
   */
  need_password: Bool;

  /**
   * Product title
   * @type {string} {@link string}
   */
  product_title: string;

  /**
   * Product description
   * @type {formattedText} {@link formattedText}
   */
  product_description: formattedText;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  product_photo: photo;
};

export type paymentForm$Input = {
  readonly _: "paymentForm";

  /**
   * The payment form identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Full information about the invoice
   * @type {invoice} {@link invoice}
   */
  readonly invoice?: invoice$Input;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  readonly seller_bot_user_id?: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  readonly payment_provider_user_id?: int53;

  /**
   * Information about the payment provider
   * @type {PaymentProvider} {@link PaymentProvider}
   */
  readonly payment_provider?: PaymentProvider$Input;

  /**
   * The list of additional payment options
   * @type {vector<paymentOption>} {@link vector<paymentOption>}
   */
  readonly additional_payment_options?: vector$Input<paymentOption$Input>;

  /**
   * Saved server-side order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly saved_order_info?: orderInfo$Input;

  /**
   * The list of saved payment credentials
   * @type {vector<savedCredentials>} {@link vector<savedCredentials>}
   */
  readonly saved_credentials?: vector$Input<savedCredentials$Input>;

  /**
   * True, if the user can choose to save credentials
   * @type {Bool} {@link Bool}
   */
  readonly can_save_credentials?: Bool$Input;

  /**
   * True, if the user will be able to save credentials, if sets up a 2-step verification password
   * @type {Bool} {@link Bool}
   */
  readonly need_password?: Bool$Input;

  /**
   * Product title
   * @type {string} {@link string}
   */
  readonly product_title?: string;

  /**
   * Product description
   * @type {formattedText} {@link formattedText}
   */
  readonly product_description?: formattedText$Input;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  readonly product_photo?: photo$Input;
};

/** Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options */
export type validatedOrderInfo = {
  _: "validatedOrderInfo";

  /**
   * Temporary identifier of the order information
   * @type {string} {@link string}
   */
  order_info_id: string;

  /**
   * Available shipping options
   * @type {vector<shippingOption>} {@link vector<shippingOption>}
   */
  shipping_options: vector<shippingOption>;
};

export type validatedOrderInfo$Input = {
  readonly _: "validatedOrderInfo";

  /**
   * Temporary identifier of the order information
   * @type {string} {@link string}
   */
  readonly order_info_id?: string;

  /**
   * Available shipping options
   * @type {vector<shippingOption>} {@link vector<shippingOption>}
   */
  readonly shipping_options?: vector$Input<shippingOption$Input>;
};

/** Contains the result of a payment request */
export type paymentResult = {
  _: "paymentResult";

  /**
   * True, if the payment request was successful; otherwise the verification_url will be non-empty
   * @type {Bool} {@link Bool}
   */
  success: Bool;

  /**
   * URL for additional payment credentials verification
   * @type {string} {@link string}
   */
  verification_url: string;
};

export type paymentResult$Input = {
  readonly _: "paymentResult";

  /**
   * True, if the payment request was successful; otherwise the verification_url will be non-empty
   * @type {Bool} {@link Bool}
   */
  readonly success?: Bool$Input;

  /**
   * URL for additional payment credentials verification
   * @type {string} {@link string}
   */
  readonly verification_url?: string;
};

/** Contains information about a successful payment */
export type paymentReceipt = {
  _: "paymentReceipt";

  /**
   * Product title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Contains information about a successful payment
   * @type {formattedText} {@link formattedText}
   */
  description: formattedText;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Point in time (Unix timestamp) when the payment was made
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  seller_bot_user_id: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  payment_provider_user_id: int53;

  /**
   * Information about the invoice
   * @type {invoice} {@link invoice}
   */
  invoice: invoice;

  /**
   * Order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  order_info: orderInfo;

  /**
   * Chosen shipping option; may be null
   * @type {shippingOption} {@link shippingOption}
   */
  shipping_option: shippingOption;

  /**
   * Title of the saved credentials chosen by the buyer
   * @type {string} {@link string}
   */
  credentials_title: string;

  /**
   * The amount of tip chosen by the buyer in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  tip_amount: int53;
};

export type paymentReceipt$Input = {
  readonly _: "paymentReceipt";

  /**
   * Product title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Contains information about a successful payment
   * @type {formattedText} {@link formattedText}
   */
  readonly description?: formattedText$Input;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Point in time (Unix timestamp) when the payment was made
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * User identifier of the seller bot
   * @type {int53} {@link int53}
   */
  readonly seller_bot_user_id?: int53;

  /**
   * User identifier of the payment provider bot
   * @type {int53} {@link int53}
   */
  readonly payment_provider_user_id?: int53;

  /**
   * Information about the invoice
   * @type {invoice} {@link invoice}
   */
  readonly invoice?: invoice$Input;

  /**
   * Order information; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input;

  /**
   * Chosen shipping option; may be null
   * @type {shippingOption} {@link shippingOption}
   */
  readonly shipping_option?: shippingOption$Input;

  /**
   * Title of the saved credentials chosen by the buyer
   * @type {string} {@link string}
   */
  readonly credentials_title?: string;

  /**
   * The amount of tip chosen by the buyer in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly tip_amount?: int53;
};

/** An invoice from a message of the type messageInvoice */
export type inputInvoiceMessage = {
  _: "inputInvoiceMessage";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

export type inputInvoiceMessage$Input = {
  readonly _: "inputInvoiceMessage";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/** An invoice from a link of the type internalLinkTypeInvoice */
export type inputInvoiceName = {
  _: "inputInvoiceName";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  name: string;
};

export type inputInvoiceName$Input = {
  readonly _: "inputInvoiceName";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/** The media is hidden until the invoice is paid */
export type messageExtendedMediaPreview = {
  _: "messageExtendedMediaPreview";

  /**
   * Media width; 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Media height; 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Media duration; 0 if unknown
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Media minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  minithumbnail: minithumbnail;

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type messageExtendedMediaPreview$Input = {
  readonly _: "messageExtendedMediaPreview";

  /**
   * Media width; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Media height; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Media duration; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Media minithumbnail; may be null
   * @type {minithumbnail} {@link minithumbnail}
   */
  readonly minithumbnail?: minithumbnail$Input;

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** The media is a photo */
export type messageExtendedMediaPhoto = {
  _: "messageExtendedMediaPhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type messageExtendedMediaPhoto$Input = {
  readonly _: "messageExtendedMediaPhoto";

  /**
   * The photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** The media is a video */
export type messageExtendedMediaVideo = {
  _: "messageExtendedMediaVideo";

  /**
   * The video
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type messageExtendedMediaVideo$Input = {
  readonly _: "messageExtendedMediaVideo";

  /**
   * The video
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** The media is unuspported */
export type messageExtendedMediaUnsupported = {
  _: "messageExtendedMediaUnsupported";

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type messageExtendedMediaUnsupported$Input = {
  readonly _: "messageExtendedMediaUnsupported";

  /**
   * Media caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** File with the date it was uploaded */
export type datedFile = {
  _: "datedFile";

  /**
   * The file
   * @type {file} {@link file}
   */
  file: file;

  /**
   * Point in time (Unix timestamp) when the file was uploaded
   * @type {int32} {@link int32}
   */
  date: int32;
};

export type datedFile$Input = {
  readonly _: "datedFile";

  /**
   * The file
   * @type {file} {@link file}
   */
  readonly file?: file$Input;

  /**
   * Point in time (Unix timestamp) when the file was uploaded
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/** A Telegram Passport element containing the user's personal details */
export type passportElementTypePersonalDetails = {
  _: "passportElementTypePersonalDetails";
};

export type passportElementTypePersonalDetails$Input = {
  readonly _: "passportElementTypePersonalDetails";
};

/** A Telegram Passport element containing the user's passport */
export type passportElementTypePassport = {
  _: "passportElementTypePassport";
};

export type passportElementTypePassport$Input = {
  readonly _: "passportElementTypePassport";
};

/** A Telegram Passport element containing the user's driver license */
export type passportElementTypeDriverLicense = {
  _: "passportElementTypeDriverLicense";
};

export type passportElementTypeDriverLicense$Input = {
  readonly _: "passportElementTypeDriverLicense";
};

/** A Telegram Passport element containing the user's identity card */
export type passportElementTypeIdentityCard = {
  _: "passportElementTypeIdentityCard";
};

export type passportElementTypeIdentityCard$Input = {
  readonly _: "passportElementTypeIdentityCard";
};

/** A Telegram Passport element containing the user's internal passport */
export type passportElementTypeInternalPassport = {
  _: "passportElementTypeInternalPassport";
};

export type passportElementTypeInternalPassport$Input = {
  readonly _: "passportElementTypeInternalPassport";
};

/** A Telegram Passport element containing the user's address */
export type passportElementTypeAddress = {
  _: "passportElementTypeAddress";
};

export type passportElementTypeAddress$Input = {
  readonly _: "passportElementTypeAddress";
};

/** A Telegram Passport element containing the user's utility bill */
export type passportElementTypeUtilityBill = {
  _: "passportElementTypeUtilityBill";
};

export type passportElementTypeUtilityBill$Input = {
  readonly _: "passportElementTypeUtilityBill";
};

/** A Telegram Passport element containing the user's bank statement */
export type passportElementTypeBankStatement = {
  _: "passportElementTypeBankStatement";
};

export type passportElementTypeBankStatement$Input = {
  readonly _: "passportElementTypeBankStatement";
};

/** A Telegram Passport element containing the user's rental agreement */
export type passportElementTypeRentalAgreement = {
  _: "passportElementTypeRentalAgreement";
};

export type passportElementTypeRentalAgreement$Input = {
  readonly _: "passportElementTypeRentalAgreement";
};

/** A Telegram Passport element containing the registration page of the user's passport */
export type passportElementTypePassportRegistration = {
  _: "passportElementTypePassportRegistration";
};

export type passportElementTypePassportRegistration$Input = {
  readonly _: "passportElementTypePassportRegistration";
};

/** A Telegram Passport element containing the user's temporary registration */
export type passportElementTypeTemporaryRegistration = {
  _: "passportElementTypeTemporaryRegistration";
};

export type passportElementTypeTemporaryRegistration$Input = {
  readonly _: "passportElementTypeTemporaryRegistration";
};

/** A Telegram Passport element containing the user's phone number */
export type passportElementTypePhoneNumber = {
  _: "passportElementTypePhoneNumber";
};

export type passportElementTypePhoneNumber$Input = {
  readonly _: "passportElementTypePhoneNumber";
};

/** A Telegram Passport element containing the user's email address */
export type passportElementTypeEmailAddress = {
  _: "passportElementTypeEmailAddress";
};

export type passportElementTypeEmailAddress$Input = {
  readonly _: "passportElementTypeEmailAddress";
};

/** Represents a date according to the Gregorian calendar */
export type date = {
  _: "date";

  /**
   * Day of the month; 1-31
   * @type {int32} {@link int32}
   */
  day: int32;

  /**
   * Month; 1-12
   * @type {int32} {@link int32}
   */
  month: int32;

  /**
   * Year; 1-9999
   * @type {int32} {@link int32}
   */
  year: int32;
};

export type date$Input = {
  readonly _: "date";

  /**
   * Day of the month; 1-31
   * @type {int32} {@link int32}
   */
  readonly day?: int32;

  /**
   * Month; 1-12
   * @type {int32} {@link int32}
   */
  readonly month?: int32;

  /**
   * Year; 1-9999
   * @type {int32} {@link int32}
   */
  readonly year?: int32;
};

/** Contains the user's personal details */
export type personalDetails = {
  _: "personalDetails";

  /**
   * First name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  first_name: string;

  /**
   * Middle name of the user written in English; 0-255 characters
   * @type {string} {@link string}
   */
  middle_name: string;

  /**
   * Last name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  last_name: string;

  /**
   * Native first name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  native_first_name: string;

  /**
   * Native middle name of the user; 0-255 characters
   * @type {string} {@link string}
   */
  native_middle_name: string;

  /**
   * Native last name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  native_last_name: string;

  /**
   * Birthdate of the user
   * @type {date} {@link date}
   */
  birthdate: date;

  /**
   * Gender of the user, "male" or "female"
   * @type {string} {@link string}
   */
  gender: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's country
   * @type {string} {@link string}
   */
  country_code: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
   * @type {string} {@link string}
   */
  residence_country_code: string;
};

export type personalDetails$Input = {
  readonly _: "personalDetails";

  /**
   * First name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * Middle name of the user written in English; 0-255 characters
   * @type {string} {@link string}
   */
  readonly middle_name?: string;

  /**
   * Last name of the user written in English; 1-255 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;

  /**
   * Native first name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  readonly native_first_name?: string;

  /**
   * Native middle name of the user; 0-255 characters
   * @type {string} {@link string}
   */
  readonly native_middle_name?: string;

  /**
   * Native last name of the user; 1-255 characters
   * @type {string} {@link string}
   */
  readonly native_last_name?: string;

  /**
   * Birthdate of the user
   * @type {date} {@link date}
   */
  readonly birthdate?: date$Input;

  /**
   * Gender of the user, "male" or "female"
   * @type {string} {@link string}
   */
  readonly gender?: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's country
   * @type {string} {@link string}
   */
  readonly country_code?: string;

  /**
   * A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
   * @type {string} {@link string}
   */
  readonly residence_country_code?: string;
};

/** An identity document */
export type identityDocument = {
  _: "identityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  number: string;

  /**
   * Document expiry date; may be null if not applicable
   * @type {date} {@link date}
   */
  expiry_date: date;

  /**
   * Front side of the document
   * @type {datedFile} {@link datedFile}
   */
  front_side: datedFile;

  /**
   * Reverse side of the document; only for driver license and identity card; may be null
   * @type {datedFile} {@link datedFile}
   */
  reverse_side: datedFile;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  selfie: datedFile;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  translation: vector<datedFile>;
};

export type identityDocument$Input = {
  readonly _: "identityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  readonly number?: string;

  /**
   * Document expiry date; may be null if not applicable
   * @type {date} {@link date}
   */
  readonly expiry_date?: date$Input;

  /**
   * Front side of the document
   * @type {datedFile} {@link datedFile}
   */
  readonly front_side?: datedFile$Input;

  /**
   * Reverse side of the document; only for driver license and identity card; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly reverse_side?: datedFile$Input;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly selfie?: datedFile$Input;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly translation?: vector$Input<datedFile$Input>;
};

/** An identity document to be saved to Telegram Passport */
export type inputIdentityDocument = {
  _: "inputIdentityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  number: string;

  /**
   * Document expiry date; pass null if not applicable
   * @type {date} {@link date}
   */
  expiry_date: date;

  /**
   * Front side of the document
   * @type {InputFile} {@link InputFile}
   */
  front_side: InputFile;

  /**
   * Reverse side of the document; only for driver license and identity card; pass null otherwise
   * @type {InputFile} {@link InputFile}
   */
  reverse_side: InputFile;

  /**
   * Selfie with the document; pass null if unavailable
   * @type {InputFile} {@link InputFile}
   */
  selfie: InputFile;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  translation: vector<InputFile>;
};

export type inputIdentityDocument$Input = {
  readonly _: "inputIdentityDocument";

  /**
   * Document number; 1-24 characters
   * @type {string} {@link string}
   */
  readonly number?: string;

  /**
   * Document expiry date; pass null if not applicable
   * @type {date} {@link date}
   */
  readonly expiry_date?: date$Input;

  /**
   * Front side of the document
   * @type {InputFile} {@link InputFile}
   */
  readonly front_side?: InputFile$Input;

  /**
   * Reverse side of the document; only for driver license and identity card; pass null otherwise
   * @type {InputFile} {@link InputFile}
   */
  readonly reverse_side?: InputFile$Input;

  /**
   * Selfie with the document; pass null if unavailable
   * @type {InputFile} {@link InputFile}
   */
  readonly selfie?: InputFile$Input;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  readonly translation?: vector$Input<InputFile$Input>;
};

/** A personal document, containing some information about a user */
export type personalDocument = {
  _: "personalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  files: vector<datedFile>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  translation: vector<datedFile>;
};

export type personalDocument$Input = {
  readonly _: "personalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly files?: vector$Input<datedFile$Input>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly translation?: vector$Input<datedFile$Input>;
};

/** A personal document to be saved to Telegram Passport */
export type inputPersonalDocument = {
  _: "inputPersonalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  files: vector<InputFile>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  translation: vector<InputFile>;
};

export type inputPersonalDocument$Input = {
  readonly _: "inputPersonalDocument";

  /**
   * List of files containing the pages of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  readonly files?: vector$Input<InputFile$Input>;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<InputFile>} {@link vector<InputFile>}
   */
  readonly translation?: vector$Input<InputFile$Input>;
};

/** A Telegram Passport element containing the user's personal details */
export type passportElementPersonalDetails = {
  _: "passportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  personal_details: personalDetails;
};

export type passportElementPersonalDetails$Input = {
  readonly _: "passportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  readonly personal_details?: personalDetails$Input;
};

/** A Telegram Passport element containing the user's passport */
export type passportElementPassport = {
  _: "passportElementPassport";

  /**
   * Passport
   * @type {identityDocument} {@link identityDocument}
   */
  passport: identityDocument;
};

export type passportElementPassport$Input = {
  readonly _: "passportElementPassport";

  /**
   * Passport
   * @type {identityDocument} {@link identityDocument}
   */
  readonly passport?: identityDocument$Input;
};

/** A Telegram Passport element containing the user's driver license */
export type passportElementDriverLicense = {
  _: "passportElementDriverLicense";

  /**
   * Driver license
   * @type {identityDocument} {@link identityDocument}
   */
  driver_license: identityDocument;
};

export type passportElementDriverLicense$Input = {
  readonly _: "passportElementDriverLicense";

  /**
   * Driver license
   * @type {identityDocument} {@link identityDocument}
   */
  readonly driver_license?: identityDocument$Input;
};

/** A Telegram Passport element containing the user's identity card */
export type passportElementIdentityCard = {
  _: "passportElementIdentityCard";

  /**
   * Identity card
   * @type {identityDocument} {@link identityDocument}
   */
  identity_card: identityDocument;
};

export type passportElementIdentityCard$Input = {
  readonly _: "passportElementIdentityCard";

  /**
   * Identity card
   * @type {identityDocument} {@link identityDocument}
   */
  readonly identity_card?: identityDocument$Input;
};

/** A Telegram Passport element containing the user's internal passport */
export type passportElementInternalPassport = {
  _: "passportElementInternalPassport";

  /**
   * Internal passport
   * @type {identityDocument} {@link identityDocument}
   */
  internal_passport: identityDocument;
};

export type passportElementInternalPassport$Input = {
  readonly _: "passportElementInternalPassport";

  /**
   * Internal passport
   * @type {identityDocument} {@link identityDocument}
   */
  readonly internal_passport?: identityDocument$Input;
};

/** A Telegram Passport element containing the user's address */
export type passportElementAddress = {
  _: "passportElementAddress";

  /**
   * Address
   * @type {address} {@link address}
   */
  address: address;
};

export type passportElementAddress$Input = {
  readonly _: "passportElementAddress";

  /**
   * Address
   * @type {address} {@link address}
   */
  readonly address?: address$Input;
};

/** A Telegram Passport element containing the user's utility bill */
export type passportElementUtilityBill = {
  _: "passportElementUtilityBill";

  /**
   * Utility bill
   * @type {personalDocument} {@link personalDocument}
   */
  utility_bill: personalDocument;
};

export type passportElementUtilityBill$Input = {
  readonly _: "passportElementUtilityBill";

  /**
   * Utility bill
   * @type {personalDocument} {@link personalDocument}
   */
  readonly utility_bill?: personalDocument$Input;
};

/** A Telegram Passport element containing the user's bank statement */
export type passportElementBankStatement = {
  _: "passportElementBankStatement";

  /**
   * Bank statement
   * @type {personalDocument} {@link personalDocument}
   */
  bank_statement: personalDocument;
};

export type passportElementBankStatement$Input = {
  readonly _: "passportElementBankStatement";

  /**
   * Bank statement
   * @type {personalDocument} {@link personalDocument}
   */
  readonly bank_statement?: personalDocument$Input;
};

/** A Telegram Passport element containing the user's rental agreement */
export type passportElementRentalAgreement = {
  _: "passportElementRentalAgreement";

  /**
   * Rental agreement
   * @type {personalDocument} {@link personalDocument}
   */
  rental_agreement: personalDocument;
};

export type passportElementRentalAgreement$Input = {
  readonly _: "passportElementRentalAgreement";

  /**
   * Rental agreement
   * @type {personalDocument} {@link personalDocument}
   */
  readonly rental_agreement?: personalDocument$Input;
};

/** A Telegram Passport element containing the user's passport registration pages */
export type passportElementPassportRegistration = {
  _: "passportElementPassportRegistration";

  /**
   * Passport registration pages
   * @type {personalDocument} {@link personalDocument}
   */
  passport_registration: personalDocument;
};

export type passportElementPassportRegistration$Input = {
  readonly _: "passportElementPassportRegistration";

  /**
   * Passport registration pages
   * @type {personalDocument} {@link personalDocument}
   */
  readonly passport_registration?: personalDocument$Input;
};

/** A Telegram Passport element containing the user's temporary registration */
export type passportElementTemporaryRegistration = {
  _: "passportElementTemporaryRegistration";

  /**
   * Temporary registration
   * @type {personalDocument} {@link personalDocument}
   */
  temporary_registration: personalDocument;
};

export type passportElementTemporaryRegistration$Input = {
  readonly _: "passportElementTemporaryRegistration";

  /**
   * Temporary registration
   * @type {personalDocument} {@link personalDocument}
   */
  readonly temporary_registration?: personalDocument$Input;
};

/** A Telegram Passport element containing the user's phone number */
export type passportElementPhoneNumber = {
  _: "passportElementPhoneNumber";

  /**
   * Phone number
   * @type {string} {@link string}
   */
  phone_number: string;
};

export type passportElementPhoneNumber$Input = {
  readonly _: "passportElementPhoneNumber";

  /**
   * Phone number
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/** A Telegram Passport element containing the user's email address */
export type passportElementEmailAddress = {
  _: "passportElementEmailAddress";

  /**
   * Email address
   * @type {string} {@link string}
   */
  email_address: string;
};

export type passportElementEmailAddress$Input = {
  readonly _: "passportElementEmailAddress";

  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/** A Telegram Passport element to be saved containing the user's personal details */
export type inputPassportElementPersonalDetails = {
  _: "inputPassportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  personal_details: personalDetails;
};

export type inputPassportElementPersonalDetails$Input = {
  readonly _: "inputPassportElementPersonalDetails";

  /**
   * Personal details of the user
   * @type {personalDetails} {@link personalDetails}
   */
  readonly personal_details?: personalDetails$Input;
};

/** A Telegram Passport element to be saved containing the user's passport */
export type inputPassportElementPassport = {
  _: "inputPassportElementPassport";

  /**
   * The passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  passport: inputIdentityDocument;
};

export type inputPassportElementPassport$Input = {
  readonly _: "inputPassportElementPassport";

  /**
   * The passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly passport?: inputIdentityDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's driver license */
export type inputPassportElementDriverLicense = {
  _: "inputPassportElementDriverLicense";

  /**
   * The driver license to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  driver_license: inputIdentityDocument;
};

export type inputPassportElementDriverLicense$Input = {
  readonly _: "inputPassportElementDriverLicense";

  /**
   * The driver license to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly driver_license?: inputIdentityDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's identity card */
export type inputPassportElementIdentityCard = {
  _: "inputPassportElementIdentityCard";

  /**
   * The identity card to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  identity_card: inputIdentityDocument;
};

export type inputPassportElementIdentityCard$Input = {
  readonly _: "inputPassportElementIdentityCard";

  /**
   * The identity card to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly identity_card?: inputIdentityDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's internal passport */
export type inputPassportElementInternalPassport = {
  _: "inputPassportElementInternalPassport";

  /**
   * The internal passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  internal_passport: inputIdentityDocument;
};

export type inputPassportElementInternalPassport$Input = {
  readonly _: "inputPassportElementInternalPassport";

  /**
   * The internal passport to be saved
   * @type {inputIdentityDocument} {@link inputIdentityDocument}
   */
  readonly internal_passport?: inputIdentityDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's address */
export type inputPassportElementAddress = {
  _: "inputPassportElementAddress";

  /**
   * The address to be saved
   * @type {address} {@link address}
   */
  address: address;
};

export type inputPassportElementAddress$Input = {
  readonly _: "inputPassportElementAddress";

  /**
   * The address to be saved
   * @type {address} {@link address}
   */
  readonly address?: address$Input;
};

/** A Telegram Passport element to be saved containing the user's utility bill */
export type inputPassportElementUtilityBill = {
  _: "inputPassportElementUtilityBill";

  /**
   * The utility bill to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  utility_bill: inputPersonalDocument;
};

export type inputPassportElementUtilityBill$Input = {
  readonly _: "inputPassportElementUtilityBill";

  /**
   * The utility bill to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly utility_bill?: inputPersonalDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's bank statement */
export type inputPassportElementBankStatement = {
  _: "inputPassportElementBankStatement";

  /**
   * The bank statement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  bank_statement: inputPersonalDocument;
};

export type inputPassportElementBankStatement$Input = {
  readonly _: "inputPassportElementBankStatement";

  /**
   * The bank statement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly bank_statement?: inputPersonalDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's rental agreement */
export type inputPassportElementRentalAgreement = {
  _: "inputPassportElementRentalAgreement";

  /**
   * The rental agreement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  rental_agreement: inputPersonalDocument;
};

export type inputPassportElementRentalAgreement$Input = {
  readonly _: "inputPassportElementRentalAgreement";

  /**
   * The rental agreement to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly rental_agreement?: inputPersonalDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's passport registration */
export type inputPassportElementPassportRegistration = {
  _: "inputPassportElementPassportRegistration";

  /**
   * The passport registration page to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  passport_registration: inputPersonalDocument;
};

export type inputPassportElementPassportRegistration$Input = {
  readonly _: "inputPassportElementPassportRegistration";

  /**
   * The passport registration page to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly passport_registration?: inputPersonalDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's temporary registration */
export type inputPassportElementTemporaryRegistration = {
  _: "inputPassportElementTemporaryRegistration";

  /**
   * The temporary registration document to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  temporary_registration: inputPersonalDocument;
};

export type inputPassportElementTemporaryRegistration$Input = {
  readonly _: "inputPassportElementTemporaryRegistration";

  /**
   * The temporary registration document to be saved
   * @type {inputPersonalDocument} {@link inputPersonalDocument}
   */
  readonly temporary_registration?: inputPersonalDocument$Input;
};

/** A Telegram Passport element to be saved containing the user's phone number */
export type inputPassportElementPhoneNumber = {
  _: "inputPassportElementPhoneNumber";

  /**
   * The phone number to be saved
   * @type {string} {@link string}
   */
  phone_number: string;
};

export type inputPassportElementPhoneNumber$Input = {
  readonly _: "inputPassportElementPhoneNumber";

  /**
   * The phone number to be saved
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/** A Telegram Passport element to be saved containing the user's email address */
export type inputPassportElementEmailAddress = {
  _: "inputPassportElementEmailAddress";

  /**
   * The email address to be saved
   * @type {string} {@link string}
   */
  email_address: string;
};

export type inputPassportElementEmailAddress$Input = {
  readonly _: "inputPassportElementEmailAddress";

  /**
   * The email address to be saved
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/** Contains information about saved Telegram Passport elements */
export type passportElements = {
  _: "passportElements";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  elements: vector<PassportElement>;
};

export type passportElements$Input = {
  readonly _: "passportElements";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  readonly elements?: vector$Input<PassportElement$Input>;
};

/** The element contains an error in an unspecified place. The error will be considered resolved when new data is added */
export type passportElementErrorSourceUnspecified = {
  _: "passportElementErrorSourceUnspecified";
};

export type passportElementErrorSourceUnspecified$Input = {
  readonly _: "passportElementErrorSourceUnspecified";
};

/** One of the data fields contains an error. The error will be considered resolved when the value of the field changes */
export type passportElementErrorSourceDataField = {
  _: "passportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  field_name: string;
};

export type passportElementErrorSourceDataField$Input = {
  readonly _: "passportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  readonly field_name?: string;
};

/** The front side of the document contains an error. The error will be considered resolved when the file with the front side changes */
export type passportElementErrorSourceFrontSide = {
  _: "passportElementErrorSourceFrontSide";
};

export type passportElementErrorSourceFrontSide$Input = {
  readonly _: "passportElementErrorSourceFrontSide";
};

/** The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes */
export type passportElementErrorSourceReverseSide = {
  _: "passportElementErrorSourceReverseSide";
};

export type passportElementErrorSourceReverseSide$Input = {
  readonly _: "passportElementErrorSourceReverseSide";
};

/** The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes */
export type passportElementErrorSourceSelfie = {
  _: "passportElementErrorSourceSelfie";
};

export type passportElementErrorSourceSelfie$Input = {
  readonly _: "passportElementErrorSourceSelfie";
};

/** One of files with the translation of the document contains an error. The error will be considered resolved when the file changes */
export type passportElementErrorSourceTranslationFile = {
  _: "passportElementErrorSourceTranslationFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  file_index: int32;
};

export type passportElementErrorSourceTranslationFile$Input = {
  readonly _: "passportElementErrorSourceTranslationFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  readonly file_index?: int32;
};

/** The translation of the document contains an error. The error will be considered resolved when the list of translation files changes */
export type passportElementErrorSourceTranslationFiles = {
  _: "passportElementErrorSourceTranslationFiles";
};

export type passportElementErrorSourceTranslationFiles$Input = {
  readonly _: "passportElementErrorSourceTranslationFiles";
};

/** The file contains an error. The error will be considered resolved when the file changes */
export type passportElementErrorSourceFile = {
  _: "passportElementErrorSourceFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  file_index: int32;
};

export type passportElementErrorSourceFile$Input = {
  readonly _: "passportElementErrorSourceFile";

  /**
   * Index of a file with the error
   * @type {int32} {@link int32}
   */
  readonly file_index?: int32;
};

/** The list of attached files contains an error. The error will be considered resolved when the list of files changes */
export type passportElementErrorSourceFiles = {
  _: "passportElementErrorSourceFiles";
};

export type passportElementErrorSourceFiles$Input = {
  readonly _: "passportElementErrorSourceFiles";
};

/** Contains the description of an error in a Telegram Passport element */
export type passportElementError = {
  _: "passportElementError";

  /**
   * Type of the Telegram Passport element which has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * Error message
   * @type {string} {@link string}
   */
  message: string;

  /**
   * Error source
   * @type {PassportElementErrorSource} {@link PassportElementErrorSource}
   */
  source: PassportElementErrorSource;
};

export type passportElementError$Input = {
  readonly _: "passportElementError";

  /**
   * Type of the Telegram Passport element which has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * Error message
   * @type {string} {@link string}
   */
  readonly message?: string;

  /**
   * Error source
   * @type {PassportElementErrorSource} {@link PassportElementErrorSource}
   */
  readonly source?: PassportElementErrorSource$Input;
};

/** Contains information about a Telegram Passport element that was requested by a service */
export type passportSuitableElement = {
  _: "passportSuitableElement";

  /**
   * Type of the element
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * True, if a selfie is required with the identity document
   * @type {Bool} {@link Bool}
   */
  is_selfie_required: Bool;

  /**
   * True, if a certified English translation is required with the document
   * @type {Bool} {@link Bool}
   */
  is_translation_required: Bool;

  /**
   * True, if personal details must include the user's name in the language of their country of residence
   * @type {Bool} {@link Bool}
   */
  is_native_name_required: Bool;
};

export type passportSuitableElement$Input = {
  readonly _: "passportSuitableElement";

  /**
   * Type of the element
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * True, if a selfie is required with the identity document
   * @type {Bool} {@link Bool}
   */
  readonly is_selfie_required?: Bool$Input;

  /**
   * True, if a certified English translation is required with the document
   * @type {Bool} {@link Bool}
   */
  readonly is_translation_required?: Bool$Input;

  /**
   * True, if personal details must include the user's name in the language of their country of residence
   * @type {Bool} {@link Bool}
   */
  readonly is_native_name_required?: Bool$Input;
};

/** Contains a description of the required Telegram Passport element that was requested by a service */
export type passportRequiredElement = {
  _: "passportRequiredElement";

  /**
   * List of Telegram Passport elements any of which is enough to provide
   * @type {vector<passportSuitableElement>} {@link vector<passportSuitableElement>}
   */
  suitable_elements: vector<passportSuitableElement>;
};

export type passportRequiredElement$Input = {
  readonly _: "passportRequiredElement";

  /**
   * List of Telegram Passport elements any of which is enough to provide
   * @type {vector<passportSuitableElement>} {@link vector<passportSuitableElement>}
   */
  readonly suitable_elements?: vector$Input<passportSuitableElement$Input>;
};

/** Contains information about a Telegram Passport authorization form that was requested */
export type passportAuthorizationForm = {
  _: "passportAuthorizationForm";

  /**
   * Unique identifier of the authorization form
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Telegram Passport elements that must be provided to complete the form
   * @type {vector<passportRequiredElement>} {@link vector<passportRequiredElement>}
   */
  required_elements: vector<passportRequiredElement>;

  /**
   * URL for the privacy policy of the service; may be empty
   * @type {string} {@link string}
   */
  privacy_policy_url: string;
};

export type passportAuthorizationForm$Input = {
  readonly _: "passportAuthorizationForm";

  /**
   * Unique identifier of the authorization form
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Telegram Passport elements that must be provided to complete the form
   * @type {vector<passportRequiredElement>} {@link vector<passportRequiredElement>}
   */
  readonly required_elements?: vector$Input<passportRequiredElement$Input>;

  /**
   * URL for the privacy policy of the service; may be empty
   * @type {string} {@link string}
   */
  readonly privacy_policy_url?: string;
};

/** Contains information about a Telegram Passport elements and corresponding errors */
export type passportElementsWithErrors = {
  _: "passportElementsWithErrors";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  elements: vector<PassportElement>;

  /**
   * Errors in the elements that are already available
   * @type {vector<passportElementError>} {@link vector<passportElementError>}
   */
  errors: vector<passportElementError>;
};

export type passportElementsWithErrors$Input = {
  readonly _: "passportElementsWithErrors";

  /**
   * Telegram Passport elements
   * @type {vector<PassportElement>} {@link vector<PassportElement>}
   */
  readonly elements?: vector$Input<PassportElement$Input>;

  /**
   * Errors in the elements that are already available
   * @type {vector<passportElementError>} {@link vector<passportElementError>}
   */
  readonly errors?: vector$Input<passportElementError$Input>;
};

/** Contains encrypted Telegram Passport data credentials */
export type encryptedCredentials = {
  _: "encryptedCredentials";

  /**
   * The encrypted credentials
   * @type {bytes} {@link bytes}
   */
  data: bytes;

  /**
   * The decrypted data hash
   * @type {bytes} {@link bytes}
   */
  hash: bytes;

  /**
   * Secret for data decryption, encrypted with the service's public key
   * @type {bytes} {@link bytes}
   */
  secret: bytes;
};

export type encryptedCredentials$Input = {
  readonly _: "encryptedCredentials";

  /**
   * The encrypted credentials
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;

  /**
   * The decrypted data hash
   * @type {bytes} {@link bytes}
   */
  readonly hash?: bytes;

  /**
   * Secret for data decryption, encrypted with the service's public key
   * @type {bytes} {@link bytes}
   */
  readonly secret?: bytes;
};

/** Contains information about an encrypted Telegram Passport element; for bots only */
export type encryptedPassportElement = {
  _: "encryptedPassportElement";

  /**
   * Type of Telegram Passport element
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * Encrypted JSON-encoded data about the user
   * @type {bytes} {@link bytes}
   */
  data: bytes;

  /**
   * The front side of an identity document
   * @type {datedFile} {@link datedFile}
   */
  front_side: datedFile;

  /**
   * The reverse side of an identity document; may be null
   * @type {datedFile} {@link datedFile}
   */
  reverse_side: datedFile;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  selfie: datedFile;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  translation: vector<datedFile>;

  /**
   * List of attached files
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  files: vector<datedFile>;

  /**
   * Unencrypted data, phone number or email address
   * @type {string} {@link string}
   */
  value: string;

  /**
   * Hash of the entire element
   * @type {string} {@link string}
   */
  hash: string;
};

export type encryptedPassportElement$Input = {
  readonly _: "encryptedPassportElement";

  /**
   * Type of Telegram Passport element
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * Encrypted JSON-encoded data about the user
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;

  /**
   * The front side of an identity document
   * @type {datedFile} {@link datedFile}
   */
  readonly front_side?: datedFile$Input;

  /**
   * The reverse side of an identity document; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly reverse_side?: datedFile$Input;

  /**
   * Selfie with the document; may be null
   * @type {datedFile} {@link datedFile}
   */
  readonly selfie?: datedFile$Input;

  /**
   * List of files containing a certified English translation of the document
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly translation?: vector$Input<datedFile$Input>;

  /**
   * List of attached files
   * @type {vector<datedFile>} {@link vector<datedFile>}
   */
  readonly files?: vector$Input<datedFile$Input>;

  /**
   * Unencrypted data, phone number or email address
   * @type {string} {@link string}
   */
  readonly value?: string;

  /**
   * Hash of the entire element
   * @type {string} {@link string}
   */
  readonly hash?: string;
};

/** The element contains an error in an unspecified place. The error will be considered resolved when new data is added */
export type inputPassportElementErrorSourceUnspecified = {
  _: "inputPassportElementErrorSourceUnspecified";

  /**
   * Current hash of the entire element
   * @type {bytes} {@link bytes}
   */
  element_hash: bytes;
};

export type inputPassportElementErrorSourceUnspecified$Input = {
  readonly _: "inputPassportElementErrorSourceUnspecified";

  /**
   * Current hash of the entire element
   * @type {bytes} {@link bytes}
   */
  readonly element_hash?: bytes;
};

/** A data field contains an error. The error is considered resolved when the field's value changes */
export type inputPassportElementErrorSourceDataField = {
  _: "inputPassportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  field_name: string;

  /**
   * Current data hash
   * @type {bytes} {@link bytes}
   */
  data_hash: bytes;
};

export type inputPassportElementErrorSourceDataField$Input = {
  readonly _: "inputPassportElementErrorSourceDataField";

  /**
   * Field name
   * @type {string} {@link string}
   */
  readonly field_name?: string;

  /**
   * Current data hash
   * @type {bytes} {@link bytes}
   */
  readonly data_hash?: bytes;
};

/** The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes */
export type inputPassportElementErrorSourceFrontSide = {
  _: "inputPassportElementErrorSourceFrontSide";

  /**
   * Current hash of the file containing the front side
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

export type inputPassportElementErrorSourceFrontSide$Input = {
  readonly _: "inputPassportElementErrorSourceFrontSide";

  /**
   * Current hash of the file containing the front side
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes;
};

/** The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes */
export type inputPassportElementErrorSourceReverseSide = {
  _: "inputPassportElementErrorSourceReverseSide";

  /**
   * Current hash of the file containing the reverse side
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

export type inputPassportElementErrorSourceReverseSide$Input = {
  readonly _: "inputPassportElementErrorSourceReverseSide";

  /**
   * Current hash of the file containing the reverse side
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes;
};

/** The selfie contains an error. The error is considered resolved when the file with the selfie changes */
export type inputPassportElementErrorSourceSelfie = {
  _: "inputPassportElementErrorSourceSelfie";

  /**
   * Current hash of the file containing the selfie
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

export type inputPassportElementErrorSourceSelfie$Input = {
  readonly _: "inputPassportElementErrorSourceSelfie";

  /**
   * Current hash of the file containing the selfie
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes;
};

/** One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes */
export type inputPassportElementErrorSourceTranslationFile = {
  _: "inputPassportElementErrorSourceTranslationFile";

  /**
   * Current hash of the file containing the translation
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

export type inputPassportElementErrorSourceTranslationFile$Input = {
  readonly _: "inputPassportElementErrorSourceTranslationFile";

  /**
   * Current hash of the file containing the translation
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes;
};

/** The translation of the document contains an error. The error is considered resolved when the list of files changes */
export type inputPassportElementErrorSourceTranslationFiles = {
  _: "inputPassportElementErrorSourceTranslationFiles";

  /**
   * Current hashes of all files with the translation
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  file_hashes: vector<bytes>;
};

export type inputPassportElementErrorSourceTranslationFiles$Input = {
  readonly _: "inputPassportElementErrorSourceTranslationFiles";

  /**
   * Current hashes of all files with the translation
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  readonly file_hashes?: vector$Input<bytes>;
};

/** The file contains an error. The error is considered resolved when the file changes */
export type inputPassportElementErrorSourceFile = {
  _: "inputPassportElementErrorSourceFile";

  /**
   * Current hash of the file which has the error
   * @type {bytes} {@link bytes}
   */
  file_hash: bytes;
};

export type inputPassportElementErrorSourceFile$Input = {
  readonly _: "inputPassportElementErrorSourceFile";

  /**
   * Current hash of the file which has the error
   * @type {bytes} {@link bytes}
   */
  readonly file_hash?: bytes;
};

/** The list of attached files contains an error. The error is considered resolved when the file list changes */
export type inputPassportElementErrorSourceFiles = {
  _: "inputPassportElementErrorSourceFiles";

  /**
   * Current hashes of all attached files
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  file_hashes: vector<bytes>;
};

export type inputPassportElementErrorSourceFiles$Input = {
  readonly _: "inputPassportElementErrorSourceFiles";

  /**
   * Current hashes of all attached files
   * @type {vector<bytes>} {@link vector<bytes>}
   */
  readonly file_hashes?: vector$Input<bytes>;
};

/** Contains the description of an error in a Telegram Passport element; for bots only */
export type inputPassportElementError = {
  _: "inputPassportElementError";

  /**
   * Type of Telegram Passport element that has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  type: PassportElementType;

  /**
   * Error message
   * @type {string} {@link string}
   */
  message: string;

  /**
   * Error source
   * @type {InputPassportElementErrorSource} {@link InputPassportElementErrorSource}
   */
  source: InputPassportElementErrorSource;
};

export type inputPassportElementError$Input = {
  readonly _: "inputPassportElementError";

  /**
   * Type of Telegram Passport element that has the error
   * @type {PassportElementType} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * Error message
   * @type {string} {@link string}
   */
  readonly message?: string;

  /**
   * Error source
   * @type {InputPassportElementErrorSource} {@link InputPassportElementErrorSource}
   */
  readonly source?: InputPassportElementErrorSource$Input;
};

/** A text message */
export type messageText = {
  _: "messageText";

  /**
   * Text of the message
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * A preview of the web page that's mentioned in the text; may be null
   * @type {webPage} {@link webPage}
   */
  web_page: webPage;
};

export type messageText$Input = {
  readonly _: "messageText";

  /**
   * Text of the message
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * A preview of the web page that's mentioned in the text; may be null
   * @type {webPage} {@link webPage}
   */
  readonly web_page?: webPage$Input;
};

/** An animation message (GIF-style). */
export type messageAnimation = {
  _: "messageAnimation";

  /**
   * The animation description
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Animation caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

export type messageAnimation$Input = {
  readonly _: "messageAnimation";

  /**
   * The animation description
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Animation caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/** An audio message */
export type messageAudio = {
  _: "messageAudio";

  /**
   * The audio description
   * @type {audio} {@link audio}
   */
  audio: audio;

  /**
   * Audio caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type messageAudio$Input = {
  readonly _: "messageAudio";

  /**
   * The audio description
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;

  /**
   * Audio caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** A document message (general file) */
export type messageDocument = {
  _: "messageDocument";

  /**
   * The document description
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Document caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type messageDocument$Input = {
  readonly _: "messageDocument";

  /**
   * The document description
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Document caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** A photo message */
export type messagePhoto = {
  _: "messagePhoto";

  /**
   * The photo description
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if the photo must be blurred and must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

export type messagePhoto$Input = {
  readonly _: "messagePhoto";

  /**
   * The photo description
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Photo caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if the photo must be blurred and must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/** An expired photo message (self-destructed after TTL has elapsed) */
export type messageExpiredPhoto = {
  _: "messageExpiredPhoto";
};

export type messageExpiredPhoto$Input = {
  readonly _: "messageExpiredPhoto";
};

/** A sticker message */
export type messageSticker = {
  _: "messageSticker";

  /**
   * The sticker description
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;

  /**
   * True, if premium animation of the sticker must be played
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;
};

export type messageSticker$Input = {
  readonly _: "messageSticker";

  /**
   * The sticker description
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;

  /**
   * True, if premium animation of the sticker must be played
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;
};

/** A video message */
export type messageVideo = {
  _: "messageVideo";

  /**
   * The video description
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Video caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if the video thumbnail must be blurred and the video must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

export type messageVideo$Input = {
  readonly _: "messageVideo";

  /**
   * The video description
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Video caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if the video thumbnail must be blurred and the video must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/** An expired video message (self-destructed after TTL has elapsed) */
export type messageExpiredVideo = {
  _: "messageExpiredVideo";
};

export type messageExpiredVideo$Input = {
  readonly _: "messageExpiredVideo";
};

/** A video note message */
export type messageVideoNote = {
  _: "messageVideoNote";

  /**
   * The video note description
   * @type {videoNote} {@link videoNote}
   */
  video_note: videoNote;

  /**
   * True, if at least one of the recipients has viewed the video note
   * @type {Bool} {@link Bool}
   */
  is_viewed: Bool;

  /**
   * True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;
};

export type messageVideoNote$Input = {
  readonly _: "messageVideoNote";

  /**
   * The video note description
   * @type {videoNote} {@link videoNote}
   */
  readonly video_note?: videoNote$Input;

  /**
   * True, if at least one of the recipients has viewed the video note
   * @type {Bool} {@link Bool}
   */
  readonly is_viewed?: Bool$Input;

  /**
   * True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;
};

/** A voice note message */
export type messageVoiceNote = {
  _: "messageVoiceNote";

  /**
   * The voice note description
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * Voice note caption
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * True, if at least one of the recipients has listened to the voice note
   * @type {Bool} {@link Bool}
   */
  is_listened: Bool;
};

export type messageVoiceNote$Input = {
  readonly _: "messageVoiceNote";

  /**
   * The voice note description
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * Voice note caption
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * True, if at least one of the recipients has listened to the voice note
   * @type {Bool} {@link Bool}
   */
  readonly is_listened?: Bool$Input;
};

/** A message with a location */
export type messageLocation = {
  _: "messageLocation";

  /**
   * The location description
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Time relative to the message send date, for which the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  live_period: int32;

  /**
   * Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
   * @type {int32} {@link int32}
   */
  expires_in: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
   * @type {int32} {@link int32}
   */
  heading: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only for the message sender
   * @type {int32} {@link int32}
   */
  proximity_alert_radius: int32;
};

export type messageLocation$Input = {
  readonly _: "messageLocation";

  /**
   * The location description
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Time relative to the message send date, for which the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  readonly live_period?: int32;

  /**
   * Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
   * @type {int32} {@link int32}
   */
  readonly expires_in?: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only for the message sender
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/** A message with information about a venue */
export type messageVenue = {
  _: "messageVenue";

  /**
   * The venue description
   * @type {venue} {@link venue}
   */
  venue: venue;
};

export type messageVenue$Input = {
  readonly _: "messageVenue";

  /**
   * The venue description
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;
};

/** A message with a user contact */
export type messageContact = {
  _: "messageContact";

  /**
   * The contact description
   * @type {contact} {@link contact}
   */
  contact: contact;
};

export type messageContact$Input = {
  readonly _: "messageContact";

  /**
   * The contact description
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;
};

/** A message with an animated emoji */
export type messageAnimatedEmoji = {
  _: "messageAnimatedEmoji";

  /**
   * The animated emoji
   * @type {animatedEmoji} {@link animatedEmoji}
   */
  animated_emoji: animatedEmoji;

  /**
   * The corresponding emoji
   * @type {string} {@link string}
   */
  emoji: string;
};

export type messageAnimatedEmoji$Input = {
  readonly _: "messageAnimatedEmoji";

  /**
   * The animated emoji
   * @type {animatedEmoji} {@link animatedEmoji}
   */
  readonly animated_emoji?: animatedEmoji$Input;

  /**
   * The corresponding emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/** A dice message. The dice value is randomly generated by the server */
export type messageDice = {
  _: "messageDice";

  /**
   * The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  initial_state: DiceStickers;

  /**
   * The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  final_state: DiceStickers;

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * The dice value. If the value is 0, the dice don't have final state yet
   * @type {int32} {@link int32}
   */
  value: int32;

  /**
   * Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
   * @type {int32} {@link int32}
   */
  success_animation_frame_number: int32;
};

export type messageDice$Input = {
  readonly _: "messageDice";

  /**
   * The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  readonly initial_state?: DiceStickers$Input;

  /**
   * The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
   * @type {DiceStickers} {@link DiceStickers}
   */
  readonly final_state?: DiceStickers$Input;

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * The dice value. If the value is 0, the dice don't have final state yet
   * @type {int32} {@link int32}
   */
  readonly value?: int32;

  /**
   * Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
   * @type {int32} {@link int32}
   */
  readonly success_animation_frame_number?: int32;
};

/** A message with a game */
export type messageGame = {
  _: "messageGame";

  /**
   * The game description
   * @type {game} {@link game}
   */
  game: game;
};

export type messageGame$Input = {
  readonly _: "messageGame";

  /**
   * The game description
   * @type {game} {@link game}
   */
  readonly game?: game$Input;
};

/** A message with a poll */
export type messagePoll = {
  _: "messagePoll";

  /**
   * The poll description
   * @type {poll} {@link poll}
   */
  poll: poll;
};

export type messagePoll$Input = {
  readonly _: "messagePoll";

  /**
   * The poll description
   * @type {poll} {@link poll}
   */
  readonly poll?: poll$Input;
};

/** A message with an invoice from a bot */
export type messageInvoice = {
  _: "messageInvoice";

  /**
   * Product title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * A message with an invoice from a bot
   * @type {formattedText} {@link formattedText}
   */
  description: formattedText;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Product total price in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * True, if the invoice is a test invoice
   * @type {Bool} {@link Bool}
   */
  is_test: Bool;

  /**
   * True, if the shipping address must be specified
   * @type {Bool} {@link Bool}
   */
  need_shipping_address: Bool;

  /**
   * The identifier of the message with the receipt, after the product has been purchased
   * @type {int53} {@link int53}
   */
  receipt_message_id: int53;

  /**
   * Extended media attached to the invoice; may be null
   * @type {MessageExtendedMedia} {@link MessageExtendedMedia}
   */
  extended_media: MessageExtendedMedia;
};

export type messageInvoice$Input = {
  readonly _: "messageInvoice";

  /**
   * Product title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * A message with an invoice from a bot
   * @type {formattedText} {@link formattedText}
   */
  readonly description?: formattedText$Input;

  /**
   * Product photo; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Product total price in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * True, if the invoice is a test invoice
   * @type {Bool} {@link Bool}
   */
  readonly is_test?: Bool$Input;

  /**
   * True, if the shipping address must be specified
   * @type {Bool} {@link Bool}
   */
  readonly need_shipping_address?: Bool$Input;

  /**
   * The identifier of the message with the receipt, after the product has been purchased
   * @type {int53} {@link int53}
   */
  readonly receipt_message_id?: int53;

  /**
   * Extended media attached to the invoice; may be null
   * @type {MessageExtendedMedia} {@link MessageExtendedMedia}
   */
  readonly extended_media?: MessageExtendedMedia$Input;
};

/** A message with information about an ended call */
export type messageCall = {
  _: "messageCall";

  /**
   * True, if the call was a video call
   * @type {Bool} {@link Bool}
   */
  is_video: Bool;

  /**
   * Reason why the call was discarded
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  discard_reason: CallDiscardReason;

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;
};

export type messageCall$Input = {
  readonly _: "messageCall";

  /**
   * True, if the call was a video call
   * @type {Bool} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Reason why the call was discarded
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  readonly discard_reason?: CallDiscardReason$Input;

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/** A new video chat was scheduled */
export type messageVideoChatScheduled = {
  _: "messageVideoChatScheduled";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
   * @type {int32} {@link int32}
   */
  start_date: int32;
};

export type messageVideoChatScheduled$Input = {
  readonly _: "messageVideoChatScheduled";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;
};

/** A newly created video chat */
export type messageVideoChatStarted = {
  _: "messageVideoChatStarted";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;
};

export type messageVideoChatStarted$Input = {
  readonly _: "messageVideoChatStarted";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/** A message with information about an ended video chat */
export type messageVideoChatEnded = {
  _: "messageVideoChatEnded";

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;
};

export type messageVideoChatEnded$Input = {
  readonly _: "messageVideoChatEnded";

  /**
   * Call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/** A message with information about an invite to a video chat */
export type messageInviteVideoChatParticipants = {
  _: "messageInviteVideoChatParticipants";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * Invited user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

export type messageInviteVideoChatParticipants$Input = {
  readonly _: "messageInviteVideoChatParticipants";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Invited user identifiers
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/** A newly created basic group */
export type messageBasicGroupChatCreate = {
  _: "messageBasicGroupChatCreate";

  /**
   * Title of the basic group
   * @type {string} {@link string}
   */
  title: string;

  /**
   * User identifiers of members in the basic group
   * @type {vector<int53>} {@link vector<int53>}
   */
  member_user_ids: vector<int53>;
};

export type messageBasicGroupChatCreate$Input = {
  readonly _: "messageBasicGroupChatCreate";

  /**
   * Title of the basic group
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * User identifiers of members in the basic group
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly member_user_ids?: vector$Input<int53>;
};

/** A newly created supergroup or channel */
export type messageSupergroupChatCreate = {
  _: "messageSupergroupChatCreate";

  /**
   * Title of the supergroup or channel
   * @type {string} {@link string}
   */
  title: string;
};

export type messageSupergroupChatCreate$Input = {
  readonly _: "messageSupergroupChatCreate";

  /**
   * Title of the supergroup or channel
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** An updated chat title */
export type messageChatChangeTitle = {
  _: "messageChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  title: string;
};

export type messageChatChangeTitle$Input = {
  readonly _: "messageChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** An updated chat photo */
export type messageChatChangePhoto = {
  _: "messageChatChangePhoto";

  /**
   * New chat photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  photo: chatPhoto;
};

export type messageChatChangePhoto$Input = {
  readonly _: "messageChatChangePhoto";

  /**
   * New chat photo
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly photo?: chatPhoto$Input;
};

/** A deleted chat photo */
export type messageChatDeletePhoto = {
  _: "messageChatDeletePhoto";
};

export type messageChatDeletePhoto$Input = {
  readonly _: "messageChatDeletePhoto";
};

/** New chat members were added */
export type messageChatAddMembers = {
  _: "messageChatAddMembers";

  /**
   * User identifiers of the new members
   * @type {vector<int53>} {@link vector<int53>}
   */
  member_user_ids: vector<int53>;
};

export type messageChatAddMembers$Input = {
  readonly _: "messageChatAddMembers";

  /**
   * User identifiers of the new members
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly member_user_ids?: vector$Input<int53>;
};

/** A new member joined the chat via an invite link */
export type messageChatJoinByLink = {
  _: "messageChatJoinByLink";
};

export type messageChatJoinByLink$Input = {
  readonly _: "messageChatJoinByLink";
};

/** A new member was accepted to the chat by an administrator */
export type messageChatJoinByRequest = {
  _: "messageChatJoinByRequest";
};

export type messageChatJoinByRequest$Input = {
  readonly _: "messageChatJoinByRequest";
};

/** A chat member was deleted */
export type messageChatDeleteMember = {
  _: "messageChatDeleteMember";

  /**
   * User identifier of the deleted chat member
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type messageChatDeleteMember$Input = {
  readonly _: "messageChatDeleteMember";

  /**
   * User identifier of the deleted chat member
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** A basic group was upgraded to a supergroup and was deactivated as the result */
export type messageChatUpgradeTo = {
  _: "messageChatUpgradeTo";

  /**
   * Identifier of the supergroup to which the basic group was upgraded
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;
};

export type messageChatUpgradeTo$Input = {
  readonly _: "messageChatUpgradeTo";

  /**
   * Identifier of the supergroup to which the basic group was upgraded
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/** A supergroup has been created from a basic group */
export type messageChatUpgradeFrom = {
  _: "messageChatUpgradeFrom";

  /**
   * Title of the newly created supergroup
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The identifier of the original basic group
   * @type {int53} {@link int53}
   */
  basic_group_id: int53;
};

export type messageChatUpgradeFrom$Input = {
  readonly _: "messageChatUpgradeFrom";

  /**
   * Title of the newly created supergroup
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The identifier of the original basic group
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/** A message has been pinned */
export type messagePinMessage = {
  _: "messagePinMessage";

  /**
   * Identifier of the pinned message, can be an identifier of a deleted message or 0
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

export type messagePinMessage$Input = {
  readonly _: "messagePinMessage";

  /**
   * Identifier of the pinned message, can be an identifier of a deleted message or 0
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/** A screenshot of a message in the chat has been taken */
export type messageScreenshotTaken = {
  _: "messageScreenshotTaken";
};

export type messageScreenshotTaken$Input = {
  readonly _: "messageScreenshotTaken";
};

/** A theme in the chat has been changed */
export type messageChatSetTheme = {
  _: "messageChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
   * @type {string} {@link string}
   */
  theme_name: string;
};

export type messageChatSetTheme$Input = {
  readonly _: "messageChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/** The TTL (Time To Live) setting for messages in the chat has been changed */
export type messageChatSetTtl = {
  _: "messageChatSetTtl";

  /**
   * New message TTL
   * @type {int32} {@link int32}
   */
  ttl: int32;
};

export type messageChatSetTtl$Input = {
  readonly _: "messageChatSetTtl";

  /**
   * New message TTL
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;
};

/** A forum topic has been created */
export type messageForumTopicCreated = {
  _: "messageForumTopicCreated";

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  icon: forumTopicIcon;
};

export type messageForumTopicCreated$Input = {
  readonly _: "messageForumTopicCreated";

  /**
   * Name of the topic
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic
   * @type {forumTopicIcon} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;
};

/** A forum topic has been edited */
export type messageForumTopicEdited = {
  _: "messageForumTopicEdited";

  /**
   * If non-empty, the new name of the topic
   * @type {string} {@link string}
   */
  name: string;

  /**
   * True, if icon's custom_emoji_id is changed
   * @type {Bool} {@link Bool}
   */
  edit_icon_custom_emoji_id: Bool;

  /**
   * New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
   * @type {int64} {@link int64}
   */
  icon_custom_emoji_id: int64;
};

export type messageForumTopicEdited$Input = {
  readonly _: "messageForumTopicEdited";

  /**
   * If non-empty, the new name of the topic
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * True, if icon's custom_emoji_id is changed
   * @type {Bool} {@link Bool}
   */
  readonly edit_icon_custom_emoji_id?: Bool$Input;

  /**
   * New unique identifier of the custom emoji shown on the topic icon; 0 if none. Must be ignored if edit_icon_custom_emoji_id is false
   * @type {int64} {@link int64}
   */
  readonly icon_custom_emoji_id?: int64;
};

/** A forum topic has been closed or opened */
export type messageForumTopicIsClosedToggled = {
  _: "messageForumTopicIsClosedToggled";

  /**
   * True if the topic was closed or reopened
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

export type messageForumTopicIsClosedToggled$Input = {
  readonly _: "messageForumTopicIsClosedToggled";

  /**
   * True if the topic was closed or reopened
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/** A non-standard action has happened in the chat */
export type messageCustomServiceAction = {
  _: "messageCustomServiceAction";

  /**
   * Message text to be shown in the chat
   * @type {string} {@link string}
   */
  text: string;
};

export type messageCustomServiceAction$Input = {
  readonly _: "messageCustomServiceAction";

  /**
   * Message text to be shown in the chat
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/** A new high score was achieved in a game */
export type messageGameScore = {
  _: "messageGameScore";

  /**
   * Identifier of the message with the game, can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  game_message_id: int53;

  /**
   * Identifier of the game; may be different from the games presented in the message with the game
   * @type {int64} {@link int64}
   */
  game_id: int64;

  /**
   * New score
   * @type {int32} {@link int32}
   */
  score: int32;
};

export type messageGameScore$Input = {
  readonly _: "messageGameScore";

  /**
   * Identifier of the message with the game, can be an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly game_message_id?: int53;

  /**
   * Identifier of the game; may be different from the games presented in the message with the game
   * @type {int64} {@link int64}
   */
  readonly game_id?: int64;

  /**
   * New score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;
};

/** A payment has been completed */
export type messagePaymentSuccessful = {
  _: "messagePaymentSuccessful";

  /**
   * Identifier of the chat, containing the corresponding invoice message
   * @type {int53} {@link int53}
   */
  invoice_chat_id: int53;

  /**
   * Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  invoice_message_id: int53;

  /**
   * Currency for the price of the product
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  is_recurring: Bool;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  is_first_recurring: Bool;

  /**
   * Name of the invoice; may be empty if unknown
   * @type {string} {@link string}
   */
  invoice_name: string;
};

export type messagePaymentSuccessful$Input = {
  readonly _: "messagePaymentSuccessful";

  /**
   * Identifier of the chat, containing the corresponding invoice message
   * @type {int53} {@link int53}
   */
  readonly invoice_chat_id?: int53;

  /**
   * Identifier of the message with the corresponding invoice; can be 0 or an identifier of a deleted message
   * @type {int53} {@link int53}
   */
  readonly invoice_message_id?: int53;

  /**
   * Currency for the price of the product
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_recurring?: Bool$Input;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_first_recurring?: Bool$Input;

  /**
   * Name of the invoice; may be empty if unknown
   * @type {string} {@link string}
   */
  readonly invoice_name?: string;
};

/** A payment has been completed; for bots only */
export type messagePaymentSuccessfulBot = {
  _: "messagePaymentSuccessfulBot";

  /**
   * Currency for price of the product
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  is_recurring: Bool;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  is_first_recurring: Bool;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  invoice_payload: bytes;

  /**
   * Identifier of the shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  shipping_option_id: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  order_info: orderInfo;

  /**
   * Telegram payment identifier
   * @type {string} {@link string}
   */
  telegram_payment_charge_id: string;

  /**
   * Provider payment identifier
   * @type {string} {@link string}
   */
  provider_payment_charge_id: string;
};

export type messagePaymentSuccessfulBot$Input = {
  readonly _: "messagePaymentSuccessfulBot";

  /**
   * Currency for price of the product
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * True, if this is a recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_recurring?: Bool$Input;

  /**
   * True, if this is the first recurring payment
   * @type {Bool} {@link Bool}
   */
  readonly is_first_recurring?: Bool$Input;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  readonly invoice_payload?: bytes;

  /**
   * Identifier of the shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input;

  /**
   * Telegram payment identifier
   * @type {string} {@link string}
   */
  readonly telegram_payment_charge_id?: string;

  /**
   * Provider payment identifier
   * @type {string} {@link string}
   */
  readonly provider_payment_charge_id?: string;
};

/** Telegram Premium was gifted to the user */
export type messageGiftedPremium = {
  _: "messageGiftedPremium";

  /**
   * Currency for the paid amount
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * The paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;

  /**
   * Number of month the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  month_count: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

export type messageGiftedPremium$Input = {
  readonly _: "messageGiftedPremium";

  /**
   * Currency for the paid amount
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * The paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;

  /**
   * Number of month the Telegram Premium subscription will be active
   * @type {int32} {@link int32}
   */
  readonly month_count?: int32;

  /**
   * A sticker to be shown in the message; may be null if unknown
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/** A contact has registered with Telegram */
export type messageContactRegistered = {
  _: "messageContactRegistered";
};

export type messageContactRegistered$Input = {
  readonly _: "messageContactRegistered";
};

/** The current user has connected a website by logging in using Telegram Login Widget on it */
export type messageWebsiteConnected = {
  _: "messageWebsiteConnected";

  /**
   * Domain name of the connected website
   * @type {string} {@link string}
   */
  domain_name: string;
};

export type messageWebsiteConnected$Input = {
  readonly _: "messageWebsiteConnected";

  /**
   * Domain name of the connected website
   * @type {string} {@link string}
   */
  readonly domain_name?: string;
};

/** Data from a Web App has been sent to a bot */
export type messageWebAppDataSent = {
  _: "messageWebAppDataSent";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  button_text: string;
};

export type messageWebAppDataSent$Input = {
  readonly _: "messageWebAppDataSent";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;
};

/** Data from a Web App has been received; for bots only */
export type messageWebAppDataReceived = {
  _: "messageWebAppDataReceived";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  button_text: string;

  /**
   * Received data
   * @type {string} {@link string}
   */
  data: string;
};

export type messageWebAppDataReceived$Input = {
  readonly _: "messageWebAppDataReceived";

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;

  /**
   * Received data
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/** Telegram Passport data has been sent to a bot */
export type messagePassportDataSent = {
  _: "messagePassportDataSent";

  /**
   * List of Telegram Passport element types sent
   * @type {vector<PassportElementType>} {@link vector<PassportElementType>}
   */
  types: vector<PassportElementType>;
};

export type messagePassportDataSent$Input = {
  readonly _: "messagePassportDataSent";

  /**
   * List of Telegram Passport element types sent
   * @type {vector<PassportElementType>} {@link vector<PassportElementType>}
   */
  readonly types?: vector$Input<PassportElementType$Input>;
};

/** Telegram Passport data has been received; for bots only */
export type messagePassportDataReceived = {
  _: "messagePassportDataReceived";

  /**
   * List of received Telegram Passport elements
   * @type {vector<encryptedPassportElement>} {@link vector<encryptedPassportElement>}
   */
  elements: vector<encryptedPassportElement>;

  /**
   * Encrypted data credentials
   * @type {encryptedCredentials} {@link encryptedCredentials}
   */
  credentials: encryptedCredentials;
};

export type messagePassportDataReceived$Input = {
  readonly _: "messagePassportDataReceived";

  /**
   * List of received Telegram Passport elements
   * @type {vector<encryptedPassportElement>} {@link vector<encryptedPassportElement>}
   */
  readonly elements?: vector$Input<encryptedPassportElement$Input>;

  /**
   * Encrypted data credentials
   * @type {encryptedCredentials} {@link encryptedCredentials}
   */
  readonly credentials?: encryptedCredentials$Input;
};

/** A user in the chat came within proximity alert range */
export type messageProximityAlertTriggered = {
  _: "messageProximityAlertTriggered";

  /**
   * The identifier of a user or chat that triggered the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  traveler_id: MessageSender;

  /**
   * The identifier of a user or chat that subscribed for the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  watcher_id: MessageSender;

  /**
   * The distance between the users
   * @type {int32} {@link int32}
   */
  distance: int32;
};

export type messageProximityAlertTriggered$Input = {
  readonly _: "messageProximityAlertTriggered";

  /**
   * The identifier of a user or chat that triggered the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  readonly traveler_id?: MessageSender$Input;

  /**
   * The identifier of a user or chat that subscribed for the proximity alert
   * @type {MessageSender} {@link MessageSender}
   */
  readonly watcher_id?: MessageSender$Input;

  /**
   * The distance between the users
   * @type {int32} {@link int32}
   */
  readonly distance?: int32;
};

/** Message content that is not supported in the current TDLib version */
export type messageUnsupported = {
  _: "messageUnsupported";
};

export type messageUnsupported$Input = {
  readonly _: "messageUnsupported";
};

/** A mention of a user, a supergroup, or a channel by their username */
export type textEntityTypeMention = {
  _: "textEntityTypeMention";
};

export type textEntityTypeMention$Input = {
  readonly _: "textEntityTypeMention";
};

/** A hashtag text, beginning with "#" */
export type textEntityTypeHashtag = {
  _: "textEntityTypeHashtag";
};

export type textEntityTypeHashtag$Input = {
  readonly _: "textEntityTypeHashtag";
};

/** A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD") */
export type textEntityTypeCashtag = {
  _: "textEntityTypeCashtag";
};

export type textEntityTypeCashtag$Input = {
  readonly _: "textEntityTypeCashtag";
};

/** A bot command, beginning with "/" */
export type textEntityTypeBotCommand = {
  _: "textEntityTypeBotCommand";
};

export type textEntityTypeBotCommand$Input = {
  readonly _: "textEntityTypeBotCommand";
};

/** An HTTP URL */
export type textEntityTypeUrl = {
  _: "textEntityTypeUrl";
};

export type textEntityTypeUrl$Input = {
  readonly _: "textEntityTypeUrl";
};

/** An email address */
export type textEntityTypeEmailAddress = {
  _: "textEntityTypeEmailAddress";
};

export type textEntityTypeEmailAddress$Input = {
  readonly _: "textEntityTypeEmailAddress";
};

/** A phone number */
export type textEntityTypePhoneNumber = {
  _: "textEntityTypePhoneNumber";
};

export type textEntityTypePhoneNumber$Input = {
  readonly _: "textEntityTypePhoneNumber";
};

/** A bank card number. The getBankCardInfo method can be used to get information about the bank card */
export type textEntityTypeBankCardNumber = {
  _: "textEntityTypeBankCardNumber";
};

export type textEntityTypeBankCardNumber$Input = {
  readonly _: "textEntityTypeBankCardNumber";
};

/** A bold text */
export type textEntityTypeBold = {
  _: "textEntityTypeBold";
};

export type textEntityTypeBold$Input = {
  readonly _: "textEntityTypeBold";
};

/** An italic text */
export type textEntityTypeItalic = {
  _: "textEntityTypeItalic";
};

export type textEntityTypeItalic$Input = {
  readonly _: "textEntityTypeItalic";
};

/** An underlined text */
export type textEntityTypeUnderline = {
  _: "textEntityTypeUnderline";
};

export type textEntityTypeUnderline$Input = {
  readonly _: "textEntityTypeUnderline";
};

/** A strikethrough text */
export type textEntityTypeStrikethrough = {
  _: "textEntityTypeStrikethrough";
};

export type textEntityTypeStrikethrough$Input = {
  readonly _: "textEntityTypeStrikethrough";
};

/** A spoiler text */
export type textEntityTypeSpoiler = {
  _: "textEntityTypeSpoiler";
};

export type textEntityTypeSpoiler$Input = {
  readonly _: "textEntityTypeSpoiler";
};

/** Text that must be formatted as if inside a code HTML tag */
export type textEntityTypeCode = {
  _: "textEntityTypeCode";
};

export type textEntityTypeCode$Input = {
  readonly _: "textEntityTypeCode";
};

/** Text that must be formatted as if inside a pre HTML tag */
export type textEntityTypePre = {
  _: "textEntityTypePre";
};

export type textEntityTypePre$Input = {
  readonly _: "textEntityTypePre";
};

/** Text that must be formatted as if inside pre, and code HTML tags */
export type textEntityTypePreCode = {
  _: "textEntityTypePreCode";

  /**
   * Programming language of the code; as defined by the sender
   * @type {string} {@link string}
   */
  language: string;
};

export type textEntityTypePreCode$Input = {
  readonly _: "textEntityTypePreCode";

  /**
   * Programming language of the code; as defined by the sender
   * @type {string} {@link string}
   */
  readonly language?: string;
};

/** A text description shown instead of a raw URL */
export type textEntityTypeTextUrl = {
  _: "textEntityTypeTextUrl";

  /**
   * HTTP or tg:// URL to be opened when the link is clicked
   * @type {string} {@link string}
   */
  url: string;
};

export type textEntityTypeTextUrl$Input = {
  readonly _: "textEntityTypeTextUrl";

  /**
   * HTTP or tg:// URL to be opened when the link is clicked
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** A text shows instead of a raw mention of the user (e.g., when the user has no username) */
export type textEntityTypeMentionName = {
  _: "textEntityTypeMentionName";

  /**
   * Identifier of the mentioned user
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type textEntityTypeMentionName$Input = {
  readonly _: "textEntityTypeMentionName";

  /**
   * Identifier of the mentioned user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** A custom emoji. The text behind a custom emoji must be an emoji. Only premium users can use premium custom emoji */
export type textEntityTypeCustomEmoji = {
  _: "textEntityTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  custom_emoji_id: int64;
};

export type textEntityTypeCustomEmoji$Input = {
  readonly _: "textEntityTypeCustomEmoji";

  /**
   * Unique identifier of the custom emoji
   * @type {int64} {@link int64}
   */
  readonly custom_emoji_id?: int64;
};

/** A media timestamp */
export type textEntityTypeMediaTimestamp = {
  _: "textEntityTypeMediaTimestamp";

  /**
   * Timestamp from which a video/audio/video note/voice note playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message
   * @type {int32} {@link int32}
   */
  media_timestamp: int32;
};

export type textEntityTypeMediaTimestamp$Input = {
  readonly _: "textEntityTypeMediaTimestamp";

  /**
   * Timestamp from which a video/audio/video note/voice note playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;
};

/** A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size */
export type inputThumbnail = {
  _: "inputThumbnail";

  /**
   * Thumbnail file to send. Sending thumbnails by file_id is currently not supported
   * @type {InputFile} {@link InputFile}
   */
  thumbnail: InputFile;

  /**
   * Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  height: int32;
};

export type inputThumbnail$Input = {
  readonly _: "inputThumbnail";

  /**
   * Thumbnail file to send. Sending thumbnails by file_id is currently not supported
   * @type {InputFile} {@link InputFile}
   */
  readonly thumbnail?: InputFile$Input;

  /**
   * Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly height?: int32;
};

/** The message will be sent at the specified date */
export type messageSchedulingStateSendAtDate = {
  _: "messageSchedulingStateSendAtDate";

  /**
   * Date the message will be sent. The date must be within 367 days in the future
   * @type {int32} {@link int32}
   */
  send_date: int32;
};

export type messageSchedulingStateSendAtDate$Input = {
  readonly _: "messageSchedulingStateSendAtDate";

  /**
   * Date the message will be sent. The date must be within 367 days in the future
   * @type {int32} {@link int32}
   */
  readonly send_date?: int32;
};

/** The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known */
export type messageSchedulingStateSendWhenOnline = {
  _: "messageSchedulingStateSendWhenOnline";
};

export type messageSchedulingStateSendWhenOnline$Input = {
  readonly _: "messageSchedulingStateSendWhenOnline";
};

/** Options to be used when a message is sent */
export type messageSendOptions = {
  _: "messageSendOptions";

  /**
   * Pass true to disable notification for the message
   * @type {Bool} {@link Bool}
   */
  disable_notification: Bool;

  /**
   * Pass true if the message is sent from the background
   * @type {Bool} {@link Bool}
   */
  from_background: Bool;

  /**
   * Pass true if the content of the message must be protected from forwarding and saving; for bots only
   * @type {Bool} {@link Bool}
   */
  protect_content: Bool;

  /**
   * Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
   * @type {Bool} {@link Bool}
   */
  update_order_of_installed_sticker_sets: Bool;

  /**
   * Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  scheduling_state: MessageSchedulingState;
};

export type messageSendOptions$Input = {
  readonly _: "messageSendOptions";

  /**
   * Pass true to disable notification for the message
   * @type {Bool} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * Pass true if the message is sent from the background
   * @type {Bool} {@link Bool}
   */
  readonly from_background?: Bool$Input;

  /**
   * Pass true if the content of the message must be protected from forwarding and saving; for bots only
   * @type {Bool} {@link Bool}
   */
  readonly protect_content?: Bool$Input;

  /**
   * Pass true if the user explicitly chosen a sticker or a custom emoji from an installed sticker set; applicable only to sendMessage and sendMessageAlbum
   * @type {Bool} {@link Bool}
   */
  readonly update_order_of_installed_sticker_sets?: Bool$Input;

  /**
   * Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
   * @type {MessageSchedulingState} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input;
};

/** Options to be used when a message content is copied without reference to the original sender. Service messages and messageInvoice can't be copied */
export type messageCopyOptions = {
  _: "messageCopyOptions";

  /**
   * True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
   * @type {Bool} {@link Bool}
   */
  send_copy: Bool;

  /**
   * True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
   * @type {Bool} {@link Bool}
   */
  replace_caption: Bool;

  /**
   * New message caption; pass null to copy message without caption. Ignored if replace_caption is false
   * @type {formattedText} {@link formattedText}
   */
  new_caption: formattedText;
};

export type messageCopyOptions$Input = {
  readonly _: "messageCopyOptions";

  /**
   * True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
   * @type {Bool} {@link Bool}
   */
  readonly send_copy?: Bool$Input;

  /**
   * True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
   * @type {Bool} {@link Bool}
   */
  readonly replace_caption?: Bool$Input;

  /**
   * New message caption; pass null to copy message without caption. Ignored if replace_caption is false
   * @type {formattedText} {@link formattedText}
   */
  readonly new_caption?: formattedText$Input;
};

/** A text message */
export type inputMessageText = {
  _: "inputMessageText";

  /**
   * Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * True, if rich web page previews for URLs in the message text must be disabled
   * @type {Bool} {@link Bool}
   */
  disable_web_page_preview: Bool;

  /**
   * True, if a chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  clear_draft: Bool;
};

export type inputMessageText$Input = {
  readonly _: "inputMessageText";

  /**
   * Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * True, if rich web page previews for URLs in the message text must be disabled
   * @type {Bool} {@link Bool}
   */
  readonly disable_web_page_preview?: Bool$Input;

  /**
   * True, if a chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  readonly clear_draft?: Bool$Input;
};

/** An animation message (GIF-style). */
export type inputMessageAnimation = {
  _: "inputMessageAnimation";

  /**
   * Animation file to be sent
   * @type {InputFile} {@link InputFile}
   */
  animation: InputFile;

  /**
   * Animation thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail;

  /**
   * File identifiers of the stickers added to the animation, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Duration of the animation, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Width of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Height of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type inputMessageAnimation$Input = {
  readonly _: "inputMessageAnimation";

  /**
   * Animation file to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly animation?: InputFile$Input;

  /**
   * Animation thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input;

  /**
   * File identifiers of the stickers added to the animation, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Duration of the animation, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Width of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Height of the animation; may be replaced by the server
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** An audio message */
export type inputMessageAudio = {
  _: "inputMessageAudio";

  /**
   * Audio file to be sent
   * @type {InputFile} {@link InputFile}
   */
  audio: InputFile;

  /**
   * Thumbnail of the cover for the album; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  album_cover_thumbnail: inputThumbnail;

  /**
   * Duration of the audio, in seconds; may be replaced by the server
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Title of the audio; 0-64 characters; may be replaced by the server
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Performer of the audio; 0-64 characters, may be replaced by the server
   * @type {string} {@link string}
   */
  performer: string;

  /**
   * Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type inputMessageAudio$Input = {
  readonly _: "inputMessageAudio";

  /**
   * Audio file to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly audio?: InputFile$Input;

  /**
   * Thumbnail of the cover for the album; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly album_cover_thumbnail?: inputThumbnail$Input;

  /**
   * Duration of the audio, in seconds; may be replaced by the server
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Title of the audio; 0-64 characters; may be replaced by the server
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Performer of the audio; 0-64 characters, may be replaced by the server
   * @type {string} {@link string}
   */
  readonly performer?: string;

  /**
   * Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** A document message (general file) */
export type inputMessageDocument = {
  _: "inputMessageDocument";

  /**
   * Document to be sent
   * @type {InputFile} {@link InputFile}
   */
  document: InputFile;

  /**
   * Document thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail;

  /**
   * If true, automatic file type detection will be disabled and the document will always be sent as file. Always true for files sent to secret chats
   * @type {Bool} {@link Bool}
   */
  disable_content_type_detection: Bool;

  /**
   * Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type inputMessageDocument$Input = {
  readonly _: "inputMessageDocument";

  /**
   * Document to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly document?: InputFile$Input;

  /**
   * Document thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input;

  /**
   * If true, automatic file type detection will be disabled and the document will always be sent as file. Always true for files sent to secret chats
   * @type {Bool} {@link Bool}
   */
  readonly disable_content_type_detection?: Bool$Input;

  /**
   * Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** A photo message */
export type inputMessagePhoto = {
  _: "inputMessagePhoto";

  /**
   * Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
   * @type {InputFile} {@link InputFile}
   */
  photo: InputFile;

  /**
   * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail;

  /**
   * File identifiers of the stickers added to the photo, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Photo width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Photo height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
   * @type {int32} {@link int32}
   */
  ttl: int32;
};

export type inputMessagePhoto$Input = {
  readonly _: "inputMessagePhoto";

  /**
   * Photo to send. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20
   * @type {InputFile} {@link InputFile}
   */
  readonly photo?: InputFile$Input;

  /**
   * Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input;

  /**
   * File identifiers of the stickers added to the photo, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Photo width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Photo height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;
};

/** A sticker message */
export type inputMessageSticker = {
  _: "inputMessageSticker";

  /**
   * Sticker to be sent
   * @type {InputFile} {@link InputFile}
   */
  sticker: InputFile;

  /**
   * Sticker thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail;

  /**
   * Sticker width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Sticker height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * Emoji used to choose the sticker
   * @type {string} {@link string}
   */
  emoji: string;
};

export type inputMessageSticker$Input = {
  readonly _: "inputMessageSticker";

  /**
   * Sticker to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * Sticker thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input;

  /**
   * Sticker width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Sticker height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Emoji used to choose the sticker
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/** A video message */
export type inputMessageVideo = {
  _: "inputMessageVideo";

  /**
   * Video to be sent
   * @type {InputFile} {@link InputFile}
   */
  video: InputFile;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail;

  /**
   * File identifiers of the stickers added to the video, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  added_sticker_file_ids: vector<int32>;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Video width
   * @type {int32} {@link int32}
   */
  width: int32;

  /**
   * Video height
   * @type {int32} {@link int32}
   */
  height: int32;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  supports_streaming: Bool;

  /**
   * Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;

  /**
   * Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
   * @type {int32} {@link int32}
   */
  ttl: int32;
};

export type inputMessageVideo$Input = {
  readonly _: "inputMessageVideo";

  /**
   * Video to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly video?: InputFile$Input;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input;

  /**
   * File identifiers of the stickers added to the video, if applicable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly added_sticker_file_ids?: vector$Input<int32>;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Video width
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Video height
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * True, if the video is supposed to be streamed
   * @type {Bool} {@link Bool}
   */
  readonly supports_streaming?: Bool$Input;

  /**
   * Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;

  /**
   * Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;
};

/** A video note message */
export type inputMessageVideoNote = {
  _: "inputMessageVideoNote";

  /**
   * Video note to be sent
   * @type {InputFile} {@link InputFile}
   */
  video_note: InputFile;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  thumbnail: inputThumbnail;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Video width and height; must be positive and not greater than 640
   * @type {int32} {@link int32}
   */
  length: int32;
};

export type inputMessageVideoNote$Input = {
  readonly _: "inputMessageVideoNote";

  /**
   * Video note to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly video_note?: InputFile$Input;

  /**
   * Video thumbnail; pass null to skip thumbnail uploading
   * @type {inputThumbnail} {@link inputThumbnail}
   */
  readonly thumbnail?: inputThumbnail$Input;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Video width and height; must be positive and not greater than 640
   * @type {int32} {@link int32}
   */
  readonly length?: int32;
};

/** A voice note message */
export type inputMessageVoiceNote = {
  _: "inputMessageVoiceNote";

  /**
   * Voice note to be sent
   * @type {InputFile} {@link InputFile}
   */
  voice_note: InputFile;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  waveform: bytes;

  /**
   * Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  caption: formattedText;
};

export type inputMessageVoiceNote$Input = {
  readonly _: "inputMessageVoiceNote";

  /**
   * Voice note to be sent
   * @type {InputFile} {@link InputFile}
   */
  readonly voice_note?: InputFile$Input;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Waveform representation of the voice note in 5-bit format
   * @type {bytes} {@link bytes}
   */
  readonly waveform?: bytes;

  /**
   * Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/** A message with a location */
export type inputMessageLocation = {
  _: "inputMessageLocation";

  /**
   * Location to be sent
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise
   * @type {int32} {@link int32}
   */
  live_period: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  heading: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
   * @type {int32} {@link int32}
   */
  proximity_alert_radius: int32;
};

export type inputMessageLocation$Input = {
  readonly _: "inputMessageLocation";

  /**
   * Location to be sent
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise
   * @type {int32} {@link int32}
   */
  readonly live_period?: int32;

  /**
   * For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/** A message with information about a venue */
export type inputMessageVenue = {
  _: "inputMessageVenue";

  /**
   * Venue to send
   * @type {venue} {@link venue}
   */
  venue: venue;
};

export type inputMessageVenue$Input = {
  readonly _: "inputMessageVenue";

  /**
   * Venue to send
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;
};

/** A message containing a user contact */
export type inputMessageContact = {
  _: "inputMessageContact";

  /**
   * Contact to send
   * @type {contact} {@link contact}
   */
  contact: contact;
};

export type inputMessageContact$Input = {
  readonly _: "inputMessageContact";

  /**
   * Contact to send
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;
};

/** A dice message */
export type inputMessageDice = {
  _: "inputMessageDice";

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * True, if the chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  clear_draft: Bool;
};

export type inputMessageDice$Input = {
  readonly _: "inputMessageDice";

  /**
   * Emoji on which the dice throw animation is based
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * True, if the chat message draft must be deleted
   * @type {Bool} {@link Bool}
   */
  readonly clear_draft?: Bool$Input;
};

/** A message with a game; not supported for channels or secret chats */
export type inputMessageGame = {
  _: "inputMessageGame";

  /**
   * User identifier of the bot that owns the game
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  game_short_name: string;
};

export type inputMessageGame$Input = {
  readonly _: "inputMessageGame";

  /**
   * User identifier of the bot that owns the game
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;
};

/** A message with an invoice; can be used only by bots */
export type inputMessageInvoice = {
  _: "inputMessageInvoice";

  /**
   * Invoice
   * @type {invoice} {@link invoice}
   */
  invoice: invoice;

  /**
   * Product title; 1-32 characters
   * @type {string} {@link string}
   */
  title: string;

  /**
   * A message with an invoice; can be used only by bots
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Product photo URL; optional
   * @type {string} {@link string}
   */
  photo_url: string;

  /**
   * Product photo size
   * @type {int32} {@link int32}
   */
  photo_size: int32;

  /**
   * Product photo width
   * @type {int32} {@link int32}
   */
  photo_width: int32;

  /**
   * Product photo height
   * @type {int32} {@link int32}
   */
  photo_height: int32;

  /**
   * The invoice payload
   * @type {bytes} {@link bytes}
   */
  payload: bytes;

  /**
   * Payment provider token
   * @type {string} {@link string}
   */
  provider_token: string;

  /**
   * JSON-encoded data about the invoice, which will be shared with the payment provider
   * @type {string} {@link string}
   */
  provider_data: string;

  /**
   * Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * The content of extended media attached to the invoice. The content of the message to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  extended_media_content: InputMessageContent;
};

export type inputMessageInvoice$Input = {
  readonly _: "inputMessageInvoice";

  /**
   * Invoice
   * @type {invoice} {@link invoice}
   */
  readonly invoice?: invoice$Input;

  /**
   * Product title; 1-32 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * A message with an invoice; can be used only by bots
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Product photo URL; optional
   * @type {string} {@link string}
   */
  readonly photo_url?: string;

  /**
   * Product photo size
   * @type {int32} {@link int32}
   */
  readonly photo_size?: int32;

  /**
   * Product photo width
   * @type {int32} {@link int32}
   */
  readonly photo_width?: int32;

  /**
   * Product photo height
   * @type {int32} {@link int32}
   */
  readonly photo_height?: int32;

  /**
   * The invoice payload
   * @type {bytes} {@link bytes}
   */
  readonly payload?: bytes;

  /**
   * Payment provider token
   * @type {string} {@link string}
   */
  readonly provider_token?: string;

  /**
   * JSON-encoded data about the invoice, which will be shared with the payment provider
   * @type {string} {@link string}
   */
  readonly provider_data?: string;

  /**
   * Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * The content of extended media attached to the invoice. The content of the message to be sent. Must be one of the following types: inputMessagePhoto, inputMessageVideo
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly extended_media_content?: InputMessageContent$Input;
};

/** A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot */
export type inputMessagePoll = {
  _: "inputMessagePoll";

  /**
   * Poll question; 1-255 characters (up to 300 characters for bots)
   * @type {string} {@link string}
   */
  question: string;

  /**
   * List of poll answer options, 2-10 strings 1-100 characters each
   * @type {vector<string>} {@link vector<string>}
   */
  options: vector<string>;

  /**
   * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
   * @type {Bool} {@link Bool}
   */
  is_anonymous: Bool;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  type: PollType;

  /**
   * Amount of time the poll will be active after creation, in seconds; for bots only
   * @type {int32} {@link int32}
   */
  open_period: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
   * @type {int32} {@link int32}
   */
  close_date: int32;

  /**
   * True, if the poll needs to be sent already closed; for bots only
   * @type {Bool} {@link Bool}
   */
  is_closed: Bool;
};

export type inputMessagePoll$Input = {
  readonly _: "inputMessagePoll";

  /**
   * Poll question; 1-255 characters (up to 300 characters for bots)
   * @type {string} {@link string}
   */
  readonly question?: string;

  /**
   * List of poll answer options, 2-10 strings 1-100 characters each
   * @type {vector<string>} {@link vector<string>}
   */
  readonly options?: vector$Input<string>;

  /**
   * True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
   * @type {Bool} {@link Bool}
   */
  readonly is_anonymous?: Bool$Input;

  /**
   * Type of the poll
   * @type {PollType} {@link PollType}
   */
  readonly type?: PollType$Input;

  /**
   * Amount of time the poll will be active after creation, in seconds; for bots only
   * @type {int32} {@link int32}
   */
  readonly open_period?: int32;

  /**
   * Point in time (Unix timestamp) when the poll will automatically be closed; for bots only
   * @type {int32} {@link int32}
   */
  readonly close_date?: int32;

  /**
   * True, if the poll needs to be sent already closed; for bots only
   * @type {Bool} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/** A forwarded message */
export type inputMessageForwarded = {
  _: "inputMessageForwarded";

  /**
   * Identifier for the chat this forwarded message came from
   * @type {int53} {@link int53}
   */
  from_chat_id: int53;

  /**
   * Identifier of the message to forward
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * True, if a game message is being shared from a launched game; applies only to game messages
   * @type {Bool} {@link Bool}
   */
  in_game_share: Bool;

  /**
   * Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
   * @type {messageCopyOptions} {@link messageCopyOptions}
   */
  copy_options: messageCopyOptions;
};

export type inputMessageForwarded$Input = {
  readonly _: "inputMessageForwarded";

  /**
   * Identifier for the chat this forwarded message came from
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * Identifier of the message to forward
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * True, if a game message is being shared from a launched game; applies only to game messages
   * @type {Bool} {@link Bool}
   */
  readonly in_game_share?: Bool$Input;

  /**
   * Options to be used to copy content of the message without reference to the original sender; pass null to forward the message as usual
   * @type {messageCopyOptions} {@link messageCopyOptions}
   */
  readonly copy_options?: messageCopyOptions$Input;
};

/** Returns all found messages, no filter is applied */
export type searchMessagesFilterEmpty = {
  _: "searchMessagesFilterEmpty";
};

export type searchMessagesFilterEmpty$Input = {
  readonly _: "searchMessagesFilterEmpty";
};

/** Returns only animation messages */
export type searchMessagesFilterAnimation = {
  _: "searchMessagesFilterAnimation";
};

export type searchMessagesFilterAnimation$Input = {
  readonly _: "searchMessagesFilterAnimation";
};

/** Returns only audio messages */
export type searchMessagesFilterAudio = {
  _: "searchMessagesFilterAudio";
};

export type searchMessagesFilterAudio$Input = {
  readonly _: "searchMessagesFilterAudio";
};

/** Returns only document messages */
export type searchMessagesFilterDocument = {
  _: "searchMessagesFilterDocument";
};

export type searchMessagesFilterDocument$Input = {
  readonly _: "searchMessagesFilterDocument";
};

/** Returns only photo messages */
export type searchMessagesFilterPhoto = {
  _: "searchMessagesFilterPhoto";
};

export type searchMessagesFilterPhoto$Input = {
  readonly _: "searchMessagesFilterPhoto";
};

/** Returns only video messages */
export type searchMessagesFilterVideo = {
  _: "searchMessagesFilterVideo";
};

export type searchMessagesFilterVideo$Input = {
  readonly _: "searchMessagesFilterVideo";
};

/** Returns only voice note messages */
export type searchMessagesFilterVoiceNote = {
  _: "searchMessagesFilterVoiceNote";
};

export type searchMessagesFilterVoiceNote$Input = {
  readonly _: "searchMessagesFilterVoiceNote";
};

/** Returns only photo and video messages */
export type searchMessagesFilterPhotoAndVideo = {
  _: "searchMessagesFilterPhotoAndVideo";
};

export type searchMessagesFilterPhotoAndVideo$Input = {
  readonly _: "searchMessagesFilterPhotoAndVideo";
};

/** Returns only messages containing URLs */
export type searchMessagesFilterUrl = {
  _: "searchMessagesFilterUrl";
};

export type searchMessagesFilterUrl$Input = {
  readonly _: "searchMessagesFilterUrl";
};

/** Returns only messages containing chat photos */
export type searchMessagesFilterChatPhoto = {
  _: "searchMessagesFilterChatPhoto";
};

export type searchMessagesFilterChatPhoto$Input = {
  readonly _: "searchMessagesFilterChatPhoto";
};

/** Returns only video note messages */
export type searchMessagesFilterVideoNote = {
  _: "searchMessagesFilterVideoNote";
};

export type searchMessagesFilterVideoNote$Input = {
  readonly _: "searchMessagesFilterVideoNote";
};

/** Returns only voice and video note messages */
export type searchMessagesFilterVoiceAndVideoNote = {
  _: "searchMessagesFilterVoiceAndVideoNote";
};

export type searchMessagesFilterVoiceAndVideoNote$Input = {
  readonly _: "searchMessagesFilterVoiceAndVideoNote";
};

/** Returns only messages with mentions of the current user, or messages that are replies to their messages */
export type searchMessagesFilterMention = {
  _: "searchMessagesFilterMention";
};

export type searchMessagesFilterMention$Input = {
  readonly _: "searchMessagesFilterMention";
};

/** Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user */
export type searchMessagesFilterUnreadMention = {
  _: "searchMessagesFilterUnreadMention";
};

export type searchMessagesFilterUnreadMention$Input = {
  readonly _: "searchMessagesFilterUnreadMention";
};

/** Returns only messages with unread reactions for the current user. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user */
export type searchMessagesFilterUnreadReaction = {
  _: "searchMessagesFilterUnreadReaction";
};

export type searchMessagesFilterUnreadReaction$Input = {
  readonly _: "searchMessagesFilterUnreadReaction";
};

/** Returns only failed to send messages. This filter can be used only if the message database is used */
export type searchMessagesFilterFailedToSend = {
  _: "searchMessagesFilterFailedToSend";
};

export type searchMessagesFilterFailedToSend$Input = {
  readonly _: "searchMessagesFilterFailedToSend";
};

/** Returns only pinned messages */
export type searchMessagesFilterPinned = {
  _: "searchMessagesFilterPinned";
};

export type searchMessagesFilterPinned$Input = {
  readonly _: "searchMessagesFilterPinned";
};

/** The user is typing a message */
export type chatActionTyping = {
  _: "chatActionTyping";
};

export type chatActionTyping$Input = {
  readonly _: "chatActionTyping";
};

/** The user is recording a video */
export type chatActionRecordingVideo = {
  _: "chatActionRecordingVideo";
};

export type chatActionRecordingVideo$Input = {
  readonly _: "chatActionRecordingVideo";
};

/** The user is uploading a video */
export type chatActionUploadingVideo = {
  _: "chatActionUploadingVideo";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

export type chatActionUploadingVideo$Input = {
  readonly _: "chatActionUploadingVideo";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/** The user is recording a voice note */
export type chatActionRecordingVoiceNote = {
  _: "chatActionRecordingVoiceNote";
};

export type chatActionRecordingVoiceNote$Input = {
  readonly _: "chatActionRecordingVoiceNote";
};

/** The user is uploading a voice note */
export type chatActionUploadingVoiceNote = {
  _: "chatActionUploadingVoiceNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

export type chatActionUploadingVoiceNote$Input = {
  readonly _: "chatActionUploadingVoiceNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/** The user is uploading a photo */
export type chatActionUploadingPhoto = {
  _: "chatActionUploadingPhoto";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

export type chatActionUploadingPhoto$Input = {
  readonly _: "chatActionUploadingPhoto";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/** The user is uploading a document */
export type chatActionUploadingDocument = {
  _: "chatActionUploadingDocument";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

export type chatActionUploadingDocument$Input = {
  readonly _: "chatActionUploadingDocument";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/** The user is picking a sticker to send */
export type chatActionChoosingSticker = {
  _: "chatActionChoosingSticker";
};

export type chatActionChoosingSticker$Input = {
  readonly _: "chatActionChoosingSticker";
};

/** The user is picking a location or venue to send */
export type chatActionChoosingLocation = {
  _: "chatActionChoosingLocation";
};

export type chatActionChoosingLocation$Input = {
  readonly _: "chatActionChoosingLocation";
};

/** The user is picking a contact to send */
export type chatActionChoosingContact = {
  _: "chatActionChoosingContact";
};

export type chatActionChoosingContact$Input = {
  readonly _: "chatActionChoosingContact";
};

/** The user has started to play a game */
export type chatActionStartPlayingGame = {
  _: "chatActionStartPlayingGame";
};

export type chatActionStartPlayingGame$Input = {
  readonly _: "chatActionStartPlayingGame";
};

/** The user is recording a video note */
export type chatActionRecordingVideoNote = {
  _: "chatActionRecordingVideoNote";
};

export type chatActionRecordingVideoNote$Input = {
  readonly _: "chatActionRecordingVideoNote";
};

/** The user is uploading a video note */
export type chatActionUploadingVideoNote = {
  _: "chatActionUploadingVideoNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  progress: int32;
};

export type chatActionUploadingVideoNote$Input = {
  readonly _: "chatActionUploadingVideoNote";

  /**
   * Upload progress, as a percentage
   * @type {int32} {@link int32}
   */
  readonly progress?: int32;
};

/** The user is watching animations sent by the other party by clicking on an animated emoji */
export type chatActionWatchingAnimations = {
  _: "chatActionWatchingAnimations";

  /**
   * The animated emoji
   * @type {string} {@link string}
   */
  emoji: string;
};

export type chatActionWatchingAnimations$Input = {
  readonly _: "chatActionWatchingAnimations";

  /**
   * The animated emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/** The user has canceled the previous action */
export type chatActionCancel = {
  _: "chatActionCancel";
};

export type chatActionCancel$Input = {
  readonly _: "chatActionCancel";
};

/** The user status was never changed */
export type userStatusEmpty = {
  _: "userStatusEmpty";
};

export type userStatusEmpty$Input = {
  readonly _: "userStatusEmpty";
};

/** The user is online */
export type userStatusOnline = {
  _: "userStatusOnline";

  /**
   * Point in time (Unix timestamp) when the user's online status will expire
   * @type {int32} {@link int32}
   */
  expires: int32;
};

export type userStatusOnline$Input = {
  readonly _: "userStatusOnline";

  /**
   * Point in time (Unix timestamp) when the user's online status will expire
   * @type {int32} {@link int32}
   */
  readonly expires?: int32;
};

/** The user is offline */
export type userStatusOffline = {
  _: "userStatusOffline";

  /**
   * Point in time (Unix timestamp) when the user was last online
   * @type {int32} {@link int32}
   */
  was_online: int32;
};

export type userStatusOffline$Input = {
  readonly _: "userStatusOffline";

  /**
   * Point in time (Unix timestamp) when the user was last online
   * @type {int32} {@link int32}
   */
  readonly was_online?: int32;
};

/** The user was online recently */
export type userStatusRecently = {
  _: "userStatusRecently";
};

export type userStatusRecently$Input = {
  readonly _: "userStatusRecently";
};

/** The user is offline, but was online last week */
export type userStatusLastWeek = {
  _: "userStatusLastWeek";
};

export type userStatusLastWeek$Input = {
  readonly _: "userStatusLastWeek";
};

/** The user is offline, but was online last month */
export type userStatusLastMonth = {
  _: "userStatusLastMonth";
};

export type userStatusLastMonth$Input = {
  readonly _: "userStatusLastMonth";
};

/** Represents a list of stickers */
export type stickers = {
  _: "stickers";

  /**
   * List of stickers
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  stickers: vector<sticker>;
};

export type stickers$Input = {
  readonly _: "stickers";

  /**
   * List of stickers
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  readonly stickers?: vector$Input<sticker$Input>;
};

/** Represents a list of emoji */
export type emojis = {
  _: "emojis";

  /**
   * List of emojis
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

export type emojis$Input = {
  readonly _: "emojis";

  /**
   * List of emojis
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/** Represents a sticker set */
export type stickerSet = {
  _: "stickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  thumbnail_outline: vector<closedVectorPath>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  is_installed: Bool;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  is_archived: Bool;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  is_official: Bool;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  sticker_format: StickerFormat;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  is_viewed: Bool;

  /**
   * List of stickers in this set
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  stickers: vector<sticker>;

  /**
   * A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
   * @type {vector<emojis>} {@link vector<emojis>}
   */
  emojis: vector<emojis>;
};

export type stickerSet$Input = {
  readonly _: "stickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  readonly thumbnail_outline?: vector$Input<closedVectorPath$Input>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  readonly is_archived?: Bool$Input;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  readonly is_official?: Bool$Input;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  readonly is_viewed?: Bool$Input;

  /**
   * List of stickers in this set
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  readonly stickers?: vector$Input<sticker$Input>;

  /**
   * A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
   * @type {vector<emojis>} {@link vector<emojis>}
   */
  readonly emojis?: vector$Input<emojis$Input>;
};

/** Represents short information about a sticker set */
export type stickerSetInfo = {
  _: "stickerSetInfo";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  thumbnail_outline: vector<closedVectorPath>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  is_installed: Bool;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  is_archived: Bool;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  is_official: Bool;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  sticker_format: StickerFormat;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  is_viewed: Bool;

  /**
   * Total number of stickers in the set
   * @type {int32} {@link int32}
   */
  size: int32;

  /**
   * Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  covers: vector<sticker>;
};

export type stickerSetInfo$Input = {
  readonly _: "stickerSetInfo";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Title of the sticker set
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker set thumbnail in WEBP, TGS, or WEBM format with width and height 100; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;

  /**
   * Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
   * @type {vector<closedVectorPath>} {@link vector<closedVectorPath>}
   */
  readonly thumbnail_outline?: vector$Input<closedVectorPath$Input>;

  /**
   * True, if the sticker set has been installed by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool} {@link Bool}
   */
  readonly is_archived?: Bool$Input;

  /**
   * True, if the sticker set is official
   * @type {Bool} {@link Bool}
   */
  readonly is_official?: Bool$Input;

  /**
   * Format of the stickers in the set
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly sticker_format?: StickerFormat$Input;

  /**
   * Type of the stickers in the set
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * True for already viewed trending sticker sets
   * @type {Bool} {@link Bool}
   */
  readonly is_viewed?: Bool$Input;

  /**
   * Total number of stickers in the set
   * @type {int32} {@link int32}
   */
  readonly size?: int32;

  /**
   * Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
   * @type {vector<sticker>} {@link vector<sticker>}
   */
  readonly covers?: vector$Input<sticker$Input>;
};

/** Represents a list of sticker sets */
export type stickerSets = {
  _: "stickerSets";

  /**
   * Approximate total number of sticker sets found
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  sets: vector<stickerSetInfo>;
};

export type stickerSets$Input = {
  readonly _: "stickerSets";

  /**
   * Approximate total number of sticker sets found
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  readonly sets?: vector$Input<stickerSetInfo$Input>;
};

/** Represents a list of trending sticker sets */
export type trendingStickerSets = {
  _: "trendingStickerSets";

  /**
   * Approximate total number of trending sticker sets
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of trending sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  sets: vector<stickerSetInfo>;

  /**
   * True, if the list contains sticker sets with premium stickers
   * @type {Bool} {@link Bool}
   */
  is_premium: Bool;
};

export type trendingStickerSets$Input = {
  readonly _: "trendingStickerSets";

  /**
   * Approximate total number of trending sticker sets
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of trending sticker sets
   * @type {vector<stickerSetInfo>} {@link vector<stickerSetInfo>}
   */
  readonly sets?: vector$Input<stickerSetInfo$Input>;

  /**
   * True, if the list contains sticker sets with premium stickers
   * @type {Bool} {@link Bool}
   */
  readonly is_premium?: Bool$Input;
};

/** The call wasn't discarded, or the reason is unknown */
export type callDiscardReasonEmpty = {
  _: "callDiscardReasonEmpty";
};

export type callDiscardReasonEmpty$Input = {
  readonly _: "callDiscardReasonEmpty";
};

/** The call was ended before the conversation started. It was canceled by the caller or missed by the other party */
export type callDiscardReasonMissed = {
  _: "callDiscardReasonMissed";
};

export type callDiscardReasonMissed$Input = {
  readonly _: "callDiscardReasonMissed";
};

/** The call was ended before the conversation started. It was declined by the other party */
export type callDiscardReasonDeclined = {
  _: "callDiscardReasonDeclined";
};

export type callDiscardReasonDeclined$Input = {
  readonly _: "callDiscardReasonDeclined";
};

/** The call was ended during the conversation because the users were disconnected */
export type callDiscardReasonDisconnected = {
  _: "callDiscardReasonDisconnected";
};

export type callDiscardReasonDisconnected$Input = {
  readonly _: "callDiscardReasonDisconnected";
};

/** The call was ended because one of the parties hung up */
export type callDiscardReasonHungUp = {
  _: "callDiscardReasonHungUp";
};

export type callDiscardReasonHungUp$Input = {
  readonly _: "callDiscardReasonHungUp";
};

/** Specifies the supported call protocols */
export type callProtocol = {
  _: "callProtocol";

  /**
   * True, if UDP peer-to-peer connections are supported
   * @type {Bool} {@link Bool}
   */
  udp_p2p: Bool;

  /**
   * True, if connection through UDP reflectors is supported
   * @type {Bool} {@link Bool}
   */
  udp_reflector: Bool;

  /**
   * The minimum supported API layer; use 65
   * @type {int32} {@link int32}
   */
  min_layer: int32;

  /**
   * The maximum supported API layer; use 65
   * @type {int32} {@link int32}
   */
  max_layer: int32;

  /**
   * List of supported tgcalls versions
   * @type {vector<string>} {@link vector<string>}
   */
  library_versions: vector<string>;
};

export type callProtocol$Input = {
  readonly _: "callProtocol";

  /**
   * True, if UDP peer-to-peer connections are supported
   * @type {Bool} {@link Bool}
   */
  readonly udp_p2p?: Bool$Input;

  /**
   * True, if connection through UDP reflectors is supported
   * @type {Bool} {@link Bool}
   */
  readonly udp_reflector?: Bool$Input;

  /**
   * The minimum supported API layer; use 65
   * @type {int32} {@link int32}
   */
  readonly min_layer?: int32;

  /**
   * The maximum supported API layer; use 65
   * @type {int32} {@link int32}
   */
  readonly max_layer?: int32;

  /**
   * List of supported tgcalls versions
   * @type {vector<string>} {@link vector<string>}
   */
  readonly library_versions?: vector$Input<string>;
};

/** A Telegram call reflector */
export type callServerTypeTelegramReflector = {
  _: "callServerTypeTelegramReflector";

  /**
   * A peer tag to be used with the reflector
   * @type {bytes} {@link bytes}
   */
  peer_tag: bytes;

  /**
   * True, if the server uses TCP instead of UDP
   * @type {Bool} {@link Bool}
   */
  is_tcp: Bool;
};

export type callServerTypeTelegramReflector$Input = {
  readonly _: "callServerTypeTelegramReflector";

  /**
   * A peer tag to be used with the reflector
   * @type {bytes} {@link bytes}
   */
  readonly peer_tag?: bytes;

  /**
   * True, if the server uses TCP instead of UDP
   * @type {Bool} {@link Bool}
   */
  readonly is_tcp?: Bool$Input;
};

/** A WebRTC server */
export type callServerTypeWebrtc = {
  _: "callServerTypeWebrtc";

  /**
   * Username to be used for authentication
   * @type {string} {@link string}
   */
  username: string;

  /**
   * Authentication password
   * @type {string} {@link string}
   */
  password: string;

  /**
   * True, if the server supports TURN
   * @type {Bool} {@link Bool}
   */
  supports_turn: Bool;

  /**
   * True, if the server supports STUN
   * @type {Bool} {@link Bool}
   */
  supports_stun: Bool;
};

export type callServerTypeWebrtc$Input = {
  readonly _: "callServerTypeWebrtc";

  /**
   * Username to be used for authentication
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Authentication password
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * True, if the server supports TURN
   * @type {Bool} {@link Bool}
   */
  readonly supports_turn?: Bool$Input;

  /**
   * True, if the server supports STUN
   * @type {Bool} {@link Bool}
   */
  readonly supports_stun?: Bool$Input;
};

/** Describes a server for relaying call data */
export type callServer = {
  _: "callServer";

  /**
   * Server identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Server IPv4 address
   * @type {string} {@link string}
   */
  ip_address: string;

  /**
   * Server IPv6 address
   * @type {string} {@link string}
   */
  ipv6_address: string;

  /**
   * Server port number
   * @type {int32} {@link int32}
   */
  port: int32;

  /**
   * Server type
   * @type {CallServerType} {@link CallServerType}
   */
  type: CallServerType;
};

export type callServer$Input = {
  readonly _: "callServer";

  /**
   * Server identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Server IPv4 address
   * @type {string} {@link string}
   */
  readonly ip_address?: string;

  /**
   * Server IPv6 address
   * @type {string} {@link string}
   */
  readonly ipv6_address?: string;

  /**
   * Server port number
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Server type
   * @type {CallServerType} {@link CallServerType}
   */
  readonly type?: CallServerType$Input;
};

/** Contains the call identifier */
export type callId = {
  _: "callId";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  id: int32;
};

export type callId$Input = {
  readonly _: "callId";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;
};

/** Contains the group call identifier */
export type groupCallId = {
  _: "groupCallId";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  id: int32;
};

export type groupCallId$Input = {
  readonly _: "groupCallId";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;
};

/** The call is pending, waiting to be accepted by a user */
export type callStatePending = {
  _: "callStatePending";

  /**
   * True, if the call has already been created by the server
   * @type {Bool} {@link Bool}
   */
  is_created: Bool;

  /**
   * True, if the call has already been received by the other party
   * @type {Bool} {@link Bool}
   */
  is_received: Bool;
};

export type callStatePending$Input = {
  readonly _: "callStatePending";

  /**
   * True, if the call has already been created by the server
   * @type {Bool} {@link Bool}
   */
  readonly is_created?: Bool$Input;

  /**
   * True, if the call has already been received by the other party
   * @type {Bool} {@link Bool}
   */
  readonly is_received?: Bool$Input;
};

/** The call has been answered and encryption keys are being exchanged */
export type callStateExchangingKeys = {
  _: "callStateExchangingKeys";
};

export type callStateExchangingKeys$Input = {
  readonly _: "callStateExchangingKeys";
};

/** The call is ready to use */
export type callStateReady = {
  _: "callStateReady";

  /**
   * Call protocols supported by the peer
   * @type {callProtocol} {@link callProtocol}
   */
  protocol: callProtocol;

  /**
   * List of available call servers
   * @type {vector<callServer>} {@link vector<callServer>}
   */
  servers: vector<callServer>;

  /**
   * A JSON-encoded call config
   * @type {string} {@link string}
   */
  config: string;

  /**
   * Call encryption key
   * @type {bytes} {@link bytes}
   */
  encryption_key: bytes;

  /**
   * Encryption key emojis fingerprint
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;

  /**
   * True, if peer-to-peer connection is allowed by users privacy settings
   * @type {Bool} {@link Bool}
   */
  allow_p2p: Bool;
};

export type callStateReady$Input = {
  readonly _: "callStateReady";

  /**
   * Call protocols supported by the peer
   * @type {callProtocol} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;

  /**
   * List of available call servers
   * @type {vector<callServer>} {@link vector<callServer>}
   */
  readonly servers?: vector$Input<callServer$Input>;

  /**
   * A JSON-encoded call config
   * @type {string} {@link string}
   */
  readonly config?: string;

  /**
   * Call encryption key
   * @type {bytes} {@link bytes}
   */
  readonly encryption_key?: bytes;

  /**
   * Encryption key emojis fingerprint
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;

  /**
   * True, if peer-to-peer connection is allowed by users privacy settings
   * @type {Bool} {@link Bool}
   */
  readonly allow_p2p?: Bool$Input;
};

/** The call is hanging up after discardCall has been called */
export type callStateHangingUp = {
  _: "callStateHangingUp";
};

export type callStateHangingUp$Input = {
  readonly _: "callStateHangingUp";
};

/** The call has ended successfully */
export type callStateDiscarded = {
  _: "callStateDiscarded";

  /**
   * The reason, why the call has ended
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  reason: CallDiscardReason;

  /**
   * True, if the call rating must be sent to the server
   * @type {Bool} {@link Bool}
   */
  need_rating: Bool;

  /**
   * True, if the call debug information must be sent to the server
   * @type {Bool} {@link Bool}
   */
  need_debug_information: Bool;

  /**
   * True, if the call log must be sent to the server
   * @type {Bool} {@link Bool}
   */
  need_log: Bool;
};

export type callStateDiscarded$Input = {
  readonly _: "callStateDiscarded";

  /**
   * The reason, why the call has ended
   * @type {CallDiscardReason} {@link CallDiscardReason}
   */
  readonly reason?: CallDiscardReason$Input;

  /**
   * True, if the call rating must be sent to the server
   * @type {Bool} {@link Bool}
   */
  readonly need_rating?: Bool$Input;

  /**
   * True, if the call debug information must be sent to the server
   * @type {Bool} {@link Bool}
   */
  readonly need_debug_information?: Bool$Input;

  /**
   * True, if the call log must be sent to the server
   * @type {Bool} {@link Bool}
   */
  readonly need_log?: Bool$Input;
};

/** The call has ended with an error */
export type callStateError = {
  _: "callStateError";

  /**
   * Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
   * @type {error} {@link error}
   */
  error: error;
};

export type callStateError$Input = {
  readonly _: "callStateError";

  /**
   * Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
   * @type {error} {@link error}
   */
  readonly error?: error$Input;
};

/** The worst available video quality */
export type groupCallVideoQualityThumbnail = {
  _: "groupCallVideoQualityThumbnail";
};

export type groupCallVideoQualityThumbnail$Input = {
  readonly _: "groupCallVideoQualityThumbnail";
};

/** The medium video quality */
export type groupCallVideoQualityMedium = {
  _: "groupCallVideoQualityMedium";
};

export type groupCallVideoQualityMedium$Input = {
  readonly _: "groupCallVideoQualityMedium";
};

/** The best available video quality */
export type groupCallVideoQualityFull = {
  _: "groupCallVideoQualityFull";
};

export type groupCallVideoQualityFull$Input = {
  readonly _: "groupCallVideoQualityFull";
};

/** Describes an available stream in a group call */
export type groupCallStream = {
  _: "groupCallStream";

  /**
   * Identifier of an audio/video channel
   * @type {int32} {@link int32}
   */
  channel_id: int32;

  /**
   * Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  scale: int32;

  /**
   * Point in time when the stream currently ends; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  time_offset: int53;
};

export type groupCallStream$Input = {
  readonly _: "groupCallStream";

  /**
   * Identifier of an audio/video channel
   * @type {int32} {@link int32}
   */
  readonly channel_id?: int32;

  /**
   * Scale of segment durations in the stream. The duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Point in time when the stream currently ends; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  readonly time_offset?: int53;
};

/** Represents a list of group call streams */
export type groupCallStreams = {
  _: "groupCallStreams";

  /**
   * A list of group call streams
   * @type {vector<groupCallStream>} {@link vector<groupCallStream>}
   */
  streams: vector<groupCallStream>;
};

export type groupCallStreams$Input = {
  readonly _: "groupCallStreams";

  /**
   * A list of group call streams
   * @type {vector<groupCallStream>} {@link vector<groupCallStream>}
   */
  readonly streams?: vector$Input<groupCallStream$Input>;
};

/** Represents an RTMP url */
export type rtmpUrl = {
  _: "rtmpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Stream key
   * @type {string} {@link string}
   */
  stream_key: string;
};

export type rtmpUrl$Input = {
  readonly _: "rtmpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Stream key
   * @type {string} {@link string}
   */
  readonly stream_key?: string;
};

/** Describes a recently speaking participant in a group call */
export type groupCallRecentSpeaker = {
  _: "groupCallRecentSpeaker";

  /**
   * Group call participant identifier
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * True, is the user has spoken recently
   * @type {Bool} {@link Bool}
   */
  is_speaking: Bool;
};

export type groupCallRecentSpeaker$Input = {
  readonly _: "groupCallRecentSpeaker";

  /**
   * Group call participant identifier
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * True, is the user has spoken recently
   * @type {Bool} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;
};

/** Describes a group call */
export type groupCall = {
  _: "groupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Group call title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
   * @type {int32} {@link int32}
   */
  scheduled_start_date: int32;

  /**
   * True, if the group call is scheduled and the current user will receive a notification when the group call will start
   * @type {Bool} {@link Bool}
   */
  enabled_start_notification: Bool;

  /**
   * True, if the call is active
   * @type {Bool} {@link Bool}
   */
  is_active: Bool;

  /**
   * True, if the chat is an RTMP stream instead of an ordinary video chat
   * @type {Bool} {@link Bool}
   */
  is_rtmp_stream: Bool;

  /**
   * True, if the call is joined
   * @type {Bool} {@link Bool}
   */
  is_joined: Bool;

  /**
   * True, if user was kicked from the call because of network loss and the call needs to be rejoined
   * @type {Bool} {@link Bool}
   */
  need_rejoin: Bool;

  /**
   * True, if the current user can manage the group call
   * @type {Bool} {@link Bool}
   */
  can_be_managed: Bool;

  /**
   * Number of participants in the group call
   * @type {int32} {@link int32}
   */
  participant_count: int32;

  /**
   * True, if group call participants, which are muted, aren't returned in participant list
   * @type {Bool} {@link Bool}
   */
  has_hidden_listeners: Bool;

  /**
   * True, if all group call participants are loaded
   * @type {Bool} {@link Bool}
   */
  loaded_all_participants: Bool;

  /**
   * At most 3 recently speaking users in the group call
   * @type {vector<groupCallRecentSpeaker>} {@link vector<groupCallRecentSpeaker>}
   */
  recent_speakers: vector<groupCallRecentSpeaker>;

  /**
   * True, if the current user's video is enabled
   * @type {Bool} {@link Bool}
   */
  is_my_video_enabled: Bool;

  /**
   * True, if the current user's video is paused
   * @type {Bool} {@link Bool}
   */
  is_my_video_paused: Bool;

  /**
   * True, if the current user can broadcast video or share screen
   * @type {Bool} {@link Bool}
   */
  can_enable_video: Bool;

  /**
   * True, if only group call administrators can unmute new participants
   * @type {Bool} {@link Bool}
   */
  mute_new_participants: Bool;

  /**
   * True, if the current user can enable or disable mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  can_toggle_mute_new_participants: Bool;

  /**
   * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
   * @type {int32} {@link int32}
   */
  record_duration: int32;

  /**
   * True, if a video file is being recorded for the call
   * @type {Bool} {@link Bool}
   */
  is_video_recorded: Bool;

  /**
   * Call duration, in seconds; for ended calls only
   * @type {int32} {@link int32}
   */
  duration: int32;
};

export type groupCall$Input = {
  readonly _: "groupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Group call title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
   * @type {int32} {@link int32}
   */
  readonly scheduled_start_date?: int32;

  /**
   * True, if the group call is scheduled and the current user will receive a notification when the group call will start
   * @type {Bool} {@link Bool}
   */
  readonly enabled_start_notification?: Bool$Input;

  /**
   * True, if the call is active
   * @type {Bool} {@link Bool}
   */
  readonly is_active?: Bool$Input;

  /**
   * True, if the chat is an RTMP stream instead of an ordinary video chat
   * @type {Bool} {@link Bool}
   */
  readonly is_rtmp_stream?: Bool$Input;

  /**
   * True, if the call is joined
   * @type {Bool} {@link Bool}
   */
  readonly is_joined?: Bool$Input;

  /**
   * True, if user was kicked from the call because of network loss and the call needs to be rejoined
   * @type {Bool} {@link Bool}
   */
  readonly need_rejoin?: Bool$Input;

  /**
   * True, if the current user can manage the group call
   * @type {Bool} {@link Bool}
   */
  readonly can_be_managed?: Bool$Input;

  /**
   * Number of participants in the group call
   * @type {int32} {@link int32}
   */
  readonly participant_count?: int32;

  /**
   * True, if group call participants, which are muted, aren't returned in participant list
   * @type {Bool} {@link Bool}
   */
  readonly has_hidden_listeners?: Bool$Input;

  /**
   * True, if all group call participants are loaded
   * @type {Bool} {@link Bool}
   */
  readonly loaded_all_participants?: Bool$Input;

  /**
   * At most 3 recently speaking users in the group call
   * @type {vector<groupCallRecentSpeaker>} {@link vector<groupCallRecentSpeaker>}
   */
  readonly recent_speakers?: vector$Input<groupCallRecentSpeaker$Input>;

  /**
   * True, if the current user's video is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;

  /**
   * True, if the current user's video is paused
   * @type {Bool} {@link Bool}
   */
  readonly is_my_video_paused?: Bool$Input;

  /**
   * True, if the current user can broadcast video or share screen
   * @type {Bool} {@link Bool}
   */
  readonly can_enable_video?: Bool$Input;

  /**
   * True, if only group call administrators can unmute new participants
   * @type {Bool} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;

  /**
   * True, if the current user can enable or disable mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  readonly can_toggle_mute_new_participants?: Bool$Input;

  /**
   * Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
   * @type {int32} {@link int32}
   */
  readonly record_duration?: int32;

  /**
   * True, if a video file is being recorded for the call
   * @type {Bool} {@link Bool}
   */
  readonly is_video_recorded?: Bool$Input;

  /**
   * Call duration, in seconds; for ended calls only
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/** Describes a group of video synchronization source identifiers */
export type groupCallVideoSourceGroup = {
  _: "groupCallVideoSourceGroup";

  /**
   * The semantics of sources, one of "SIM" or "FID"
   * @type {string} {@link string}
   */
  semantics: string;

  /**
   * The list of synchronization source identifiers
   * @type {vector<int32>} {@link vector<int32>}
   */
  source_ids: vector<int32>;
};

export type groupCallVideoSourceGroup$Input = {
  readonly _: "groupCallVideoSourceGroup";

  /**
   * The semantics of sources, one of "SIM" or "FID"
   * @type {string} {@link string}
   */
  readonly semantics?: string;

  /**
   * The list of synchronization source identifiers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly source_ids?: vector$Input<int32>;
};

/** Contains information about a group call participant's video channel */
export type groupCallParticipantVideoInfo = {
  _: "groupCallParticipantVideoInfo";

  /**
   * List of synchronization source groups of the video
   * @type {vector<groupCallVideoSourceGroup>} {@link vector<groupCallVideoSourceGroup>}
   */
  source_groups: vector<groupCallVideoSourceGroup>;

  /**
   * Video channel endpoint identifier
   * @type {string} {@link string}
   */
  endpoint_id: string;

  /**
   * True if the video is paused. This flag needs to be ignored, if new video frames are received
   * @type {Bool} {@link Bool}
   */
  is_paused: Bool;
};

export type groupCallParticipantVideoInfo$Input = {
  readonly _: "groupCallParticipantVideoInfo";

  /**
   * List of synchronization source groups of the video
   * @type {vector<groupCallVideoSourceGroup>} {@link vector<groupCallVideoSourceGroup>}
   */
  readonly source_groups?: vector$Input<groupCallVideoSourceGroup$Input>;

  /**
   * Video channel endpoint identifier
   * @type {string} {@link string}
   */
  readonly endpoint_id?: string;

  /**
   * True if the video is paused. This flag needs to be ignored, if new video frames are received
   * @type {Bool} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/** Represents a group call participant */
export type groupCallParticipant = {
  _: "groupCallParticipant";

  /**
   * Identifier of the group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * User's audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  audio_source_id: int32;

  /**
   * User's screen sharing audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  screen_sharing_audio_source_id: int32;

  /**
   * Information about user's video channel; may be null if there is no active video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  video_info: groupCallParticipantVideoInfo;

  /**
   * Information about user's screen sharing video channel; may be null if there is no active screen sharing video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  screen_sharing_video_info: groupCallParticipantVideoInfo;

  /**
   * The participant user's bio or the participant chat's description
   * @type {string} {@link string}
   */
  bio: string;

  /**
   * True, if the participant is the current user
   * @type {Bool} {@link Bool}
   */
  is_current_user: Bool;

  /**
   * True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
   * @type {Bool} {@link Bool}
   */
  is_speaking: Bool;

  /**
   * True, if the participant hand is raised
   * @type {Bool} {@link Bool}
   */
  is_hand_raised: Bool;

  /**
   * True, if the current user can mute the participant for all other group call participants
   * @type {Bool} {@link Bool}
   */
  can_be_muted_for_all_users: Bool;

  /**
   * True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
   * @type {Bool} {@link Bool}
   */
  can_be_unmuted_for_all_users: Bool;

  /**
   * True, if the current user can mute the participant only for self
   * @type {Bool} {@link Bool}
   */
  can_be_muted_for_current_user: Bool;

  /**
   * True, if the current user can unmute the participant for self
   * @type {Bool} {@link Bool}
   */
  can_be_unmuted_for_current_user: Bool;

  /**
   * True, if the participant is muted for all users
   * @type {Bool} {@link Bool}
   */
  is_muted_for_all_users: Bool;

  /**
   * True, if the participant is muted for the current user
   * @type {Bool} {@link Bool}
   */
  is_muted_for_current_user: Bool;

  /**
   * True, if the participant is muted for all users, but can unmute themselves
   * @type {Bool} {@link Bool}
   */
  can_unmute_self: Bool;

  /**
   * Participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  volume_level: int32;

  /**
   * User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
   * @type {string} {@link string}
   */
  order: string;
};

export type groupCallParticipant$Input = {
  readonly _: "groupCallParticipant";

  /**
   * Identifier of the group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * User's audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * User's screen sharing audio channel synchronization source identifier
   * @type {int32} {@link int32}
   */
  readonly screen_sharing_audio_source_id?: int32;

  /**
   * Information about user's video channel; may be null if there is no active video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  readonly video_info?: groupCallParticipantVideoInfo$Input;

  /**
   * Information about user's screen sharing video channel; may be null if there is no active screen sharing video
   * @type {groupCallParticipantVideoInfo} {@link groupCallParticipantVideoInfo}
   */
  readonly screen_sharing_video_info?: groupCallParticipantVideoInfo$Input;

  /**
   * The participant user's bio or the participant chat's description
   * @type {string} {@link string}
   */
  readonly bio?: string;

  /**
   * True, if the participant is the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_current_user?: Bool$Input;

  /**
   * True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
   * @type {Bool} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;

  /**
   * True, if the participant hand is raised
   * @type {Bool} {@link Bool}
   */
  readonly is_hand_raised?: Bool$Input;

  /**
   * True, if the current user can mute the participant for all other group call participants
   * @type {Bool} {@link Bool}
   */
  readonly can_be_muted_for_all_users?: Bool$Input;

  /**
   * True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
   * @type {Bool} {@link Bool}
   */
  readonly can_be_unmuted_for_all_users?: Bool$Input;

  /**
   * True, if the current user can mute the participant only for self
   * @type {Bool} {@link Bool}
   */
  readonly can_be_muted_for_current_user?: Bool$Input;

  /**
   * True, if the current user can unmute the participant for self
   * @type {Bool} {@link Bool}
   */
  readonly can_be_unmuted_for_current_user?: Bool$Input;

  /**
   * True, if the participant is muted for all users
   * @type {Bool} {@link Bool}
   */
  readonly is_muted_for_all_users?: Bool$Input;

  /**
   * True, if the participant is muted for the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_muted_for_current_user?: Bool$Input;

  /**
   * True, if the participant is muted for all users, but can unmute themselves
   * @type {Bool} {@link Bool}
   */
  readonly can_unmute_self?: Bool$Input;

  /**
   * Participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;

  /**
   * User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
   * @type {string} {@link string}
   */
  readonly order?: string;
};

/** The user heard their own voice */
export type callProblemEcho = {
  _: "callProblemEcho";
};

export type callProblemEcho$Input = {
  readonly _: "callProblemEcho";
};

/** The user heard background noise */
export type callProblemNoise = {
  _: "callProblemNoise";
};

export type callProblemNoise$Input = {
  readonly _: "callProblemNoise";
};

/** The other side kept disappearing */
export type callProblemInterruptions = {
  _: "callProblemInterruptions";
};

export type callProblemInterruptions$Input = {
  readonly _: "callProblemInterruptions";
};

/** The speech was distorted */
export type callProblemDistortedSpeech = {
  _: "callProblemDistortedSpeech";
};

export type callProblemDistortedSpeech$Input = {
  readonly _: "callProblemDistortedSpeech";
};

/** The user couldn't hear the other side */
export type callProblemSilentLocal = {
  _: "callProblemSilentLocal";
};

export type callProblemSilentLocal$Input = {
  readonly _: "callProblemSilentLocal";
};

/** The other side couldn't hear the user */
export type callProblemSilentRemote = {
  _: "callProblemSilentRemote";
};

export type callProblemSilentRemote$Input = {
  readonly _: "callProblemSilentRemote";
};

/** The call ended unexpectedly */
export type callProblemDropped = {
  _: "callProblemDropped";
};

export type callProblemDropped$Input = {
  readonly _: "callProblemDropped";
};

/** The video was distorted */
export type callProblemDistortedVideo = {
  _: "callProblemDistortedVideo";
};

export type callProblemDistortedVideo$Input = {
  readonly _: "callProblemDistortedVideo";
};

/** The video was pixelated */
export type callProblemPixelatedVideo = {
  _: "callProblemPixelatedVideo";
};

export type callProblemPixelatedVideo$Input = {
  readonly _: "callProblemPixelatedVideo";
};

/** Describes a call */
export type call = {
  _: "call";

  /**
   * Call identifier, not persistent
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Peer user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * True, if the call is outgoing
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * True, if the call is a video call
   * @type {Bool} {@link Bool}
   */
  is_video: Bool;

  /**
   * Call state
   * @type {CallState} {@link CallState}
   */
  state: CallState;
};

export type call$Input = {
  readonly _: "call";

  /**
   * Call identifier, not persistent
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Peer user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * True, if the call is outgoing
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * True, if the call is a video call
   * @type {Bool} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Call state
   * @type {CallState} {@link CallState}
   */
  readonly state?: CallState$Input;
};

/** Contains settings for the authentication of the user's phone number */
export type phoneNumberAuthenticationSettings = {
  _: "phoneNumberAuthenticationSettings";

  /**
   * Pass true if the authentication code may be sent via a flash call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  allow_flash_call: Bool;

  /**
   * Pass true if the authentication code may be sent via a missed call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  allow_missed_call: Bool;

  /**
   * Pass true if the authenticated phone number is used on the current device
   * @type {Bool} {@link Bool}
   */
  is_current_phone_number: Bool;

  /**
   * For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
   * @type {Bool} {@link Bool}
   */
  allow_sms_retriever_api: Bool;

  /**
   * List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
   * @type {vector<string>} {@link vector<string>}
   */
  authentication_tokens: vector<string>;
};

export type phoneNumberAuthenticationSettings$Input = {
  readonly _: "phoneNumberAuthenticationSettings";

  /**
   * Pass true if the authentication code may be sent via a flash call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  readonly allow_flash_call?: Bool$Input;

  /**
   * Pass true if the authentication code may be sent via a missed call to the specified phone number
   * @type {Bool} {@link Bool}
   */
  readonly allow_missed_call?: Bool$Input;

  /**
   * Pass true if the authenticated phone number is used on the current device
   * @type {Bool} {@link Bool}
   */
  readonly is_current_phone_number?: Bool$Input;

  /**
   * For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services >= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
   * @type {Bool} {@link Bool}
   */
  readonly allow_sms_retriever_api?: Bool$Input;

  /**
   * List of up to 20 authentication tokens, recently received in updateOption("authentication_token") in previously logged out sessions
   * @type {vector<string>} {@link vector<string>}
   */
  readonly authentication_tokens?: vector$Input<string>;
};

/** Represents a reaction applied to a message */
export type addedReaction = {
  _: "addedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * Identifier of the chat member, applied the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;
};

export type addedReaction$Input = {
  readonly _: "addedReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * Identifier of the chat member, applied the reaction
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/** Represents a list of reactions added to a message */
export type addedReactions = {
  _: "addedReactions";

  /**
   * The total number of found reactions
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * The list of added reactions
   * @type {vector<addedReaction>} {@link vector<addedReaction>}
   */
  reactions: vector<addedReaction>;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;
};

export type addedReactions$Input = {
  readonly _: "addedReactions";

  /**
   * The total number of found reactions
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * The list of added reactions
   * @type {vector<addedReaction>} {@link vector<addedReaction>}
   */
  readonly reactions?: vector$Input<addedReaction$Input>;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;
};

/** Represents an available reaction */
export type availableReaction = {
  _: "availableReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  type: ReactionType;

  /**
   * True, if Telegram Premium is needed to send the reaction
   * @type {Bool} {@link Bool}
   */
  needs_premium: Bool;
};

export type availableReaction$Input = {
  readonly _: "availableReaction";

  /**
   * Type of the reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly type?: ReactionType$Input;

  /**
   * True, if Telegram Premium is needed to send the reaction
   * @type {Bool} {@link Bool}
   */
  readonly needs_premium?: Bool$Input;
};

/** Represents a list of reactions that can be added to a message */
export type availableReactions = {
  _: "availableReactions";

  /**
   * List of reactions to be shown at the top
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  top_reactions: vector<availableReaction>;

  /**
   * List of recently used reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  recent_reactions: vector<availableReaction>;

  /**
   * List of popular reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  popular_reactions: vector<availableReaction>;

  /**
   * True, if custom emoji reactions could be added by Telegram Premium subscribers
   * @type {Bool} {@link Bool}
   */
  allow_custom_emoji: Bool;
};

export type availableReactions$Input = {
  readonly _: "availableReactions";

  /**
   * List of reactions to be shown at the top
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  readonly top_reactions?: vector$Input<availableReaction$Input>;

  /**
   * List of recently used reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  readonly recent_reactions?: vector$Input<availableReaction$Input>;

  /**
   * List of popular reactions
   * @type {vector<availableReaction>} {@link vector<availableReaction>}
   */
  readonly popular_reactions?: vector$Input<availableReaction$Input>;

  /**
   * True, if custom emoji reactions could be added by Telegram Premium subscribers
   * @type {Bool} {@link Bool}
   */
  readonly allow_custom_emoji?: Bool$Input;
};

/** Contains information about a emoji reaction */
export type emojiReaction = {
  _: "emojiReaction";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * Reaction title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * True, if the reaction can be added to new messages and enabled in chats
   * @type {Bool} {@link Bool}
   */
  is_active: Bool;

  /**
   * Static icon for the reaction
   * @type {sticker} {@link sticker}
   */
  static_icon: sticker;

  /**
   * Appear animation for the reaction
   * @type {sticker} {@link sticker}
   */
  appear_animation: sticker;

  /**
   * Select animation for the reaction
   * @type {sticker} {@link sticker}
   */
  select_animation: sticker;

  /**
   * Activate animation for the reaction
   * @type {sticker} {@link sticker}
   */
  activate_animation: sticker;

  /**
   * Effect animation for the reaction
   * @type {sticker} {@link sticker}
   */
  effect_animation: sticker;

  /**
   * Around animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  around_animation: sticker;

  /**
   * Center animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  center_animation: sticker;
};

export type emojiReaction$Input = {
  readonly _: "emojiReaction";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * Reaction title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * True, if the reaction can be added to new messages and enabled in chats
   * @type {Bool} {@link Bool}
   */
  readonly is_active?: Bool$Input;

  /**
   * Static icon for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly static_icon?: sticker$Input;

  /**
   * Appear animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly appear_animation?: sticker$Input;

  /**
   * Select animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly select_animation?: sticker$Input;

  /**
   * Activate animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly activate_animation?: sticker$Input;

  /**
   * Effect animation for the reaction
   * @type {sticker} {@link sticker}
   */
  readonly effect_animation?: sticker$Input;

  /**
   * Around animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  readonly around_animation?: sticker$Input;

  /**
   * Center animation for the reaction; may be null
   * @type {sticker} {@link sticker}
   */
  readonly center_animation?: sticker$Input;
};

/** Represents a list of animations */
export type animations = {
  _: "animations";

  /**
   * List of animations
   * @type {vector<animation>} {@link vector<animation>}
   */
  animations: vector<animation>;
};

export type animations$Input = {
  readonly _: "animations";

  /**
   * List of animations
   * @type {vector<animation>} {@link vector<animation>}
   */
  readonly animations?: vector$Input<animation$Input>;
};

/** A regular animated sticker */
export type diceStickersRegular = {
  _: "diceStickersRegular";

  /**
   * The animated sticker with the dice animation
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

export type diceStickersRegular$Input = {
  readonly _: "diceStickersRegular";

  /**
   * The animated sticker with the dice animation
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/** Animated stickers to be combined into a slot machine */
export type diceStickersSlotMachine = {
  _: "diceStickersSlotMachine";

  /**
   * The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
   * @type {sticker} {@link sticker}
   */
  background: sticker;

  /**
   * The animated sticker with the lever animation. The lever animation must play once in the initial dice state
   * @type {sticker} {@link sticker}
   */
  lever: sticker;

  /**
   * The animated sticker with the left reel
   * @type {sticker} {@link sticker}
   */
  left_reel: sticker;

  /**
   * The animated sticker with the center reel
   * @type {sticker} {@link sticker}
   */
  center_reel: sticker;

  /**
   * The animated sticker with the right reel
   * @type {sticker} {@link sticker}
   */
  right_reel: sticker;
};

export type diceStickersSlotMachine$Input = {
  readonly _: "diceStickersSlotMachine";

  /**
   * The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
   * @type {sticker} {@link sticker}
   */
  readonly background?: sticker$Input;

  /**
   * The animated sticker with the lever animation. The lever animation must play once in the initial dice state
   * @type {sticker} {@link sticker}
   */
  readonly lever?: sticker$Input;

  /**
   * The animated sticker with the left reel
   * @type {sticker} {@link sticker}
   */
  readonly left_reel?: sticker$Input;

  /**
   * The animated sticker with the center reel
   * @type {sticker} {@link sticker}
   */
  readonly center_reel?: sticker$Input;

  /**
   * The animated sticker with the right reel
   * @type {sticker} {@link sticker}
   */
  readonly right_reel?: sticker$Input;
};

/** Represents the result of an ImportContacts request */
export type importedContacts = {
  _: "importedContacts";

  /**
   * User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;

  /**
   * The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
   * @type {vector<int32>} {@link vector<int32>}
   */
  importer_count: vector<int32>;
};

export type importedContacts$Input = {
  readonly _: "importedContacts";

  /**
   * User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly importer_count?: vector$Input<int32>;
};

/** The speech recognition is ongoing */
export type speechRecognitionResultPending = {
  _: "speechRecognitionResultPending";

  /**
   * Partially recognized text
   * @type {string} {@link string}
   */
  partial_text: string;
};

export type speechRecognitionResultPending$Input = {
  readonly _: "speechRecognitionResultPending";

  /**
   * Partially recognized text
   * @type {string} {@link string}
   */
  readonly partial_text?: string;
};

/** The speech recognition successfully finished */
export type speechRecognitionResultText = {
  _: "speechRecognitionResultText";

  /**
   * Recognized text
   * @type {string} {@link string}
   */
  text: string;
};

export type speechRecognitionResultText$Input = {
  readonly _: "speechRecognitionResultText";

  /**
   * Recognized text
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/** The speech recognition failed */
export type speechRecognitionResultError = {
  _: "speechRecognitionResultError";

  /**
   * Received error
   * @type {error} {@link error}
   */
  error: error;
};

export type speechRecognitionResultError$Input = {
  readonly _: "speechRecognitionResultError";

  /**
   * Received error
   * @type {error} {@link error}
   */
  readonly error?: error$Input;
};

/** Describes a color to highlight a bot added to attachment menu */
export type attachmentMenuBotColor = {
  _: "attachmentMenuBotColor";

  /**
   * Color in the RGB24 format for light themes
   * @type {int32} {@link int32}
   */
  light_color: int32;

  /**
   * Color in the RGB24 format for dark themes
   * @type {int32} {@link int32}
   */
  dark_color: int32;
};

export type attachmentMenuBotColor$Input = {
  readonly _: "attachmentMenuBotColor";

  /**
   * Color in the RGB24 format for light themes
   * @type {int32} {@link int32}
   */
  readonly light_color?: int32;

  /**
   * Color in the RGB24 format for dark themes
   * @type {int32} {@link int32}
   */
  readonly dark_color?: int32;
};

/** Represents a bot added to attachment menu */
export type attachmentMenuBot = {
  _: "attachmentMenuBot";

  /**
   * User identifier of the bot added to attachment menu
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * True, if the bot supports opening from attachment menu in the chat with the bot
   * @type {Bool} {@link Bool}
   */
  supports_self_chat: Bool;

  /**
   * True, if the bot supports opening from attachment menu in private chats with ordinary users
   * @type {Bool} {@link Bool}
   */
  supports_user_chats: Bool;

  /**
   * True, if the bot supports opening from attachment menu in private chats with other bots
   * @type {Bool} {@link Bool}
   */
  supports_bot_chats: Bool;

  /**
   * True, if the bot supports opening from attachment menu in basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  supports_group_chats: Bool;

  /**
   * True, if the bot supports opening from attachment menu in channel chats
   * @type {Bool} {@link Bool}
   */
  supports_channel_chats: Bool;

  /**
   * True, if the bot supports "settings_button_pressed" event
   * @type {Bool} {@link Bool}
   */
  supports_settings: Bool;

  /**
   * Name for the bot in attachment menu
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Color to highlight selected name of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  name_color: attachmentMenuBotColor;

  /**
   * Default attachment menu icon for the bot in SVG format; may be null
   * @type {file} {@link file}
   */
  default_icon: file;

  /**
   * Attachment menu icon for the bot in SVG format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  ios_static_icon: file;

  /**
   * Attachment menu icon for the bot in TGS format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  ios_animated_icon: file;

  /**
   * Attachment menu icon for the bot in TGS format for the official Android app; may be null
   * @type {file} {@link file}
   */
  android_icon: file;

  /**
   * Attachment menu icon for the bot in TGS format for the official native macOS app; may be null
   * @type {file} {@link file}
   */
  macos_icon: file;

  /**
   * Color to highlight selected icon of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  icon_color: attachmentMenuBotColor;

  /**
   * Default placeholder for opened Web Apps in SVG format; may be null
   * @type {file} {@link file}
   */
  web_app_placeholder: file;
};

export type attachmentMenuBot$Input = {
  readonly _: "attachmentMenuBot";

  /**
   * User identifier of the bot added to attachment menu
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * True, if the bot supports opening from attachment menu in the chat with the bot
   * @type {Bool} {@link Bool}
   */
  readonly supports_self_chat?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in private chats with ordinary users
   * @type {Bool} {@link Bool}
   */
  readonly supports_user_chats?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in private chats with other bots
   * @type {Bool} {@link Bool}
   */
  readonly supports_bot_chats?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in basic group and supergroup chats
   * @type {Bool} {@link Bool}
   */
  readonly supports_group_chats?: Bool$Input;

  /**
   * True, if the bot supports opening from attachment menu in channel chats
   * @type {Bool} {@link Bool}
   */
  readonly supports_channel_chats?: Bool$Input;

  /**
   * True, if the bot supports "settings_button_pressed" event
   * @type {Bool} {@link Bool}
   */
  readonly supports_settings?: Bool$Input;

  /**
   * Name for the bot in attachment menu
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Color to highlight selected name of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  readonly name_color?: attachmentMenuBotColor$Input;

  /**
   * Default attachment menu icon for the bot in SVG format; may be null
   * @type {file} {@link file}
   */
  readonly default_icon?: file$Input;

  /**
   * Attachment menu icon for the bot in SVG format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  readonly ios_static_icon?: file$Input;

  /**
   * Attachment menu icon for the bot in TGS format for the official iOS app; may be null
   * @type {file} {@link file}
   */
  readonly ios_animated_icon?: file$Input;

  /**
   * Attachment menu icon for the bot in TGS format for the official Android app; may be null
   * @type {file} {@link file}
   */
  readonly android_icon?: file$Input;

  /**
   * Attachment menu icon for the bot in TGS format for the official native macOS app; may be null
   * @type {file} {@link file}
   */
  readonly macos_icon?: file$Input;

  /**
   * Color to highlight selected icon of the bot if appropriate; may be null
   * @type {attachmentMenuBotColor} {@link attachmentMenuBotColor}
   */
  readonly icon_color?: attachmentMenuBotColor$Input;

  /**
   * Default placeholder for opened Web Apps in SVG format; may be null
   * @type {file} {@link file}
   */
  readonly web_app_placeholder?: file$Input;
};

/** Information about the message sent by answerWebAppQuery */
export type sentWebAppMessage = {
  _: "sentWebAppMessage";

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  inline_message_id: string;
};

export type sentWebAppMessage$Input = {
  readonly _: "sentWebAppMessage";

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;
};

/** Contains an HTTP URL */
export type httpUrl = {
  _: "httpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  url: string;
};

export type httpUrl$Input = {
  readonly _: "httpUrl";

  /**
   * The URL
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video */
export type inputInlineQueryResultAnimation = {
  _: "inputInlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the query result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  thumbnail_mime_type: string;

  /**
   * The URL of the video file (file size must not exceed 1MB)
   * @type {string} {@link string}
   */
  video_url: string;

  /**
   * MIME type of the video file. Must be one of "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  video_mime_type: string;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  video_duration: int32;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  video_width: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  video_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultAnimation$Input = {
  readonly _: "inputInlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the query result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  readonly thumbnail_mime_type?: string;

  /**
   * The URL of the video file (file size must not exceed 1MB)
   * @type {string} {@link string}
   */
  readonly video_url?: string;

  /**
   * MIME type of the video file. Must be one of "image/gif" and "video/mp4"
   * @type {string} {@link string}
   */
  readonly video_mime_type?: string;

  /**
   * Duration of the video, in seconds
   * @type {int32} {@link int32}
   */
  readonly video_duration?: int32;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  readonly video_width?: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  readonly video_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to an article or web page */
export type inputInlineQueryResultArticle = {
  _: "inputInlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  hide_url: Bool;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  description: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultArticle$Input = {
  readonly _: "inputInlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  readonly hide_url?: Bool$Input;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to an MP3 audio file */
export type inputInlineQueryResultAudio = {
  _: "inputInlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the audio file
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Performer of the audio file
   * @type {string} {@link string}
   */
  performer: string;

  /**
   * The URL of the audio file
   * @type {string} {@link string}
   */
  audio_url: string;

  /**
   * Audio file duration, in seconds
   * @type {int32} {@link int32}
   */
  audio_duration: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultAudio$Input = {
  readonly _: "inputInlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the audio file
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Performer of the audio file
   * @type {string} {@link string}
   */
  readonly performer?: string;

  /**
   * The URL of the audio file
   * @type {string} {@link string}
   */
  readonly audio_url?: string;

  /**
   * Audio file duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly audio_duration?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a user contact */
export type inputInlineQueryResultContact = {
  _: "inputInlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * User contact
   * @type {contact} {@link contact}
   */
  contact: contact;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultContact$Input = {
  readonly _: "inputInlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * User contact
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to a file */
export type inputInlineQueryResultDocument = {
  _: "inputInlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the resulting file
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to a file
   * @type {string} {@link string}
   */
  description: string;

  /**
   * URL of the file
   * @type {string} {@link string}
   */
  document_url: string;

  /**
   * MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * The URL of the file thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Width of the thumbnail
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Height of the thumbnail
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultDocument$Input = {
  readonly _: "inputInlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the resulting file
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to a file
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * URL of the file
   * @type {string} {@link string}
   */
  readonly document_url?: string;

  /**
   * MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * The URL of the file thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Width of the thumbnail
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Height of the thumbnail
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a game */
export type inputInlineQueryResultGame = {
  _: "inputInlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  game_short_name: string;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;
};

export type inputInlineQueryResultGame$Input = {
  readonly _: "inputInlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;
};

/** Represents a point on the map */
export type inputInlineQueryResultLocation = {
  _: "inputInlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Amount of time relative to the message sent time until the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  live_period: int32;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultLocation$Input = {
  readonly _: "inputInlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Amount of time relative to the message sent time until the location can be updated, in seconds
   * @type {int32} {@link int32}
   */
  readonly live_period?: int32;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents link to a JPEG image */
export type inputInlineQueryResultPhoto = {
  _: "inputInlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents link to a JPEG image
   * @type {string} {@link string}
   */
  description: string;

  /**
   * URL of the photo thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * The URL of the JPEG photo (photo size must not exceed 5MB)
   * @type {string} {@link string}
   */
  photo_url: string;

  /**
   * Width of the photo
   * @type {int32} {@link int32}
   */
  photo_width: int32;

  /**
   * Height of the photo
   * @type {int32} {@link int32}
   */
  photo_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultPhoto$Input = {
  readonly _: "inputInlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents link to a JPEG image
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * URL of the photo thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * The URL of the JPEG photo (photo size must not exceed 5MB)
   * @type {string} {@link string}
   */
  readonly photo_url?: string;

  /**
   * Width of the photo
   * @type {int32} {@link int32}
   */
  readonly photo_width?: int32;

  /**
   * Height of the photo
   * @type {int32} {@link int32}
   */
  readonly photo_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to a WEBP, TGS, or WEBM sticker */
export type inputInlineQueryResultSticker = {
  _: "inputInlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * URL of the sticker thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
   * @type {string} {@link string}
   */
  sticker_url: string;

  /**
   * Width of the sticker
   * @type {int32} {@link int32}
   */
  sticker_width: int32;

  /**
   * Height of the sticker
   * @type {int32} {@link int32}
   */
  sticker_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultSticker$Input = {
  readonly _: "inputInlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * URL of the sticker thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * The URL of the WEBP, TGS, or WEBM sticker (sticker file size must not exceed 5MB)
   * @type {string} {@link string}
   */
  readonly sticker_url?: string;

  /**
   * Width of the sticker
   * @type {int32} {@link int32}
   */
  readonly sticker_width?: int32;

  /**
   * Height of the sticker
   * @type {int32} {@link int32}
   */
  readonly sticker_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents information about a venue */
export type inputInlineQueryResultVenue = {
  _: "inputInlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  venue: venue;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  thumbnail_width: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  thumbnail_height: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultVenue$Input = {
  readonly _: "inputInlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;

  /**
   * URL of the result thumbnail, if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * Thumbnail width, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_width?: int32;

  /**
   * Thumbnail height, if known
   * @type {int32} {@link int32}
   */
  readonly thumbnail_height?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to a page containing an embedded video player or a video file */
export type inputInlineQueryResultVideo = {
  _: "inputInlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to a page containing an embedded video player or a video file
   * @type {string} {@link string}
   */
  description: string;

  /**
   * The URL of the video thumbnail (JPEG), if it exists
   * @type {string} {@link string}
   */
  thumbnail_url: string;

  /**
   * URL of the embedded video player or video file
   * @type {string} {@link string}
   */
  video_url: string;

  /**
   * MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
   * @type {string} {@link string}
   */
  mime_type: string;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  video_width: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  video_height: int32;

  /**
   * Video duration, in seconds
   * @type {int32} {@link int32}
   */
  video_duration: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultVideo$Input = {
  readonly _: "inputInlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to a page containing an embedded video player or a video file
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * The URL of the video thumbnail (JPEG), if it exists
   * @type {string} {@link string}
   */
  readonly thumbnail_url?: string;

  /**
   * URL of the embedded video player or video file
   * @type {string} {@link string}
   */
  readonly video_url?: string;

  /**
   * MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
   * @type {string} {@link string}
   */
  readonly mime_type?: string;

  /**
   * Width of the video
   * @type {int32} {@link int32}
   */
  readonly video_width?: int32;

  /**
   * Height of the video
   * @type {int32} {@link int32}
   */
  readonly video_height?: int32;

  /**
   * Video duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly video_duration?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to an opus-encoded audio file within an OGG container, single channel audio */
export type inputInlineQueryResultVoiceNote = {
  _: "inputInlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  title: string;

  /**
   * The URL of the voice note file
   * @type {string} {@link string}
   */
  voice_note_url: string;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  voice_note_duration: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  input_message_content: InputMessageContent;
};

export type inputInlineQueryResultVoiceNote$Input = {
  readonly _: "inputInlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * The URL of the voice note file
   * @type {string} {@link string}
   */
  readonly voice_note_url?: string;

  /**
   * Duration of the voice note, in seconds
   * @type {int32} {@link int32}
   */
  readonly voice_note_duration?: int32;

  /**
   * The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
   * @type {InputMessageContent} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/** Represents a link to an article or web page */
export type inlineQueryResultArticle = {
  _: "inlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  url: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  hide_url: Bool;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  description: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;
};

export type inlineQueryResultArticle$Input = {
  readonly _: "inlineQueryResultArticle";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * URL of the result, if it exists
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * True, if the URL must be not shown
   * @type {Bool} {@link Bool}
   */
  readonly hide_url?: Bool$Input;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a link to an article or web page
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;
};

/** Represents a user contact */
export type inlineQueryResultContact = {
  _: "inlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * A user contact
   * @type {contact} {@link contact}
   */
  contact: contact;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;
};

export type inlineQueryResultContact$Input = {
  readonly _: "inlineQueryResultContact";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * A user contact
   * @type {contact} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;
};

/** Represents a point on the map */
export type inlineQueryResultLocation = {
  _: "inlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  location: location;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;
};

export type inlineQueryResultLocation$Input = {
  readonly _: "inlineQueryResultLocation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Location result
   * @type {location} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Title of the result
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;
};

/** Represents information about a venue */
export type inlineQueryResultVenue = {
  _: "inlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  venue: venue;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  thumbnail: thumbnail;
};

export type inlineQueryResultVenue$Input = {
  readonly _: "inlineQueryResultVenue";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Venue result
   * @type {venue} {@link venue}
   */
  readonly venue?: venue$Input;

  /**
   * Result thumbnail in JPEG format; may be null
   * @type {thumbnail} {@link thumbnail}
   */
  readonly thumbnail?: thumbnail$Input;
};

/** Represents information about a game */
export type inlineQueryResultGame = {
  _: "inlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Game result
   * @type {game} {@link game}
   */
  game: game;
};

export type inlineQueryResultGame$Input = {
  readonly _: "inlineQueryResultGame";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Game result
   * @type {game} {@link game}
   */
  readonly game?: game$Input;
};

/** Represents an animation file */
export type inlineQueryResultAnimation = {
  _: "inlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Animation file
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Animation title
   * @type {string} {@link string}
   */
  title: string;
};

export type inlineQueryResultAnimation$Input = {
  readonly _: "inlineQueryResultAnimation";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Animation file
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Animation title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** Represents an audio file */
export type inlineQueryResultAudio = {
  _: "inlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Audio file
   * @type {audio} {@link audio}
   */
  audio: audio;
};

export type inlineQueryResultAudio$Input = {
  readonly _: "inlineQueryResultAudio";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Audio file
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;
};

/** Represents a document */
export type inlineQueryResultDocument = {
  _: "inlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Document
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Document title
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a document
   * @type {string} {@link string}
   */
  description: string;
};

export type inlineQueryResultDocument$Input = {
  readonly _: "inlineQueryResultDocument";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Document
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Document title
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a document
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/** Represents a photo */
export type inlineQueryResultPhoto = {
  _: "inlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Photo
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a photo
   * @type {string} {@link string}
   */
  description: string;
};

export type inlineQueryResultPhoto$Input = {
  readonly _: "inlineQueryResultPhoto";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Photo
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Title of the result, if known
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a photo
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/** Represents a sticker */
export type inlineQueryResultSticker = {
  _: "inlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Sticker
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

export type inlineQueryResultSticker$Input = {
  readonly _: "inlineQueryResultSticker";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Sticker
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/** Represents a video */
export type inlineQueryResultVideo = {
  _: "inlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Video
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Title of the video
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Represents a video
   * @type {string} {@link string}
   */
  description: string;
};

export type inlineQueryResultVideo$Input = {
  readonly _: "inlineQueryResultVideo";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Video
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Title of the video
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Represents a video
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/** Represents a voice note */
export type inlineQueryResultVoiceNote = {
  _: "inlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Voice note
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  title: string;
};

export type inlineQueryResultVoiceNote$Input = {
  readonly _: "inlineQueryResultVoiceNote";

  /**
   * Unique identifier of the query result
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Voice note
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * Title of the voice note
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query */
export type inlineQueryResults = {
  _: "inlineQueryResults";

  /**
   * Unique identifier of the inline query
   * @type {int64} {@link int64}
   */
  inline_query_id: int64;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  next_offset: string;

  /**
   * Results of the query
   * @type {vector<InlineQueryResult>} {@link vector<InlineQueryResult>}
   */
  results: vector<InlineQueryResult>;

  /**
   * If non-empty, this text must be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter
   * @type {string} {@link string}
   */
  switch_pm_text: string;

  /**
   * Parameter for the bot start message
   * @type {string} {@link string}
   */
  switch_pm_parameter: string;
};

export type inlineQueryResults$Input = {
  readonly _: "inlineQueryResults";

  /**
   * Unique identifier of the inline query
   * @type {int64} {@link int64}
   */
  readonly inline_query_id?: int64;

  /**
   * The offset for the next request. If empty, there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;

  /**
   * Results of the query
   * @type {vector<InlineQueryResult>} {@link vector<InlineQueryResult>}
   */
  readonly results?: vector$Input<InlineQueryResult$Input>;

  /**
   * If non-empty, this text must be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter
   * @type {string} {@link string}
   */
  readonly switch_pm_text?: string;

  /**
   * Parameter for the bot start message
   * @type {string} {@link string}
   */
  readonly switch_pm_parameter?: string;
};

/** The payload for a general callback button */
export type callbackQueryPayloadData = {
  _: "callbackQueryPayloadData";

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type callbackQueryPayloadData$Input = {
  readonly _: "callbackQueryPayloadData";

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** The payload for a callback button requiring password */
export type callbackQueryPayloadDataWithPassword = {
  _: "callbackQueryPayloadDataWithPassword";

  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  password: string;

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type callbackQueryPayloadDataWithPassword$Input = {
  readonly _: "callbackQueryPayloadDataWithPassword";

  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Data that was attached to the callback button
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** The payload for a game callback button */
export type callbackQueryPayloadGame = {
  _: "callbackQueryPayloadGame";

  /**
   * A short name of the game that was attached to the callback button
   * @type {string} {@link string}
   */
  game_short_name: string;
};

export type callbackQueryPayloadGame$Input = {
  readonly _: "callbackQueryPayloadGame";

  /**
   * A short name of the game that was attached to the callback button
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;
};

/** Contains a bot's answer to a callback query */
export type callbackQueryAnswer = {
  _: "callbackQueryAnswer";

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  text: string;

  /**
   * True, if an alert must be shown to the user instead of a toast notification
   * @type {Bool} {@link Bool}
   */
  show_alert: Bool;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  url: string;
};

export type callbackQueryAnswer$Input = {
  readonly _: "callbackQueryAnswer";

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * True, if an alert must be shown to the user instead of a toast notification
   * @type {Bool} {@link Bool}
   */
  readonly show_alert?: Bool$Input;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** Contains the result of a custom request */
export type customRequestResult = {
  _: "customRequestResult";

  /**
   * A JSON-serialized result
   * @type {string} {@link string}
   */
  result: string;
};

export type customRequestResult$Input = {
  readonly _: "customRequestResult";

  /**
   * A JSON-serialized result
   * @type {string} {@link string}
   */
  readonly result?: string;
};

/** Contains one row of the game high score table */
export type gameHighScore = {
  _: "gameHighScore";

  /**
   * Position in the high score table
   * @type {int32} {@link int32}
   */
  position: int32;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * User score
   * @type {int32} {@link int32}
   */
  score: int32;
};

export type gameHighScore$Input = {
  readonly _: "gameHighScore";

  /**
   * Position in the high score table
   * @type {int32} {@link int32}
   */
  readonly position?: int32;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * User score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;
};

/** Contains a list of game high scores */
export type gameHighScores = {
  _: "gameHighScores";

  /**
   * A list of game high scores
   * @type {vector<gameHighScore>} {@link vector<gameHighScore>}
   */
  scores: vector<gameHighScore>;
};

export type gameHighScores$Input = {
  readonly _: "gameHighScores";

  /**
   * A list of game high scores
   * @type {vector<gameHighScore>} {@link vector<gameHighScore>}
   */
  readonly scores?: vector$Input<gameHighScore$Input>;
};

/** A message was edited */
export type chatEventMessageEdited = {
  _: "chatEventMessageEdited";

  /**
   * The original message before the edit
   * @type {message} {@link message}
   */
  old_message: message;

  /**
   * The message after it was edited
   * @type {message} {@link message}
   */
  new_message: message;
};

export type chatEventMessageEdited$Input = {
  readonly _: "chatEventMessageEdited";

  /**
   * The original message before the edit
   * @type {message} {@link message}
   */
  readonly old_message?: message$Input;

  /**
   * The message after it was edited
   * @type {message} {@link message}
   */
  readonly new_message?: message$Input;
};

/** A message was deleted */
export type chatEventMessageDeleted = {
  _: "chatEventMessageDeleted";

  /**
   * Deleted message
   * @type {message} {@link message}
   */
  message: message;
};

export type chatEventMessageDeleted$Input = {
  readonly _: "chatEventMessageDeleted";

  /**
   * Deleted message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/** A message was pinned */
export type chatEventMessagePinned = {
  _: "chatEventMessagePinned";

  /**
   * Pinned message
   * @type {message} {@link message}
   */
  message: message;
};

export type chatEventMessagePinned$Input = {
  readonly _: "chatEventMessagePinned";

  /**
   * Pinned message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/** A message was unpinned */
export type chatEventMessageUnpinned = {
  _: "chatEventMessageUnpinned";

  /**
   * Unpinned message
   * @type {message} {@link message}
   */
  message: message;
};

export type chatEventMessageUnpinned$Input = {
  readonly _: "chatEventMessageUnpinned";

  /**
   * Unpinned message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/** A poll in a message was stopped */
export type chatEventPollStopped = {
  _: "chatEventPollStopped";

  /**
   * The message with the poll
   * @type {message} {@link message}
   */
  message: message;
};

export type chatEventPollStopped$Input = {
  readonly _: "chatEventPollStopped";

  /**
   * The message with the poll
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/** A new member joined the chat */
export type chatEventMemberJoined = {
  _: "chatEventMemberJoined";
};

export type chatEventMemberJoined$Input = {
  readonly _: "chatEventMemberJoined";
};

/** A new member joined the chat via an invite link */
export type chatEventMemberJoinedByInviteLink = {
  _: "chatEventMemberJoinedByInviteLink";

  /**
   * Invite link used to join the chat
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

export type chatEventMemberJoinedByInviteLink$Input = {
  readonly _: "chatEventMemberJoinedByInviteLink";

  /**
   * Invite link used to join the chat
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/** A new member was accepted to the chat by an administrator */
export type chatEventMemberJoinedByRequest = {
  _: "chatEventMemberJoinedByRequest";

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  approver_user_id: int53;

  /**
   * Invite link used to join the chat; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

export type chatEventMemberJoinedByRequest$Input = {
  readonly _: "chatEventMemberJoinedByRequest";

  /**
   * User identifier of the chat administrator, approved user join request
   * @type {int53} {@link int53}
   */
  readonly approver_user_id?: int53;

  /**
   * Invite link used to join the chat; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/** A new chat member was invited */
export type chatEventMemberInvited = {
  _: "chatEventMemberInvited";

  /**
   * New member user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * New member status
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  status: ChatMemberStatus;
};

export type chatEventMemberInvited$Input = {
  readonly _: "chatEventMemberInvited";

  /**
   * New member user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New member status
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/** A member left the chat */
export type chatEventMemberLeft = {
  _: "chatEventMemberLeft";
};

export type chatEventMemberLeft$Input = {
  readonly _: "chatEventMemberLeft";
};

/** A chat member has gained/lost administrator status, or the list of their administrator privileges has changed */
export type chatEventMemberPromoted = {
  _: "chatEventMemberPromoted";

  /**
   * Affected chat member user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  old_status: ChatMemberStatus;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  new_status: ChatMemberStatus;
};

export type chatEventMemberPromoted$Input = {
  readonly _: "chatEventMemberPromoted";

  /**
   * Affected chat member user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly old_status?: ChatMemberStatus$Input;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly new_status?: ChatMemberStatus$Input;
};

/** A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed */
export type chatEventMemberRestricted = {
  _: "chatEventMemberRestricted";

  /**
   * Affected chat member identifier
   * @type {MessageSender} {@link MessageSender}
   */
  member_id: MessageSender;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  old_status: ChatMemberStatus;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  new_status: ChatMemberStatus;
};

export type chatEventMemberRestricted$Input = {
  readonly _: "chatEventMemberRestricted";

  /**
   * Affected chat member identifier
   * @type {MessageSender} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Previous status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly old_status?: ChatMemberStatus$Input;

  /**
   * New status of the chat member
   * @type {ChatMemberStatus} {@link ChatMemberStatus}
   */
  readonly new_status?: ChatMemberStatus$Input;
};

/** The chat available reactions were changed */
export type chatEventAvailableReactionsChanged = {
  _: "chatEventAvailableReactionsChanged";

  /**
   * Previous chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  old_available_reactions: ChatAvailableReactions;

  /**
   * New chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  new_available_reactions: ChatAvailableReactions;
};

export type chatEventAvailableReactionsChanged$Input = {
  readonly _: "chatEventAvailableReactionsChanged";

  /**
   * Previous chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly old_available_reactions?: ChatAvailableReactions$Input;

  /**
   * New chat available reactions
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly new_available_reactions?: ChatAvailableReactions$Input;
};

/** The chat description was changed */
export type chatEventDescriptionChanged = {
  _: "chatEventDescriptionChanged";

  /**
   * Previous chat description
   * @type {string} {@link string}
   */
  old_description: string;

  /**
   * New chat description
   * @type {string} {@link string}
   */
  new_description: string;
};

export type chatEventDescriptionChanged$Input = {
  readonly _: "chatEventDescriptionChanged";

  /**
   * Previous chat description
   * @type {string} {@link string}
   */
  readonly old_description?: string;

  /**
   * New chat description
   * @type {string} {@link string}
   */
  readonly new_description?: string;
};

/** The linked chat of a supergroup was changed */
export type chatEventLinkedChatChanged = {
  _: "chatEventLinkedChatChanged";

  /**
   * Previous supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  old_linked_chat_id: int53;

  /**
   * New supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  new_linked_chat_id: int53;
};

export type chatEventLinkedChatChanged$Input = {
  readonly _: "chatEventLinkedChatChanged";

  /**
   * Previous supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  readonly old_linked_chat_id?: int53;

  /**
   * New supergroup linked chat identifier
   * @type {int53} {@link int53}
   */
  readonly new_linked_chat_id?: int53;
};

/** The supergroup location was changed */
export type chatEventLocationChanged = {
  _: "chatEventLocationChanged";

  /**
   * Previous location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  old_location: chatLocation;

  /**
   * New location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  new_location: chatLocation;
};

export type chatEventLocationChanged$Input = {
  readonly _: "chatEventLocationChanged";

  /**
   * Previous location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  readonly old_location?: chatLocation$Input;

  /**
   * New location; may be null
   * @type {chatLocation} {@link chatLocation}
   */
  readonly new_location?: chatLocation$Input;
};

/** The message TTL was changed */
export type chatEventMessageTtlChanged = {
  _: "chatEventMessageTtlChanged";

  /**
   * Previous value of message_ttl
   * @type {int32} {@link int32}
   */
  old_message_ttl: int32;

  /**
   * New value of message_ttl
   * @type {int32} {@link int32}
   */
  new_message_ttl: int32;
};

export type chatEventMessageTtlChanged$Input = {
  readonly _: "chatEventMessageTtlChanged";

  /**
   * Previous value of message_ttl
   * @type {int32} {@link int32}
   */
  readonly old_message_ttl?: int32;

  /**
   * New value of message_ttl
   * @type {int32} {@link int32}
   */
  readonly new_message_ttl?: int32;
};

/** The chat permissions was changed */
export type chatEventPermissionsChanged = {
  _: "chatEventPermissionsChanged";

  /**
   * Previous chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  old_permissions: chatPermissions;

  /**
   * New chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  new_permissions: chatPermissions;
};

export type chatEventPermissionsChanged$Input = {
  readonly _: "chatEventPermissionsChanged";

  /**
   * Previous chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly old_permissions?: chatPermissions$Input;

  /**
   * New chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly new_permissions?: chatPermissions$Input;
};

/** The chat photo was changed */
export type chatEventPhotoChanged = {
  _: "chatEventPhotoChanged";

  /**
   * Previous chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  old_photo: chatPhoto;

  /**
   * New chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  new_photo: chatPhoto;
};

export type chatEventPhotoChanged$Input = {
  readonly _: "chatEventPhotoChanged";

  /**
   * Previous chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly old_photo?: chatPhoto$Input;

  /**
   * New chat photo value; may be null
   * @type {chatPhoto} {@link chatPhoto}
   */
  readonly new_photo?: chatPhoto$Input;
};

/** The slow_mode_delay setting of a supergroup was changed */
export type chatEventSlowModeDelayChanged = {
  _: "chatEventSlowModeDelayChanged";

  /**
   * Previous value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  old_slow_mode_delay: int32;

  /**
   * New value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  new_slow_mode_delay: int32;
};

export type chatEventSlowModeDelayChanged$Input = {
  readonly _: "chatEventSlowModeDelayChanged";

  /**
   * Previous value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  readonly old_slow_mode_delay?: int32;

  /**
   * New value of slow_mode_delay, in seconds
   * @type {int32} {@link int32}
   */
  readonly new_slow_mode_delay?: int32;
};

/** The supergroup sticker set was changed */
export type chatEventStickerSetChanged = {
  _: "chatEventStickerSetChanged";

  /**
   * Previous identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  old_sticker_set_id: int64;

  /**
   * New identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  new_sticker_set_id: int64;
};

export type chatEventStickerSetChanged$Input = {
  readonly _: "chatEventStickerSetChanged";

  /**
   * Previous identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly old_sticker_set_id?: int64;

  /**
   * New identifier of the chat sticker set; 0 if none
   * @type {int64} {@link int64}
   */
  readonly new_sticker_set_id?: int64;
};

/** The chat title was changed */
export type chatEventTitleChanged = {
  _: "chatEventTitleChanged";

  /**
   * Previous chat title
   * @type {string} {@link string}
   */
  old_title: string;

  /**
   * New chat title
   * @type {string} {@link string}
   */
  new_title: string;
};

export type chatEventTitleChanged$Input = {
  readonly _: "chatEventTitleChanged";

  /**
   * Previous chat title
   * @type {string} {@link string}
   */
  readonly old_title?: string;

  /**
   * New chat title
   * @type {string} {@link string}
   */
  readonly new_title?: string;
};

/** The chat editable username was changed */
export type chatEventUsernameChanged = {
  _: "chatEventUsernameChanged";

  /**
   * Previous chat username
   * @type {string} {@link string}
   */
  old_username: string;

  /**
   * New chat username
   * @type {string} {@link string}
   */
  new_username: string;
};

export type chatEventUsernameChanged$Input = {
  readonly _: "chatEventUsernameChanged";

  /**
   * Previous chat username
   * @type {string} {@link string}
   */
  readonly old_username?: string;

  /**
   * New chat username
   * @type {string} {@link string}
   */
  readonly new_username?: string;
};

/** The chat active usernames were changed */
export type chatEventActiveUsernamesChanged = {
  _: "chatEventActiveUsernamesChanged";

  /**
   * Previous list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  old_usernames: vector<string>;

  /**
   * New list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  new_usernames: vector<string>;
};

export type chatEventActiveUsernamesChanged$Input = {
  readonly _: "chatEventActiveUsernamesChanged";

  /**
   * Previous list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  readonly old_usernames?: vector$Input<string>;

  /**
   * New list of active usernames
   * @type {vector<string>} {@link vector<string>}
   */
  readonly new_usernames?: vector$Input<string>;
};

/** The has_protected_content setting of a channel was toggled */
export type chatEventHasProtectedContentToggled = {
  _: "chatEventHasProtectedContentToggled";

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  has_protected_content: Bool;
};

export type chatEventHasProtectedContentToggled$Input = {
  readonly _: "chatEventHasProtectedContentToggled";

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/** The can_invite_users permission of a supergroup chat was toggled */
export type chatEventInvitesToggled = {
  _: "chatEventInvitesToggled";

  /**
   * New value of can_invite_users permission
   * @type {Bool} {@link Bool}
   */
  can_invite_users: Bool;
};

export type chatEventInvitesToggled$Input = {
  readonly _: "chatEventInvitesToggled";

  /**
   * New value of can_invite_users permission
   * @type {Bool} {@link Bool}
   */
  readonly can_invite_users?: Bool$Input;
};

/** The is_all_history_available setting of a supergroup was toggled */
export type chatEventIsAllHistoryAvailableToggled = {
  _: "chatEventIsAllHistoryAvailableToggled";

  /**
   * New value of is_all_history_available
   * @type {Bool} {@link Bool}
   */
  is_all_history_available: Bool;
};

export type chatEventIsAllHistoryAvailableToggled$Input = {
  readonly _: "chatEventIsAllHistoryAvailableToggled";

  /**
   * New value of is_all_history_available
   * @type {Bool} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;
};

/** The sign_messages setting of a channel was toggled */
export type chatEventSignMessagesToggled = {
  _: "chatEventSignMessagesToggled";

  /**
   * New value of sign_messages
   * @type {Bool} {@link Bool}
   */
  sign_messages: Bool;
};

export type chatEventSignMessagesToggled$Input = {
  readonly _: "chatEventSignMessagesToggled";

  /**
   * New value of sign_messages
   * @type {Bool} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;
};

/** A chat invite link was edited */
export type chatEventInviteLinkEdited = {
  _: "chatEventInviteLinkEdited";

  /**
   * Previous information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  old_invite_link: chatInviteLink;

  /**
   * New information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  new_invite_link: chatInviteLink;
};

export type chatEventInviteLinkEdited$Input = {
  readonly _: "chatEventInviteLinkEdited";

  /**
   * Previous information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly old_invite_link?: chatInviteLink$Input;

  /**
   * New information about the invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly new_invite_link?: chatInviteLink$Input;
};

/** A chat invite link was revoked */
export type chatEventInviteLinkRevoked = {
  _: "chatEventInviteLinkRevoked";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

export type chatEventInviteLinkRevoked$Input = {
  readonly _: "chatEventInviteLinkRevoked";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/** A revoked chat invite link was deleted */
export type chatEventInviteLinkDeleted = {
  _: "chatEventInviteLinkDeleted";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

export type chatEventInviteLinkDeleted$Input = {
  readonly _: "chatEventInviteLinkDeleted";

  /**
   * The invite link
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/** A video chat was created */
export type chatEventVideoChatCreated = {
  _: "chatEventVideoChatCreated";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;
};

export type chatEventVideoChatCreated$Input = {
  readonly _: "chatEventVideoChatCreated";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/** A video chat was ended */
export type chatEventVideoChatEnded = {
  _: "chatEventVideoChatEnded";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  group_call_id: int32;
};

export type chatEventVideoChatEnded$Input = {
  readonly _: "chatEventVideoChatEnded";

  /**
   * Identifier of the video chat. The video chat can be received through the method getGroupCall
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/** The mute_new_participants setting of a video chat was toggled */
export type chatEventVideoChatMuteNewParticipantsToggled = {
  _: "chatEventVideoChatMuteNewParticipantsToggled";

  /**
   * New value of the mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  mute_new_participants: Bool;
};

export type chatEventVideoChatMuteNewParticipantsToggled$Input = {
  readonly _: "chatEventVideoChatMuteNewParticipantsToggled";

  /**
   * New value of the mute_new_participants setting
   * @type {Bool} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;
};

/** A video chat participant was muted or unmuted */
export type chatEventVideoChatParticipantIsMutedToggled = {
  _: "chatEventVideoChatParticipantIsMutedToggled";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * New value of is_muted
   * @type {Bool} {@link Bool}
   */
  is_muted: Bool;
};

export type chatEventVideoChatParticipantIsMutedToggled$Input = {
  readonly _: "chatEventVideoChatParticipantIsMutedToggled";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New value of is_muted
   * @type {Bool} {@link Bool}
   */
  readonly is_muted?: Bool$Input;
};

/** A video chat participant volume level was changed */
export type chatEventVideoChatParticipantVolumeLevelChanged = {
  _: "chatEventVideoChatParticipantVolumeLevelChanged";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  participant_id: MessageSender;

  /**
   * New value of volume_level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  volume_level: int32;
};

export type chatEventVideoChatParticipantVolumeLevelChanged$Input = {
  readonly _: "chatEventVideoChatParticipantVolumeLevelChanged";

  /**
   * Identifier of the affected group call participant
   * @type {MessageSender} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New value of volume_level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;
};

/** The is_forum setting of a channel was toggled */
export type chatEventIsForumToggled = {
  _: "chatEventIsForumToggled";

  /**
   * New value of is_forum
   * @type {Bool} {@link Bool}
   */
  is_forum: Bool;
};

export type chatEventIsForumToggled$Input = {
  readonly _: "chatEventIsForumToggled";

  /**
   * New value of is_forum
   * @type {Bool} {@link Bool}
   */
  readonly is_forum?: Bool$Input;
};

/** A new forum topic was created */
export type chatEventForumTopicCreated = {
  _: "chatEventForumTopicCreated";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

export type chatEventForumTopicCreated$Input = {
  readonly _: "chatEventForumTopicCreated";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/** A forum topic was edited */
export type chatEventForumTopicEdited = {
  _: "chatEventForumTopicEdited";

  /**
   * Old information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  old_topic_info: forumTopicInfo;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  new_topic_info: forumTopicInfo;
};

export type chatEventForumTopicEdited$Input = {
  readonly _: "chatEventForumTopicEdited";

  /**
   * Old information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly old_topic_info?: forumTopicInfo$Input;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly new_topic_info?: forumTopicInfo$Input;
};

/** A forum topic was closed or reopened */
export type chatEventForumTopicToggleIsClosed = {
  _: "chatEventForumTopicToggleIsClosed";

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

export type chatEventForumTopicToggleIsClosed$Input = {
  readonly _: "chatEventForumTopicToggleIsClosed";

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/** A forum topic was deleted */
export type chatEventForumTopicDeleted = {
  _: "chatEventForumTopicDeleted";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  topic_info: forumTopicInfo;
};

export type chatEventForumTopicDeleted$Input = {
  readonly _: "chatEventForumTopicDeleted";

  /**
   * Information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly topic_info?: forumTopicInfo$Input;
};

/** A pinned forum topic was changed */
export type chatEventForumTopicPinned = {
  _: "chatEventForumTopicPinned";

  /**
   * Information about the old pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  old_topic_info: forumTopicInfo;

  /**
   * Information about the new pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  new_topic_info: forumTopicInfo;
};

export type chatEventForumTopicPinned$Input = {
  readonly _: "chatEventForumTopicPinned";

  /**
   * Information about the old pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly old_topic_info?: forumTopicInfo$Input;

  /**
   * Information about the new pinned topic; may be null
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly new_topic_info?: forumTopicInfo$Input;
};

/** Represents a chat event */
export type chatEvent = {
  _: "chatEvent";

  /**
   * Chat event identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Point in time (Unix timestamp) when the event happened
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Identifier of the user or chat who performed the action
   * @type {MessageSender} {@link MessageSender}
   */
  member_id: MessageSender;

  /**
   * The action
   * @type {ChatEventAction} {@link ChatEventAction}
   */
  action: ChatEventAction;
};

export type chatEvent$Input = {
  readonly _: "chatEvent";

  /**
   * Chat event identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Point in time (Unix timestamp) when the event happened
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Identifier of the user or chat who performed the action
   * @type {MessageSender} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * The action
   * @type {ChatEventAction} {@link ChatEventAction}
   */
  readonly action?: ChatEventAction$Input;
};

/** Contains a list of chat events */
export type chatEvents = {
  _: "chatEvents";

  /**
   * List of events
   * @type {vector<chatEvent>} {@link vector<chatEvent>}
   */
  events: vector<chatEvent>;
};

export type chatEvents$Input = {
  readonly _: "chatEvents";

  /**
   * List of events
   * @type {vector<chatEvent>} {@link vector<chatEvent>}
   */
  readonly events?: vector$Input<chatEvent$Input>;
};

/** Represents a set of filters used to obtain a chat event log */
export type chatEventLogFilters = {
  _: "chatEventLogFilters";

  /**
   * True, if message edits need to be returned
   * @type {Bool} {@link Bool}
   */
  message_edits: Bool;

  /**
   * True, if message deletions need to be returned
   * @type {Bool} {@link Bool}
   */
  message_deletions: Bool;

  /**
   * True, if pin/unpin events need to be returned
   * @type {Bool} {@link Bool}
   */
  message_pins: Bool;

  /**
   * True, if members joining events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_joins: Bool;

  /**
   * True, if members leaving events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_leaves: Bool;

  /**
   * True, if invited member events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_invites: Bool;

  /**
   * True, if member promotion/demotion events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_promotions: Bool;

  /**
   * True, if member restricted/unrestricted/banned/unbanned events need to be returned
   * @type {Bool} {@link Bool}
   */
  member_restrictions: Bool;

  /**
   * True, if changes in chat information need to be returned
   * @type {Bool} {@link Bool}
   */
  info_changes: Bool;

  /**
   * True, if changes in chat settings need to be returned
   * @type {Bool} {@link Bool}
   */
  setting_changes: Bool;

  /**
   * True, if changes to invite links need to be returned
   * @type {Bool} {@link Bool}
   */
  invite_link_changes: Bool;

  /**
   * True, if video chat actions need to be returned
   * @type {Bool} {@link Bool}
   */
  video_chat_changes: Bool;

  /**
   * True, if forum-related actions need to be returned
   * @type {Bool} {@link Bool}
   */
  forum_changes: Bool;
};

export type chatEventLogFilters$Input = {
  readonly _: "chatEventLogFilters";

  /**
   * True, if message edits need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly message_edits?: Bool$Input;

  /**
   * True, if message deletions need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly message_deletions?: Bool$Input;

  /**
   * True, if pin/unpin events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly message_pins?: Bool$Input;

  /**
   * True, if members joining events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_joins?: Bool$Input;

  /**
   * True, if members leaving events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_leaves?: Bool$Input;

  /**
   * True, if invited member events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_invites?: Bool$Input;

  /**
   * True, if member promotion/demotion events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_promotions?: Bool$Input;

  /**
   * True, if member restricted/unrestricted/banned/unbanned events need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly member_restrictions?: Bool$Input;

  /**
   * True, if changes in chat information need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly info_changes?: Bool$Input;

  /**
   * True, if changes in chat settings need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly setting_changes?: Bool$Input;

  /**
   * True, if changes to invite links need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly invite_link_changes?: Bool$Input;

  /**
   * True, if video chat actions need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly video_chat_changes?: Bool$Input;

  /**
   * True, if forum-related actions need to be returned
   * @type {Bool} {@link Bool}
   */
  readonly forum_changes?: Bool$Input;
};

/** An ordinary language pack string */
export type languagePackStringValueOrdinary = {
  _: "languagePackStringValueOrdinary";

  /**
   * String value
   * @type {string} {@link string}
   */
  value: string;
};

export type languagePackStringValueOrdinary$Input = {
  readonly _: "languagePackStringValueOrdinary";

  /**
   * String value
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/** A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information */
export type languagePackStringValuePluralized = {
  _: "languagePackStringValuePluralized";

  /**
   * Value for zero objects
   * @type {string} {@link string}
   */
  zero_value: string;

  /**
   * Value for one object
   * @type {string} {@link string}
   */
  one_value: string;

  /**
   * Value for two objects
   * @type {string} {@link string}
   */
  two_value: string;

  /**
   * Value for few objects
   * @type {string} {@link string}
   */
  few_value: string;

  /**
   * Value for many objects
   * @type {string} {@link string}
   */
  many_value: string;

  /**
   * Default value
   * @type {string} {@link string}
   */
  other_value: string;
};

export type languagePackStringValuePluralized$Input = {
  readonly _: "languagePackStringValuePluralized";

  /**
   * Value for zero objects
   * @type {string} {@link string}
   */
  readonly zero_value?: string;

  /**
   * Value for one object
   * @type {string} {@link string}
   */
  readonly one_value?: string;

  /**
   * Value for two objects
   * @type {string} {@link string}
   */
  readonly two_value?: string;

  /**
   * Value for few objects
   * @type {string} {@link string}
   */
  readonly few_value?: string;

  /**
   * Value for many objects
   * @type {string} {@link string}
   */
  readonly many_value?: string;

  /**
   * Default value
   * @type {string} {@link string}
   */
  readonly other_value?: string;
};

/** A deleted language pack string, the value must be taken from the built-in English language pack */
export type languagePackStringValueDeleted = {
  _: "languagePackStringValueDeleted";
};

export type languagePackStringValueDeleted$Input = {
  readonly _: "languagePackStringValueDeleted";
};

/** Represents one language pack string */
export type languagePackString = {
  _: "languagePackString";

  /**
   * String key
   * @type {string} {@link string}
   */
  key: string;

  /**
   * String value; pass null if the string needs to be taken from the built-in English language pack
   * @type {LanguagePackStringValue} {@link LanguagePackStringValue}
   */
  value: LanguagePackStringValue;
};

export type languagePackString$Input = {
  readonly _: "languagePackString";

  /**
   * String key
   * @type {string} {@link string}
   */
  readonly key?: string;

  /**
   * String value; pass null if the string needs to be taken from the built-in English language pack
   * @type {LanguagePackStringValue} {@link LanguagePackStringValue}
   */
  readonly value?: LanguagePackStringValue$Input;
};

/** Contains a list of language pack strings */
export type languagePackStrings = {
  _: "languagePackStrings";

  /**
   * A list of language pack strings
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  strings: vector<languagePackString>;
};

export type languagePackStrings$Input = {
  readonly _: "languagePackStrings";

  /**
   * A list of language pack strings
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/** Contains information about a language pack */
export type languagePackInfo = {
  _: "languagePackInfo";

  /**
   * Unique language pack identifier
   * @type {string} {@link string}
   */
  id: string;

  /**
   * Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
   * @type {string} {@link string}
   */
  base_language_pack_id: string;

  /**
   * Language name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Name of the language in that language
   * @type {string} {@link string}
   */
  native_name: string;

  /**
   * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
   * @type {string} {@link string}
   */
  plural_code: string;

  /**
   * True, if the language pack is official
   * @type {Bool} {@link Bool}
   */
  is_official: Bool;

  /**
   * True, if the language pack strings are RTL
   * @type {Bool} {@link Bool}
   */
  is_rtl: Bool;

  /**
   * True, if the language pack is a beta language pack
   * @type {Bool} {@link Bool}
   */
  is_beta: Bool;

  /**
   * True, if the language pack is installed by the current user
   * @type {Bool} {@link Bool}
   */
  is_installed: Bool;

  /**
   * Total number of non-deleted strings from the language pack
   * @type {int32} {@link int32}
   */
  total_string_count: int32;

  /**
   * Total number of translated strings from the language pack
   * @type {int32} {@link int32}
   */
  translated_string_count: int32;

  /**
   * Total number of non-deleted strings from the language pack available locally
   * @type {int32} {@link int32}
   */
  local_string_count: int32;

  /**
   * Link to language translation interface; empty for custom local language packs
   * @type {string} {@link string}
   */
  translation_url: string;
};

export type languagePackInfo$Input = {
  readonly _: "languagePackInfo";

  /**
   * Unique language pack identifier
   * @type {string} {@link string}
   */
  readonly id?: string;

  /**
   * Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
   * @type {string} {@link string}
   */
  readonly base_language_pack_id?: string;

  /**
   * Language name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Name of the language in that language
   * @type {string} {@link string}
   */
  readonly native_name?: string;

  /**
   * A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more information
   * @type {string} {@link string}
   */
  readonly plural_code?: string;

  /**
   * True, if the language pack is official
   * @type {Bool} {@link Bool}
   */
  readonly is_official?: Bool$Input;

  /**
   * True, if the language pack strings are RTL
   * @type {Bool} {@link Bool}
   */
  readonly is_rtl?: Bool$Input;

  /**
   * True, if the language pack is a beta language pack
   * @type {Bool} {@link Bool}
   */
  readonly is_beta?: Bool$Input;

  /**
   * True, if the language pack is installed by the current user
   * @type {Bool} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * Total number of non-deleted strings from the language pack
   * @type {int32} {@link int32}
   */
  readonly total_string_count?: int32;

  /**
   * Total number of translated strings from the language pack
   * @type {int32} {@link int32}
   */
  readonly translated_string_count?: int32;

  /**
   * Total number of non-deleted strings from the language pack available locally
   * @type {int32} {@link int32}
   */
  readonly local_string_count?: int32;

  /**
   * Link to language translation interface; empty for custom local language packs
   * @type {string} {@link string}
   */
  readonly translation_url?: string;
};

/** Contains information about the current localization target */
export type localizationTargetInfo = {
  _: "localizationTargetInfo";

  /**
   * List of available language packs for this application
   * @type {vector<languagePackInfo>} {@link vector<languagePackInfo>}
   */
  language_packs: vector<languagePackInfo>;
};

export type localizationTargetInfo$Input = {
  readonly _: "localizationTargetInfo";

  /**
   * List of available language packs for this application
   * @type {vector<languagePackInfo>} {@link vector<languagePackInfo>}
   */
  readonly language_packs?: vector$Input<languagePackInfo$Input>;
};

/** The maximum number of joined supergroups and channels */
export type premiumLimitTypeSupergroupCount = {
  _: "premiumLimitTypeSupergroupCount";
};

export type premiumLimitTypeSupergroupCount$Input = {
  readonly _: "premiumLimitTypeSupergroupCount";
};

/** The maximum number of pinned chats in the main chat list */
export type premiumLimitTypePinnedChatCount = {
  _: "premiumLimitTypePinnedChatCount";
};

export type premiumLimitTypePinnedChatCount$Input = {
  readonly _: "premiumLimitTypePinnedChatCount";
};

/** The maximum number of created public chats */
export type premiumLimitTypeCreatedPublicChatCount = {
  _: "premiumLimitTypeCreatedPublicChatCount";
};

export type premiumLimitTypeCreatedPublicChatCount$Input = {
  readonly _: "premiumLimitTypeCreatedPublicChatCount";
};

/** The maximum number of saved animations */
export type premiumLimitTypeSavedAnimationCount = {
  _: "premiumLimitTypeSavedAnimationCount";
};

export type premiumLimitTypeSavedAnimationCount$Input = {
  readonly _: "premiumLimitTypeSavedAnimationCount";
};

/** The maximum number of favorite stickers */
export type premiumLimitTypeFavoriteStickerCount = {
  _: "premiumLimitTypeFavoriteStickerCount";
};

export type premiumLimitTypeFavoriteStickerCount$Input = {
  readonly _: "premiumLimitTypeFavoriteStickerCount";
};

/** The maximum number of chat filters */
export type premiumLimitTypeChatFilterCount = {
  _: "premiumLimitTypeChatFilterCount";
};

export type premiumLimitTypeChatFilterCount$Input = {
  readonly _: "premiumLimitTypeChatFilterCount";
};

/** The maximum number of pinned and always included, or always excluded chats in a chat filter */
export type premiumLimitTypeChatFilterChosenChatCount = {
  _: "premiumLimitTypeChatFilterChosenChatCount";
};

export type premiumLimitTypeChatFilterChosenChatCount$Input = {
  readonly _: "premiumLimitTypeChatFilterChosenChatCount";
};

/** The maximum number of pinned chats in the archive chat list */
export type premiumLimitTypePinnedArchivedChatCount = {
  _: "premiumLimitTypePinnedArchivedChatCount";
};

export type premiumLimitTypePinnedArchivedChatCount$Input = {
  readonly _: "premiumLimitTypePinnedArchivedChatCount";
};

/** The maximum length of sent media caption */
export type premiumLimitTypeCaptionLength = {
  _: "premiumLimitTypeCaptionLength";
};

export type premiumLimitTypeCaptionLength$Input = {
  readonly _: "premiumLimitTypeCaptionLength";
};

/** The maximum length of the user's bio */
export type premiumLimitTypeBioLength = {
  _: "premiumLimitTypeBioLength";
};

export type premiumLimitTypeBioLength$Input = {
  readonly _: "premiumLimitTypeBioLength";
};

/** Increased limits */
export type premiumFeatureIncreasedLimits = {
  _: "premiumFeatureIncreasedLimits";
};

export type premiumFeatureIncreasedLimits$Input = {
  readonly _: "premiumFeatureIncreasedLimits";
};

/** Increased maximum upload file size */
export type premiumFeatureIncreasedUploadFileSize = {
  _: "premiumFeatureIncreasedUploadFileSize";
};

export type premiumFeatureIncreasedUploadFileSize$Input = {
  readonly _: "premiumFeatureIncreasedUploadFileSize";
};

/** Improved download speed */
export type premiumFeatureImprovedDownloadSpeed = {
  _: "premiumFeatureImprovedDownloadSpeed";
};

export type premiumFeatureImprovedDownloadSpeed$Input = {
  readonly _: "premiumFeatureImprovedDownloadSpeed";
};

/** The ability to convert voice notes to text */
export type premiumFeatureVoiceRecognition = {
  _: "premiumFeatureVoiceRecognition";
};

export type premiumFeatureVoiceRecognition$Input = {
  readonly _: "premiumFeatureVoiceRecognition";
};

/** Disabled ads */
export type premiumFeatureDisabledAds = {
  _: "premiumFeatureDisabledAds";
};

export type premiumFeatureDisabledAds$Input = {
  readonly _: "premiumFeatureDisabledAds";
};

/** Allowed to use more reactions */
export type premiumFeatureUniqueReactions = {
  _: "premiumFeatureUniqueReactions";
};

export type premiumFeatureUniqueReactions$Input = {
  readonly _: "premiumFeatureUniqueReactions";
};

/** Allowed to use premium stickers with unique effects */
export type premiumFeatureUniqueStickers = {
  _: "premiumFeatureUniqueStickers";
};

export type premiumFeatureUniqueStickers$Input = {
  readonly _: "premiumFeatureUniqueStickers";
};

/** Allowed to use custom emoji stickers in message texts and captions */
export type premiumFeatureCustomEmoji = {
  _: "premiumFeatureCustomEmoji";
};

export type premiumFeatureCustomEmoji$Input = {
  readonly _: "premiumFeatureCustomEmoji";
};

/** Ability to change position of the main chat list, archive and mute all new chats from non-contacts, and completely disable notifications about the user's contacts joined Telegram */
export type premiumFeatureAdvancedChatManagement = {
  _: "premiumFeatureAdvancedChatManagement";
};

export type premiumFeatureAdvancedChatManagement$Input = {
  readonly _: "premiumFeatureAdvancedChatManagement";
};

/** A badge in the user's profile */
export type premiumFeatureProfileBadge = {
  _: "premiumFeatureProfileBadge";
};

export type premiumFeatureProfileBadge$Input = {
  readonly _: "premiumFeatureProfileBadge";
};

/** A emoji status shown along with the user's name */
export type premiumFeatureEmojiStatus = {
  _: "premiumFeatureEmojiStatus";
};

export type premiumFeatureEmojiStatus$Input = {
  readonly _: "premiumFeatureEmojiStatus";
};

/** Profile photo animation on message and chat screens */
export type premiumFeatureAnimatedProfilePhoto = {
  _: "premiumFeatureAnimatedProfilePhoto";
};

export type premiumFeatureAnimatedProfilePhoto$Input = {
  readonly _: "premiumFeatureAnimatedProfilePhoto";
};

/** The ability to set a custom emoji as a forum topic icon */
export type premiumFeatureForumTopicIcon = {
  _: "premiumFeatureForumTopicIcon";
};

export type premiumFeatureForumTopicIcon$Input = {
  readonly _: "premiumFeatureForumTopicIcon";
};

/** Allowed to set a premium appllication icons */
export type premiumFeatureAppIcons = {
  _: "premiumFeatureAppIcons";
};

export type premiumFeatureAppIcons$Input = {
  readonly _: "premiumFeatureAppIcons";
};

/** Contains information about a limit, increased for Premium users */
export type premiumLimit = {
  _: "premiumLimit";

  /**
   * The type of the limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  type: PremiumLimitType;

  /**
   * Default value of the limit
   * @type {int32} {@link int32}
   */
  default_value: int32;

  /**
   * Value of the limit for Premium users
   * @type {int32} {@link int32}
   */
  premium_value: int32;
};

export type premiumLimit$Input = {
  readonly _: "premiumLimit";

  /**
   * The type of the limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  readonly type?: PremiumLimitType$Input;

  /**
   * Default value of the limit
   * @type {int32} {@link int32}
   */
  readonly default_value?: int32;

  /**
   * Value of the limit for Premium users
   * @type {int32} {@link int32}
   */
  readonly premium_value?: int32;
};

/** Contains information about features, available to Premium users */
export type premiumFeatures = {
  _: "premiumFeatures";

  /**
   * The list of available features
   * @type {vector<PremiumFeature>} {@link vector<PremiumFeature>}
   */
  features: vector<PremiumFeature>;

  /**
   * The list of limits, increased for Premium users
   * @type {vector<premiumLimit>} {@link vector<premiumLimit>}
   */
  limits: vector<premiumLimit>;

  /**
   * An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  payment_link: InternalLinkType;
};

export type premiumFeatures$Input = {
  readonly _: "premiumFeatures";

  /**
   * The list of available features
   * @type {vector<PremiumFeature>} {@link vector<PremiumFeature>}
   */
  readonly features?: vector$Input<PremiumFeature$Input>;

  /**
   * The list of limits, increased for Premium users
   * @type {vector<premiumLimit>} {@link vector<premiumLimit>}
   */
  readonly limits?: vector$Input<premiumLimit$Input>;

  /**
   * An internal link to be opened to pay for Telegram Premium if store payment isn't possible; may be null if direct payment isn't available
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly payment_link?: InternalLinkType$Input;
};

/** A limit was exceeded */
export type premiumSourceLimitExceeded = {
  _: "premiumSourceLimitExceeded";

  /**
   * Type of the exceeded limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  limit_type: PremiumLimitType;
};

export type premiumSourceLimitExceeded$Input = {
  readonly _: "premiumSourceLimitExceeded";

  /**
   * Type of the exceeded limit
   * @type {PremiumLimitType} {@link PremiumLimitType}
   */
  readonly limit_type?: PremiumLimitType$Input;
};

/** A user tried to use a Premium feature */
export type premiumSourceFeature = {
  _: "premiumSourceFeature";

  /**
   * The used feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  feature: PremiumFeature;
};

export type premiumSourceFeature$Input = {
  readonly _: "premiumSourceFeature";

  /**
   * The used feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;
};

/** A user opened an internal link of the type internalLinkTypePremiumFeatures */
export type premiumSourceLink = {
  _: "premiumSourceLink";

  /**
   * The referrer from the link
   * @type {string} {@link string}
   */
  referrer: string;
};

export type premiumSourceLink$Input = {
  readonly _: "premiumSourceLink";

  /**
   * The referrer from the link
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/** A user opened the Premium features screen from settings */
export type premiumSourceSettings = {
  _: "premiumSourceSettings";
};

export type premiumSourceSettings$Input = {
  readonly _: "premiumSourceSettings";
};

/** Describes a promotion animation for a Premium feature */
export type premiumFeaturePromotionAnimation = {
  _: "premiumFeaturePromotionAnimation";

  /**
   * Premium feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  feature: PremiumFeature;

  /**
   * Promotion animation for the feature
   * @type {animation} {@link animation}
   */
  animation: animation;
};

export type premiumFeaturePromotionAnimation$Input = {
  readonly _: "premiumFeaturePromotionAnimation";

  /**
   * Premium feature
   * @type {PremiumFeature} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;

  /**
   * Promotion animation for the feature
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;
};

/** Contains state of Telegram Premium subscription and promotion videos for Premium features */
export type premiumState = {
  _: "premiumState";

  /**
   * Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
   * @type {formattedText} {@link formattedText}
   */
  state: formattedText;

  /**
   * The list of available options for buying Telegram Premium
   * @type {vector<premiumPaymentOption>} {@link vector<premiumPaymentOption>}
   */
  payment_options: vector<premiumPaymentOption>;

  /**
   * The list of available promotion animations for Premium features
   * @type {vector<premiumFeaturePromotionAnimation>} {@link vector<premiumFeaturePromotionAnimation>}
   */
  animations: vector<premiumFeaturePromotionAnimation>;
};

export type premiumState$Input = {
  readonly _: "premiumState";

  /**
   * Text description of the state of the current Premium subscription; may be empty if the current user has no Telegram Premium subscription
   * @type {formattedText} {@link formattedText}
   */
  readonly state?: formattedText$Input;

  /**
   * The list of available options for buying Telegram Premium
   * @type {vector<premiumPaymentOption>} {@link vector<premiumPaymentOption>}
   */
  readonly payment_options?: vector$Input<premiumPaymentOption$Input>;

  /**
   * The list of available promotion animations for Premium features
   * @type {vector<premiumFeaturePromotionAnimation>} {@link vector<premiumFeaturePromotionAnimation>}
   */
  readonly animations?: vector$Input<premiumFeaturePromotionAnimation$Input>;
};

/** The user subscribed to Telegram Premium */
export type storePaymentPurposePremiumSubscription = {
  _: "storePaymentPurposePremiumSubscription";

  /**
   * Pass true if this is a restore of a Telegram Premium purchase; only for App Store
   * @type {Bool} {@link Bool}
   */
  is_restore: Bool;
};

export type storePaymentPurposePremiumSubscription$Input = {
  readonly _: "storePaymentPurposePremiumSubscription";

  /**
   * Pass true if this is a restore of a Telegram Premium purchase; only for App Store
   * @type {Bool} {@link Bool}
   */
  readonly is_restore?: Bool$Input;
};

/** The user gifted Telegram Premium to another user */
export type storePaymentPurposeGiftedPremium = {
  _: "storePaymentPurposeGiftedPremium";

  /**
   * Identifier of the user for which Premium was gifted
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  amount: int53;
};

export type storePaymentPurposeGiftedPremium$Input = {
  readonly _: "storePaymentPurposeGiftedPremium";

  /**
   * Identifier of the user for which Premium was gifted
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * ISO 4217 currency code of the payment currency
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Paid amount, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly amount?: int53;
};

/** A token for Firebase Cloud Messaging */
export type deviceTokenFirebaseCloudMessaging = {
  _: "deviceTokenFirebaseCloudMessaging";

  /**
   * Device registration token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  encrypt: Bool;
};

export type deviceTokenFirebaseCloudMessaging$Input = {
  readonly _: "deviceTokenFirebaseCloudMessaging";

  /**
   * Device registration token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  readonly encrypt?: Bool$Input;
};

/** A token for Apple Push Notification service */
export type deviceTokenApplePush = {
  _: "deviceTokenApplePush";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  device_token: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  is_app_sandbox: Bool;
};

export type deviceTokenApplePush$Input = {
  readonly _: "deviceTokenApplePush";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly device_token?: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_app_sandbox?: Bool$Input;
};

/** A token for Apple Push Notification service VoIP notifications */
export type deviceTokenApplePushVoIP = {
  _: "deviceTokenApplePushVoIP";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  device_token: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  is_app_sandbox: Bool;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  encrypt: Bool;
};

export type deviceTokenApplePushVoIP$Input = {
  readonly _: "deviceTokenApplePushVoIP";

  /**
   * Device token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly device_token?: string;

  /**
   * True, if App Sandbox is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_app_sandbox?: Bool$Input;

  /**
   * True, if push notifications must be additionally encrypted
   * @type {Bool} {@link Bool}
   */
  readonly encrypt?: Bool$Input;
};

/** A token for Windows Push Notification Services */
export type deviceTokenWindowsPush = {
  _: "deviceTokenWindowsPush";

  /**
   * The access token that will be used to send notifications; may be empty to deregister a device
   * @type {string} {@link string}
   */
  access_token: string;
};

export type deviceTokenWindowsPush$Input = {
  readonly _: "deviceTokenWindowsPush";

  /**
   * The access token that will be used to send notifications; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly access_token?: string;
};

/** A token for Microsoft Push Notification Service */
export type deviceTokenMicrosoftPush = {
  _: "deviceTokenMicrosoftPush";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  channel_uri: string;
};

export type deviceTokenMicrosoftPush$Input = {
  readonly _: "deviceTokenMicrosoftPush";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly channel_uri?: string;
};

/** A token for Microsoft Push Notification Service VoIP channel */
export type deviceTokenMicrosoftPushVoIP = {
  _: "deviceTokenMicrosoftPushVoIP";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  channel_uri: string;
};

export type deviceTokenMicrosoftPushVoIP$Input = {
  readonly _: "deviceTokenMicrosoftPushVoIP";

  /**
   * Push notification channel URI; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly channel_uri?: string;
};

/** A token for web Push API */
export type deviceTokenWebPush = {
  _: "deviceTokenWebPush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  endpoint: string;

  /**
   * Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
   * @type {string} {@link string}
   */
  p256dh_base64url: string;

  /**
   * Base64url-encoded authentication secret
   * @type {string} {@link string}
   */
  auth_base64url: string;
};

export type deviceTokenWebPush$Input = {
  readonly _: "deviceTokenWebPush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly endpoint?: string;

  /**
   * Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
   * @type {string} {@link string}
   */
  readonly p256dh_base64url?: string;

  /**
   * Base64url-encoded authentication secret
   * @type {string} {@link string}
   */
  readonly auth_base64url?: string;
};

/** A token for Simple Push API for Firefox OS */
export type deviceTokenSimplePush = {
  _: "deviceTokenSimplePush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  endpoint: string;
};

export type deviceTokenSimplePush$Input = {
  readonly _: "deviceTokenSimplePush";

  /**
   * Absolute URL exposed by the push service where the application server can send push messages; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly endpoint?: string;
};

/** A token for Ubuntu Push Client service */
export type deviceTokenUbuntuPush = {
  _: "deviceTokenUbuntuPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;
};

export type deviceTokenUbuntuPush$Input = {
  readonly _: "deviceTokenUbuntuPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/** A token for BlackBerry Push Service */
export type deviceTokenBlackBerryPush = {
  _: "deviceTokenBlackBerryPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  token: string;
};

export type deviceTokenBlackBerryPush$Input = {
  readonly _: "deviceTokenBlackBerryPush";

  /**
   * Token; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/** A token for Tizen Push Service */
export type deviceTokenTizenPush = {
  _: "deviceTokenTizenPush";

  /**
   * Push service registration identifier; may be empty to deregister a device
   * @type {string} {@link string}
   */
  reg_id: string;
};

export type deviceTokenTizenPush$Input = {
  readonly _: "deviceTokenTizenPush";

  /**
   * Push service registration identifier; may be empty to deregister a device
   * @type {string} {@link string}
   */
  readonly reg_id?: string;
};

/** Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification */
export type pushReceiverId = {
  _: "pushReceiverId";

  /**
   * The globally unique identifier of push notification subscription
   * @type {int64} {@link int64}
   */
  id: int64;
};

export type pushReceiverId$Input = {
  readonly _: "pushReceiverId";

  /**
   * The globally unique identifier of push notification subscription
   * @type {int64} {@link int64}
   */
  readonly id?: int64;
};

/** Describes a solid fill of a background */
export type backgroundFillSolid = {
  _: "backgroundFillSolid";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  color: int32;
};

export type backgroundFillSolid$Input = {
  readonly _: "backgroundFillSolid";

  /**
   * A color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly color?: int32;
};

/** Describes a gradient fill of a background */
export type backgroundFillGradient = {
  _: "backgroundFillGradient";

  /**
   * A top color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  top_color: int32;

  /**
   * A bottom color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  bottom_color: int32;

  /**
   * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
   * @type {int32} {@link int32}
   */
  rotation_angle: int32;
};

export type backgroundFillGradient$Input = {
  readonly _: "backgroundFillGradient";

  /**
   * A top color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly top_color?: int32;

  /**
   * A bottom color of the background in the RGB24 format
   * @type {int32} {@link int32}
   */
  readonly bottom_color?: int32;

  /**
   * Clockwise rotation angle of the gradient, in degrees; 0-359. Must always be divisible by 45
   * @type {int32} {@link int32}
   */
  readonly rotation_angle?: int32;
};

/** Describes a freeform gradient fill of a background */
export type backgroundFillFreeformGradient = {
  _: "backgroundFillFreeformGradient";

  /**
   * A list of 3 or 4 colors of the freeform gradients in the RGB24 format
   * @type {vector<int32>} {@link vector<int32>}
   */
  colors: vector<int32>;
};

export type backgroundFillFreeformGradient$Input = {
  readonly _: "backgroundFillFreeformGradient";

  /**
   * A list of 3 or 4 colors of the freeform gradients in the RGB24 format
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly colors?: vector$Input<int32>;
};

/** A wallpaper in JPEG format */
export type backgroundTypeWallpaper = {
  _: "backgroundTypeWallpaper";

  /**
   * True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
   * @type {Bool} {@link Bool}
   */
  is_blurred: Bool;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  is_moving: Bool;
};

export type backgroundTypeWallpaper$Input = {
  readonly _: "backgroundTypeWallpaper";

  /**
   * True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
   * @type {Bool} {@link Bool}
   */
  readonly is_blurred?: Bool$Input;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  readonly is_moving?: Bool$Input;
};

/** A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user */
export type backgroundTypePattern = {
  _: "backgroundTypePattern";

  /**
   * Fill of the background
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  fill: BackgroundFill;

  /**
   * Intensity of the pattern when it is shown above the filled background; 0-100.
   * @type {int32} {@link int32}
   */
  intensity: int32;

  /**
   * True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
   * @type {Bool} {@link Bool}
   */
  is_inverted: Bool;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  is_moving: Bool;
};

export type backgroundTypePattern$Input = {
  readonly _: "backgroundTypePattern";

  /**
   * Fill of the background
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly fill?: BackgroundFill$Input;

  /**
   * Intensity of the pattern when it is shown above the filled background; 0-100.
   * @type {int32} {@link int32}
   */
  readonly intensity?: int32;

  /**
   * True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
   * @type {Bool} {@link Bool}
   */
  readonly is_inverted?: Bool$Input;

  /**
   * True, if the background needs to be slightly moved when device is tilted
   * @type {Bool} {@link Bool}
   */
  readonly is_moving?: Bool$Input;
};

/** A filled background */
export type backgroundTypeFill = {
  _: "backgroundTypeFill";

  /**
   * The background fill
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  fill: BackgroundFill;
};

export type backgroundTypeFill$Input = {
  readonly _: "backgroundTypeFill";

  /**
   * The background fill
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly fill?: BackgroundFill$Input;
};

/** Describes a chat background */
export type background = {
  _: "background";

  /**
   * Unique background identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * True, if this is one of default backgrounds
   * @type {Bool} {@link Bool}
   */
  is_default: Bool;

  /**
   * True, if the background is dark and is recommended to be used with dark theme
   * @type {Bool} {@link Bool}
   */
  is_dark: Bool;

  /**
   * Unique background name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Document with the background; may be null. Null only for filled backgrounds
   * @type {document} {@link document}
   */
  document: document;

  /**
   * Type of the background
   * @type {BackgroundType} {@link BackgroundType}
   */
  type: BackgroundType;
};

export type background$Input = {
  readonly _: "background";

  /**
   * Unique background identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * True, if this is one of default backgrounds
   * @type {Bool} {@link Bool}
   */
  readonly is_default?: Bool$Input;

  /**
   * True, if the background is dark and is recommended to be used with dark theme
   * @type {Bool} {@link Bool}
   */
  readonly is_dark?: Bool$Input;

  /**
   * Unique background name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Document with the background; may be null. Null only for filled backgrounds
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * Type of the background
   * @type {BackgroundType} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input;
};

/** Contains a list of backgrounds */
export type backgrounds = {
  _: "backgrounds";

  /**
   * A list of backgrounds
   * @type {vector<background>} {@link vector<background>}
   */
  backgrounds: vector<background>;
};

export type backgrounds$Input = {
  readonly _: "backgrounds";

  /**
   * A list of backgrounds
   * @type {vector<background>} {@link vector<background>}
   */
  readonly backgrounds?: vector$Input<background$Input>;
};

/** A background from a local file */
export type inputBackgroundLocal = {
  _: "inputBackgroundLocal";

  /**
   * Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
   * @type {InputFile} {@link InputFile}
   */
  background: InputFile;
};

export type inputBackgroundLocal$Input = {
  readonly _: "inputBackgroundLocal";

  /**
   * Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
   * @type {InputFile} {@link InputFile}
   */
  readonly background?: InputFile$Input;
};

/** A background from the server */
export type inputBackgroundRemote = {
  _: "inputBackgroundRemote";

  /**
   * The background identifier
   * @type {int64} {@link int64}
   */
  background_id: int64;
};

export type inputBackgroundRemote$Input = {
  readonly _: "inputBackgroundRemote";

  /**
   * The background identifier
   * @type {int64} {@link int64}
   */
  readonly background_id?: int64;
};

/** Describes theme settings */
export type themeSettings = {
  _: "themeSettings";

  /**
   * Theme accent color in ARGB format
   * @type {int32} {@link int32}
   */
  accent_color: int32;

  /**
   * The background to be used in chats; may be null
   * @type {background} {@link background}
   */
  background: background;

  /**
   * The fill to be used as a background for outgoing messages
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  outgoing_message_fill: BackgroundFill;

  /**
   * If true, the freeform gradient fill needs to be animated on every sent message
   * @type {Bool} {@link Bool}
   */
  animate_outgoing_message_fill: Bool;

  /**
   * Accent color of outgoing messages in ARGB format
   * @type {int32} {@link int32}
   */
  outgoing_message_accent_color: int32;
};

export type themeSettings$Input = {
  readonly _: "themeSettings";

  /**
   * Theme accent color in ARGB format
   * @type {int32} {@link int32}
   */
  readonly accent_color?: int32;

  /**
   * The background to be used in chats; may be null
   * @type {background} {@link background}
   */
  readonly background?: background$Input;

  /**
   * The fill to be used as a background for outgoing messages
   * @type {BackgroundFill} {@link BackgroundFill}
   */
  readonly outgoing_message_fill?: BackgroundFill$Input;

  /**
   * If true, the freeform gradient fill needs to be animated on every sent message
   * @type {Bool} {@link Bool}
   */
  readonly animate_outgoing_message_fill?: Bool$Input;

  /**
   * Accent color of outgoing messages in ARGB format
   * @type {int32} {@link int32}
   */
  readonly outgoing_message_accent_color?: int32;
};

/** Describes a chat theme */
export type chatTheme = {
  _: "chatTheme";

  /**
   * Theme name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * Theme settings for a light chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  light_settings: themeSettings;

  /**
   * Theme settings for a dark chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  dark_settings: themeSettings;
};

export type chatTheme$Input = {
  readonly _: "chatTheme";

  /**
   * Theme name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Theme settings for a light chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  readonly light_settings?: themeSettings$Input;

  /**
   * Theme settings for a dark chat theme
   * @type {themeSettings} {@link themeSettings}
   */
  readonly dark_settings?: themeSettings$Input;
};

/** Contains a list of hashtags */
export type hashtags = {
  _: "hashtags";

  /**
   * A list of hashtags
   * @type {vector<string>} {@link vector<string>}
   */
  hashtags: vector<string>;
};

export type hashtags$Input = {
  readonly _: "hashtags";

  /**
   * A list of hashtags
   * @type {vector<string>} {@link vector<string>}
   */
  readonly hashtags?: vector$Input<string>;
};

/** The session can be used */
export type canTransferOwnershipResultOk = {
  _: "canTransferOwnershipResultOk";
};

export type canTransferOwnershipResultOk$Input = {
  readonly _: "canTransferOwnershipResultOk";
};

/** The 2-step verification needs to be enabled first */
export type canTransferOwnershipResultPasswordNeeded = {
  _: "canTransferOwnershipResultPasswordNeeded";
};

export type canTransferOwnershipResultPasswordNeeded$Input = {
  readonly _: "canTransferOwnershipResultPasswordNeeded";
};

/** The 2-step verification was enabled recently, user needs to wait */
export type canTransferOwnershipResultPasswordTooFresh = {
  _: "canTransferOwnershipResultPasswordTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  retry_after: int32;
};

export type canTransferOwnershipResultPasswordTooFresh$Input = {
  readonly _: "canTransferOwnershipResultPasswordTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  readonly retry_after?: int32;
};

/** The session was created recently, user needs to wait */
export type canTransferOwnershipResultSessionTooFresh = {
  _: "canTransferOwnershipResultSessionTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  retry_after: int32;
};

export type canTransferOwnershipResultSessionTooFresh$Input = {
  readonly _: "canTransferOwnershipResultSessionTooFresh";

  /**
   * Time left before the session can be used to transfer ownership of a chat, in seconds
   * @type {int32} {@link int32}
   */
  readonly retry_after?: int32;
};

/** The username can be set */
export type checkChatUsernameResultOk = {
  _: "checkChatUsernameResultOk";
};

export type checkChatUsernameResultOk$Input = {
  readonly _: "checkChatUsernameResultOk";
};

/** The username is invalid */
export type checkChatUsernameResultUsernameInvalid = {
  _: "checkChatUsernameResultUsernameInvalid";
};

export type checkChatUsernameResultUsernameInvalid$Input = {
  readonly _: "checkChatUsernameResultUsernameInvalid";
};

/** The username is occupied */
export type checkChatUsernameResultUsernameOccupied = {
  _: "checkChatUsernameResultUsernameOccupied";
};

export type checkChatUsernameResultUsernameOccupied$Input = {
  readonly _: "checkChatUsernameResultUsernameOccupied";
};

/** The user has too many chats with username, one of them must be made private first */
export type checkChatUsernameResultPublicChatsTooMuch = {
  _: "checkChatUsernameResultPublicChatsTooMuch";
};

export type checkChatUsernameResultPublicChatsTooMuch$Input = {
  readonly _: "checkChatUsernameResultPublicChatsTooMuch";
};

/** The user can't be a member of a public supergroup */
export type checkChatUsernameResultPublicGroupsUnavailable = {
  _: "checkChatUsernameResultPublicGroupsUnavailable";
};

export type checkChatUsernameResultPublicGroupsUnavailable$Input = {
  readonly _: "checkChatUsernameResultPublicGroupsUnavailable";
};

/** The name can be set */
export type checkStickerSetNameResultOk = {
  _: "checkStickerSetNameResultOk";
};

export type checkStickerSetNameResultOk$Input = {
  readonly _: "checkStickerSetNameResultOk";
};

/** The name is invalid */
export type checkStickerSetNameResultNameInvalid = {
  _: "checkStickerSetNameResultNameInvalid";
};

export type checkStickerSetNameResultNameInvalid$Input = {
  readonly _: "checkStickerSetNameResultNameInvalid";
};

/** The name is occupied */
export type checkStickerSetNameResultNameOccupied = {
  _: "checkStickerSetNameResultNameOccupied";
};

export type checkStickerSetNameResultNameOccupied$Input = {
  readonly _: "checkStickerSetNameResultNameOccupied";
};

/** The password was reset */
export type resetPasswordResultOk = {
  _: "resetPasswordResultOk";
};

export type resetPasswordResultOk$Input = {
  readonly _: "resetPasswordResultOk";
};

/** The password reset request is pending */
export type resetPasswordResultPending = {
  _: "resetPasswordResultPending";

  /**
   * Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  pending_reset_date: int32;
};

export type resetPasswordResultPending$Input = {
  readonly _: "resetPasswordResultPending";

  /**
   * Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
   * @type {int32} {@link int32}
   */
  readonly pending_reset_date?: int32;
};

/** The password reset request was declined */
export type resetPasswordResultDeclined = {
  _: "resetPasswordResultDeclined";

  /**
   * Point in time (Unix timestamp) when the password reset can be retried
   * @type {int32} {@link int32}
   */
  retry_date: int32;
};

export type resetPasswordResultDeclined$Input = {
  readonly _: "resetPasswordResultDeclined";

  /**
   * Point in time (Unix timestamp) when the password reset can be retried
   * @type {int32} {@link int32}
   */
  readonly retry_date?: int32;
};

/** The messages was exported from a private chat */
export type messageFileTypePrivate = {
  _: "messageFileTypePrivate";

  /**
   * Name of the other party; may be empty if unrecognized
   * @type {string} {@link string}
   */
  name: string;
};

export type messageFileTypePrivate$Input = {
  readonly _: "messageFileTypePrivate";

  /**
   * Name of the other party; may be empty if unrecognized
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/** The messages was exported from a group chat */
export type messageFileTypeGroup = {
  _: "messageFileTypeGroup";

  /**
   * Title of the group chat; may be empty if unrecognized
   * @type {string} {@link string}
   */
  title: string;
};

export type messageFileTypeGroup$Input = {
  readonly _: "messageFileTypeGroup";

  /**
   * Title of the group chat; may be empty if unrecognized
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** The messages was exported from a chat of unknown type */
export type messageFileTypeUnknown = {
  _: "messageFileTypeUnknown";
};

export type messageFileTypeUnknown$Input = {
  readonly _: "messageFileTypeUnknown";
};

/** A general message with hidden content */
export type pushMessageContentHidden = {
  _: "pushMessageContentHidden";

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentHidden$Input = {
  readonly _: "pushMessageContentHidden";

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** An animation message (GIF-style). */
export type pushMessageContentAnimation = {
  _: "pushMessageContentAnimation";

  /**
   * Message content; may be null
   * @type {animation} {@link animation}
   */
  animation: animation;

  /**
   * Animation caption
   * @type {string} {@link string}
   */
  caption: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentAnimation$Input = {
  readonly _: "pushMessageContentAnimation";

  /**
   * Message content; may be null
   * @type {animation} {@link animation}
   */
  readonly animation?: animation$Input;

  /**
   * Animation caption
   * @type {string} {@link string}
   */
  readonly caption?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** An audio message */
export type pushMessageContentAudio = {
  _: "pushMessageContentAudio";

  /**
   * Message content; may be null
   * @type {audio} {@link audio}
   */
  audio: audio;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentAudio$Input = {
  readonly _: "pushMessageContentAudio";

  /**
   * Message content; may be null
   * @type {audio} {@link audio}
   */
  readonly audio?: audio$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A message with a user contact */
export type pushMessageContentContact = {
  _: "pushMessageContentContact";

  /**
   * Contact's name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentContact$Input = {
  readonly _: "pushMessageContentContact";

  /**
   * Contact's name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A contact has registered with Telegram */
export type pushMessageContentContactRegistered = {
  _: "pushMessageContentContactRegistered";
};

export type pushMessageContentContactRegistered$Input = {
  readonly _: "pushMessageContentContactRegistered";
};

/** A document message (a general file) */
export type pushMessageContentDocument = {
  _: "pushMessageContentDocument";

  /**
   * Message content; may be null
   * @type {document} {@link document}
   */
  document: document;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentDocument$Input = {
  readonly _: "pushMessageContentDocument";

  /**
   * Message content; may be null
   * @type {document} {@link document}
   */
  readonly document?: document$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A message with a game */
export type pushMessageContentGame = {
  _: "pushMessageContentGame";

  /**
   * Game title, empty for pinned game message
   * @type {string} {@link string}
   */
  title: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentGame$Input = {
  readonly _: "pushMessageContentGame";

  /**
   * Game title, empty for pinned game message
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A new high score was achieved in a game */
export type pushMessageContentGameScore = {
  _: "pushMessageContentGameScore";

  /**
   * Game title, empty for pinned message
   * @type {string} {@link string}
   */
  title: string;

  /**
   * New score, 0 for pinned message
   * @type {int32} {@link int32}
   */
  score: int32;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentGameScore$Input = {
  readonly _: "pushMessageContentGameScore";

  /**
   * Game title, empty for pinned message
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * New score, 0 for pinned message
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A message with an invoice from a bot */
export type pushMessageContentInvoice = {
  _: "pushMessageContentInvoice";

  /**
   * Product price
   * @type {string} {@link string}
   */
  price: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentInvoice$Input = {
  readonly _: "pushMessageContentInvoice";

  /**
   * Product price
   * @type {string} {@link string}
   */
  readonly price?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A message with a location */
export type pushMessageContentLocation = {
  _: "pushMessageContentLocation";

  /**
   * True, if the location is live
   * @type {Bool} {@link Bool}
   */
  is_live: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentLocation$Input = {
  readonly _: "pushMessageContentLocation";

  /**
   * True, if the location is live
   * @type {Bool} {@link Bool}
   */
  readonly is_live?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A photo message */
export type pushMessageContentPhoto = {
  _: "pushMessageContentPhoto";

  /**
   * Message content; may be null
   * @type {photo} {@link photo}
   */
  photo: photo;

  /**
   * Photo caption
   * @type {string} {@link string}
   */
  caption: string;

  /**
   * True, if the photo is secret
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentPhoto$Input = {
  readonly _: "pushMessageContentPhoto";

  /**
   * Message content; may be null
   * @type {photo} {@link photo}
   */
  readonly photo?: photo$Input;

  /**
   * Photo caption
   * @type {string} {@link string}
   */
  readonly caption?: string;

  /**
   * True, if the photo is secret
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A message with a poll */
export type pushMessageContentPoll = {
  _: "pushMessageContentPoll";

  /**
   * Poll question
   * @type {string} {@link string}
   */
  question: string;

  /**
   * True, if the poll is regular and not in quiz mode
   * @type {Bool} {@link Bool}
   */
  is_regular: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentPoll$Input = {
  readonly _: "pushMessageContentPoll";

  /**
   * Poll question
   * @type {string} {@link string}
   */
  readonly question?: string;

  /**
   * True, if the poll is regular and not in quiz mode
   * @type {Bool} {@link Bool}
   */
  readonly is_regular?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A screenshot of a message in the chat has been taken */
export type pushMessageContentScreenshotTaken = {
  _: "pushMessageContentScreenshotTaken";
};

export type pushMessageContentScreenshotTaken$Input = {
  readonly _: "pushMessageContentScreenshotTaken";
};

/** A message with a sticker */
export type pushMessageContentSticker = {
  _: "pushMessageContentSticker";

  /**
   * Message content; may be null
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;

  /**
   * Emoji corresponding to the sticker; may be empty
   * @type {string} {@link string}
   */
  emoji: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentSticker$Input = {
  readonly _: "pushMessageContentSticker";

  /**
   * Message content; may be null
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;

  /**
   * Emoji corresponding to the sticker; may be empty
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A text message */
export type pushMessageContentText = {
  _: "pushMessageContentText";

  /**
   * Message text
   * @type {string} {@link string}
   */
  text: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentText$Input = {
  readonly _: "pushMessageContentText";

  /**
   * Message text
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A video message */
export type pushMessageContentVideo = {
  _: "pushMessageContentVideo";

  /**
   * Message content; may be null
   * @type {video} {@link video}
   */
  video: video;

  /**
   * Video caption
   * @type {string} {@link string}
   */
  caption: string;

  /**
   * True, if the video is secret
   * @type {Bool} {@link Bool}
   */
  is_secret: Bool;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentVideo$Input = {
  readonly _: "pushMessageContentVideo";

  /**
   * Message content; may be null
   * @type {video} {@link video}
   */
  readonly video?: video$Input;

  /**
   * Video caption
   * @type {string} {@link string}
   */
  readonly caption?: string;

  /**
   * True, if the video is secret
   * @type {Bool} {@link Bool}
   */
  readonly is_secret?: Bool$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A video note message */
export type pushMessageContentVideoNote = {
  _: "pushMessageContentVideoNote";

  /**
   * Message content; may be null
   * @type {videoNote} {@link videoNote}
   */
  video_note: videoNote;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentVideoNote$Input = {
  readonly _: "pushMessageContentVideoNote";

  /**
   * Message content; may be null
   * @type {videoNote} {@link videoNote}
   */
  readonly video_note?: videoNote$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A voice note message */
export type pushMessageContentVoiceNote = {
  _: "pushMessageContentVoiceNote";

  /**
   * Message content; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  voice_note: voiceNote;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type pushMessageContentVoiceNote$Input = {
  readonly _: "pushMessageContentVoiceNote";

  /**
   * Message content; may be null
   * @type {voiceNote} {@link voiceNote}
   */
  readonly voice_note?: voiceNote$Input;

  /**
   * True, if the message is a pinned message with the specified content
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** A newly created basic group */
export type pushMessageContentBasicGroupChatCreate = {
  _: "pushMessageContentBasicGroupChatCreate";
};

export type pushMessageContentBasicGroupChatCreate$Input = {
  readonly _: "pushMessageContentBasicGroupChatCreate";
};

/** New chat members were invited to a group */
export type pushMessageContentChatAddMembers = {
  _: "pushMessageContentChatAddMembers";

  /**
   * Name of the added member
   * @type {string} {@link string}
   */
  member_name: string;

  /**
   * True, if the current user was added to the group
   * @type {Bool} {@link Bool}
   */
  is_current_user: Bool;

  /**
   * True, if the user has returned to the group themselves
   * @type {Bool} {@link Bool}
   */
  is_returned: Bool;
};

export type pushMessageContentChatAddMembers$Input = {
  readonly _: "pushMessageContentChatAddMembers";

  /**
   * Name of the added member
   * @type {string} {@link string}
   */
  readonly member_name?: string;

  /**
   * True, if the current user was added to the group
   * @type {Bool} {@link Bool}
   */
  readonly is_current_user?: Bool$Input;

  /**
   * True, if the user has returned to the group themselves
   * @type {Bool} {@link Bool}
   */
  readonly is_returned?: Bool$Input;
};

/** A chat photo was edited */
export type pushMessageContentChatChangePhoto = {
  _: "pushMessageContentChatChangePhoto";
};

export type pushMessageContentChatChangePhoto$Input = {
  readonly _: "pushMessageContentChatChangePhoto";
};

/** A chat title was edited */
export type pushMessageContentChatChangeTitle = {
  _: "pushMessageContentChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  title: string;
};

export type pushMessageContentChatChangeTitle$Input = {
  readonly _: "pushMessageContentChatChangeTitle";

  /**
   * New chat title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** A chat theme was edited */
export type pushMessageContentChatSetTheme = {
  _: "pushMessageContentChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
   * @type {string} {@link string}
   */
  theme_name: string;
};

export type pushMessageContentChatSetTheme$Input = {
  readonly _: "pushMessageContentChatSetTheme";

  /**
   * If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/** A chat member was deleted */
export type pushMessageContentChatDeleteMember = {
  _: "pushMessageContentChatDeleteMember";

  /**
   * Name of the deleted member
   * @type {string} {@link string}
   */
  member_name: string;

  /**
   * True, if the current user was deleted from the group
   * @type {Bool} {@link Bool}
   */
  is_current_user: Bool;

  /**
   * True, if the user has left the group themselves
   * @type {Bool} {@link Bool}
   */
  is_left: Bool;
};

export type pushMessageContentChatDeleteMember$Input = {
  readonly _: "pushMessageContentChatDeleteMember";

  /**
   * Name of the deleted member
   * @type {string} {@link string}
   */
  readonly member_name?: string;

  /**
   * True, if the current user was deleted from the group
   * @type {Bool} {@link Bool}
   */
  readonly is_current_user?: Bool$Input;

  /**
   * True, if the user has left the group themselves
   * @type {Bool} {@link Bool}
   */
  readonly is_left?: Bool$Input;
};

/** A new member joined the chat via an invite link */
export type pushMessageContentChatJoinByLink = {
  _: "pushMessageContentChatJoinByLink";
};

export type pushMessageContentChatJoinByLink$Input = {
  readonly _: "pushMessageContentChatJoinByLink";
};

/** A new member was accepted to the chat by an administrator */
export type pushMessageContentChatJoinByRequest = {
  _: "pushMessageContentChatJoinByRequest";
};

export type pushMessageContentChatJoinByRequest$Input = {
  readonly _: "pushMessageContentChatJoinByRequest";
};

/** A new recurrent payment was made by the current user */
export type pushMessageContentRecurringPayment = {
  _: "pushMessageContentRecurringPayment";

  /**
   * The paid amount
   * @type {string} {@link string}
   */
  amount: string;
};

export type pushMessageContentRecurringPayment$Input = {
  readonly _: "pushMessageContentRecurringPayment";

  /**
   * The paid amount
   * @type {string} {@link string}
   */
  readonly amount?: string;
};

/** A forwarded messages */
export type pushMessageContentMessageForwards = {
  _: "pushMessageContentMessageForwards";

  /**
   * Number of forwarded messages
   * @type {int32} {@link int32}
   */
  total_count: int32;
};

export type pushMessageContentMessageForwards$Input = {
  readonly _: "pushMessageContentMessageForwards";

  /**
   * Number of forwarded messages
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;
};

/** A media album */
export type pushMessageContentMediaAlbum = {
  _: "pushMessageContentMediaAlbum";

  /**
   * Number of messages in the album
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * True, if the album has at least one photo
   * @type {Bool} {@link Bool}
   */
  has_photos: Bool;

  /**
   * True, if the album has at least one video
   * @type {Bool} {@link Bool}
   */
  has_videos: Bool;

  /**
   * True, if the album has at least one audio file
   * @type {Bool} {@link Bool}
   */
  has_audios: Bool;

  /**
   * True, if the album has at least one document
   * @type {Bool} {@link Bool}
   */
  has_documents: Bool;
};

export type pushMessageContentMediaAlbum$Input = {
  readonly _: "pushMessageContentMediaAlbum";

  /**
   * Number of messages in the album
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * True, if the album has at least one photo
   * @type {Bool} {@link Bool}
   */
  readonly has_photos?: Bool$Input;

  /**
   * True, if the album has at least one video
   * @type {Bool} {@link Bool}
   */
  readonly has_videos?: Bool$Input;

  /**
   * True, if the album has at least one audio file
   * @type {Bool} {@link Bool}
   */
  readonly has_audios?: Bool$Input;

  /**
   * True, if the album has at least one document
   * @type {Bool} {@link Bool}
   */
  readonly has_documents?: Bool$Input;
};

/** New message was received */
export type notificationTypeNewMessage = {
  _: "notificationTypeNewMessage";

  /**
   * The message
   * @type {message} {@link message}
   */
  message: message;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  show_preview: Bool;
};

export type notificationTypeNewMessage$Input = {
  readonly _: "notificationTypeNewMessage";

  /**
   * The message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * True, if message content must be displayed in notifications
   * @type {Bool} {@link Bool}
   */
  readonly show_preview?: Bool$Input;
};

/** New secret chat was created */
export type notificationTypeNewSecretChat = {
  _: "notificationTypeNewSecretChat";
};

export type notificationTypeNewSecretChat$Input = {
  readonly _: "notificationTypeNewSecretChat";
};

/** New call was received */
export type notificationTypeNewCall = {
  _: "notificationTypeNewCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  call_id: int32;
};

export type notificationTypeNewCall$Input = {
  readonly _: "notificationTypeNewCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;
};

/** New message was received through a push notification */
export type notificationTypeNewPushMessage = {
  _: "notificationTypeNewPushMessage";

  /**
   * The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages, or as reply_to_message_id
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Identifier of the sender of the message. Corresponding user or chat may be inaccessible
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  sender_name: string;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  is_outgoing: Bool;

  /**
   * Push message content
   * @type {PushMessageContent} {@link PushMessageContent}
   */
  content: PushMessageContent;
};

export type notificationTypeNewPushMessage$Input = {
  readonly _: "notificationTypeNewPushMessage";

  /**
   * The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages, or as reply_to_message_id
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the sender of the message. Corresponding user or chat may be inaccessible
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Name of the sender
   * @type {string} {@link string}
   */
  readonly sender_name?: string;

  /**
   * True, if the message is outgoing
   * @type {Bool} {@link Bool}
   */
  readonly is_outgoing?: Bool$Input;

  /**
   * Push message content
   * @type {PushMessageContent} {@link PushMessageContent}
   */
  readonly content?: PushMessageContent$Input;
};

/** A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages */
export type notificationGroupTypeMessages = {
  _: "notificationGroupTypeMessages";
};

export type notificationGroupTypeMessages$Input = {
  readonly _: "notificationGroupTypeMessages";
};

/** A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message */
export type notificationGroupTypeMentions = {
  _: "notificationGroupTypeMentions";
};

export type notificationGroupTypeMentions$Input = {
  readonly _: "notificationGroupTypeMentions";
};

/** A group containing a notification of type notificationTypeNewSecretChat */
export type notificationGroupTypeSecretChat = {
  _: "notificationGroupTypeSecretChat";
};

export type notificationGroupTypeSecretChat$Input = {
  readonly _: "notificationGroupTypeSecretChat";
};

/** A group containing notifications of type notificationTypeNewCall */
export type notificationGroupTypeCalls = {
  _: "notificationGroupTypeCalls";
};

export type notificationGroupTypeCalls$Input = {
  readonly _: "notificationGroupTypeCalls";
};

/** Describes a notification sound in MP3 format */
export type notificationSound = {
  _: "notificationSound";

  /**
   * Unique identifier of the notification sound
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Duration of the sound, in seconds
   * @type {int32} {@link int32}
   */
  duration: int32;

  /**
   * Point in time (Unix timestamp) when the sound was created
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * Title of the notification sound
   * @type {string} {@link string}
   */
  title: string;

  /**
   * Arbitrary data, defined while the sound was uploaded
   * @type {string} {@link string}
   */
  data: string;

  /**
   * File containing the sound
   * @type {file} {@link file}
   */
  sound: file;
};

export type notificationSound$Input = {
  readonly _: "notificationSound";

  /**
   * Unique identifier of the notification sound
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Duration of the sound, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Point in time (Unix timestamp) when the sound was created
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * Title of the notification sound
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Arbitrary data, defined while the sound was uploaded
   * @type {string} {@link string}
   */
  readonly data?: string;

  /**
   * File containing the sound
   * @type {file} {@link file}
   */
  readonly sound?: file$Input;
};

/** Contains a list of notification sounds */
export type notificationSounds = {
  _: "notificationSounds";

  /**
   * A list of notification sounds
   * @type {vector<notificationSound>} {@link vector<notificationSound>}
   */
  notification_sounds: vector<notificationSound>;
};

export type notificationSounds$Input = {
  readonly _: "notificationSounds";

  /**
   * A list of notification sounds
   * @type {vector<notificationSound>} {@link vector<notificationSound>}
   */
  readonly notification_sounds?: vector$Input<notificationSound$Input>;
};

/** Contains information about a notification */
export type notification = {
  _: "notification";

  /**
   * Unique persistent identifier of this notification
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Notification date
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * True, if the notification was explicitly sent without sound
   * @type {Bool} {@link Bool}
   */
  is_silent: Bool;

  /**
   * Notification type
   * @type {NotificationType} {@link NotificationType}
   */
  type: NotificationType;
};

export type notification$Input = {
  readonly _: "notification";

  /**
   * Unique persistent identifier of this notification
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Notification date
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * True, if the notification was explicitly sent without sound
   * @type {Bool} {@link Bool}
   */
  readonly is_silent?: Bool$Input;

  /**
   * Notification type
   * @type {NotificationType} {@link NotificationType}
   */
  readonly type?: NotificationType$Input;
};

/** Describes a group of notifications */
export type notificationGroup = {
  _: "notificationGroup";

  /**
   * Unique persistent auto-incremented from 1 identifier of the notification group
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Type of the group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  type: NotificationGroupType;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Total number of active notifications in the group
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * The list of active notifications
   * @type {vector<notification>} {@link vector<notification>}
   */
  notifications: vector<notification>;
};

export type notificationGroup$Input = {
  readonly _: "notificationGroup";

  /**
   * Unique persistent auto-incremented from 1 identifier of the notification group
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Type of the group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  readonly type?: NotificationGroupType$Input;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Total number of active notifications in the group
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * The list of active notifications
   * @type {vector<notification>} {@link vector<notification>}
   */
  readonly notifications?: vector$Input<notification$Input>;
};

/** Represents a boolean option */
export type optionValueBoolean = {
  _: "optionValueBoolean";

  /**
   * The value of the option
   * @type {Bool} {@link Bool}
   */
  value: Bool;
};

export type optionValueBoolean$Input = {
  readonly _: "optionValueBoolean";

  /**
   * The value of the option
   * @type {Bool} {@link Bool}
   */
  readonly value?: Bool$Input;
};

/** Represents an unknown option or an option which has a default value */
export type optionValueEmpty = {
  _: "optionValueEmpty";
};

export type optionValueEmpty$Input = {
  readonly _: "optionValueEmpty";
};

/** Represents an integer option */
export type optionValueInteger = {
  _: "optionValueInteger";

  /**
   * The value of the option
   * @type {int64} {@link int64}
   */
  value: int64;
};

export type optionValueInteger$Input = {
  readonly _: "optionValueInteger";

  /**
   * The value of the option
   * @type {int64} {@link int64}
   */
  readonly value?: int64;
};

/** Represents a string option */
export type optionValueString = {
  _: "optionValueString";

  /**
   * The value of the option
   * @type {string} {@link string}
   */
  value: string;
};

export type optionValueString$Input = {
  readonly _: "optionValueString";

  /**
   * The value of the option
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/** Represents one member of a JSON object */
export type jsonObjectMember = {
  _: "jsonObjectMember";

  /**
   * Member's key
   * @type {string} {@link string}
   */
  key: string;

  /**
   * Member's value
   * @type {JsonValue} {@link JsonValue}
   */
  value: JsonValue;
};

export type jsonObjectMember$Input = {
  readonly _: "jsonObjectMember";

  /**
   * Member's key
   * @type {string} {@link string}
   */
  readonly key?: string;

  /**
   * Member's value
   * @type {JsonValue} {@link JsonValue}
   */
  readonly value?: JsonValue$Input;
};

/** Represents a null JSON value */
export type jsonValueNull = {
  _: "jsonValueNull";
};

export type jsonValueNull$Input = {
  readonly _: "jsonValueNull";
};

/** Represents a boolean JSON value */
export type jsonValueBoolean = {
  _: "jsonValueBoolean";

  /**
   * The value
   * @type {Bool} {@link Bool}
   */
  value: Bool;
};

export type jsonValueBoolean$Input = {
  readonly _: "jsonValueBoolean";

  /**
   * The value
   * @type {Bool} {@link Bool}
   */
  readonly value?: Bool$Input;
};

/** Represents a numeric JSON value */
export type jsonValueNumber = {
  _: "jsonValueNumber";

  /**
   * The value
   * @type {double} {@link double}
   */
  value: double;
};

export type jsonValueNumber$Input = {
  readonly _: "jsonValueNumber";

  /**
   * The value
   * @type {double} {@link double}
   */
  readonly value?: double;
};

/** Represents a string JSON value */
export type jsonValueString = {
  _: "jsonValueString";

  /**
   * The value
   * @type {string} {@link string}
   */
  value: string;
};

export type jsonValueString$Input = {
  readonly _: "jsonValueString";

  /**
   * The value
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/** Represents a JSON array */
export type jsonValueArray = {
  _: "jsonValueArray";

  /**
   * The list of array elements
   * @type {vector<JsonValue>} {@link vector<JsonValue>}
   */
  values: vector<JsonValue>;
};

export type jsonValueArray$Input = {
  readonly _: "jsonValueArray";

  /**
   * The list of array elements
   * @type {vector<JsonValue>} {@link vector<JsonValue>}
   */
  readonly values?: vector$Input<JsonValue$Input>;
};

/** Represents a JSON object */
export type jsonValueObject = {
  _: "jsonValueObject";

  /**
   * The list of object members
   * @type {vector<jsonObjectMember>} {@link vector<jsonObjectMember>}
   */
  members: vector<jsonObjectMember>;
};

export type jsonValueObject$Input = {
  readonly _: "jsonValueObject";

  /**
   * The list of object members
   * @type {vector<jsonObjectMember>} {@link vector<jsonObjectMember>}
   */
  readonly members?: vector$Input<jsonObjectMember$Input>;
};

/** A rule to allow all users to do something */
export type userPrivacySettingRuleAllowAll = {
  _: "userPrivacySettingRuleAllowAll";
};

export type userPrivacySettingRuleAllowAll$Input = {
  readonly _: "userPrivacySettingRuleAllowAll";
};

/** A rule to allow all of a user's contacts to do something */
export type userPrivacySettingRuleAllowContacts = {
  _: "userPrivacySettingRuleAllowContacts";
};

export type userPrivacySettingRuleAllowContacts$Input = {
  readonly _: "userPrivacySettingRuleAllowContacts";
};

/** A rule to allow certain specified users to do something */
export type userPrivacySettingRuleAllowUsers = {
  _: "userPrivacySettingRuleAllowUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

export type userPrivacySettingRuleAllowUsers$Input = {
  readonly _: "userPrivacySettingRuleAllowUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/** A rule to allow all members of certain specified basic groups and supergroups to doing something */
export type userPrivacySettingRuleAllowChatMembers = {
  _: "userPrivacySettingRuleAllowChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

export type userPrivacySettingRuleAllowChatMembers$Input = {
  readonly _: "userPrivacySettingRuleAllowChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/** A rule to restrict all users from doing something */
export type userPrivacySettingRuleRestrictAll = {
  _: "userPrivacySettingRuleRestrictAll";
};

export type userPrivacySettingRuleRestrictAll$Input = {
  readonly _: "userPrivacySettingRuleRestrictAll";
};

/** A rule to restrict all contacts of a user from doing something */
export type userPrivacySettingRuleRestrictContacts = {
  _: "userPrivacySettingRuleRestrictContacts";
};

export type userPrivacySettingRuleRestrictContacts$Input = {
  readonly _: "userPrivacySettingRuleRestrictContacts";
};

/** A rule to restrict all specified users from doing something */
export type userPrivacySettingRuleRestrictUsers = {
  _: "userPrivacySettingRuleRestrictUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  user_ids: vector<int53>;
};

export type userPrivacySettingRuleRestrictUsers$Input = {
  readonly _: "userPrivacySettingRuleRestrictUsers";

  /**
   * The user identifiers, total number of users in all rules must not exceed 1000
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/** A rule to restrict all members of specified basic groups and supergroups from doing something */
export type userPrivacySettingRuleRestrictChatMembers = {
  _: "userPrivacySettingRuleRestrictChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  chat_ids: vector<int53>;
};

export type userPrivacySettingRuleRestrictChatMembers$Input = {
  readonly _: "userPrivacySettingRuleRestrictChatMembers";

  /**
   * The chat identifiers, total number of chats in all rules must not exceed 20
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/** A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed */
export type userPrivacySettingRules = {
  _: "userPrivacySettingRules";

  /**
   * A list of rules
   * @type {vector<UserPrivacySettingRule>} {@link vector<UserPrivacySettingRule>}
   */
  rules: vector<UserPrivacySettingRule>;
};

export type userPrivacySettingRules$Input = {
  readonly _: "userPrivacySettingRules";

  /**
   * A list of rules
   * @type {vector<UserPrivacySettingRule>} {@link vector<UserPrivacySettingRule>}
   */
  readonly rules?: vector$Input<UserPrivacySettingRule$Input>;
};

/** A privacy setting for managing whether the user's online status is visible */
export type userPrivacySettingShowStatus = {
  _: "userPrivacySettingShowStatus";
};

export type userPrivacySettingShowStatus$Input = {
  readonly _: "userPrivacySettingShowStatus";
};

/** A privacy setting for managing whether the user's profile photo is visible */
export type userPrivacySettingShowProfilePhoto = {
  _: "userPrivacySettingShowProfilePhoto";
};

export type userPrivacySettingShowProfilePhoto$Input = {
  readonly _: "userPrivacySettingShowProfilePhoto";
};

/** A privacy setting for managing whether a link to the user's account is included in forwarded messages */
export type userPrivacySettingShowLinkInForwardedMessages = {
  _: "userPrivacySettingShowLinkInForwardedMessages";
};

export type userPrivacySettingShowLinkInForwardedMessages$Input = {
  readonly _: "userPrivacySettingShowLinkInForwardedMessages";
};

/** A privacy setting for managing whether the user's phone number is visible */
export type userPrivacySettingShowPhoneNumber = {
  _: "userPrivacySettingShowPhoneNumber";
};

export type userPrivacySettingShowPhoneNumber$Input = {
  readonly _: "userPrivacySettingShowPhoneNumber";
};

/** A privacy setting for managing whether the user can be invited to chats */
export type userPrivacySettingAllowChatInvites = {
  _: "userPrivacySettingAllowChatInvites";
};

export type userPrivacySettingAllowChatInvites$Input = {
  readonly _: "userPrivacySettingAllowChatInvites";
};

/** A privacy setting for managing whether the user can be called */
export type userPrivacySettingAllowCalls = {
  _: "userPrivacySettingAllowCalls";
};

export type userPrivacySettingAllowCalls$Input = {
  readonly _: "userPrivacySettingAllowCalls";
};

/** A privacy setting for managing whether peer-to-peer connections can be used for calls */
export type userPrivacySettingAllowPeerToPeerCalls = {
  _: "userPrivacySettingAllowPeerToPeerCalls";
};

export type userPrivacySettingAllowPeerToPeerCalls$Input = {
  readonly _: "userPrivacySettingAllowPeerToPeerCalls";
};

/** A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all" */
export type userPrivacySettingAllowFindingByPhoneNumber = {
  _: "userPrivacySettingAllowFindingByPhoneNumber";
};

export type userPrivacySettingAllowFindingByPhoneNumber$Input = {
  readonly _: "userPrivacySettingAllowFindingByPhoneNumber";
};

/** A privacy setting for managing whether the user can receive voice and video messages in private chats */
export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages = {
  _: "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages";
};

export type userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input = {
  readonly _: "userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages";
};

/** Contains information about the period of inactivity after which the current user's account will automatically be deleted */
export type accountTtl = {
  _: "accountTtl";

  /**
   * Number of days of inactivity before the account will be flagged for deletion; 30-366 days
   * @type {int32} {@link int32}
   */
  days: int32;
};

export type accountTtl$Input = {
  readonly _: "accountTtl";

  /**
   * Number of days of inactivity before the account will be flagged for deletion; 30-366 days
   * @type {int32} {@link int32}
   */
  readonly days?: int32;
};

/** The session is running on an Android device */
export type sessionTypeAndroid = {
  _: "sessionTypeAndroid";
};

export type sessionTypeAndroid$Input = {
  readonly _: "sessionTypeAndroid";
};

/** The session is running on a generic Apple device */
export type sessionTypeApple = {
  _: "sessionTypeApple";
};

export type sessionTypeApple$Input = {
  readonly _: "sessionTypeApple";
};

/** The session is running on the Brave browser */
export type sessionTypeBrave = {
  _: "sessionTypeBrave";
};

export type sessionTypeBrave$Input = {
  readonly _: "sessionTypeBrave";
};

/** The session is running on the Chrome browser */
export type sessionTypeChrome = {
  _: "sessionTypeChrome";
};

export type sessionTypeChrome$Input = {
  readonly _: "sessionTypeChrome";
};

/** The session is running on the Edge browser */
export type sessionTypeEdge = {
  _: "sessionTypeEdge";
};

export type sessionTypeEdge$Input = {
  readonly _: "sessionTypeEdge";
};

/** The session is running on the Firefox browser */
export type sessionTypeFirefox = {
  _: "sessionTypeFirefox";
};

export type sessionTypeFirefox$Input = {
  readonly _: "sessionTypeFirefox";
};

/** The session is running on an iPad device */
export type sessionTypeIpad = {
  _: "sessionTypeIpad";
};

export type sessionTypeIpad$Input = {
  readonly _: "sessionTypeIpad";
};

/** The session is running on an iPhone device */
export type sessionTypeIphone = {
  _: "sessionTypeIphone";
};

export type sessionTypeIphone$Input = {
  readonly _: "sessionTypeIphone";
};

/** The session is running on a Linux device */
export type sessionTypeLinux = {
  _: "sessionTypeLinux";
};

export type sessionTypeLinux$Input = {
  readonly _: "sessionTypeLinux";
};

/** The session is running on a Mac device */
export type sessionTypeMac = {
  _: "sessionTypeMac";
};

export type sessionTypeMac$Input = {
  readonly _: "sessionTypeMac";
};

/** The session is running on the Opera browser */
export type sessionTypeOpera = {
  _: "sessionTypeOpera";
};

export type sessionTypeOpera$Input = {
  readonly _: "sessionTypeOpera";
};

/** The session is running on the Safari browser */
export type sessionTypeSafari = {
  _: "sessionTypeSafari";
};

export type sessionTypeSafari$Input = {
  readonly _: "sessionTypeSafari";
};

/** The session is running on an Ubuntu device */
export type sessionTypeUbuntu = {
  _: "sessionTypeUbuntu";
};

export type sessionTypeUbuntu$Input = {
  readonly _: "sessionTypeUbuntu";
};

/** The session is running on an unknown type of device */
export type sessionTypeUnknown = {
  _: "sessionTypeUnknown";
};

export type sessionTypeUnknown$Input = {
  readonly _: "sessionTypeUnknown";
};

/** The session is running on the Vivaldi browser */
export type sessionTypeVivaldi = {
  _: "sessionTypeVivaldi";
};

export type sessionTypeVivaldi$Input = {
  readonly _: "sessionTypeVivaldi";
};

/** The session is running on a Windows device */
export type sessionTypeWindows = {
  _: "sessionTypeWindows";
};

export type sessionTypeWindows$Input = {
  readonly _: "sessionTypeWindows";
};

/** The session is running on an Xbox console */
export type sessionTypeXbox = {
  _: "sessionTypeXbox";
};

export type sessionTypeXbox$Input = {
  readonly _: "sessionTypeXbox";
};

/** Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order */
export type session = {
  _: "session";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * True, if this session is the current session
   * @type {Bool} {@link Bool}
   */
  is_current: Bool;

  /**
   * True, if a 2-step verification password is needed to complete authorization of the session
   * @type {Bool} {@link Bool}
   */
  is_password_pending: Bool;

  /**
   * True, if incoming secret chats can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  can_accept_secret_chats: Bool;

  /**
   * True, if incoming calls can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  can_accept_calls: Bool;

  /**
   * Session type based on the system and application version, which can be used to display a corresponding icon
   * @type {SessionType} {@link SessionType}
   */
  type: SessionType;

  /**
   * Telegram API identifier, as provided by the application
   * @type {int32} {@link int32}
   */
  api_id: int32;

  /**
   * Name of the application, as provided by the application
   * @type {string} {@link string}
   */
  application_name: string;

  /**
   * The version of the application, as provided by the application
   * @type {string} {@link string}
   */
  application_version: string;

  /**
   * True, if the application is an official application or uses the api_id of an official application
   * @type {Bool} {@link Bool}
   */
  is_official_application: Bool;

  /**
   * Model of the device the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  device_model: string;

  /**
   * Operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  platform: string;

  /**
   * Version of the operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  system_version: string;

  /**
   * Point in time (Unix timestamp) when the user has logged in
   * @type {int32} {@link int32}
   */
  log_in_date: int32;

  /**
   * Point in time (Unix timestamp) when the session was last used
   * @type {int32} {@link int32}
   */
  last_active_date: int32;

  /**
   * IP address from which the session was created, in human-readable format
   * @type {string} {@link string}
   */
  ip: string;

  /**
   * A two-letter country code for the country from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  country: string;

  /**
   * Region code from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  region: string;
};

export type session$Input = {
  readonly _: "session";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * True, if this session is the current session
   * @type {Bool} {@link Bool}
   */
  readonly is_current?: Bool$Input;

  /**
   * True, if a 2-step verification password is needed to complete authorization of the session
   * @type {Bool} {@link Bool}
   */
  readonly is_password_pending?: Bool$Input;

  /**
   * True, if incoming secret chats can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  readonly can_accept_secret_chats?: Bool$Input;

  /**
   * True, if incoming calls can be accepted by the session
   * @type {Bool} {@link Bool}
   */
  readonly can_accept_calls?: Bool$Input;

  /**
   * Session type based on the system and application version, which can be used to display a corresponding icon
   * @type {SessionType} {@link SessionType}
   */
  readonly type?: SessionType$Input;

  /**
   * Telegram API identifier, as provided by the application
   * @type {int32} {@link int32}
   */
  readonly api_id?: int32;

  /**
   * Name of the application, as provided by the application
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * The version of the application, as provided by the application
   * @type {string} {@link string}
   */
  readonly application_version?: string;

  /**
   * True, if the application is an official application or uses the api_id of an official application
   * @type {Bool} {@link Bool}
   */
  readonly is_official_application?: Bool$Input;

  /**
   * Model of the device the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  readonly device_model?: string;

  /**
   * Operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  readonly platform?: string;

  /**
   * Version of the operating system the application has been run or is running on, as provided by the application
   * @type {string} {@link string}
   */
  readonly system_version?: string;

  /**
   * Point in time (Unix timestamp) when the user has logged in
   * @type {int32} {@link int32}
   */
  readonly log_in_date?: int32;

  /**
   * Point in time (Unix timestamp) when the session was last used
   * @type {int32} {@link int32}
   */
  readonly last_active_date?: int32;

  /**
   * IP address from which the session was created, in human-readable format
   * @type {string} {@link string}
   */
  readonly ip?: string;

  /**
   * A two-letter country code for the country from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  readonly country?: string;

  /**
   * Region code from which the session was created, based on the IP address
   * @type {string} {@link string}
   */
  readonly region?: string;
};

/** Contains a list of sessions */
export type sessions = {
  _: "sessions";

  /**
   * List of sessions
   * @type {vector<session>} {@link vector<session>}
   */
  sessions: vector<session>;

  /**
   * Number of days of inactivity before sessions will automatically be terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  inactive_session_ttl_days: int32;
};

export type sessions$Input = {
  readonly _: "sessions";

  /**
   * List of sessions
   * @type {vector<session>} {@link vector<session>}
   */
  readonly sessions?: vector$Input<session$Input>;

  /**
   * Number of days of inactivity before sessions will automatically be terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  readonly inactive_session_ttl_days?: int32;
};

/** Contains information about one website the current user is logged in with Telegram */
export type connectedWebsite = {
  _: "connectedWebsite";

  /**
   * Website identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * The domain name of the website
   * @type {string} {@link string}
   */
  domain_name: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * The version of a browser used to log in
   * @type {string} {@link string}
   */
  browser: string;

  /**
   * Operating system the browser is running on
   * @type {string} {@link string}
   */
  platform: string;

  /**
   * Point in time (Unix timestamp) when the user was logged in
   * @type {int32} {@link int32}
   */
  log_in_date: int32;

  /**
   * Point in time (Unix timestamp) when obtained authorization was last used
   * @type {int32} {@link int32}
   */
  last_active_date: int32;

  /**
   * IP address from which the user was logged in, in human-readable format
   * @type {string} {@link string}
   */
  ip: string;

  /**
   * Human-readable description of a country and a region from which the user was logged in, based on the IP address
   * @type {string} {@link string}
   */
  location: string;
};

export type connectedWebsite$Input = {
  readonly _: "connectedWebsite";

  /**
   * Website identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * The domain name of the website
   * @type {string} {@link string}
   */
  readonly domain_name?: string;

  /**
   * User identifier of a bot linked with the website
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The version of a browser used to log in
   * @type {string} {@link string}
   */
  readonly browser?: string;

  /**
   * Operating system the browser is running on
   * @type {string} {@link string}
   */
  readonly platform?: string;

  /**
   * Point in time (Unix timestamp) when the user was logged in
   * @type {int32} {@link int32}
   */
  readonly log_in_date?: int32;

  /**
   * Point in time (Unix timestamp) when obtained authorization was last used
   * @type {int32} {@link int32}
   */
  readonly last_active_date?: int32;

  /**
   * IP address from which the user was logged in, in human-readable format
   * @type {string} {@link string}
   */
  readonly ip?: string;

  /**
   * Human-readable description of a country and a region from which the user was logged in, based on the IP address
   * @type {string} {@link string}
   */
  readonly location?: string;
};

/** Contains a list of websites the current user is logged in with Telegram */
export type connectedWebsites = {
  _: "connectedWebsites";

  /**
   * List of connected websites
   * @type {vector<connectedWebsite>} {@link vector<connectedWebsite>}
   */
  websites: vector<connectedWebsite>;
};

export type connectedWebsites$Input = {
  readonly _: "connectedWebsites";

  /**
   * List of connected websites
   * @type {vector<connectedWebsite>} {@link vector<connectedWebsite>}
   */
  readonly websites?: vector$Input<connectedWebsite$Input>;
};

/** The chat contains spam messages */
export type chatReportReasonSpam = {
  _: "chatReportReasonSpam";
};

export type chatReportReasonSpam$Input = {
  readonly _: "chatReportReasonSpam";
};

/** The chat promotes violence */
export type chatReportReasonViolence = {
  _: "chatReportReasonViolence";
};

export type chatReportReasonViolence$Input = {
  readonly _: "chatReportReasonViolence";
};

/** The chat contains pornographic messages */
export type chatReportReasonPornography = {
  _: "chatReportReasonPornography";
};

export type chatReportReasonPornography$Input = {
  readonly _: "chatReportReasonPornography";
};

/** The chat has child abuse related content */
export type chatReportReasonChildAbuse = {
  _: "chatReportReasonChildAbuse";
};

export type chatReportReasonChildAbuse$Input = {
  readonly _: "chatReportReasonChildAbuse";
};

/** The chat contains copyrighted content */
export type chatReportReasonCopyright = {
  _: "chatReportReasonCopyright";
};

export type chatReportReasonCopyright$Input = {
  readonly _: "chatReportReasonCopyright";
};

/** The location-based chat is unrelated to its stated location */
export type chatReportReasonUnrelatedLocation = {
  _: "chatReportReasonUnrelatedLocation";
};

export type chatReportReasonUnrelatedLocation$Input = {
  readonly _: "chatReportReasonUnrelatedLocation";
};

/** The chat represents a fake account */
export type chatReportReasonFake = {
  _: "chatReportReasonFake";
};

export type chatReportReasonFake$Input = {
  readonly _: "chatReportReasonFake";
};

/** The chat has illegal drugs related content */
export type chatReportReasonIllegalDrugs = {
  _: "chatReportReasonIllegalDrugs";
};

export type chatReportReasonIllegalDrugs$Input = {
  readonly _: "chatReportReasonIllegalDrugs";
};

/** The chat contains messages with personal details */
export type chatReportReasonPersonalDetails = {
  _: "chatReportReasonPersonalDetails";
};

export type chatReportReasonPersonalDetails$Input = {
  readonly _: "chatReportReasonPersonalDetails";
};

/** A custom reason provided by the user */
export type chatReportReasonCustom = {
  _: "chatReportReasonCustom";
};

export type chatReportReasonCustom$Input = {
  readonly _: "chatReportReasonCustom";
};

/** The currently opened chat needs to be kept */
export type targetChatCurrent = {
  _: "targetChatCurrent";
};

export type targetChatCurrent$Input = {
  readonly _: "targetChatCurrent";
};

/** The chat needs to be chosen by the user among chats of the specified types */
export type targetChatChosen = {
  _: "targetChatChosen";

  /**
   * True, if private chats with ordinary users are allowed
   * @type {Bool} {@link Bool}
   */
  allow_user_chats: Bool;

  /**
   * True, if private chats with other bots are allowed
   * @type {Bool} {@link Bool}
   */
  allow_bot_chats: Bool;

  /**
   * True, if basic group and supergroup chats are allowed
   * @type {Bool} {@link Bool}
   */
  allow_group_chats: Bool;

  /**
   * True, if channel chats are allowed
   * @type {Bool} {@link Bool}
   */
  allow_channel_chats: Bool;
};

export type targetChatChosen$Input = {
  readonly _: "targetChatChosen";

  /**
   * True, if private chats with ordinary users are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_user_chats?: Bool$Input;

  /**
   * True, if private chats with other bots are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_bot_chats?: Bool$Input;

  /**
   * True, if basic group and supergroup chats are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_group_chats?: Bool$Input;

  /**
   * True, if channel chats are allowed
   * @type {Bool} {@link Bool}
   */
  readonly allow_channel_chats?: Bool$Input;
};

/** The chat needs to be open with the provided internal link */
export type targetChatInternalLink = {
  _: "targetChatInternalLink";

  /**
   * An internal link pointing to the chat
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  link: InternalLinkType;
};

export type targetChatInternalLink$Input = {
  readonly _: "targetChatInternalLink";

  /**
   * An internal link pointing to the chat
   * @type {InternalLinkType} {@link InternalLinkType}
   */
  readonly link?: InternalLinkType$Input;
};

/** The link is a link to the active sessions section of the application. Use getActiveSessions to handle the link */
export type internalLinkTypeActiveSessions = {
  _: "internalLinkTypeActiveSessions";
};

export type internalLinkTypeActiveSessions$Input = {
  readonly _: "internalLinkTypeActiveSessions";
};

/** The link is a link to an attachment menu bot to be opened in the specified or a chosen chat. Process given target_chat to open the chat.
-Then call searchPublicChat with the given bot username, check that the user is a bot and can be added to attachment menu. Then use getAttachmentMenuBot to receive information about the bot.
-If the bot isn't added to attachment menu, then user needs to confirm adding the bot to attachment menu. If user confirms adding, then use toggleBotIsAddedToAttachmentMenu to add it.
-If the attachment menu bot can't be used in the opened chat, show an error to the user. If the bot is added to attachment menu and can be used in the chat, then use openWebApp with the given URL */
export type internalLinkTypeAttachmentMenuBot = {
  _: "internalLinkTypeAttachmentMenuBot";

  /**
   * Target chat to be opened
   * @type {TargetChat} {@link TargetChat}
   */
  target_chat: TargetChat;

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  url: string;
};

export type internalLinkTypeAttachmentMenuBot$Input = {
  readonly _: "internalLinkTypeAttachmentMenuBot";

  /**
   * Target chat to be opened
   * @type {TargetChat} {@link TargetChat}
   */
  readonly target_chat?: TargetChat$Input;

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * URL to be passed to openWebApp
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode */
export type internalLinkTypeAuthenticationCode = {
  _: "internalLinkTypeAuthenticationCode";

  /**
   * The authentication code
   * @type {string} {@link string}
   */
  code: string;
};

export type internalLinkTypeAuthenticationCode$Input = {
  readonly _: "internalLinkTypeAuthenticationCode";

  /**
   * The authentication code
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/** The link is a link to a background. Call searchBackground with the given background name to process the link */
export type internalLinkTypeBackground = {
  _: "internalLinkTypeBackground";

  /**
   * Name of the background
   * @type {string} {@link string}
   */
  background_name: string;
};

export type internalLinkTypeBackground$Input = {
  readonly _: "internalLinkTypeBackground";

  /**
   * Name of the background
   * @type {string} {@link string}
   */
  readonly background_name?: string;
};

/** The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot,
-and then call sendBotStartMessage with the given start parameter after the button is pressed */
export type internalLinkTypeBotStart = {
  _: "internalLinkTypeBotStart";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * True, if sendBotStartMessage must be called automatically without showing the START button
   * @type {Bool} {@link Bool}
   */
  autostart: Bool;
};

export type internalLinkTypeBotStart$Input = {
  readonly _: "internalLinkTypeBotStart";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * True, if sendBotStartMessage must be called automatically without showing the START button
   * @type {Bool} {@link Bool}
   */
  readonly autostart?: Bool$Input;
};

/** The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups,
-ask the current user to select a basic group or a supergroup chat to add the bot to, taking into account that bots can be added to a public supergroup only by administrators of the supergroup.
-If administrator rights are provided by the link, call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator,
-check that the current user can edit its administrator rights, combine received rights with the requested administrator rights, show confirmation box to the user,
-and call setChatMemberStatus with the chosen chat and confirmed administrator rights. Before call to setChatMemberStatus it may be required to upgrade the chosen basic group chat to a supergroup chat.
-Then if start_parameter isn't empty, call sendBotStartMessage with the given start parameter and the chosen chat, otherwise just send /start message with bot's username added to the chat. */
export type internalLinkTypeBotStartInGroup = {
  _: "internalLinkTypeBotStartInGroup";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  start_parameter: string;

  /**
   * Expected administrator rights for the bot; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  administrator_rights: chatAdministratorRights;
};

export type internalLinkTypeBotStartInGroup$Input = {
  readonly _: "internalLinkTypeBotStartInGroup";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * The parameter to be passed to sendBotStartMessage
   * @type {string} {@link string}
   */
  readonly start_parameter?: string;

  /**
   * Expected administrator rights for the bot; may be null
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly administrator_rights?: chatAdministratorRights$Input;
};

/** The link is a link to a Telegram bot, which is supposed to be added to a channel chat as an administrator. Call searchPublicChat with the given bot username and check that the user is a bot,
-ask the current user to select a channel chat to add the bot to as an administrator. Then call getChatMember to receive the current bot rights in the chat and if the bot already is an administrator,
-check that the current user can edit its administrator rights and combine received rights with the requested administrator rights. Then show confirmation box to the user, and call setChatMemberStatus with the chosen chat and confirmed rights */
export type internalLinkTypeBotAddToChannel = {
  _: "internalLinkTypeBotAddToChannel";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * Expected administrator rights for the bot
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  administrator_rights: chatAdministratorRights;
};

export type internalLinkTypeBotAddToChannel$Input = {
  readonly _: "internalLinkTypeBotAddToChannel";

  /**
   * Username of the bot
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * Expected administrator rights for the bot
   * @type {chatAdministratorRights} {@link chatAdministratorRights}
   */
  readonly administrator_rights?: chatAdministratorRights$Input;
};

/** The link is a link to the change phone number section of the app */
export type internalLinkTypeChangePhoneNumber = {
  _: "internalLinkTypeChangePhoneNumber";
};

export type internalLinkTypeChangePhoneNumber$Input = {
  readonly _: "internalLinkTypeChangePhoneNumber";
};

/** The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link */
export type internalLinkTypeChatInvite = {
  _: "internalLinkTypeChatInvite";

  /**
   * Internal representation of the invite link
   * @type {string} {@link string}
   */
  invite_link: string;
};

export type internalLinkTypeChatInvite$Input = {
  readonly _: "internalLinkTypeChatInvite";

  /**
   * Internal representation of the invite link
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/** The link is a link to the filter settings section of the app */
export type internalLinkTypeFilterSettings = {
  _: "internalLinkTypeFilterSettings";
};

export type internalLinkTypeFilterSettings$Input = {
  readonly _: "internalLinkTypeFilterSettings";
};

/** The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame */
export type internalLinkTypeGame = {
  _: "internalLinkTypeGame";

  /**
   * Username of the bot that owns the game
   * @type {string} {@link string}
   */
  bot_username: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  game_short_name: string;
};

export type internalLinkTypeGame$Input = {
  readonly _: "internalLinkTypeGame";

  /**
   * Username of the bot that owns the game
   * @type {string} {@link string}
   */
  readonly bot_username?: string;

  /**
   * Short name of the game
   * @type {string} {@link string}
   */
  readonly game_short_name?: string;
};

/** The link must be opened in an Instant View. Call getWebPageInstantView with the given URL to process the link */
export type internalLinkTypeInstantView = {
  _: "internalLinkTypeInstantView";

  /**
   * URL to be passed to getWebPageInstantView
   * @type {string} {@link string}
   */
  url: string;

  /**
   * An URL to open if getWebPageInstantView fails
   * @type {string} {@link string}
   */
  fallback_url: string;
};

export type internalLinkTypeInstantView$Input = {
  readonly _: "internalLinkTypeInstantView";

  /**
   * URL to be passed to getWebPageInstantView
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * An URL to open if getWebPageInstantView fails
   * @type {string} {@link string}
   */
  readonly fallback_url?: string;
};

/** The link is a link to an invoice. Call getPaymentForm with the given invoice name to process the link */
export type internalLinkTypeInvoice = {
  _: "internalLinkTypeInvoice";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  invoice_name: string;
};

export type internalLinkTypeInvoice$Input = {
  readonly _: "internalLinkTypeInvoice";

  /**
   * Name of the invoice
   * @type {string} {@link string}
   */
  readonly invoice_name?: string;
};

/** The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link */
export type internalLinkTypeLanguagePack = {
  _: "internalLinkTypeLanguagePack";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  language_pack_id: string;
};

export type internalLinkTypeLanguagePack$Input = {
  readonly _: "internalLinkTypeLanguagePack";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/** The link is a link to the language settings section of the app */
export type internalLinkTypeLanguageSettings = {
  _: "internalLinkTypeLanguageSettings";
};

export type internalLinkTypeLanguageSettings$Input = {
  readonly _: "internalLinkTypeLanguageSettings";
};

/** The link is a link to a Telegram message. Call getMessageLinkInfo with the given URL to process the link */
export type internalLinkTypeMessage = {
  _: "internalLinkTypeMessage";

  /**
   * URL to be passed to getMessageLinkInfo
   * @type {string} {@link string}
   */
  url: string;
};

export type internalLinkTypeMessage$Input = {
  readonly _: "internalLinkTypeMessage";

  /**
   * URL to be passed to getMessageLinkInfo
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/** The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field */
export type internalLinkTypeMessageDraft = {
  _: "internalLinkTypeMessageDraft";

  /**
   * Message draft text
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
   * @type {Bool} {@link Bool}
   */
  contains_link: Bool;
};

export type internalLinkTypeMessageDraft$Input = {
  readonly _: "internalLinkTypeMessageDraft";

  /**
   * Message draft text
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
   * @type {Bool} {@link Bool}
   */
  readonly contains_link?: Bool$Input;
};

/** The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the application, otherwise ignore it */
export type internalLinkTypePassportDataRequest = {
  _: "internalLinkTypePassportDataRequest";

  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  bot_user_id: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  scope: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  public_key: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  nonce: string;

  /**
   * An HTTP URL to open once the request is finished or canceled with the parameter tg_passport=success or tg_passport=cancel respectively. If empty, then the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel needs to be opened instead
   * @type {string} {@link string}
   */
  callback_url: string;
};

export type internalLinkTypePassportDataRequest$Input = {
  readonly _: "internalLinkTypePassportDataRequest";

  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  readonly scope?: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  readonly public_key?: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  readonly nonce?: string;

  /**
   * An HTTP URL to open once the request is finished or canceled with the parameter tg_passport=success or tg_passport=cancel respectively. If empty, then the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel needs to be opened instead
   * @type {string} {@link string}
   */
  readonly callback_url?: string;
};

/** The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link */
export type internalLinkTypePhoneNumberConfirmation = {
  _: "internalLinkTypePhoneNumberConfirmation";

  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  hash: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  phone_number: string;
};

export type internalLinkTypePhoneNumberConfirmation$Input = {
  readonly _: "internalLinkTypePhoneNumberConfirmation";

  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  readonly hash?: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/** The link is a link to the Premium features screen of the applcation from which the user can subscribe to Telegram Premium. Call getPremiumFeatures with the given referrer to process the link */
export type internalLinkTypePremiumFeatures = {
  _: "internalLinkTypePremiumFeatures";

  /**
   * Referrer specified in the link
   * @type {string} {@link string}
   */
  referrer: string;
};

export type internalLinkTypePremiumFeatures$Input = {
  readonly _: "internalLinkTypePremiumFeatures";

  /**
   * Referrer specified in the link
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/** The link is a link to the privacy and security settings section of the app */
export type internalLinkTypePrivacyAndSecuritySettings = {
  _: "internalLinkTypePrivacyAndSecuritySettings";
};

export type internalLinkTypePrivacyAndSecuritySettings$Input = {
  readonly _: "internalLinkTypePrivacyAndSecuritySettings";
};

/** The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy */
export type internalLinkTypeProxy = {
  _: "internalLinkTypeProxy";

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  server: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  port: int32;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  type: ProxyType;
};

export type internalLinkTypeProxy$Input = {
  readonly _: "internalLinkTypeProxy";

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/** The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link */
export type internalLinkTypePublicChat = {
  _: "internalLinkTypePublicChat";

  /**
   * Username of the chat
   * @type {string} {@link string}
   */
  chat_username: string;
};

export type internalLinkTypePublicChat$Input = {
  readonly _: "internalLinkTypePublicChat";

  /**
   * Username of the chat
   * @type {string} {@link string}
   */
  readonly chat_username?: string;
};

/** The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to
-"This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings > Devices > Scan QR and scan the code" needs to be shown */
export type internalLinkTypeQrCodeAuthentication = {
  _: "internalLinkTypeQrCodeAuthentication";
};

export type internalLinkTypeQrCodeAuthentication$Input = {
  readonly _: "internalLinkTypeQrCodeAuthentication";
};

/** The link forces restore of App Store purchases when opened. For official iOS application only */
export type internalLinkTypeRestorePurchases = {
  _: "internalLinkTypeRestorePurchases";
};

export type internalLinkTypeRestorePurchases$Input = {
  readonly _: "internalLinkTypeRestorePurchases";
};

/** The link is a link to application settings */
export type internalLinkTypeSettings = {
  _: "internalLinkTypeSettings";
};

export type internalLinkTypeSettings$Input = {
  readonly _: "internalLinkTypeSettings";
};

/** The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set */
export type internalLinkTypeStickerSet = {
  _: "internalLinkTypeStickerSet";

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  sticker_set_name: string;
};

export type internalLinkTypeStickerSet$Input = {
  readonly _: "internalLinkTypeStickerSet";

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly sticker_set_name?: string;
};

/** The link is a link to a theme. TDLib has no theme support yet */
export type internalLinkTypeTheme = {
  _: "internalLinkTypeTheme";

  /**
   * Name of the theme
   * @type {string} {@link string}
   */
  theme_name: string;
};

export type internalLinkTypeTheme$Input = {
  readonly _: "internalLinkTypeTheme";

  /**
   * Name of the theme
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/** The link is a link to the theme settings section of the app */
export type internalLinkTypeThemeSettings = {
  _: "internalLinkTypeThemeSettings";
};

export type internalLinkTypeThemeSettings$Input = {
  readonly _: "internalLinkTypeThemeSettings";
};

/** The link is an unknown tg: link. Call getDeepLinkInfo to process the link */
export type internalLinkTypeUnknownDeepLink = {
  _: "internalLinkTypeUnknownDeepLink";

  /**
   * Link to be passed to getDeepLinkInfo
   * @type {string} {@link string}
   */
  link: string;
};

export type internalLinkTypeUnknownDeepLink$Input = {
  readonly _: "internalLinkTypeUnknownDeepLink";

  /**
   * Link to be passed to getDeepLinkInfo
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/** The link is a link to an unsupported proxy. An alert can be shown to the user */
export type internalLinkTypeUnsupportedProxy = {
  _: "internalLinkTypeUnsupportedProxy";
};

export type internalLinkTypeUnsupportedProxy$Input = {
  readonly _: "internalLinkTypeUnsupportedProxy";
};

/** The link is a link to a user by its phone number. Call searchUserByPhoneNumber with the given phone number to process the link */
export type internalLinkTypeUserPhoneNumber = {
  _: "internalLinkTypeUserPhoneNumber";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  phone_number: string;
};

export type internalLinkTypeUserPhoneNumber$Input = {
  readonly _: "internalLinkTypeUserPhoneNumber";

  /**
   * Phone number of the user
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/** The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGroupCall with the given invite hash to process the link */
export type internalLinkTypeVideoChat = {
  _: "internalLinkTypeVideoChat";

  /**
   * Username of the chat with the video chat
   * @type {string} {@link string}
   */
  chat_username: string;

  /**
   * If non-empty, invite hash to be used to join the video chat without being muted by administrators
   * @type {string} {@link string}
   */
  invite_hash: string;

  /**
   * True, if the video chat is expected to be a live stream in a channel or a broadcast group
   * @type {Bool} {@link Bool}
   */
  is_live_stream: Bool;
};

export type internalLinkTypeVideoChat$Input = {
  readonly _: "internalLinkTypeVideoChat";

  /**
   * Username of the chat with the video chat
   * @type {string} {@link string}
   */
  readonly chat_username?: string;

  /**
   * If non-empty, invite hash to be used to join the video chat without being muted by administrators
   * @type {string} {@link string}
   */
  readonly invite_hash?: string;

  /**
   * True, if the video chat is expected to be a live stream in a channel or a broadcast group
   * @type {Bool} {@link Bool}
   */
  readonly is_live_stream?: Bool$Input;
};

/** Contains an HTTPS link to a message in a supergroup or channel */
export type messageLink = {
  _: "messageLink";

  /**
   * Message link
   * @type {string} {@link string}
   */
  link: string;

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;
};

export type messageLink$Input = {
  readonly _: "messageLink";

  /**
   * Message link
   * @type {string} {@link string}
   */
  readonly link?: string;

  /**
   * True, if the link will work for non-members of the chat
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;
};

/** Contains information about a link to a message in a chat */
export type messageLinkInfo = {
  _: "messageLinkInfo";

  /**
   * True, if the link is a public link for a message in a chat
   * @type {Bool} {@link Bool}
   */
  is_public: Bool;

  /**
   * If found, identifier of the chat to which the message belongs, 0 otherwise
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * If found, identifier of the message thread in which to open the message, or which to open in case of a missing message
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * If found, the linked message; may be null
   * @type {message} {@link message}
   */
  message: message;

  /**
   * Timestamp from which the video/audio/video note/voice note playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  media_timestamp: int32;

  /**
   * True, if the whole media album to which the message belongs is linked
   * @type {Bool} {@link Bool}
   */
  for_album: Bool;
};

export type messageLinkInfo$Input = {
  readonly _: "messageLinkInfo";

  /**
   * True, if the link is a public link for a message in a chat
   * @type {Bool} {@link Bool}
   */
  readonly is_public?: Bool$Input;

  /**
   * If found, identifier of the chat to which the message belongs, 0 otherwise
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If found, identifier of the message thread in which to open the message, or which to open in case of a missing message
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * If found, the linked message; may be null
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * Timestamp from which the video/audio/video note/voice note playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;

  /**
   * True, if the whole media album to which the message belongs is linked
   * @type {Bool} {@link Bool}
   */
  readonly for_album?: Bool$Input;
};

/** Contains a part of a file */
export type filePart = {
  _: "filePart";

  /**
   * File bytes
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type filePart$Input = {
  readonly _: "filePart";

  /**
   * File bytes
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** The data is not a file */
export type fileTypeNone = {
  _: "fileTypeNone";
};

export type fileTypeNone$Input = {
  readonly _: "fileTypeNone";
};

/** The file is an animation */
export type fileTypeAnimation = {
  _: "fileTypeAnimation";
};

export type fileTypeAnimation$Input = {
  readonly _: "fileTypeAnimation";
};

/** The file is an audio file */
export type fileTypeAudio = {
  _: "fileTypeAudio";
};

export type fileTypeAudio$Input = {
  readonly _: "fileTypeAudio";
};

/** The file is a document */
export type fileTypeDocument = {
  _: "fileTypeDocument";
};

export type fileTypeDocument$Input = {
  readonly _: "fileTypeDocument";
};

/** The file is a notification sound */
export type fileTypeNotificationSound = {
  _: "fileTypeNotificationSound";
};

export type fileTypeNotificationSound$Input = {
  readonly _: "fileTypeNotificationSound";
};

/** The file is a photo */
export type fileTypePhoto = {
  _: "fileTypePhoto";
};

export type fileTypePhoto$Input = {
  readonly _: "fileTypePhoto";
};

/** The file is a profile photo */
export type fileTypeProfilePhoto = {
  _: "fileTypeProfilePhoto";
};

export type fileTypeProfilePhoto$Input = {
  readonly _: "fileTypeProfilePhoto";
};

/** The file was sent to a secret chat (the file type is not known to the server) */
export type fileTypeSecret = {
  _: "fileTypeSecret";
};

export type fileTypeSecret$Input = {
  readonly _: "fileTypeSecret";
};

/** The file is a thumbnail of a file from a secret chat */
export type fileTypeSecretThumbnail = {
  _: "fileTypeSecretThumbnail";
};

export type fileTypeSecretThumbnail$Input = {
  readonly _: "fileTypeSecretThumbnail";
};

/** The file is a file from Secure storage used for storing Telegram Passport files */
export type fileTypeSecure = {
  _: "fileTypeSecure";
};

export type fileTypeSecure$Input = {
  readonly _: "fileTypeSecure";
};

/** The file is a sticker */
export type fileTypeSticker = {
  _: "fileTypeSticker";
};

export type fileTypeSticker$Input = {
  readonly _: "fileTypeSticker";
};

/** The file is a thumbnail of another file */
export type fileTypeThumbnail = {
  _: "fileTypeThumbnail";
};

export type fileTypeThumbnail$Input = {
  readonly _: "fileTypeThumbnail";
};

/** The file type is not yet known */
export type fileTypeUnknown = {
  _: "fileTypeUnknown";
};

export type fileTypeUnknown$Input = {
  readonly _: "fileTypeUnknown";
};

/** The file is a video */
export type fileTypeVideo = {
  _: "fileTypeVideo";
};

export type fileTypeVideo$Input = {
  readonly _: "fileTypeVideo";
};

/** The file is a video note */
export type fileTypeVideoNote = {
  _: "fileTypeVideoNote";
};

export type fileTypeVideoNote$Input = {
  readonly _: "fileTypeVideoNote";
};

/** The file is a voice note */
export type fileTypeVoiceNote = {
  _: "fileTypeVoiceNote";
};

export type fileTypeVoiceNote$Input = {
  readonly _: "fileTypeVoiceNote";
};

/** The file is a wallpaper or a background pattern */
export type fileTypeWallpaper = {
  _: "fileTypeWallpaper";
};

export type fileTypeWallpaper$Input = {
  readonly _: "fileTypeWallpaper";
};

/** Contains the storage usage statistics for a specific file type */
export type storageStatisticsByFileType = {
  _: "storageStatisticsByFileType";

  /**
   * File type
   * @type {FileType} {@link FileType}
   */
  file_type: FileType;

  /**
   * Total size of the files, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  count: int32;
};

export type storageStatisticsByFileType$Input = {
  readonly _: "storageStatisticsByFileType";

  /**
   * File type
   * @type {FileType} {@link FileType}
   */
  readonly file_type?: FileType$Input;

  /**
   * Total size of the files, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  readonly count?: int32;
};

/** Contains the storage usage statistics for a specific chat */
export type storageStatisticsByChat = {
  _: "storageStatisticsByChat";

  /**
   * Chat identifier; 0 if none
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Total size of the files in the chat, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Total number of files in the chat
   * @type {int32} {@link int32}
   */
  count: int32;

  /**
   * Statistics split by file types
   * @type {vector<storageStatisticsByFileType>} {@link vector<storageStatisticsByFileType>}
   */
  by_file_type: vector<storageStatisticsByFileType>;
};

export type storageStatisticsByChat$Input = {
  readonly _: "storageStatisticsByChat";

  /**
   * Chat identifier; 0 if none
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Total size of the files in the chat, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Total number of files in the chat
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * Statistics split by file types
   * @type {vector<storageStatisticsByFileType>} {@link vector<storageStatisticsByFileType>}
   */
  readonly by_file_type?: vector$Input<storageStatisticsByFileType$Input>;
};

/** Contains the exact storage usage statistics split by chats and file type */
export type storageStatistics = {
  _: "storageStatistics";

  /**
   * Total size of files, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  count: int32;

  /**
   * Statistics split by chats
   * @type {vector<storageStatisticsByChat>} {@link vector<storageStatisticsByChat>}
   */
  by_chat: vector<storageStatisticsByChat>;
};

export type storageStatistics$Input = {
  readonly _: "storageStatistics";

  /**
   * Total size of files, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Total number of files
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * Statistics split by chats
   * @type {vector<storageStatisticsByChat>} {@link vector<storageStatisticsByChat>}
   */
  readonly by_chat?: vector$Input<storageStatisticsByChat$Input>;
};

/** Contains approximate storage usage statistics, excluding files of unknown file type */
export type storageStatisticsFast = {
  _: "storageStatisticsFast";

  /**
   * Approximate total size of files, in bytes
   * @type {int53} {@link int53}
   */
  files_size: int53;

  /**
   * Approximate number of files
   * @type {int32} {@link int32}
   */
  file_count: int32;

  /**
   * Size of the database
   * @type {int53} {@link int53}
   */
  database_size: int53;

  /**
   * Size of the language pack database
   * @type {int53} {@link int53}
   */
  language_pack_database_size: int53;

  /**
   * Size of the TDLib internal log
   * @type {int53} {@link int53}
   */
  log_size: int53;
};

export type storageStatisticsFast$Input = {
  readonly _: "storageStatisticsFast";

  /**
   * Approximate total size of files, in bytes
   * @type {int53} {@link int53}
   */
  readonly files_size?: int53;

  /**
   * Approximate number of files
   * @type {int32} {@link int32}
   */
  readonly file_count?: int32;

  /**
   * Size of the database
   * @type {int53} {@link int53}
   */
  readonly database_size?: int53;

  /**
   * Size of the language pack database
   * @type {int53} {@link int53}
   */
  readonly language_pack_database_size?: int53;

  /**
   * Size of the TDLib internal log
   * @type {int53} {@link int53}
   */
  readonly log_size?: int53;
};

/** Contains database statistics */
export type databaseStatistics = {
  _: "databaseStatistics";

  /**
   * Database statistics in an unspecified human-readable format
   * @type {string} {@link string}
   */
  statistics: string;
};

export type databaseStatistics$Input = {
  readonly _: "databaseStatistics";

  /**
   * Database statistics in an unspecified human-readable format
   * @type {string} {@link string}
   */
  readonly statistics?: string;
};

/** The network is not available */
export type networkTypeNone = {
  _: "networkTypeNone";
};

export type networkTypeNone$Input = {
  readonly _: "networkTypeNone";
};

/** A mobile network */
export type networkTypeMobile = {
  _: "networkTypeMobile";
};

export type networkTypeMobile$Input = {
  readonly _: "networkTypeMobile";
};

/** A mobile roaming network */
export type networkTypeMobileRoaming = {
  _: "networkTypeMobileRoaming";
};

export type networkTypeMobileRoaming$Input = {
  readonly _: "networkTypeMobileRoaming";
};

/** A Wi-Fi network */
export type networkTypeWiFi = {
  _: "networkTypeWiFi";
};

export type networkTypeWiFi$Input = {
  readonly _: "networkTypeWiFi";
};

/** A different network type (e.g., Ethernet network) */
export type networkTypeOther = {
  _: "networkTypeOther";
};

export type networkTypeOther$Input = {
  readonly _: "networkTypeOther";
};

/** Contains information about the total amount of data that was used to send and receive files */
export type networkStatisticsEntryFile = {
  _: "networkStatisticsEntryFile";

  /**
   * Type of the file the data is part of; pass null if the data isn't related to files
   * @type {FileType} {@link FileType}
   */
  file_type: FileType;

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  network_type: NetworkType;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  sent_bytes: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  received_bytes: int53;
};

export type networkStatisticsEntryFile$Input = {
  readonly _: "networkStatisticsEntryFile";

  /**
   * Type of the file the data is part of; pass null if the data isn't related to files
   * @type {FileType} {@link FileType}
   */
  readonly file_type?: FileType$Input;

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  readonly network_type?: NetworkType$Input;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  readonly sent_bytes?: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  readonly received_bytes?: int53;
};

/** Contains information about the total amount of data that was used for calls */
export type networkStatisticsEntryCall = {
  _: "networkStatisticsEntryCall";

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  network_type: NetworkType;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  sent_bytes: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  received_bytes: int53;

  /**
   * Total call duration, in seconds
   * @type {double} {@link double}
   */
  duration: double;
};

export type networkStatisticsEntryCall$Input = {
  readonly _: "networkStatisticsEntryCall";

  /**
   * Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
   * @type {NetworkType} {@link NetworkType}
   */
  readonly network_type?: NetworkType$Input;

  /**
   * Total number of bytes sent
   * @type {int53} {@link int53}
   */
  readonly sent_bytes?: int53;

  /**
   * Total number of bytes received
   * @type {int53} {@link int53}
   */
  readonly received_bytes?: int53;

  /**
   * Total call duration, in seconds
   * @type {double} {@link double}
   */
  readonly duration?: double;
};

/** A full list of available network statistic entries */
export type networkStatistics = {
  _: "networkStatistics";

  /**
   * Point in time (Unix timestamp) from which the statistics are collected
   * @type {int32} {@link int32}
   */
  since_date: int32;

  /**
   * Network statistics entries
   * @type {vector<NetworkStatisticsEntry>} {@link vector<NetworkStatisticsEntry>}
   */
  entries: vector<NetworkStatisticsEntry>;
};

export type networkStatistics$Input = {
  readonly _: "networkStatistics";

  /**
   * Point in time (Unix timestamp) from which the statistics are collected
   * @type {int32} {@link int32}
   */
  readonly since_date?: int32;

  /**
   * Network statistics entries
   * @type {vector<NetworkStatisticsEntry>} {@link vector<NetworkStatisticsEntry>}
   */
  readonly entries?: vector$Input<NetworkStatisticsEntry$Input>;
};

/** Contains auto-download settings */
export type autoDownloadSettings = {
  _: "autoDownloadSettings";

  /**
   * True, if the auto-download is enabled
   * @type {Bool} {@link Bool}
   */
  is_auto_download_enabled: Bool;

  /**
   * The maximum size of a photo file to be auto-downloaded, in bytes
   * @type {int32} {@link int32}
   */
  max_photo_file_size: int32;

  /**
   * The maximum size of a video file to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  max_video_file_size: int53;

  /**
   * The maximum size of other file types to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  max_other_file_size: int53;

  /**
   * The maximum suggested bitrate for uploaded videos, in kbit/s
   * @type {int32} {@link int32}
   */
  video_upload_bitrate: int32;

  /**
   * True, if the beginning of video files needs to be preloaded for instant playback
   * @type {Bool} {@link Bool}
   */
  preload_large_videos: Bool;

  /**
   * True, if the next audio track needs to be preloaded while the user is listening to an audio file
   * @type {Bool} {@link Bool}
   */
  preload_next_audio: Bool;

  /**
   * True, if "use less data for calls" option needs to be enabled
   * @type {Bool} {@link Bool}
   */
  use_less_data_for_calls: Bool;
};

export type autoDownloadSettings$Input = {
  readonly _: "autoDownloadSettings";

  /**
   * True, if the auto-download is enabled
   * @type {Bool} {@link Bool}
   */
  readonly is_auto_download_enabled?: Bool$Input;

  /**
   * The maximum size of a photo file to be auto-downloaded, in bytes
   * @type {int32} {@link int32}
   */
  readonly max_photo_file_size?: int32;

  /**
   * The maximum size of a video file to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  readonly max_video_file_size?: int53;

  /**
   * The maximum size of other file types to be auto-downloaded, in bytes
   * @type {int53} {@link int53}
   */
  readonly max_other_file_size?: int53;

  /**
   * The maximum suggested bitrate for uploaded videos, in kbit/s
   * @type {int32} {@link int32}
   */
  readonly video_upload_bitrate?: int32;

  /**
   * True, if the beginning of video files needs to be preloaded for instant playback
   * @type {Bool} {@link Bool}
   */
  readonly preload_large_videos?: Bool$Input;

  /**
   * True, if the next audio track needs to be preloaded while the user is listening to an audio file
   * @type {Bool} {@link Bool}
   */
  readonly preload_next_audio?: Bool$Input;

  /**
   * True, if "use less data for calls" option needs to be enabled
   * @type {Bool} {@link Bool}
   */
  readonly use_less_data_for_calls?: Bool$Input;
};

/** Contains auto-download settings presets for the current user */
export type autoDownloadSettingsPresets = {
  _: "autoDownloadSettingsPresets";

  /**
   * Preset with lowest settings; supposed to be used by default when roaming
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  low: autoDownloadSettings;

  /**
   * Preset with medium settings; supposed to be used by default when using mobile data
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  medium: autoDownloadSettings;

  /**
   * Preset with highest settings; supposed to be used by default when connected on Wi-Fi
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  high: autoDownloadSettings;
};

export type autoDownloadSettingsPresets$Input = {
  readonly _: "autoDownloadSettingsPresets";

  /**
   * Preset with lowest settings; supposed to be used by default when roaming
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  readonly low?: autoDownloadSettings$Input;

  /**
   * Preset with medium settings; supposed to be used by default when using mobile data
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  readonly medium?: autoDownloadSettings$Input;

  /**
   * Preset with highest settings; supposed to be used by default when connected on Wi-Fi
   * @type {autoDownloadSettings} {@link autoDownloadSettings}
   */
  readonly high?: autoDownloadSettings$Input;
};

/** Currently waiting for the network to become available. Use setNetworkType to change the available network type */
export type connectionStateWaitingForNetwork = {
  _: "connectionStateWaitingForNetwork";
};

export type connectionStateWaitingForNetwork$Input = {
  readonly _: "connectionStateWaitingForNetwork";
};

/** Currently establishing a connection with a proxy server */
export type connectionStateConnectingToProxy = {
  _: "connectionStateConnectingToProxy";
};

export type connectionStateConnectingToProxy$Input = {
  readonly _: "connectionStateConnectingToProxy";
};

/** Currently establishing a connection to the Telegram servers */
export type connectionStateConnecting = {
  _: "connectionStateConnecting";
};

export type connectionStateConnecting$Input = {
  readonly _: "connectionStateConnecting";
};

/** Downloading data received while the application was offline */
export type connectionStateUpdating = {
  _: "connectionStateUpdating";
};

export type connectionStateUpdating$Input = {
  readonly _: "connectionStateUpdating";
};

/** There is a working connection to the Telegram servers */
export type connectionStateReady = {
  _: "connectionStateReady";
};

export type connectionStateReady$Input = {
  readonly _: "connectionStateReady";
};

/** A category containing frequently used private chats with non-bot users */
export type topChatCategoryUsers = {
  _: "topChatCategoryUsers";
};

export type topChatCategoryUsers$Input = {
  readonly _: "topChatCategoryUsers";
};

/** A category containing frequently used private chats with bot users */
export type topChatCategoryBots = {
  _: "topChatCategoryBots";
};

export type topChatCategoryBots$Input = {
  readonly _: "topChatCategoryBots";
};

/** A category containing frequently used basic groups and supergroups */
export type topChatCategoryGroups = {
  _: "topChatCategoryGroups";
};

export type topChatCategoryGroups$Input = {
  readonly _: "topChatCategoryGroups";
};

/** A category containing frequently used channels */
export type topChatCategoryChannels = {
  _: "topChatCategoryChannels";
};

export type topChatCategoryChannels$Input = {
  readonly _: "topChatCategoryChannels";
};

/** A category containing frequently used chats with inline bots sorted by their usage in inline mode */
export type topChatCategoryInlineBots = {
  _: "topChatCategoryInlineBots";
};

export type topChatCategoryInlineBots$Input = {
  readonly _: "topChatCategoryInlineBots";
};

/** A category containing frequently used chats used for calls */
export type topChatCategoryCalls = {
  _: "topChatCategoryCalls";
};

export type topChatCategoryCalls$Input = {
  readonly _: "topChatCategoryCalls";
};

/** A category containing frequently used chats used to forward messages */
export type topChatCategoryForwardChats = {
  _: "topChatCategoryForwardChats";
};

export type topChatCategoryForwardChats$Input = {
  readonly _: "topChatCategoryForwardChats";
};

/** A URL linking to a user */
export type tMeUrlTypeUser = {
  _: "tMeUrlTypeUser";

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type tMeUrlTypeUser$Input = {
  readonly _: "tMeUrlTypeUser";

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** A URL linking to a public supergroup or channel */
export type tMeUrlTypeSupergroup = {
  _: "tMeUrlTypeSupergroup";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;
};

export type tMeUrlTypeSupergroup$Input = {
  readonly _: "tMeUrlTypeSupergroup";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/** A chat invite link */
export type tMeUrlTypeChatInvite = {
  _: "tMeUrlTypeChatInvite";

  /**
   * Information about the chat invite link
   * @type {chatInviteLinkInfo} {@link chatInviteLinkInfo}
   */
  info: chatInviteLinkInfo;
};

export type tMeUrlTypeChatInvite$Input = {
  readonly _: "tMeUrlTypeChatInvite";

  /**
   * Information about the chat invite link
   * @type {chatInviteLinkInfo} {@link chatInviteLinkInfo}
   */
  readonly info?: chatInviteLinkInfo$Input;
};

/** A URL linking to a sticker set */
export type tMeUrlTypeStickerSet = {
  _: "tMeUrlTypeStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  sticker_set_id: int64;
};

export type tMeUrlTypeStickerSet$Input = {
  readonly _: "tMeUrlTypeStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly sticker_set_id?: int64;
};

/** Represents a URL linking to an internal Telegram entity */
export type tMeUrl = {
  _: "tMeUrl";

  /**
   * URL
   * @type {string} {@link string}
   */
  url: string;

  /**
   * Type of the URL
   * @type {TMeUrlType} {@link TMeUrlType}
   */
  type: TMeUrlType;
};

export type tMeUrl$Input = {
  readonly _: "tMeUrl";

  /**
   * URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Type of the URL
   * @type {TMeUrlType} {@link TMeUrlType}
   */
  readonly type?: TMeUrlType$Input;
};

/** Contains a list of t.me URLs */
export type tMeUrls = {
  _: "tMeUrls";

  /**
   * List of URLs
   * @type {vector<tMeUrl>} {@link vector<tMeUrl>}
   */
  urls: vector<tMeUrl>;
};

export type tMeUrls$Input = {
  readonly _: "tMeUrls";

  /**
   * List of URLs
   * @type {vector<tMeUrl>} {@link vector<tMeUrl>}
   */
  readonly urls?: vector$Input<tMeUrl$Input>;
};

/** Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users" option */
export type suggestedActionEnableArchiveAndMuteNewChats = {
  _: "suggestedActionEnableArchiveAndMuteNewChats";
};

export type suggestedActionEnableArchiveAndMuteNewChats$Input = {
  readonly _: "suggestedActionEnableArchiveAndMuteNewChats";
};

/** Suggests the user to check whether they still remember their 2-step verification password */
export type suggestedActionCheckPassword = {
  _: "suggestedActionCheckPassword";
};

export type suggestedActionCheckPassword$Input = {
  readonly _: "suggestedActionCheckPassword";
};

/** Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible */
export type suggestedActionCheckPhoneNumber = {
  _: "suggestedActionCheckPhoneNumber";
};

export type suggestedActionCheckPhoneNumber$Input = {
  readonly _: "suggestedActionCheckPhoneNumber";
};

/** Suggests the user to view a hint about the meaning of one and two check marks on sent messages */
export type suggestedActionViewChecksHint = {
  _: "suggestedActionViewChecksHint";
};

export type suggestedActionViewChecksHint$Input = {
  readonly _: "suggestedActionViewChecksHint";
};

/** Suggests the user to convert specified supergroup to a broadcast group */
export type suggestedActionConvertToBroadcastGroup = {
  _: "suggestedActionConvertToBroadcastGroup";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;
};

export type suggestedActionConvertToBroadcastGroup$Input = {
  readonly _: "suggestedActionConvertToBroadcastGroup";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/** Suggests the user to set a 2-step verification password to be able to log in again */
export type suggestedActionSetPassword = {
  _: "suggestedActionSetPassword";

  /**
   * The number of days to pass between consecutive authorizations if the user declines to set password
   * @type {int32} {@link int32}
   */
  authorization_delay: int32;
};

export type suggestedActionSetPassword$Input = {
  readonly _: "suggestedActionSetPassword";

  /**
   * The number of days to pass between consecutive authorizations if the user declines to set password
   * @type {int32} {@link int32}
   */
  readonly authorization_delay?: int32;
};

/** Contains a counter */
export type count = {
  _: "count";

  /**
   * Count
   * @type {int32} {@link int32}
   */
  count: int32;
};

export type count$Input = {
  readonly _: "count";

  /**
   * Count
   * @type {int32} {@link int32}
   */
  readonly count?: int32;
};

/** Contains some text */
export type text = {
  _: "text";

  /**
   * Text
   * @type {string} {@link string}
   */
  text: string;
};

export type text$Input = {
  readonly _: "text";

  /**
   * Text
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/** Contains a value representing a number of seconds */
export type seconds = {
  _: "seconds";

  /**
   * Number of seconds
   * @type {double} {@link double}
   */
  seconds: double;
};

export type seconds$Input = {
  readonly _: "seconds";

  /**
   * Number of seconds
   * @type {double} {@link double}
   */
  readonly seconds?: double;
};

/** Contains size of downloaded prefix of a file */
export type fileDownloadedPrefixSize = {
  _: "fileDownloadedPrefixSize";

  /**
   * The prefix size, in bytes
   * @type {int53} {@link int53}
   */
  size: int53;
};

export type fileDownloadedPrefixSize$Input = {
  readonly _: "fileDownloadedPrefixSize";

  /**
   * The prefix size, in bytes
   * @type {int53} {@link int53}
   */
  readonly size?: int53;
};

/** Contains information about a tg: deep link */
export type deepLinkInfo = {
  _: "deepLinkInfo";

  /**
   * Text to be shown to the user
   * @type {formattedText} {@link formattedText}
   */
  text: formattedText;

  /**
   * True, if the user must be asked to update the application
   * @type {Bool} {@link Bool}
   */
  need_update_application: Bool;
};

export type deepLinkInfo$Input = {
  readonly _: "deepLinkInfo";

  /**
   * Text to be shown to the user
   * @type {formattedText} {@link formattedText}
   */
  readonly text?: formattedText$Input;

  /**
   * True, if the user must be asked to update the application
   * @type {Bool} {@link Bool}
   */
  readonly need_update_application?: Bool$Input;
};

/** The text uses Markdown-style formatting */
export type textParseModeMarkdown = {
  _: "textParseModeMarkdown";

  /**
   * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
   * @type {int32} {@link int32}
   */
  version: int32;
};

export type textParseModeMarkdown$Input = {
  readonly _: "textParseModeMarkdown";

  /**
   * Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
   * @type {int32} {@link int32}
   */
  readonly version?: int32;
};

/** The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode */
export type textParseModeHTML = {
  _: "textParseModeHTML";
};

export type textParseModeHTML$Input = {
  readonly _: "textParseModeHTML";
};

/** A SOCKS5 proxy server */
export type proxyTypeSocks5 = {
  _: "proxyTypeSocks5";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  username: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  password: string;
};

export type proxyTypeSocks5$Input = {
  readonly _: "proxyTypeSocks5";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/** A HTTP transparent proxy server */
export type proxyTypeHttp = {
  _: "proxyTypeHttp";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  username: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  password: string;

  /**
   * Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
   * @type {Bool} {@link Bool}
   */
  http_only: Bool;
};

export type proxyTypeHttp$Input = {
  readonly _: "proxyTypeHttp";

  /**
   * Username for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Password for logging in; may be empty
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
   * @type {Bool} {@link Bool}
   */
  readonly http_only?: Bool$Input;
};

/** An MTProto proxy server */
export type proxyTypeMtproto = {
  _: "proxyTypeMtproto";

  /**
   * The proxy's secret in hexadecimal encoding
   * @type {string} {@link string}
   */
  secret: string;
};

export type proxyTypeMtproto$Input = {
  readonly _: "proxyTypeMtproto";

  /**
   * The proxy's secret in hexadecimal encoding
   * @type {string} {@link string}
   */
  readonly secret?: string;
};

/** Contains information about a proxy server */
export type proxy = {
  _: "proxy";

  /**
   * Unique identifier of the proxy
   * @type {int32} {@link int32}
   */
  id: int32;

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  server: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  port: int32;

  /**
   * Point in time (Unix timestamp) when the proxy was last used; 0 if never
   * @type {int32} {@link int32}
   */
  last_used_date: int32;

  /**
   * True, if the proxy is enabled now
   * @type {Bool} {@link Bool}
   */
  is_enabled: Bool;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  type: ProxyType;
};

export type proxy$Input = {
  readonly _: "proxy";

  /**
   * Unique identifier of the proxy
   * @type {int32} {@link int32}
   */
  readonly id?: int32;

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Point in time (Unix timestamp) when the proxy was last used; 0 if never
   * @type {int32} {@link int32}
   */
  readonly last_used_date?: int32;

  /**
   * True, if the proxy is enabled now
   * @type {Bool} {@link Bool}
   */
  readonly is_enabled?: Bool$Input;

  /**
   * Type of the proxy
   * @type {ProxyType} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/** Represents a list of proxy servers */
export type proxies = {
  _: "proxies";

  /**
   * List of proxy servers
   * @type {vector<proxy>} {@link vector<proxy>}
   */
  proxies: vector<proxy>;
};

export type proxies$Input = {
  readonly _: "proxies";

  /**
   * List of proxy servers
   * @type {vector<proxy>} {@link vector<proxy>}
   */
  readonly proxies?: vector$Input<proxy$Input>;
};

/** A sticker to be added to a sticker set */
export type inputSticker = {
  _: "inputSticker";

  /**
   * File with the sticker; must fit in a 512x512 square. For WEBP stickers and masks the file must be in PNG format, which will be converted to WEBP server-side. Otherwise, the file must be local or uploaded within a week. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
   * @type {InputFile} {@link InputFile}
   */
  sticker: InputFile;

  /**
   * Emojis corresponding to the sticker
   * @type {string} {@link string}
   */
  emojis: string;

  /**
   * Sticker format
   * @type {StickerFormat} {@link StickerFormat}
   */
  format: StickerFormat;

  /**
   * Position where the mask is placed; pass null if not specified
   * @type {maskPosition} {@link maskPosition}
   */
  mask_position: maskPosition;
};

export type inputSticker$Input = {
  readonly _: "inputSticker";

  /**
   * File with the sticker; must fit in a 512x512 square. For WEBP stickers and masks the file must be in PNG format, which will be converted to WEBP server-side. Otherwise, the file must be local or uploaded within a week. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
   * @type {InputFile} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * Emojis corresponding to the sticker
   * @type {string} {@link string}
   */
  readonly emojis?: string;

  /**
   * Sticker format
   * @type {StickerFormat} {@link StickerFormat}
   */
  readonly format?: StickerFormat$Input;

  /**
   * Position where the mask is placed; pass null if not specified
   * @type {maskPosition} {@link maskPosition}
   */
  readonly mask_position?: maskPosition$Input;
};

/** Represents a date range */
export type dateRange = {
  _: "dateRange";

  /**
   * Point in time (Unix timestamp) at which the date range begins
   * @type {int32} {@link int32}
   */
  start_date: int32;

  /**
   * Point in time (Unix timestamp) at which the date range ends
   * @type {int32} {@link int32}
   */
  end_date: int32;
};

export type dateRange$Input = {
  readonly _: "dateRange";

  /**
   * Point in time (Unix timestamp) at which the date range begins
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Point in time (Unix timestamp) at which the date range ends
   * @type {int32} {@link int32}
   */
  readonly end_date?: int32;
};

/** A value with information about its recent changes */
export type statisticalValue = {
  _: "statisticalValue";

  /**
   * The current value
   * @type {double} {@link double}
   */
  value: double;

  /**
   * The value for the previous day
   * @type {double} {@link double}
   */
  previous_value: double;

  /**
   * The growth rate of the value, as a percentage
   * @type {double} {@link double}
   */
  growth_rate_percentage: double;
};

export type statisticalValue$Input = {
  readonly _: "statisticalValue";

  /**
   * The current value
   * @type {double} {@link double}
   */
  readonly value?: double;

  /**
   * The value for the previous day
   * @type {double} {@link double}
   */
  readonly previous_value?: double;

  /**
   * The growth rate of the value, as a percentage
   * @type {double} {@link double}
   */
  readonly growth_rate_percentage?: double;
};

/** A graph data */
export type statisticalGraphData = {
  _: "statisticalGraphData";

  /**
   * Graph data in JSON format
   * @type {string} {@link string}
   */
  json_data: string;

  /**
   * If non-empty, a token which can be used to receive a zoomed in graph
   * @type {string} {@link string}
   */
  zoom_token: string;
};

export type statisticalGraphData$Input = {
  readonly _: "statisticalGraphData";

  /**
   * Graph data in JSON format
   * @type {string} {@link string}
   */
  readonly json_data?: string;

  /**
   * If non-empty, a token which can be used to receive a zoomed in graph
   * @type {string} {@link string}
   */
  readonly zoom_token?: string;
};

/** The graph data to be asynchronously loaded through getStatisticalGraph */
export type statisticalGraphAsync = {
  _: "statisticalGraphAsync";

  /**
   * The token to use for data loading
   * @type {string} {@link string}
   */
  token: string;
};

export type statisticalGraphAsync$Input = {
  readonly _: "statisticalGraphAsync";

  /**
   * The token to use for data loading
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/** An error message to be shown to the user instead of the graph */
export type statisticalGraphError = {
  _: "statisticalGraphError";

  /**
   * The error message
   * @type {string} {@link string}
   */
  error_message: string;
};

export type statisticalGraphError$Input = {
  readonly _: "statisticalGraphError";

  /**
   * The error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/** Contains statistics about interactions with a message */
export type chatStatisticsMessageInteractionInfo = {
  _: "chatStatisticsMessageInteractionInfo";

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Number of times the message was viewed
   * @type {int32} {@link int32}
   */
  view_count: int32;

  /**
   * Number of times the message was forwarded
   * @type {int32} {@link int32}
   */
  forward_count: int32;
};

export type chatStatisticsMessageInteractionInfo$Input = {
  readonly _: "chatStatisticsMessageInteractionInfo";

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Number of times the message was viewed
   * @type {int32} {@link int32}
   */
  readonly view_count?: int32;

  /**
   * Number of times the message was forwarded
   * @type {int32} {@link int32}
   */
  readonly forward_count?: int32;
};

/** Contains statistics about messages sent by a user */
export type chatStatisticsMessageSenderInfo = {
  _: "chatStatisticsMessageSenderInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of sent messages
   * @type {int32} {@link int32}
   */
  sent_message_count: int32;

  /**
   * Average number of characters in sent messages; 0 if unknown
   * @type {int32} {@link int32}
   */
  average_character_count: int32;
};

export type chatStatisticsMessageSenderInfo$Input = {
  readonly _: "chatStatisticsMessageSenderInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of sent messages
   * @type {int32} {@link int32}
   */
  readonly sent_message_count?: int32;

  /**
   * Average number of characters in sent messages; 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly average_character_count?: int32;
};

/** Contains statistics about administrator actions done by a user */
export type chatStatisticsAdministratorActionsInfo = {
  _: "chatStatisticsAdministratorActionsInfo";

  /**
   * Administrator user identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of messages deleted by the administrator
   * @type {int32} {@link int32}
   */
  deleted_message_count: int32;

  /**
   * Number of users banned by the administrator
   * @type {int32} {@link int32}
   */
  banned_user_count: int32;

  /**
   * Number of users restricted by the administrator
   * @type {int32} {@link int32}
   */
  restricted_user_count: int32;
};

export type chatStatisticsAdministratorActionsInfo$Input = {
  readonly _: "chatStatisticsAdministratorActionsInfo";

  /**
   * Administrator user identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of messages deleted by the administrator
   * @type {int32} {@link int32}
   */
  readonly deleted_message_count?: int32;

  /**
   * Number of users banned by the administrator
   * @type {int32} {@link int32}
   */
  readonly banned_user_count?: int32;

  /**
   * Number of users restricted by the administrator
   * @type {int32} {@link int32}
   */
  readonly restricted_user_count?: int32;
};

/** Contains statistics about number of new members invited by a user */
export type chatStatisticsInviterInfo = {
  _: "chatStatisticsInviterInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * Number of new members invited by the user
   * @type {int32} {@link int32}
   */
  added_member_count: int32;
};

export type chatStatisticsInviterInfo$Input = {
  readonly _: "chatStatisticsInviterInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Number of new members invited by the user
   * @type {int32} {@link int32}
   */
  readonly added_member_count?: int32;
};

/** A detailed statistics about a supergroup chat */
export type chatStatisticsSupergroup = {
  _: "chatStatisticsSupergroup";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  period: dateRange;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  member_count: statisticalValue;

  /**
   * Number of messages sent to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  message_count: statisticalValue;

  /**
   * Number of users who viewed messages in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  viewer_count: statisticalValue;

  /**
   * Number of users who sent messages to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  sender_count: statisticalValue;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  member_count_graph: StatisticalGraph;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_graph: StatisticalGraph;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_by_source_graph: StatisticalGraph;

  /**
   * A graph containing distribution of active users per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  language_graph: StatisticalGraph;

  /**
   * A graph containing distribution of sent messages by content type
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_content_graph: StatisticalGraph;

  /**
   * A graph containing number of different actions in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  action_graph: StatisticalGraph;

  /**
   * A graph containing distribution of message views per hour
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  day_graph: StatisticalGraph;

  /**
   * A graph containing distribution of message views per day of week
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  week_graph: StatisticalGraph;

  /**
   * List of users sent most messages in the last week
   * @type {vector<chatStatisticsMessageSenderInfo>} {@link vector<chatStatisticsMessageSenderInfo>}
   */
  top_senders: vector<chatStatisticsMessageSenderInfo>;

  /**
   * List of most active administrators in the last week
   * @type {vector<chatStatisticsAdministratorActionsInfo>} {@link vector<chatStatisticsAdministratorActionsInfo>}
   */
  top_administrators: vector<chatStatisticsAdministratorActionsInfo>;

  /**
   * List of most active inviters of new members in the last week
   * @type {vector<chatStatisticsInviterInfo>} {@link vector<chatStatisticsInviterInfo>}
   */
  top_inviters: vector<chatStatisticsInviterInfo>;
};

export type chatStatisticsSupergroup$Input = {
  readonly _: "chatStatisticsSupergroup";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  readonly period?: dateRange$Input;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly member_count?: statisticalValue$Input;

  /**
   * Number of messages sent to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly message_count?: statisticalValue$Input;

  /**
   * Number of users who viewed messages in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly viewer_count?: statisticalValue$Input;

  /**
   * Number of users who sent messages to the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly sender_count?: statisticalValue$Input;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly member_count_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_by_source_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of active users per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly language_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of sent messages by content type
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_content_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of different actions in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly action_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of message views per hour
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly day_graph?: StatisticalGraph$Input;

  /**
   * A graph containing distribution of message views per day of week
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly week_graph?: StatisticalGraph$Input;

  /**
   * List of users sent most messages in the last week
   * @type {vector<chatStatisticsMessageSenderInfo>} {@link vector<chatStatisticsMessageSenderInfo>}
   */
  readonly top_senders?: vector$Input<chatStatisticsMessageSenderInfo$Input>;

  /**
   * List of most active administrators in the last week
   * @type {vector<chatStatisticsAdministratorActionsInfo>} {@link vector<chatStatisticsAdministratorActionsInfo>}
   */
  readonly top_administrators?: vector$Input<chatStatisticsAdministratorActionsInfo$Input>;

  /**
   * List of most active inviters of new members in the last week
   * @type {vector<chatStatisticsInviterInfo>} {@link vector<chatStatisticsInviterInfo>}
   */
  readonly top_inviters?: vector$Input<chatStatisticsInviterInfo$Input>;
};

/** A detailed statistics about a channel chat */
export type chatStatisticsChannel = {
  _: "chatStatisticsChannel";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  period: dateRange;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  member_count: statisticalValue;

  /**
   * Mean number of times the recently sent messages was viewed
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_view_count: statisticalValue;

  /**
   * Mean number of times the recently sent messages was shared
   * @type {statisticalValue} {@link statisticalValue}
   */
  mean_share_count: statisticalValue;

  /**
   * A percentage of users with enabled notifications for the chat
   * @type {double} {@link double}
   */
  enabled_notifications_percentage: double;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  member_count_graph: StatisticalGraph;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_graph: StatisticalGraph;

  /**
   * A graph containing number of members muted and unmuted the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  mute_graph: StatisticalGraph;

  /**
   * A graph containing number of message views in a given hour in the last two weeks
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  view_count_by_hour_graph: StatisticalGraph;

  /**
   * A graph containing number of message views per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  view_count_by_source_graph: StatisticalGraph;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  join_by_source_graph: StatisticalGraph;

  /**
   * A graph containing number of users viewed chat messages per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  language_graph: StatisticalGraph;

  /**
   * A graph containing number of chat message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_interaction_graph: StatisticalGraph;

  /**
   * A graph containing number of views of associated with the chat instant views
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  instant_view_interaction_graph: StatisticalGraph;

  /**
   * Detailed statistics about number of views and shares of recently sent messages
   * @type {vector<chatStatisticsMessageInteractionInfo>} {@link vector<chatStatisticsMessageInteractionInfo>}
   */
  recent_message_interactions: vector<chatStatisticsMessageInteractionInfo>;
};

export type chatStatisticsChannel$Input = {
  readonly _: "chatStatisticsChannel";

  /**
   * A period to which the statistics applies
   * @type {dateRange} {@link dateRange}
   */
  readonly period?: dateRange$Input;

  /**
   * Number of members in the chat
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly member_count?: statisticalValue$Input;

  /**
   * Mean number of times the recently sent messages was viewed
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_view_count?: statisticalValue$Input;

  /**
   * Mean number of times the recently sent messages was shared
   * @type {statisticalValue} {@link statisticalValue}
   */
  readonly mean_share_count?: statisticalValue$Input;

  /**
   * A percentage of users with enabled notifications for the chat
   * @type {double} {@link double}
   */
  readonly enabled_notifications_percentage?: double;

  /**
   * A graph containing number of members in the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly member_count_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of members joined and left the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of members muted and unmuted the chat
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly mute_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of message views in a given hour in the last two weeks
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly view_count_by_hour_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of message views per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly view_count_by_source_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of new member joins per source
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly join_by_source_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of users viewed chat messages per language
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly language_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of chat message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_interaction_graph?: StatisticalGraph$Input;

  /**
   * A graph containing number of views of associated with the chat instant views
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly instant_view_interaction_graph?: StatisticalGraph$Input;

  /**
   * Detailed statistics about number of views and shares of recently sent messages
   * @type {vector<chatStatisticsMessageInteractionInfo>} {@link vector<chatStatisticsMessageInteractionInfo>}
   */
  readonly recent_message_interactions?: vector$Input<chatStatisticsMessageInteractionInfo$Input>;
};

/** A detailed statistics about a message */
export type messageStatistics = {
  _: "messageStatistics";

  /**
   * A graph containing number of message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  message_interaction_graph: StatisticalGraph;
};

export type messageStatistics$Input = {
  readonly _: "messageStatistics";

  /**
   * A graph containing number of message views and shares
   * @type {StatisticalGraph} {@link StatisticalGraph}
   */
  readonly message_interaction_graph?: StatisticalGraph$Input;
};

/** A point on a Cartesian plane */
export type point = {
  _: "point";

  /**
   * The point's first coordinate
   * @type {double} {@link double}
   */
  x: double;

  /**
   * The point's second coordinate
   * @type {double} {@link double}
   */
  y: double;
};

export type point$Input = {
  readonly _: "point";

  /**
   * The point's first coordinate
   * @type {double} {@link double}
   */
  readonly x?: double;

  /**
   * The point's second coordinate
   * @type {double} {@link double}
   */
  readonly y?: double;
};

/** A straight line to a given point */
export type vectorPathCommandLine = {
  _: "vectorPathCommandLine";

  /**
   * The end point of the straight line
   * @type {point} {@link point}
   */
  end_point: point;
};

export type vectorPathCommandLine$Input = {
  readonly _: "vectorPathCommandLine";

  /**
   * The end point of the straight line
   * @type {point} {@link point}
   */
  readonly end_point?: point$Input;
};

/** A cubic Bézier curve to a given point */
export type vectorPathCommandCubicBezierCurve = {
  _: "vectorPathCommandCubicBezierCurve";

  /**
   * The start control point of the curve
   * @type {point} {@link point}
   */
  start_control_point: point;

  /**
   * The end control point of the curve
   * @type {point} {@link point}
   */
  end_control_point: point;

  /**
   * The end point of the curve
   * @type {point} {@link point}
   */
  end_point: point;
};

export type vectorPathCommandCubicBezierCurve$Input = {
  readonly _: "vectorPathCommandCubicBezierCurve";

  /**
   * The start control point of the curve
   * @type {point} {@link point}
   */
  readonly start_control_point?: point$Input;

  /**
   * The end control point of the curve
   * @type {point} {@link point}
   */
  readonly end_control_point?: point$Input;

  /**
   * The end point of the curve
   * @type {point} {@link point}
   */
  readonly end_point?: point$Input;
};

/** A scope covering all users */
export type botCommandScopeDefault = {
  _: "botCommandScopeDefault";
};

export type botCommandScopeDefault$Input = {
  readonly _: "botCommandScopeDefault";
};

/** A scope covering all private chats */
export type botCommandScopeAllPrivateChats = {
  _: "botCommandScopeAllPrivateChats";
};

export type botCommandScopeAllPrivateChats$Input = {
  readonly _: "botCommandScopeAllPrivateChats";
};

/** A scope covering all group and supergroup chats */
export type botCommandScopeAllGroupChats = {
  _: "botCommandScopeAllGroupChats";
};

export type botCommandScopeAllGroupChats$Input = {
  readonly _: "botCommandScopeAllGroupChats";
};

/** A scope covering all group and supergroup chat administrators */
export type botCommandScopeAllChatAdministrators = {
  _: "botCommandScopeAllChatAdministrators";
};

export type botCommandScopeAllChatAdministrators$Input = {
  readonly _: "botCommandScopeAllChatAdministrators";
};

/** A scope covering all members of a chat */
export type botCommandScopeChat = {
  _: "botCommandScopeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

export type botCommandScopeChat$Input = {
  readonly _: "botCommandScopeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/** A scope covering all administrators of a chat */
export type botCommandScopeChatAdministrators = {
  _: "botCommandScopeChatAdministrators";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;
};

export type botCommandScopeChatAdministrators$Input = {
  readonly _: "botCommandScopeChatAdministrators";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/** A scope covering a member of a chat */
export type botCommandScopeChatMember = {
  _: "botCommandScopeChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;
};

export type botCommandScopeChatMember$Input = {
  readonly _: "botCommandScopeChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/** The user authorization state has changed */
export type updateAuthorizationState = {
  _: "updateAuthorizationState";

  /**
   * New authorization state
   * @type {AuthorizationState} {@link AuthorizationState}
   */
  authorization_state: AuthorizationState;
};

export type updateAuthorizationState$Input = {
  readonly _: "updateAuthorizationState";

  /**
   * New authorization state
   * @type {AuthorizationState} {@link AuthorizationState}
   */
  readonly authorization_state?: AuthorizationState$Input;
};

/** A new message was received; can also be an outgoing message */
export type updateNewMessage = {
  _: "updateNewMessage";

  /**
   * The new message
   * @type {message} {@link message}
   */
  message: message;
};

export type updateNewMessage$Input = {
  readonly _: "updateNewMessage";

  /**
   * The new message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;
};

/** A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message */
export type updateMessageSendAcknowledged = {
  _: "updateMessageSendAcknowledged";

  /**
   * The chat identifier of the sent message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * A temporary message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

export type updateMessageSendAcknowledged$Input = {
  readonly _: "updateMessageSendAcknowledged";

  /**
   * The chat identifier of the sent message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * A temporary message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/** A message has been successfully sent */
export type updateMessageSendSucceeded = {
  _: "updateMessageSendSucceeded";

  /**
   * The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
   * @type {message} {@link message}
   */
  message: message;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  old_message_id: int53;
};

export type updateMessageSendSucceeded$Input = {
  readonly _: "updateMessageSendSucceeded";

  /**
   * The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  readonly old_message_id?: int53;
};

/** A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update */
export type updateMessageSendFailed = {
  _: "updateMessageSendFailed";

  /**
   * The failed to send message
   * @type {message} {@link message}
   */
  message: message;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  old_message_id: int53;

  /**
   * An error code
   * @type {int32} {@link int32}
   */
  error_code: int32;

  /**
   * Error message
   * @type {string} {@link string}
   */
  error_message: string;
};

export type updateMessageSendFailed$Input = {
  readonly _: "updateMessageSendFailed";

  /**
   * The failed to send message
   * @type {message} {@link message}
   */
  readonly message?: message$Input;

  /**
   * The previous temporary message identifier
   * @type {int53} {@link int53}
   */
  readonly old_message_id?: int53;

  /**
   * An error code
   * @type {int32} {@link int32}
   */
  readonly error_code?: int32;

  /**
   * Error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/** The message content has changed */
export type updateMessageContent = {
  _: "updateMessageContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * New message content
   * @type {MessageContent} {@link MessageContent}
   */
  new_content: MessageContent;
};

export type updateMessageContent$Input = {
  readonly _: "updateMessageContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * New message content
   * @type {MessageContent} {@link MessageContent}
   */
  readonly new_content?: MessageContent$Input;
};

/** A message was edited. Changes in the message content will come in a separate updateMessageContent */
export type updateMessageEdited = {
  _: "updateMessageEdited";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Point in time (Unix timestamp) when the message was edited
   * @type {int32} {@link int32}
   */
  edit_date: int32;

  /**
   * New message reply markup; may be null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  reply_markup: ReplyMarkup;
};

export type updateMessageEdited$Input = {
  readonly _: "updateMessageEdited";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Point in time (Unix timestamp) when the message was edited
   * @type {int32} {@link int32}
   */
  readonly edit_date?: int32;

  /**
   * New message reply markup; may be null
   * @type {ReplyMarkup} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;
};

/** The message pinned state was changed */
export type updateMessageIsPinned = {
  _: "updateMessageIsPinned";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  is_pinned: Bool;
};

export type updateMessageIsPinned$Input = {
  readonly _: "updateMessageIsPinned";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * True, if the message is pinned
   * @type {Bool} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/** The information about interactions with a message has changed */
export type updateMessageInteractionInfo = {
  _: "updateMessageInteractionInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * New information about interactions with the message; may be null
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  interaction_info: messageInteractionInfo;
};

export type updateMessageInteractionInfo$Input = {
  readonly _: "updateMessageInteractionInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * New information about interactions with the message; may be null
   * @type {messageInteractionInfo} {@link messageInteractionInfo}
   */
  readonly interaction_info?: messageInteractionInfo$Input;
};

/** The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages */
export type updateMessageContentOpened = {
  _: "updateMessageContentOpened";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

export type updateMessageContentOpened$Input = {
  readonly _: "updateMessageContentOpened";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/** A message with an unread mention was read */
export type updateMessageMentionRead = {
  _: "updateMessageMentionRead";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * The new number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;
};

export type updateMessageMentionRead$Input = {
  readonly _: "updateMessageMentionRead";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;
};

/** The list of unread reactions added to a message was changed */
export type updateMessageUnreadReactions = {
  _: "updateMessageUnreadReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * The new list of unread reactions
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  unread_reactions: vector<unreadReaction>;

  /**
   * The new number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;
};

export type updateMessageUnreadReactions$Input = {
  readonly _: "updateMessageUnreadReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new list of unread reactions
   * @type {vector<unreadReaction>} {@link vector<unreadReaction>}
   */
  readonly unread_reactions?: vector$Input<unreadReaction$Input>;

  /**
   * The new number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;
};

/** A message with a live location was viewed. When the update is received, the application is supposed to update the live location */
export type updateMessageLiveLocationViewed = {
  _: "updateMessageLiveLocationViewed";

  /**
   * Identifier of the chat with the live location message
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message with live location
   * @type {int53} {@link int53}
   */
  message_id: int53;
};

export type updateMessageLiveLocationViewed$Input = {
  readonly _: "updateMessageLiveLocationViewed";

  /**
   * Identifier of the chat with the live location message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with live location
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/** A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates */
export type updateNewChat = {
  _: "updateNewChat";

  /**
   * The chat
   * @type {chat} {@link chat}
   */
  chat: chat;
};

export type updateNewChat$Input = {
  readonly _: "updateNewChat";

  /**
   * The chat
   * @type {chat} {@link chat}
   */
  readonly chat?: chat$Input;
};

/** The title of a chat was changed */
export type updateChatTitle = {
  _: "updateChatTitle";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat title
   * @type {string} {@link string}
   */
  title: string;
};

export type updateChatTitle$Input = {
  readonly _: "updateChatTitle";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat title
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/** A chat photo was changed */
export type updateChatPhoto = {
  _: "updateChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  photo: chatPhotoInfo;
};

export type updateChatPhoto$Input = {
  readonly _: "updateChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat photo; may be null
   * @type {chatPhotoInfo} {@link chatPhotoInfo}
   */
  readonly photo?: chatPhotoInfo$Input;
};

/** Chat permissions was changed */
export type updateChatPermissions = {
  _: "updateChatPermissions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  permissions: chatPermissions;
};

export type updateChatPermissions$Input = {
  readonly _: "updateChatPermissions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new chat permissions
   * @type {chatPermissions} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/** The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case */
export type updateChatLastMessage = {
  _: "updateChatLastMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new last message in the chat; may be null
   * @type {message} {@link message}
   */
  last_message: message;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  positions: vector<chatPosition>;
};

export type updateChatLastMessage$Input = {
  readonly _: "updateChatLastMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new last message in the chat; may be null
   * @type {message} {@link message}
   */
  readonly last_message?: message$Input;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  readonly positions?: vector$Input<chatPosition$Input>;
};

/** The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage or updateChatDraftMessage might be sent */
export type updateChatPosition = {
  _: "updateChatPosition";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New chat position. If new order is 0, then the chat needs to be removed from the list
   * @type {chatPosition} {@link chatPosition}
   */
  position: chatPosition;
};

export type updateChatPosition$Input = {
  readonly _: "updateChatPosition";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New chat position. If new order is 0, then the chat needs to be removed from the list
   * @type {chatPosition} {@link chatPosition}
   */
  readonly position?: chatPosition$Input;
};

/** Incoming messages were read or the number of unread messages has been changed */
export type updateChatReadInbox = {
  _: "updateChatReadInbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  last_read_inbox_message_id: int53;

  /**
   * The number of unread messages left in the chat
   * @type {int32} {@link int32}
   */
  unread_count: int32;
};

export type updateChatReadInbox$Input = {
  readonly _: "updateChatReadInbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the last read incoming message
   * @type {int53} {@link int53}
   */
  readonly last_read_inbox_message_id?: int53;

  /**
   * The number of unread messages left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;
};

/** Outgoing messages were read */
export type updateChatReadOutbox = {
  _: "updateChatReadOutbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of last read outgoing message
   * @type {int53} {@link int53}
   */
  last_read_outbox_message_id: int53;
};

export type updateChatReadOutbox$Input = {
  readonly _: "updateChatReadOutbox";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of last read outgoing message
   * @type {int53} {@link int53}
   */
  readonly last_read_outbox_message_id?: int53;
};

/** The chat action bar was changed */
export type updateChatActionBar = {
  _: "updateChatActionBar";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new value of the action bar; may be null
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  action_bar: ChatActionBar;
};

export type updateChatActionBar$Input = {
  readonly _: "updateChatActionBar";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new value of the action bar; may be null
   * @type {ChatActionBar} {@link ChatActionBar}
   */
  readonly action_bar?: ChatActionBar$Input;
};

/** The chat available reactions were changed */
export type updateChatAvailableReactions = {
  _: "updateChatAvailableReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new reactions, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  available_reactions: ChatAvailableReactions;
};

export type updateChatAvailableReactions$Input = {
  readonly _: "updateChatAvailableReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new reactions, available in the chat
   * @type {ChatAvailableReactions} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;
};

/** A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied */
export type updateChatDraftMessage = {
  _: "updateChatDraftMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new draft message; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  draft_message: draftMessage;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  positions: vector<chatPosition>;
};

export type updateChatDraftMessage$Input = {
  readonly _: "updateChatDraftMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new draft message; may be null
   * @type {draftMessage} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input;

  /**
   * The new chat positions in the chat lists
   * @type {vector<chatPosition>} {@link vector<chatPosition>}
   */
  readonly positions?: vector$Input<chatPosition$Input>;
};

/** The message sender that is selected to send messages in a chat has changed */
export type updateChatMessageSender = {
  _: "updateChatMessageSender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of message_sender_id; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  message_sender_id: MessageSender;
};

export type updateChatMessageSender$Input = {
  readonly _: "updateChatMessageSender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of message_sender_id; may be null if the user can't change message sender
   * @type {MessageSender} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input;
};

/** The message Time To Live setting for a chat was changed */
export type updateChatMessageTtl = {
  _: "updateChatMessageTtl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of message_ttl
   * @type {int32} {@link int32}
   */
  message_ttl: int32;
};

export type updateChatMessageTtl$Input = {
  readonly _: "updateChatMessageTtl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of message_ttl
   * @type {int32} {@link int32}
   */
  readonly message_ttl?: int32;
};

/** Notification settings for a chat were changed */
export type updateChatNotificationSettings = {
  _: "updateChatNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new notification settings
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  notification_settings: chatNotificationSettings;
};

export type updateChatNotificationSettings$Input = {
  readonly _: "updateChatNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new notification settings
   * @type {chatNotificationSettings} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/** The chat pending join requests were changed */
export type updateChatPendingJoinRequests = {
  _: "updateChatPendingJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new data about pending join requests; may be null
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  pending_join_requests: chatJoinRequestsInfo;
};

export type updateChatPendingJoinRequests$Input = {
  readonly _: "updateChatPendingJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new data about pending join requests; may be null
   * @type {chatJoinRequestsInfo} {@link chatJoinRequestsInfo}
   */
  readonly pending_join_requests?: chatJoinRequestsInfo$Input;
};

/** The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user */
export type updateChatReplyMarkup = {
  _: "updateChatReplyMarkup";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  reply_markup_message_id: int53;
};

export type updateChatReplyMarkup$Input = {
  readonly _: "updateChatReplyMarkup";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
   * @type {int53} {@link int53}
   */
  readonly reply_markup_message_id?: int53;
};

/** The chat theme was changed */
export type updateChatTheme = {
  _: "updateChatTheme";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new name of the chat theme; may be empty if theme was reset to default
   * @type {string} {@link string}
   */
  theme_name: string;
};

export type updateChatTheme$Input = {
  readonly _: "updateChatTheme";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new name of the chat theme; may be empty if theme was reset to default
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/** The chat unread_mention_count has changed */
export type updateChatUnreadMentionCount = {
  _: "updateChatUnreadMentionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  unread_mention_count: int32;
};

export type updateChatUnreadMentionCount$Input = {
  readonly _: "updateChatUnreadMentionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The number of unread mention messages left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_mention_count?: int32;
};

/** The chat unread_reaction_count has changed */
export type updateChatUnreadReactionCount = {
  _: "updateChatUnreadReactionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  unread_reaction_count: int32;
};

export type updateChatUnreadReactionCount$Input = {
  readonly _: "updateChatUnreadReactionCount";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The number of messages with unread reactions left in the chat
   * @type {int32} {@link int32}
   */
  readonly unread_reaction_count?: int32;
};

/** A chat video chat state has changed */
export type updateChatVideoChat = {
  _: "updateChatVideoChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of video_chat
   * @type {videoChat} {@link videoChat}
   */
  video_chat: videoChat;
};

export type updateChatVideoChat$Input = {
  readonly _: "updateChatVideoChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of video_chat
   * @type {videoChat} {@link videoChat}
   */
  readonly video_chat?: videoChat$Input;
};

/** The value of the default disable_notification parameter, used when a message is sent to the chat, was changed */
export type updateChatDefaultDisableNotification = {
  _: "updateChatDefaultDisableNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * The new default_disable_notification value
   * @type {Bool} {@link Bool}
   */
  default_disable_notification: Bool;
};

export type updateChatDefaultDisableNotification$Input = {
  readonly _: "updateChatDefaultDisableNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The new default_disable_notification value
   * @type {Bool} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;
};

/** A chat content was allowed or restricted for saving */
export type updateChatHasProtectedContent = {
  _: "updateChatHasProtectedContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  has_protected_content: Bool;
};

export type updateChatHasProtectedContent$Input = {
  readonly _: "updateChatHasProtectedContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_protected_content
   * @type {Bool} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/** A chat's has_scheduled_messages field has changed */
export type updateChatHasScheduledMessages = {
  _: "updateChatHasScheduledMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of has_scheduled_messages
   * @type {Bool} {@link Bool}
   */
  has_scheduled_messages: Bool;
};

export type updateChatHasScheduledMessages$Input = {
  readonly _: "updateChatHasScheduledMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_scheduled_messages
   * @type {Bool} {@link Bool}
   */
  readonly has_scheduled_messages?: Bool$Input;
};

/** A chat was blocked or unblocked */
export type updateChatIsBlocked = {
  _: "updateChatIsBlocked";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of is_blocked
   * @type {Bool} {@link Bool}
   */
  is_blocked: Bool;
};

export type updateChatIsBlocked$Input = {
  readonly _: "updateChatIsBlocked";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_blocked
   * @type {Bool} {@link Bool}
   */
  readonly is_blocked?: Bool$Input;
};

/** A chat was marked as unread or was read */
export type updateChatIsMarkedAsUnread = {
  _: "updateChatIsMarkedAsUnread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool} {@link Bool}
   */
  is_marked_as_unread: Bool;
};

export type updateChatIsMarkedAsUnread$Input = {
  readonly _: "updateChatIsMarkedAsUnread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;
};

/** The list of chat filters or a chat filter has changed */
export type updateChatFilters = {
  _: "updateChatFilters";

  /**
   * The new list of chat filters
   * @type {vector<chatFilterInfo>} {@link vector<chatFilterInfo>}
   */
  chat_filters: vector<chatFilterInfo>;

  /**
   * Position of the main chat list among chat filters, 0-based
   * @type {int32} {@link int32}
   */
  main_chat_list_position: int32;
};

export type updateChatFilters$Input = {
  readonly _: "updateChatFilters";

  /**
   * The new list of chat filters
   * @type {vector<chatFilterInfo>} {@link vector<chatFilterInfo>}
   */
  readonly chat_filters?: vector$Input<chatFilterInfo$Input>;

  /**
   * Position of the main chat list among chat filters, 0-based
   * @type {int32} {@link int32}
   */
  readonly main_chat_list_position?: int32;
};

/** The number of online group members has changed. This update with non-zero number of online group members is sent only for currently opened chats. There is no guarantee that it will be sent just after the number of online users has changed */
export type updateChatOnlineMemberCount = {
  _: "updateChatOnlineMemberCount";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New number of online members in the chat, or 0 if unknown
   * @type {int32} {@link int32}
   */
  online_member_count: int32;
};

export type updateChatOnlineMemberCount$Input = {
  readonly _: "updateChatOnlineMemberCount";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New number of online members in the chat, or 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly online_member_count?: int32;
};

/** Basic information about a topic in a forum chat was changed */
export type updateForumTopicInfo = {
  _: "updateForumTopicInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  info: forumTopicInfo;
};

export type updateForumTopicInfo$Input = {
  readonly _: "updateForumTopicInfo";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New information about the topic
   * @type {forumTopicInfo} {@link forumTopicInfo}
   */
  readonly info?: forumTopicInfo$Input;
};

/** Notification settings for some type of chats were updated */
export type updateScopeNotificationSettings = {
  _: "updateScopeNotificationSettings";

  /**
   * Types of chats for which notification settings were updated
   * @type {NotificationSettingsScope} {@link NotificationSettingsScope}
   */
  scope: NotificationSettingsScope;

  /**
   * The new notification settings
   * @type {scopeNotificationSettings} {@link scopeNotificationSettings}
   */
  notification_settings: scopeNotificationSettings;
};

export type updateScopeNotificationSettings$Input = {
  readonly _: "updateScopeNotificationSettings";

  /**
   * Types of chats for which notification settings were updated
   * @type {NotificationSettingsScope} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;

  /**
   * The new notification settings
   * @type {scopeNotificationSettings} {@link scopeNotificationSettings}
   */
  readonly notification_settings?: scopeNotificationSettings$Input;
};

/** A notification was changed */
export type updateNotification = {
  _: "updateNotification";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  notification_group_id: int32;

  /**
   * Changed notification
   * @type {notification} {@link notification}
   */
  notification: notification;
};

export type updateNotification$Input = {
  readonly _: "updateNotification";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * Changed notification
   * @type {notification} {@link notification}
   */
  readonly notification?: notification$Input;
};

/** A list of active notifications in a notification group has changed */
export type updateNotificationGroup = {
  _: "updateNotificationGroup";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  notification_group_id: int32;

  /**
   * New type of the notification group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  type: NotificationGroupType;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Chat identifier, which notification settings must be applied to the added notifications
   * @type {int53} {@link int53}
   */
  notification_settings_chat_id: int53;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  notification_sound_id: int64;

  /**
   * Total number of unread notifications in the group, can be bigger than number of active notifications
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * List of added group notifications, sorted by notification ID
   * @type {vector<notification>} {@link vector<notification>}
   */
  added_notifications: vector<notification>;

  /**
   * Identifiers of removed group notifications, sorted by notification ID
   * @type {vector<int32>} {@link vector<int32>}
   */
  removed_notification_ids: vector<int32>;
};

export type updateNotificationGroup$Input = {
  readonly _: "updateNotificationGroup";

  /**
   * Unique notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * New type of the notification group
   * @type {NotificationGroupType} {@link NotificationGroupType}
   */
  readonly type?: NotificationGroupType$Input;

  /**
   * Identifier of a chat to which all notifications in the group belong
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Chat identifier, which notification settings must be applied to the added notifications
   * @type {int53} {@link int53}
   */
  readonly notification_settings_chat_id?: int53;

  /**
   * Identifier of the notification sound to be played; 0 if sound is disabled
   * @type {int64} {@link int64}
   */
  readonly notification_sound_id?: int64;

  /**
   * Total number of unread notifications in the group, can be bigger than number of active notifications
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * List of added group notifications, sorted by notification ID
   * @type {vector<notification>} {@link vector<notification>}
   */
  readonly added_notifications?: vector$Input<notification$Input>;

  /**
   * Identifiers of removed group notifications, sorted by notification ID
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly removed_notification_ids?: vector$Input<int32>;
};

/** Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update */
export type updateActiveNotifications = {
  _: "updateActiveNotifications";

  /**
   * Lists of active notification groups
   * @type {vector<notificationGroup>} {@link vector<notificationGroup>}
   */
  groups: vector<notificationGroup>;
};

export type updateActiveNotifications$Input = {
  readonly _: "updateActiveNotifications";

  /**
   * Lists of active notification groups
   * @type {vector<notificationGroup>} {@link vector<notificationGroup>}
   */
  readonly groups?: vector$Input<notificationGroup$Input>;
};

/** Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications */
export type updateHavePendingNotifications = {
  _: "updateHavePendingNotifications";

  /**
   * True, if there are some delayed notification updates, which will be sent soon
   * @type {Bool} {@link Bool}
   */
  have_delayed_notifications: Bool;

  /**
   * True, if there can be some yet unreceived notifications, which are being fetched from the server
   * @type {Bool} {@link Bool}
   */
  have_unreceived_notifications: Bool;
};

export type updateHavePendingNotifications$Input = {
  readonly _: "updateHavePendingNotifications";

  /**
   * True, if there are some delayed notification updates, which will be sent soon
   * @type {Bool} {@link Bool}
   */
  readonly have_delayed_notifications?: Bool$Input;

  /**
   * True, if there can be some yet unreceived notifications, which are being fetched from the server
   * @type {Bool} {@link Bool}
   */
  readonly have_unreceived_notifications?: Bool$Input;
};

/** Some messages were deleted */
export type updateDeleteMessages = {
  _: "updateDeleteMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifiers of the deleted messages
   * @type {vector<int53>} {@link vector<int53>}
   */
  message_ids: vector<int53>;

  /**
   * True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
   * @type {Bool} {@link Bool}
   */
  is_permanent: Bool;

  /**
   * True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
   * @type {Bool} {@link Bool}
   */
  from_cache: Bool;
};

export type updateDeleteMessages$Input = {
  readonly _: "updateDeleteMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the deleted messages
   * @type {vector<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
   * @type {Bool} {@link Bool}
   */
  readonly is_permanent?: Bool$Input;

  /**
   * True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
   * @type {Bool} {@link Bool}
   */
  readonly from_cache?: Bool$Input;
};

/** A message sender activity in the chat has changed */
export type updateChatAction = {
  _: "updateChatAction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  message_thread_id: int53;

  /**
   * Identifier of a message sender performing the action
   * @type {MessageSender} {@link MessageSender}
   */
  sender_id: MessageSender;

  /**
   * The action
   * @type {ChatAction} {@link ChatAction}
   */
  action: ChatAction;
};

export type updateChatAction$Input = {
  readonly _: "updateChatAction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of a message sender performing the action
   * @type {MessageSender} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * The action
   * @type {ChatAction} {@link ChatAction}
   */
  readonly action?: ChatAction$Input;
};

/** The user went online or offline */
export type updateUserStatus = {
  _: "updateUserStatus";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * New status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  status: UserStatus;
};

export type updateUserStatus$Input = {
  readonly _: "updateUserStatus";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New status of the user
   * @type {UserStatus} {@link UserStatus}
   */
  readonly status?: UserStatus$Input;
};

/** Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application */
export type updateUser = {
  _: "updateUser";

  /**
   * New data about the user
   * @type {user} {@link user}
   */
  user: user;
};

export type updateUser$Input = {
  readonly _: "updateUser";

  /**
   * New data about the user
   * @type {user} {@link user}
   */
  readonly user?: user$Input;
};

/** Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application */
export type updateBasicGroup = {
  _: "updateBasicGroup";

  /**
   * New data about the group
   * @type {basicGroup} {@link basicGroup}
   */
  basic_group: basicGroup;
};

export type updateBasicGroup$Input = {
  readonly _: "updateBasicGroup";

  /**
   * New data about the group
   * @type {basicGroup} {@link basicGroup}
   */
  readonly basic_group?: basicGroup$Input;
};

/** Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application */
export type updateSupergroup = {
  _: "updateSupergroup";

  /**
   * New data about the supergroup
   * @type {supergroup} {@link supergroup}
   */
  supergroup: supergroup;
};

export type updateSupergroup$Input = {
  readonly _: "updateSupergroup";

  /**
   * New data about the supergroup
   * @type {supergroup} {@link supergroup}
   */
  readonly supergroup?: supergroup$Input;
};

/** Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application */
export type updateSecretChat = {
  _: "updateSecretChat";

  /**
   * New data about the secret chat
   * @type {secretChat} {@link secretChat}
   */
  secret_chat: secretChat;
};

export type updateSecretChat$Input = {
  readonly _: "updateSecretChat";

  /**
   * New data about the secret chat
   * @type {secretChat} {@link secretChat}
   */
  readonly secret_chat?: secretChat$Input;
};

/** Some data in userFullInfo has been changed */
export type updateUserFullInfo = {
  _: "updateUserFullInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * New full information about the user
   * @type {userFullInfo} {@link userFullInfo}
   */
  user_full_info: userFullInfo;
};

export type updateUserFullInfo$Input = {
  readonly _: "updateUserFullInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New full information about the user
   * @type {userFullInfo} {@link userFullInfo}
   */
  readonly user_full_info?: userFullInfo$Input;
};

/** Some data in basicGroupFullInfo has been changed */
export type updateBasicGroupFullInfo = {
  _: "updateBasicGroupFullInfo";

  /**
   * Identifier of a basic group
   * @type {int53} {@link int53}
   */
  basic_group_id: int53;

  /**
   * New full information about the group
   * @type {basicGroupFullInfo} {@link basicGroupFullInfo}
   */
  basic_group_full_info: basicGroupFullInfo;
};

export type updateBasicGroupFullInfo$Input = {
  readonly _: "updateBasicGroupFullInfo";

  /**
   * Identifier of a basic group
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;

  /**
   * New full information about the group
   * @type {basicGroupFullInfo} {@link basicGroupFullInfo}
   */
  readonly basic_group_full_info?: basicGroupFullInfo$Input;
};

/** Some data in supergroupFullInfo has been changed */
export type updateSupergroupFullInfo = {
  _: "updateSupergroupFullInfo";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  supergroup_id: int53;

  /**
   * New full information about the supergroup
   * @type {supergroupFullInfo} {@link supergroupFullInfo}
   */
  supergroup_full_info: supergroupFullInfo;
};

export type updateSupergroupFullInfo$Input = {
  readonly _: "updateSupergroupFullInfo";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New full information about the supergroup
   * @type {supergroupFullInfo} {@link supergroupFullInfo}
   */
  readonly supergroup_full_info?: supergroupFullInfo$Input;
};

/** A service notification from the server was received. Upon receiving this the application must show a popup with the content of the notification */
export type updateServiceNotification = {
  _: "updateServiceNotification";

  /**
   * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
   * @type {string} {@link string}
   */
  type: string;

  /**
   * Notification content
   * @type {MessageContent} {@link MessageContent}
   */
  content: MessageContent;
};

export type updateServiceNotification$Input = {
  readonly _: "updateServiceNotification";

  /**
   * Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Notification content
   * @type {MessageContent} {@link MessageContent}
   */
  readonly content?: MessageContent$Input;
};

/** Information about a file was updated */
export type updateFile = {
  _: "updateFile";

  /**
   * New data about the file
   * @type {file} {@link file}
   */
  file: file;
};

export type updateFile$Input = {
  readonly _: "updateFile";

  /**
   * New data about the file
   * @type {file} {@link file}
   */
  readonly file?: file$Input;
};

/** The file generation process needs to be started by the application */
export type updateFileGenerationStart = {
  _: "updateFileGenerationStart";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  generation_id: int64;

  /**
   * The path to a file from which a new file is generated; may be empty
   * @type {string} {@link string}
   */
  original_path: string;

  /**
   * The path to a file that must be created and where the new file is generated
   * @type {string} {@link string}
   */
  destination_path: string;

  /**
   * String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
   * @type {string} {@link string}
   */
  conversion: string;
};

export type updateFileGenerationStart$Input = {
  readonly _: "updateFileGenerationStart";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64;

  /**
   * The path to a file from which a new file is generated; may be empty
   * @type {string} {@link string}
   */
  readonly original_path?: string;

  /**
   * The path to a file that must be created and where the new file is generated
   * @type {string} {@link string}
   */
  readonly destination_path?: string;

  /**
   * String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
   * @type {string} {@link string}
   */
  readonly conversion?: string;
};

/** File generation is no longer needed */
export type updateFileGenerationStop = {
  _: "updateFileGenerationStop";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  generation_id: int64;
};

export type updateFileGenerationStop$Input = {
  readonly _: "updateFileGenerationStop";

  /**
   * Unique identifier for the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64;
};

/** The state of the file download list has changed */
export type updateFileDownloads = {
  _: "updateFileDownloads";

  /**
   * Total size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  total_size: int53;

  /**
   * Total number of files in the file download list
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Total downloaded size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  downloaded_size: int53;
};

export type updateFileDownloads$Input = {
  readonly _: "updateFileDownloads";

  /**
   * Total size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  readonly total_size?: int53;

  /**
   * Total number of files in the file download list
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Total downloaded size of files in the file download list, in bytes
   * @type {int53} {@link int53}
   */
  readonly downloaded_size?: int53;
};

/** A file was added to the file download list. This update is sent only after file download list is loaded for the first time */
export type updateFileAddedToDownloads = {
  _: "updateFileAddedToDownloads";

  /**
   * The added file download
   * @type {fileDownload} {@link fileDownload}
   */
  file_download: fileDownload;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  counts: downloadedFileCounts;
};

export type updateFileAddedToDownloads$Input = {
  readonly _: "updateFileAddedToDownloads";

  /**
   * The added file download
   * @type {fileDownload} {@link fileDownload}
   */
  readonly file_download?: fileDownload$Input;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly counts?: downloadedFileCounts$Input;
};

/** A file download was changed. This update is sent only after file download list is loaded for the first time */
export type updateFileDownload = {
  _: "updateFileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  file_id: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  complete_date: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  is_paused: Bool;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  counts: downloadedFileCounts;
};

export type updateFileDownload$Input = {
  readonly _: "updateFileDownload";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Point in time (Unix timestamp) when the file downloading was completed; 0 if the file downloading isn't completed
   * @type {int32} {@link int32}
   */
  readonly complete_date?: int32;

  /**
   * True, if downloading of the file is paused
   * @type {Bool} {@link Bool}
   */
  readonly is_paused?: Bool$Input;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly counts?: downloadedFileCounts$Input;
};

/** A file was removed from the file download list. This update is sent only after file download list is loaded for the first time */
export type updateFileRemovedFromDownloads = {
  _: "updateFileRemovedFromDownloads";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  file_id: int32;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  counts: downloadedFileCounts;
};

export type updateFileRemovedFromDownloads$Input = {
  readonly _: "updateFileRemovedFromDownloads";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * New number of being downloaded and recently downloaded files found
   * @type {downloadedFileCounts} {@link downloadedFileCounts}
   */
  readonly counts?: downloadedFileCounts$Input;
};

/** New call was created or information about a call was updated */
export type updateCall = {
  _: "updateCall";

  /**
   * New data about a call
   * @type {call} {@link call}
   */
  call: call;
};

export type updateCall$Input = {
  readonly _: "updateCall";

  /**
   * New data about a call
   * @type {call} {@link call}
   */
  readonly call?: call$Input;
};

/** Information about a group call was updated */
export type updateGroupCall = {
  _: "updateGroupCall";

  /**
   * New data about a group call
   * @type {groupCall} {@link groupCall}
   */
  group_call: groupCall;
};

export type updateGroupCall$Input = {
  readonly _: "updateGroupCall";

  /**
   * New data about a group call
   * @type {groupCall} {@link groupCall}
   */
  readonly group_call?: groupCall$Input;
};

/** Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined */
export type updateGroupCallParticipant = {
  _: "updateGroupCallParticipant";

  /**
   * Identifier of group call
   * @type {int32} {@link int32}
   */
  group_call_id: int32;

  /**
   * New data about a participant
   * @type {groupCallParticipant} {@link groupCallParticipant}
   */
  participant: groupCallParticipant;
};

export type updateGroupCallParticipant$Input = {
  readonly _: "updateGroupCallParticipant";

  /**
   * Identifier of group call
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New data about a participant
   * @type {groupCallParticipant} {@link groupCallParticipant}
   */
  readonly participant?: groupCallParticipant$Input;
};

/** New call signaling data arrived */
export type updateNewCallSignalingData = {
  _: "updateNewCallSignalingData";

  /**
   * The call identifier
   * @type {int32} {@link int32}
   */
  call_id: int32;

  /**
   * The data
   * @type {bytes} {@link bytes}
   */
  data: bytes;
};

export type updateNewCallSignalingData$Input = {
  readonly _: "updateNewCallSignalingData";

  /**
   * The call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The data
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/** Some privacy setting rules have been changed */
export type updateUserPrivacySettingRules = {
  _: "updateUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting} {@link UserPrivacySetting}
   */
  setting: UserPrivacySetting;

  /**
   * New privacy rules
   * @type {userPrivacySettingRules} {@link userPrivacySettingRules}
   */
  rules: userPrivacySettingRules;
};

export type updateUserPrivacySettingRules$Input = {
  readonly _: "updateUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;

  /**
   * New privacy rules
   * @type {userPrivacySettingRules} {@link userPrivacySettingRules}
   */
  readonly rules?: userPrivacySettingRules$Input;
};

/** Number of unread messages in a chat list has changed. This update is sent only if the message database is used */
export type updateUnreadMessageCount = {
  _: "updateUnreadMessageCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  chat_list: ChatList;

  /**
   * Total number of unread messages
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Total number of unread messages in unmuted chats
   * @type {int32} {@link int32}
   */
  unread_unmuted_count: int32;
};

export type updateUnreadMessageCount$Input = {
  readonly _: "updateUnreadMessageCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Total number of unread messages
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Total number of unread messages in unmuted chats
   * @type {int32} {@link int32}
   */
  readonly unread_unmuted_count?: int32;
};

/** Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used */
export type updateUnreadChatCount = {
  _: "updateUnreadChatCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  chat_list: ChatList;

  /**
   * Approximate total number of chats in the chat list
   * @type {int32} {@link int32}
   */
  total_count: int32;

  /**
   * Total number of unread chats
   * @type {int32} {@link int32}
   */
  unread_count: int32;

  /**
   * Total number of unread unmuted chats
   * @type {int32} {@link int32}
   */
  unread_unmuted_count: int32;

  /**
   * Total number of chats marked as unread
   * @type {int32} {@link int32}
   */
  marked_as_unread_count: int32;

  /**
   * Total number of unmuted chats marked as unread
   * @type {int32} {@link int32}
   */
  marked_as_unread_unmuted_count: int32;
};

export type updateUnreadChatCount$Input = {
  readonly _: "updateUnreadChatCount";

  /**
   * The chat list with changed number of unread messages
   * @type {ChatList} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Approximate total number of chats in the chat list
   * @type {int32} {@link int32}
   */
  readonly total_count?: int32;

  /**
   * Total number of unread chats
   * @type {int32} {@link int32}
   */
  readonly unread_count?: int32;

  /**
   * Total number of unread unmuted chats
   * @type {int32} {@link int32}
   */
  readonly unread_unmuted_count?: int32;

  /**
   * Total number of chats marked as unread
   * @type {int32} {@link int32}
   */
  readonly marked_as_unread_count?: int32;

  /**
   * Total number of unmuted chats marked as unread
   * @type {int32} {@link int32}
   */
  readonly marked_as_unread_unmuted_count?: int32;
};

/** An option changed its value */
export type updateOption = {
  _: "updateOption";

  /**
   * The option name
   * @type {string} {@link string}
   */
  name: string;

  /**
   * The new option value
   * @type {OptionValue} {@link OptionValue}
   */
  value: OptionValue;
};

export type updateOption$Input = {
  readonly _: "updateOption";

  /**
   * The option name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * The new option value
   * @type {OptionValue} {@link OptionValue}
   */
  readonly value?: OptionValue$Input;
};

/** A sticker set has changed */
export type updateStickerSet = {
  _: "updateStickerSet";

  /**
   * The sticker set
   * @type {stickerSet} {@link stickerSet}
   */
  sticker_set: stickerSet;
};

export type updateStickerSet$Input = {
  readonly _: "updateStickerSet";

  /**
   * The sticker set
   * @type {stickerSet} {@link stickerSet}
   */
  readonly sticker_set?: stickerSet$Input;
};

/** The list of installed sticker sets was updated */
export type updateInstalledStickerSets = {
  _: "updateInstalledStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * The new list of installed ordinary sticker sets
   * @type {vector<int64>} {@link vector<int64>}
   */
  sticker_set_ids: vector<int64>;
};

export type updateInstalledStickerSets$Input = {
  readonly _: "updateInstalledStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The new list of installed ordinary sticker sets
   * @type {vector<int64>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64>;
};

/** The list of trending sticker sets was updated or some of them were viewed */
export type updateTrendingStickerSets = {
  _: "updateTrendingStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  sticker_type: StickerType;

  /**
   * The prefix of the list of trending sticker sets with the newest trending sticker sets
   * @type {trendingStickerSets} {@link trendingStickerSets}
   */
  sticker_sets: trendingStickerSets;
};

export type updateTrendingStickerSets$Input = {
  readonly _: "updateTrendingStickerSets";

  /**
   * Type of the affected stickers
   * @type {StickerType} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The prefix of the list of trending sticker sets with the newest trending sticker sets
   * @type {trendingStickerSets} {@link trendingStickerSets}
   */
  readonly sticker_sets?: trendingStickerSets$Input;
};

/** The list of recently used stickers was updated */
export type updateRecentStickers = {
  _: "updateRecentStickers";

  /**
   * True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated
   * @type {Bool} {@link Bool}
   */
  is_attached: Bool;

  /**
   * The new list of file identifiers of recently used stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  sticker_ids: vector<int32>;
};

export type updateRecentStickers$Input = {
  readonly _: "updateRecentStickers";

  /**
   * True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated
   * @type {Bool} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * The new list of file identifiers of recently used stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly sticker_ids?: vector$Input<int32>;
};

/** The list of favorite stickers was updated */
export type updateFavoriteStickers = {
  _: "updateFavoriteStickers";

  /**
   * The new list of file identifiers of favorite stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  sticker_ids: vector<int32>;
};

export type updateFavoriteStickers$Input = {
  readonly _: "updateFavoriteStickers";

  /**
   * The new list of file identifiers of favorite stickers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly sticker_ids?: vector$Input<int32>;
};

/** The list of saved animations was updated */
export type updateSavedAnimations = {
  _: "updateSavedAnimations";

  /**
   * The new list of file identifiers of saved animations
   * @type {vector<int32>} {@link vector<int32>}
   */
  animation_ids: vector<int32>;
};

export type updateSavedAnimations$Input = {
  readonly _: "updateSavedAnimations";

  /**
   * The new list of file identifiers of saved animations
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly animation_ids?: vector$Input<int32>;
};

/** The list of saved notifications sounds was updated. This update may not be sent until information about a notification sound was requested for the first time */
export type updateSavedNotificationSounds = {
  _: "updateSavedNotificationSounds";

  /**
   * The new list of identifiers of saved notification sounds
   * @type {vector<int64>} {@link vector<int64>}
   */
  notification_sound_ids: vector<int64>;
};

export type updateSavedNotificationSounds$Input = {
  readonly _: "updateSavedNotificationSounds";

  /**
   * The new list of identifiers of saved notification sounds
   * @type {vector<int64>} {@link vector<int64>}
   */
  readonly notification_sound_ids?: vector$Input<int64>;
};

/** The selected background has changed */
export type updateSelectedBackground = {
  _: "updateSelectedBackground";

  /**
   * True, if background for dark theme has changed
   * @type {Bool} {@link Bool}
   */
  for_dark_theme: Bool;

  /**
   * The new selected background; may be null
   * @type {background} {@link background}
   */
  background: background;
};

export type updateSelectedBackground$Input = {
  readonly _: "updateSelectedBackground";

  /**
   * True, if background for dark theme has changed
   * @type {Bool} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;

  /**
   * The new selected background; may be null
   * @type {background} {@link background}
   */
  readonly background?: background$Input;
};

/** The list of available chat themes has changed */
export type updateChatThemes = {
  _: "updateChatThemes";

  /**
   * The new list of chat themes
   * @type {vector<chatTheme>} {@link vector<chatTheme>}
   */
  chat_themes: vector<chatTheme>;
};

export type updateChatThemes$Input = {
  readonly _: "updateChatThemes";

  /**
   * The new list of chat themes
   * @type {vector<chatTheme>} {@link vector<chatTheme>}
   */
  readonly chat_themes?: vector$Input<chatTheme$Input>;
};

/** Some language pack strings have been updated */
export type updateLanguagePackStrings = {
  _: "updateLanguagePackStrings";

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  localization_target: string;

  /**
   * Identifier of the updated language pack
   * @type {string} {@link string}
   */
  language_pack_id: string;

  /**
   * List of changed language pack strings
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  strings: vector<languagePackString>;
};

export type updateLanguagePackStrings$Input = {
  readonly _: "updateLanguagePackStrings";

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  readonly localization_target?: string;

  /**
   * Identifier of the updated language pack
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * List of changed language pack strings
   * @type {vector<languagePackString>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/** The connection state has changed. This update must be used only to show a human-readable description of the connection state */
export type updateConnectionState = {
  _: "updateConnectionState";

  /**
   * The new connection state
   * @type {ConnectionState} {@link ConnectionState}
   */
  state: ConnectionState;
};

export type updateConnectionState$Input = {
  readonly _: "updateConnectionState";

  /**
   * The new connection state
   * @type {ConnectionState} {@link ConnectionState}
   */
  readonly state?: ConnectionState$Input;
};

/** New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update" */
export type updateTermsOfService = {
  _: "updateTermsOfService";

  /**
   * Identifier of the terms of service
   * @type {string} {@link string}
   */
  terms_of_service_id: string;

  /**
   * The new terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  terms_of_service: termsOfService;
};

export type updateTermsOfService$Input = {
  readonly _: "updateTermsOfService";

  /**
   * Identifier of the terms of service
   * @type {string} {@link string}
   */
  readonly terms_of_service_id?: string;

  /**
   * The new terms of service
   * @type {termsOfService} {@link termsOfService}
   */
  readonly terms_of_service?: termsOfService$Input;
};

/** The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request */
export type updateUsersNearby = {
  _: "updateUsersNearby";

  /**
   * The new list of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  users_nearby: vector<chatNearby>;
};

export type updateUsersNearby$Input = {
  readonly _: "updateUsersNearby";

  /**
   * The new list of users nearby
   * @type {vector<chatNearby>} {@link vector<chatNearby>}
   */
  readonly users_nearby?: vector$Input<chatNearby$Input>;
};

/** The list of bots added to attachment menu has changed */
export type updateAttachmentMenuBots = {
  _: "updateAttachmentMenuBots";

  /**
   * The new list of bots added to attachment menu. The bots must not be shown on scheduled messages screen
   * @type {vector<attachmentMenuBot>} {@link vector<attachmentMenuBot>}
   */
  bots: vector<attachmentMenuBot>;
};

export type updateAttachmentMenuBots$Input = {
  readonly _: "updateAttachmentMenuBots";

  /**
   * The new list of bots added to attachment menu. The bots must not be shown on scheduled messages screen
   * @type {vector<attachmentMenuBot>} {@link vector<attachmentMenuBot>}
   */
  readonly bots?: vector$Input<attachmentMenuBot$Input>;
};

/** A message was sent by an opened Web App, so the Web App needs to be closed */
export type updateWebAppMessageSent = {
  _: "updateWebAppMessageSent";

  /**
   * Identifier of Web App launch
   * @type {int64} {@link int64}
   */
  web_app_launch_id: int64;
};

export type updateWebAppMessageSent$Input = {
  readonly _: "updateWebAppMessageSent";

  /**
   * Identifier of Web App launch
   * @type {int64} {@link int64}
   */
  readonly web_app_launch_id?: int64;
};

/** The list of active emoji reactions has changed */
export type updateActiveEmojiReactions = {
  _: "updateActiveEmojiReactions";

  /**
   * The new list of active emoji reactions
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

export type updateActiveEmojiReactions$Input = {
  readonly _: "updateActiveEmojiReactions";

  /**
   * The new list of active emoji reactions
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/** The type of default reaction has changed */
export type updateDefaultReactionType = {
  _: "updateDefaultReactionType";

  /**
   * The new type of the default reaction
   * @type {ReactionType} {@link ReactionType}
   */
  reaction_type: ReactionType;
};

export type updateDefaultReactionType$Input = {
  readonly _: "updateDefaultReactionType";

  /**
   * The new type of the default reaction
   * @type {ReactionType} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/** The list of supported dice emojis has changed */
export type updateDiceEmojis = {
  _: "updateDiceEmojis";

  /**
   * The new list of supported dice emojis
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

export type updateDiceEmojis$Input = {
  readonly _: "updateDiceEmojis";

  /**
   * The new list of supported dice emojis
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/** Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played */
export type updateAnimatedEmojiMessageClicked = {
  _: "updateAnimatedEmojiMessageClicked";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * The animated sticker to be played
   * @type {sticker} {@link sticker}
   */
  sticker: sticker;
};

export type updateAnimatedEmojiMessageClicked$Input = {
  readonly _: "updateAnimatedEmojiMessageClicked";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The animated sticker to be played
   * @type {sticker} {@link sticker}
   */
  readonly sticker?: sticker$Input;
};

/** The parameters of animation search through GetOption("animation_search_bot_username") bot has changed */
export type updateAnimationSearchParameters = {
  _: "updateAnimationSearchParameters";

  /**
   * Name of the animation search provider
   * @type {string} {@link string}
   */
  provider: string;

  /**
   * The new list of emojis suggested for searching
   * @type {vector<string>} {@link vector<string>}
   */
  emojis: vector<string>;
};

export type updateAnimationSearchParameters$Input = {
  readonly _: "updateAnimationSearchParameters";

  /**
   * Name of the animation search provider
   * @type {string} {@link string}
   */
  readonly provider?: string;

  /**
   * The new list of emojis suggested for searching
   * @type {vector<string>} {@link vector<string>}
   */
  readonly emojis?: vector$Input<string>;
};

/** The list of suggested to the user actions has changed */
export type updateSuggestedActions = {
  _: "updateSuggestedActions";

  /**
   * Added suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  added_actions: vector<SuggestedAction>;

  /**
   * Removed suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  removed_actions: vector<SuggestedAction>;
};

export type updateSuggestedActions$Input = {
  readonly _: "updateSuggestedActions";

  /**
   * Added suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  readonly added_actions?: vector$Input<SuggestedAction$Input>;

  /**
   * Removed suggested actions
   * @type {vector<SuggestedAction>} {@link vector<SuggestedAction>}
   */
  readonly removed_actions?: vector$Input<SuggestedAction$Input>;
};

/** A new incoming inline query; for bots only */
export type updateNewInlineQuery = {
  _: "updateNewInlineQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  user_location: location;

  /**
   * The type of the chat from which the query originated; may be null if unknown
   * @type {ChatType} {@link ChatType}
   */
  chat_type: ChatType;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  query: string;

  /**
   * Offset of the first entry to return
   * @type {string} {@link string}
   */
  offset: string;
};

export type updateNewInlineQuery$Input = {
  readonly _: "updateNewInlineQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  readonly user_location?: location$Input;

  /**
   * The type of the chat from which the query originated; may be null if unknown
   * @type {ChatType} {@link ChatType}
   */
  readonly chat_type?: ChatType$Input;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return
   * @type {string} {@link string}
   */
  readonly offset?: string;
};

/** The user has chosen a result of an inline query; for bots only */
export type updateNewChosenInlineResult = {
  _: "updateNewChosenInlineResult";

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  user_location: location;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  query: string;

  /**
   * Identifier of the chosen result
   * @type {string} {@link string}
   */
  result_id: string;

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  inline_message_id: string;
};

export type updateNewChosenInlineResult$Input = {
  readonly _: "updateNewChosenInlineResult";

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * User location; may be null
   * @type {location} {@link location}
   */
  readonly user_location?: location$Input;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of the chosen result
   * @type {string} {@link string}
   */
  readonly result_id?: string;

  /**
   * Identifier of the sent inline message, if known
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;
};

/** A new incoming callback query; for bots only */
export type updateNewCallbackQuery = {
  _: "updateNewCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  message_id: int53;

  /**
   * Identifier that uniquely corresponds to the chat to which the message was sent
   * @type {int64} {@link int64}
   */
  chat_instance: int64;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  payload: CallbackQueryPayload;
};

export type updateNewCallbackQuery$Input = {
  readonly _: "updateNewCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier that uniquely corresponds to the chat to which the message was sent
   * @type {int64} {@link int64}
   */
  readonly chat_instance?: int64;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/** A new incoming callback query from a message sent via a bot; for bots only */
export type updateNewInlineCallbackQuery = {
  _: "updateNewInlineCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Identifier of the inline message from which the query originated
   * @type {string} {@link string}
   */
  inline_message_id: string;

  /**
   * An identifier uniquely corresponding to the chat a message was sent to
   * @type {int64} {@link int64}
   */
  chat_instance: int64;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  payload: CallbackQueryPayload;
};

export type updateNewInlineCallbackQuery$Input = {
  readonly _: "updateNewInlineCallbackQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Identifier of the inline message from which the query originated
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * An identifier uniquely corresponding to the chat a message was sent to
   * @type {int64} {@link int64}
   */
  readonly chat_instance?: int64;

  /**
   * Query payload
   * @type {CallbackQueryPayload} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/** A new incoming shipping query; for bots only. Only for invoices with flexible price */
export type updateNewShippingQuery = {
  _: "updateNewShippingQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Invoice payload
   * @type {string} {@link string}
   */
  invoice_payload: string;

  /**
   * User shipping address
   * @type {address} {@link address}
   */
  shipping_address: address;
};

export type updateNewShippingQuery$Input = {
  readonly _: "updateNewShippingQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Invoice payload
   * @type {string} {@link string}
   */
  readonly invoice_payload?: string;

  /**
   * User shipping address
   * @type {address} {@link address}
   */
  readonly shipping_address?: address$Input;
};

/** A new incoming pre-checkout query; for bots only. Contains full information about a checkout */
export type updateNewPreCheckoutQuery = {
  _: "updateNewPreCheckoutQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  sender_user_id: int53;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  currency: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  total_amount: int53;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  invoice_payload: bytes;

  /**
   * Identifier of a shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  shipping_option_id: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  order_info: orderInfo;
};

export type updateNewPreCheckoutQuery$Input = {
  readonly _: "updateNewPreCheckoutQuery";

  /**
   * Unique query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * Identifier of the user who sent the query
   * @type {int53} {@link int53}
   */
  readonly sender_user_id?: int53;

  /**
   * Currency for the product price
   * @type {string} {@link string}
   */
  readonly currency?: string;

  /**
   * Total price for the product, in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly total_amount?: int53;

  /**
   * Invoice payload
   * @type {bytes} {@link bytes}
   */
  readonly invoice_payload?: bytes;

  /**
   * Identifier of a shipping option chosen by the user; may be empty if not applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * Information about the order; may be null
   * @type {orderInfo} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input;
};

/** A new incoming event; for bots only */
export type updateNewCustomEvent = {
  _: "updateNewCustomEvent";

  /**
   * A JSON-serialized event
   * @type {string} {@link string}
   */
  event: string;
};

export type updateNewCustomEvent$Input = {
  readonly _: "updateNewCustomEvent";

  /**
   * A JSON-serialized event
   * @type {string} {@link string}
   */
  readonly event?: string;
};

/** A new incoming query; for bots only */
export type updateNewCustomQuery = {
  _: "updateNewCustomQuery";

  /**
   * The query identifier
   * @type {int64} {@link int64}
   */
  id: int64;

  /**
   * JSON-serialized query data
   * @type {string} {@link string}
   */
  data: string;

  /**
   * Query timeout
   * @type {int32} {@link int32}
   */
  timeout: int32;
};

export type updateNewCustomQuery$Input = {
  readonly _: "updateNewCustomQuery";

  /**
   * The query identifier
   * @type {int64} {@link int64}
   */
  readonly id?: int64;

  /**
   * JSON-serialized query data
   * @type {string} {@link string}
   */
  readonly data?: string;

  /**
   * Query timeout
   * @type {int32} {@link int32}
   */
  readonly timeout?: int32;
};

/** A poll was updated; for bots only */
export type updatePoll = {
  _: "updatePoll";

  /**
   * New data about the poll
   * @type {poll} {@link poll}
   */
  poll: poll;
};

export type updatePoll$Input = {
  readonly _: "updatePoll";

  /**
   * New data about the poll
   * @type {poll} {@link poll}
   */
  readonly poll?: poll$Input;
};

/** A user changed the answer to a poll; for bots only */
export type updatePollAnswer = {
  _: "updatePollAnswer";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  poll_id: int64;

  /**
   * The user, who changed the answer to the poll
   * @type {int53} {@link int53}
   */
  user_id: int53;

  /**
   * 0-based identifiers of answer options, chosen by the user
   * @type {vector<int32>} {@link vector<int32>}
   */
  option_ids: vector<int32>;
};

export type updatePollAnswer$Input = {
  readonly _: "updatePollAnswer";

  /**
   * Unique poll identifier
   * @type {int64} {@link int64}
   */
  readonly poll_id?: int64;

  /**
   * The user, who changed the answer to the poll
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * 0-based identifiers of answer options, chosen by the user
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly option_ids?: vector$Input<int32>;
};

/** User rights changed in a chat; for bots only */
export type updateChatMember = {
  _: "updateChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Identifier of the user, changing the rights
   * @type {int53} {@link int53}
   */
  actor_user_id: int53;

  /**
   * Point in time (Unix timestamp) when the user rights was changed
   * @type {int32} {@link int32}
   */
  date: int32;

  /**
   * If user has joined the chat using an invite link, the invite link; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;

  /**
   * Previous chat member
   * @type {chatMember} {@link chatMember}
   */
  old_chat_member: chatMember;

  /**
   * New chat member
   * @type {chatMember} {@link chatMember}
   */
  new_chat_member: chatMember;
};

export type updateChatMember$Input = {
  readonly _: "updateChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user, changing the rights
   * @type {int53} {@link int53}
   */
  readonly actor_user_id?: int53;

  /**
   * Point in time (Unix timestamp) when the user rights was changed
   * @type {int32} {@link int32}
   */
  readonly date?: int32;

  /**
   * If user has joined the chat using an invite link, the invite link; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;

  /**
   * Previous chat member
   * @type {chatMember} {@link chatMember}
   */
  readonly old_chat_member?: chatMember$Input;

  /**
   * New chat member
   * @type {chatMember} {@link chatMember}
   */
  readonly new_chat_member?: chatMember$Input;
};

/** A user sent a join request to a chat; for bots only */
export type updateNewChatJoinRequest = {
  _: "updateNewChatJoinRequest";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  chat_id: int53;

  /**
   * Join request
   * @type {chatJoinRequest} {@link chatJoinRequest}
   */
  request: chatJoinRequest;

  /**
   * The invite link, which was used to send join request; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  invite_link: chatInviteLink;
};

export type updateNewChatJoinRequest$Input = {
  readonly _: "updateNewChatJoinRequest";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Join request
   * @type {chatJoinRequest} {@link chatJoinRequest}
   */
  readonly request?: chatJoinRequest$Input;

  /**
   * The invite link, which was used to send join request; may be null
   * @type {chatInviteLink} {@link chatInviteLink}
   */
  readonly invite_link?: chatInviteLink$Input;
};

/** Contains a list of updates */
export type updates = {
  _: "updates";

  /**
   * List of updates
   * @type {vector<Update>} {@link vector<Update>}
   */
  updates: vector<Update>;
};

export type updates$Input = {
  readonly _: "updates";

  /**
   * List of updates
   * @type {vector<Update>} {@link vector<Update>}
   */
  readonly updates?: vector$Input<Update$Input>;
};

/** The log is written to stderr or an OS specific log */
export type logStreamDefault = {
  _: "logStreamDefault";
};

export type logStreamDefault$Input = {
  readonly _: "logStreamDefault";
};

/** The log is written to a file */
export type logStreamFile = {
  _: "logStreamFile";

  /**
   * Path to the file to where the internal TDLib log will be written
   * @type {string} {@link string}
   */
  path: string;

  /**
   * The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
   * @type {int53} {@link int53}
   */
  max_file_size: int53;

  /**
   * Pass true to additionally redirect stderr to the log file. Ignored on Windows
   * @type {Bool} {@link Bool}
   */
  redirect_stderr: Bool;
};

export type logStreamFile$Input = {
  readonly _: "logStreamFile";

  /**
   * Path to the file to where the internal TDLib log will be written
   * @type {string} {@link string}
   */
  readonly path?: string;

  /**
   * The maximum size of the file to where the internal TDLib log is written before the file will automatically be rotated, in bytes
   * @type {int53} {@link int53}
   */
  readonly max_file_size?: int53;

  /**
   * Pass true to additionally redirect stderr to the log file. Ignored on Windows
   * @type {Bool} {@link Bool}
   */
  readonly redirect_stderr?: Bool$Input;
};

/** The log is written nowhere */
export type logStreamEmpty = {
  _: "logStreamEmpty";
};

export type logStreamEmpty$Input = {
  readonly _: "logStreamEmpty";
};

/** Contains a TDLib internal log verbosity level */
export type logVerbosityLevel = {
  _: "logVerbosityLevel";

  /**
   * Log verbosity level
   * @type {int32} {@link int32}
   */
  verbosity_level: int32;
};

export type logVerbosityLevel$Input = {
  readonly _: "logVerbosityLevel";

  /**
   * Log verbosity level
   * @type {int32} {@link int32}
   */
  readonly verbosity_level?: int32;
};

/** Contains a list of available TDLib internal log tags */
export type logTags = {
  _: "logTags";

  /**
   * List of log tags
   * @type {vector<string>} {@link vector<string>}
   */
  tags: vector<string>;
};

export type logTags$Input = {
  readonly _: "logTags";

  /**
   * List of log tags
   * @type {vector<string>} {@link vector<string>}
   */
  readonly tags?: vector$Input<string>;
};

/** Contains custom information about the user */
export type userSupportInfo = {
  _: "userSupportInfo";

  /**
   * Information message
   * @type {formattedText} {@link formattedText}
   */
  message: formattedText;

  /**
   * Information author
   * @type {string} {@link string}
   */
  author: string;

  /**
   * Information change date
   * @type {int32} {@link int32}
   */
  date: int32;
};

export type userSupportInfo$Input = {
  readonly _: "userSupportInfo";

  /**
   * Information message
   * @type {formattedText} {@link formattedText}
   */
  readonly message?: formattedText$Input;

  /**
   * Information author
   * @type {string} {@link string}
   */
  readonly author?: string;

  /**
   * Information change date
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/** A simple object containing a number; for testing only */
export type testInt = {
  _: "testInt";

  /**
   * Number
   * @type {int32} {@link int32}
   */
  value: int32;
};

export type testInt$Input = {
  readonly _: "testInt";

  /**
   * Number
   * @type {int32} {@link int32}
   */
  readonly value?: int32;
};

/** A simple object containing a string; for testing only */
export type testString = {
  _: "testString";

  /**
   * String
   * @type {string} {@link string}
   */
  value: string;
};

export type testString$Input = {
  readonly _: "testString";

  /**
   * String
   * @type {string} {@link string}
   */
  readonly value?: string;
};

/** A simple object containing a sequence of bytes; for testing only */
export type testBytes = {
  _: "testBytes";

  /**
   * Bytes
   * @type {bytes} {@link bytes}
   */
  value: bytes;
};

export type testBytes$Input = {
  readonly _: "testBytes";

  /**
   * Bytes
   * @type {bytes} {@link bytes}
   */
  readonly value?: bytes;
};

/** A simple object containing a vector of numbers; for testing only */
export type testVectorInt = {
  _: "testVectorInt";

  /**
   * Vector of numbers
   * @type {vector<int32>} {@link vector<int32>}
   */
  value: vector<int32>;
};

export type testVectorInt$Input = {
  readonly _: "testVectorInt";

  /**
   * Vector of numbers
   * @type {vector<int32>} {@link vector<int32>}
   */
  readonly value?: vector$Input<int32>;
};

/** A simple object containing a vector of objects that hold a number; for testing only */
export type testVectorIntObject = {
  _: "testVectorIntObject";

  /**
   * Vector of objects
   * @type {vector<testInt>} {@link vector<testInt>}
   */
  value: vector<testInt>;
};

export type testVectorIntObject$Input = {
  readonly _: "testVectorIntObject";

  /**
   * Vector of objects
   * @type {vector<testInt>} {@link vector<testInt>}
   */
  readonly value?: vector$Input<testInt$Input>;
};

/** A simple object containing a vector of strings; for testing only */
export type testVectorString = {
  _: "testVectorString";

  /**
   * Vector of strings
   * @type {vector<string>} {@link vector<string>}
   */
  value: vector<string>;
};

export type testVectorString$Input = {
  readonly _: "testVectorString";

  /**
   * Vector of strings
   * @type {vector<string>} {@link vector<string>}
   */
  readonly value?: vector$Input<string>;
};

/** A simple object containing a vector of objects that hold a string; for testing only */
export type testVectorStringObject = {
  _: "testVectorStringObject";

  /**
   * Vector of objects
   * @type {vector<testString>} {@link vector<testString>}
   */
  value: vector<testString>;
};

export type testVectorStringObject$Input = {
  readonly _: "testVectorStringObject";

  /**
   * Vector of objects
   * @type {vector<testString>} {@link vector<testString>}
   */
  readonly value?: vector$Input<testString$Input>;
};

/**
 * Any of:
 * - {@link double}
 */
export type Double = double;

/**
 * Any of:
 * - {@link double}
 */
export type Double$Input = double;

/**
 * Any of:
 * - {@link string}
 */
export type String = string;

/**
 * Any of:
 * - {@link string}
 */
export type String$Input = string;

/**
 * Any of:
 * - {@link int32}
 */
export type Int32 = int32;

/**
 * Any of:
 * - {@link int32}
 */
export type Int32$Input = int32;

/**
 * Any of:
 * - {@link int53}
 */
export type Int53 = int53;

/**
 * Any of:
 * - {@link int53}
 */
export type Int53$Input = int53;

/**
 * Any of:
 * - {@link int64}
 */
export type Int64 = int64;

/**
 * Any of:
 * - {@link int64}
 */
export type Int64$Input = int64;

/**
 * Any of:
 * - {@link bytes}
 */
export type Bytes = bytes;

/**
 * Any of:
 * - {@link bytes}
 */
export type Bytes$Input = bytes;

/**
 * Any of:
 * - {@link boolFalse}
 * - {@link boolTrue}
 */
export type Bool = boolFalse | boolTrue;

/**
 * Any of:
 * - {@link boolFalse}
 * - {@link boolTrue}
 */
export type Bool$Input = boolFalse | boolTrue;

/**
 * Any of:
 * - {@link error}
 */
export type Error = error;

/**
 * Any of:
 * - {@link error$Input}
 */
export type Error$Input = error$Input;

/**
 * Any of:
 * - {@link ok}
 */
export type Ok = ok;

/**
 * Any of:
 * - {@link ok$Input}
 */
export type Ok$Input = ok$Input;

/**
 * Any of:
 * - {@link authenticationCodeTypeTelegramMessage}
 * - {@link authenticationCodeTypeSms}
 * - {@link authenticationCodeTypeCall}
 * - {@link authenticationCodeTypeFlashCall}
 * - {@link authenticationCodeTypeMissedCall}
 */
export type AuthenticationCodeType =
  | authenticationCodeTypeTelegramMessage
  | authenticationCodeTypeSms
  | authenticationCodeTypeCall
  | authenticationCodeTypeFlashCall
  | authenticationCodeTypeMissedCall;

/**
 * Any of:
 * - {@link authenticationCodeTypeTelegramMessage$Input}
 * - {@link authenticationCodeTypeSms$Input}
 * - {@link authenticationCodeTypeCall$Input}
 * - {@link authenticationCodeTypeFlashCall$Input}
 * - {@link authenticationCodeTypeMissedCall$Input}
 */
export type AuthenticationCodeType$Input =
  | authenticationCodeTypeTelegramMessage$Input
  | authenticationCodeTypeSms$Input
  | authenticationCodeTypeCall$Input
  | authenticationCodeTypeFlashCall$Input
  | authenticationCodeTypeMissedCall$Input;

/**
 * Any of:
 * - {@link authenticationCodeInfo}
 */
export type AuthenticationCodeInfo = authenticationCodeInfo;

/**
 * Any of:
 * - {@link authenticationCodeInfo$Input}
 */
export type AuthenticationCodeInfo$Input = authenticationCodeInfo$Input;

/**
 * Any of:
 * - {@link emailAddressAuthenticationCodeInfo}
 */
export type EmailAddressAuthenticationCodeInfo = emailAddressAuthenticationCodeInfo;

/**
 * Any of:
 * - {@link emailAddressAuthenticationCodeInfo$Input}
 */
export type EmailAddressAuthenticationCodeInfo$Input =
  emailAddressAuthenticationCodeInfo$Input;

/**
 * Any of:
 * - {@link emailAddressAuthenticationCode}
 * - {@link emailAddressAuthenticationAppleId}
 * - {@link emailAddressAuthenticationGoogleId}
 */
export type EmailAddressAuthentication =
  | emailAddressAuthenticationCode
  | emailAddressAuthenticationAppleId
  | emailAddressAuthenticationGoogleId;

/**
 * Any of:
 * - {@link emailAddressAuthenticationCode$Input}
 * - {@link emailAddressAuthenticationAppleId$Input}
 * - {@link emailAddressAuthenticationGoogleId$Input}
 */
export type EmailAddressAuthentication$Input =
  | emailAddressAuthenticationCode$Input
  | emailAddressAuthenticationAppleId$Input
  | emailAddressAuthenticationGoogleId$Input;

/**
 * Any of:
 * - {@link textEntity}
 */
export type TextEntity = textEntity;

/**
 * Any of:
 * - {@link textEntity$Input}
 */
export type TextEntity$Input = textEntity$Input;

/**
 * Any of:
 * - {@link textEntities}
 */
export type TextEntities = textEntities;

/**
 * Any of:
 * - {@link textEntities$Input}
 */
export type TextEntities$Input = textEntities$Input;

/**
 * Any of:
 * - {@link formattedText}
 */
export type FormattedText = formattedText;

/**
 * Any of:
 * - {@link formattedText$Input}
 */
export type FormattedText$Input = formattedText$Input;

/**
 * Any of:
 * - {@link termsOfService}
 */
export type TermsOfService = termsOfService;

/**
 * Any of:
 * - {@link termsOfService$Input}
 */
export type TermsOfService$Input = termsOfService$Input;

/**
 * Any of:
 * - {@link authorizationStateWaitTdlibParameters}
 * - {@link authorizationStateWaitPhoneNumber}
 * - {@link authorizationStateWaitEmailAddress}
 * - {@link authorizationStateWaitEmailCode}
 * - {@link authorizationStateWaitCode}
 * - {@link authorizationStateWaitOtherDeviceConfirmation}
 * - {@link authorizationStateWaitRegistration}
 * - {@link authorizationStateWaitPassword}
 * - {@link authorizationStateReady}
 * - {@link authorizationStateLoggingOut}
 * - {@link authorizationStateClosing}
 * - {@link authorizationStateClosed}
 */
export type AuthorizationState =
  | authorizationStateWaitTdlibParameters
  | authorizationStateWaitPhoneNumber
  | authorizationStateWaitEmailAddress
  | authorizationStateWaitEmailCode
  | authorizationStateWaitCode
  | authorizationStateWaitOtherDeviceConfirmation
  | authorizationStateWaitRegistration
  | authorizationStateWaitPassword
  | authorizationStateReady
  | authorizationStateLoggingOut
  | authorizationStateClosing
  | authorizationStateClosed;

/**
 * Any of:
 * - {@link authorizationStateWaitTdlibParameters$Input}
 * - {@link authorizationStateWaitPhoneNumber$Input}
 * - {@link authorizationStateWaitEmailAddress$Input}
 * - {@link authorizationStateWaitEmailCode$Input}
 * - {@link authorizationStateWaitCode$Input}
 * - {@link authorizationStateWaitOtherDeviceConfirmation$Input}
 * - {@link authorizationStateWaitRegistration$Input}
 * - {@link authorizationStateWaitPassword$Input}
 * - {@link authorizationStateReady$Input}
 * - {@link authorizationStateLoggingOut$Input}
 * - {@link authorizationStateClosing$Input}
 * - {@link authorizationStateClosed$Input}
 */
export type AuthorizationState$Input =
  | authorizationStateWaitTdlibParameters$Input
  | authorizationStateWaitPhoneNumber$Input
  | authorizationStateWaitEmailAddress$Input
  | authorizationStateWaitEmailCode$Input
  | authorizationStateWaitCode$Input
  | authorizationStateWaitOtherDeviceConfirmation$Input
  | authorizationStateWaitRegistration$Input
  | authorizationStateWaitPassword$Input
  | authorizationStateReady$Input
  | authorizationStateLoggingOut$Input
  | authorizationStateClosing$Input
  | authorizationStateClosed$Input;

/**
 * Any of:
 * - {@link passwordState}
 */
export type PasswordState = passwordState;

/**
 * Any of:
 * - {@link passwordState$Input}
 */
export type PasswordState$Input = passwordState$Input;

/**
 * Any of:
 * - {@link recoveryEmailAddress}
 */
export type RecoveryEmailAddress = recoveryEmailAddress;

/**
 * Any of:
 * - {@link recoveryEmailAddress$Input}
 */
export type RecoveryEmailAddress$Input = recoveryEmailAddress$Input;

/**
 * Any of:
 * - {@link temporaryPasswordState}
 */
export type TemporaryPasswordState = temporaryPasswordState;

/**
 * Any of:
 * - {@link temporaryPasswordState$Input}
 */
export type TemporaryPasswordState$Input = temporaryPasswordState$Input;

/**
 * Any of:
 * - {@link localFile}
 */
export type LocalFile = localFile;

/**
 * Any of:
 * - {@link localFile$Input}
 */
export type LocalFile$Input = localFile$Input;

/**
 * Any of:
 * - {@link remoteFile}
 */
export type RemoteFile = remoteFile;

/**
 * Any of:
 * - {@link remoteFile$Input}
 */
export type RemoteFile$Input = remoteFile$Input;

/**
 * Any of:
 * - {@link file}
 */
export type File = file;

/**
 * Any of:
 * - {@link file$Input}
 */
export type File$Input = file$Input;

/**
 * Any of:
 * - {@link inputFileId}
 * - {@link inputFileRemote}
 * - {@link inputFileLocal}
 * - {@link inputFileGenerated}
 */
export type InputFile =
  | inputFileId
  | inputFileRemote
  | inputFileLocal
  | inputFileGenerated;

/**
 * Any of:
 * - {@link inputFileId$Input}
 * - {@link inputFileRemote$Input}
 * - {@link inputFileLocal$Input}
 * - {@link inputFileGenerated$Input}
 */
export type InputFile$Input =
  | inputFileId$Input
  | inputFileRemote$Input
  | inputFileLocal$Input
  | inputFileGenerated$Input;

/**
 * Any of:
 * - {@link photoSize}
 */
export type PhotoSize = photoSize;

/**
 * Any of:
 * - {@link photoSize$Input}
 */
export type PhotoSize$Input = photoSize$Input;

/**
 * Any of:
 * - {@link minithumbnail}
 */
export type Minithumbnail = minithumbnail;

/**
 * Any of:
 * - {@link minithumbnail$Input}
 */
export type Minithumbnail$Input = minithumbnail$Input;

/**
 * Any of:
 * - {@link thumbnailFormatJpeg}
 * - {@link thumbnailFormatGif}
 * - {@link thumbnailFormatMpeg4}
 * - {@link thumbnailFormatPng}
 * - {@link thumbnailFormatTgs}
 * - {@link thumbnailFormatWebm}
 * - {@link thumbnailFormatWebp}
 */
export type ThumbnailFormat =
  | thumbnailFormatJpeg
  | thumbnailFormatGif
  | thumbnailFormatMpeg4
  | thumbnailFormatPng
  | thumbnailFormatTgs
  | thumbnailFormatWebm
  | thumbnailFormatWebp;

/**
 * Any of:
 * - {@link thumbnailFormatJpeg$Input}
 * - {@link thumbnailFormatGif$Input}
 * - {@link thumbnailFormatMpeg4$Input}
 * - {@link thumbnailFormatPng$Input}
 * - {@link thumbnailFormatTgs$Input}
 * - {@link thumbnailFormatWebm$Input}
 * - {@link thumbnailFormatWebp$Input}
 */
export type ThumbnailFormat$Input =
  | thumbnailFormatJpeg$Input
  | thumbnailFormatGif$Input
  | thumbnailFormatMpeg4$Input
  | thumbnailFormatPng$Input
  | thumbnailFormatTgs$Input
  | thumbnailFormatWebm$Input
  | thumbnailFormatWebp$Input;

/**
 * Any of:
 * - {@link thumbnail}
 */
export type Thumbnail = thumbnail;

/**
 * Any of:
 * - {@link thumbnail$Input}
 */
export type Thumbnail$Input = thumbnail$Input;

/**
 * Any of:
 * - {@link maskPointForehead}
 * - {@link maskPointEyes}
 * - {@link maskPointMouth}
 * - {@link maskPointChin}
 */
export type MaskPoint =
  | maskPointForehead
  | maskPointEyes
  | maskPointMouth
  | maskPointChin;

/**
 * Any of:
 * - {@link maskPointForehead$Input}
 * - {@link maskPointEyes$Input}
 * - {@link maskPointMouth$Input}
 * - {@link maskPointChin$Input}
 */
export type MaskPoint$Input =
  | maskPointForehead$Input
  | maskPointEyes$Input
  | maskPointMouth$Input
  | maskPointChin$Input;

/**
 * Any of:
 * - {@link maskPosition}
 */
export type MaskPosition = maskPosition;

/**
 * Any of:
 * - {@link maskPosition$Input}
 */
export type MaskPosition$Input = maskPosition$Input;

/**
 * Any of:
 * - {@link stickerFormatWebp}
 * - {@link stickerFormatTgs}
 * - {@link stickerFormatWebm}
 */
export type StickerFormat = stickerFormatWebp | stickerFormatTgs | stickerFormatWebm;

/**
 * Any of:
 * - {@link stickerFormatWebp$Input}
 * - {@link stickerFormatTgs$Input}
 * - {@link stickerFormatWebm$Input}
 */
export type StickerFormat$Input =
  | stickerFormatWebp$Input
  | stickerFormatTgs$Input
  | stickerFormatWebm$Input;

/**
 * Any of:
 * - {@link stickerTypeRegular}
 * - {@link stickerTypeMask}
 * - {@link stickerTypeCustomEmoji}
 */
export type StickerType =
  | stickerTypeRegular
  | stickerTypeMask
  | stickerTypeCustomEmoji;

/**
 * Any of:
 * - {@link stickerTypeRegular$Input}
 * - {@link stickerTypeMask$Input}
 * - {@link stickerTypeCustomEmoji$Input}
 */
export type StickerType$Input =
  | stickerTypeRegular$Input
  | stickerTypeMask$Input
  | stickerTypeCustomEmoji$Input;

/**
 * Any of:
 * - {@link closedVectorPath}
 */
export type ClosedVectorPath = closedVectorPath;

/**
 * Any of:
 * - {@link closedVectorPath$Input}
 */
export type ClosedVectorPath$Input = closedVectorPath$Input;

/**
 * Any of:
 * - {@link pollOption}
 */
export type PollOption = pollOption;

/**
 * Any of:
 * - {@link pollOption$Input}
 */
export type PollOption$Input = pollOption$Input;

/**
 * Any of:
 * - {@link pollTypeRegular}
 * - {@link pollTypeQuiz}
 */
export type PollType = pollTypeRegular | pollTypeQuiz;

/**
 * Any of:
 * - {@link pollTypeRegular$Input}
 * - {@link pollTypeQuiz$Input}
 */
export type PollType$Input = pollTypeRegular$Input | pollTypeQuiz$Input;

/**
 * Any of:
 * - {@link animation}
 */
export type Animation = animation;

/**
 * Any of:
 * - {@link animation$Input}
 */
export type Animation$Input = animation$Input;

/**
 * Any of:
 * - {@link audio}
 */
export type Audio = audio;

/**
 * Any of:
 * - {@link audio$Input}
 */
export type Audio$Input = audio$Input;

/**
 * Any of:
 * - {@link document}
 */
export type Document = document;

/**
 * Any of:
 * - {@link document$Input}
 */
export type Document$Input = document$Input;

/**
 * Any of:
 * - {@link photo}
 */
export type Photo = photo;

/**
 * Any of:
 * - {@link photo$Input}
 */
export type Photo$Input = photo$Input;

/**
 * Any of:
 * - {@link sticker}
 */
export type Sticker = sticker;

/**
 * Any of:
 * - {@link sticker$Input}
 */
export type Sticker$Input = sticker$Input;

/**
 * Any of:
 * - {@link video}
 */
export type Video = video;

/**
 * Any of:
 * - {@link video$Input}
 */
export type Video$Input = video$Input;

/**
 * Any of:
 * - {@link videoNote}
 */
export type VideoNote = videoNote;

/**
 * Any of:
 * - {@link videoNote$Input}
 */
export type VideoNote$Input = videoNote$Input;

/**
 * Any of:
 * - {@link voiceNote}
 */
export type VoiceNote = voiceNote;

/**
 * Any of:
 * - {@link voiceNote$Input}
 */
export type VoiceNote$Input = voiceNote$Input;

/**
 * Any of:
 * - {@link animatedEmoji}
 */
export type AnimatedEmoji = animatedEmoji;

/**
 * Any of:
 * - {@link animatedEmoji$Input}
 */
export type AnimatedEmoji$Input = animatedEmoji$Input;

/**
 * Any of:
 * - {@link contact}
 */
export type Contact = contact;

/**
 * Any of:
 * - {@link contact$Input}
 */
export type Contact$Input = contact$Input;

/**
 * Any of:
 * - {@link location}
 */
export type Location = location;

/**
 * Any of:
 * - {@link location$Input}
 */
export type Location$Input = location$Input;

/**
 * Any of:
 * - {@link venue}
 */
export type Venue = venue;

/**
 * Any of:
 * - {@link venue$Input}
 */
export type Venue$Input = venue$Input;

/**
 * Any of:
 * - {@link game}
 */
export type Game = game;

/**
 * Any of:
 * - {@link game$Input}
 */
export type Game$Input = game$Input;

/**
 * Any of:
 * - {@link poll}
 */
export type Poll = poll;

/**
 * Any of:
 * - {@link poll$Input}
 */
export type Poll$Input = poll$Input;

/**
 * Any of:
 * - {@link profilePhoto}
 */
export type ProfilePhoto = profilePhoto;

/**
 * Any of:
 * - {@link profilePhoto$Input}
 */
export type ProfilePhoto$Input = profilePhoto$Input;

/**
 * Any of:
 * - {@link chatPhotoInfo}
 */
export type ChatPhotoInfo = chatPhotoInfo;

/**
 * Any of:
 * - {@link chatPhotoInfo$Input}
 */
export type ChatPhotoInfo$Input = chatPhotoInfo$Input;

/**
 * Any of:
 * - {@link userTypeRegular}
 * - {@link userTypeDeleted}
 * - {@link userTypeBot}
 * - {@link userTypeUnknown}
 */
export type UserType =
  | userTypeRegular
  | userTypeDeleted
  | userTypeBot
  | userTypeUnknown;

/**
 * Any of:
 * - {@link userTypeRegular$Input}
 * - {@link userTypeDeleted$Input}
 * - {@link userTypeBot$Input}
 * - {@link userTypeUnknown$Input}
 */
export type UserType$Input =
  | userTypeRegular$Input
  | userTypeDeleted$Input
  | userTypeBot$Input
  | userTypeUnknown$Input;

/**
 * Any of:
 * - {@link botCommand}
 */
export type BotCommand = botCommand;

/**
 * Any of:
 * - {@link botCommand$Input}
 */
export type BotCommand$Input = botCommand$Input;

/**
 * Any of:
 * - {@link botCommands}
 */
export type BotCommands = botCommands;

/**
 * Any of:
 * - {@link botCommands$Input}
 */
export type BotCommands$Input = botCommands$Input;

/**
 * Any of:
 * - {@link botMenuButton}
 */
export type BotMenuButton = botMenuButton;

/**
 * Any of:
 * - {@link botMenuButton$Input}
 */
export type BotMenuButton$Input = botMenuButton$Input;

/**
 * Any of:
 * - {@link chatLocation}
 */
export type ChatLocation = chatLocation;

/**
 * Any of:
 * - {@link chatLocation$Input}
 */
export type ChatLocation$Input = chatLocation$Input;

/**
 * Any of:
 * - {@link animatedChatPhoto}
 */
export type AnimatedChatPhoto = animatedChatPhoto;

/**
 * Any of:
 * - {@link animatedChatPhoto$Input}
 */
export type AnimatedChatPhoto$Input = animatedChatPhoto$Input;

/**
 * Any of:
 * - {@link chatPhoto}
 */
export type ChatPhoto = chatPhoto;

/**
 * Any of:
 * - {@link chatPhoto$Input}
 */
export type ChatPhoto$Input = chatPhoto$Input;

/**
 * Any of:
 * - {@link chatPhotos}
 */
export type ChatPhotos = chatPhotos;

/**
 * Any of:
 * - {@link chatPhotos$Input}
 */
export type ChatPhotos$Input = chatPhotos$Input;

/**
 * Any of:
 * - {@link inputChatPhotoPrevious}
 * - {@link inputChatPhotoStatic}
 * - {@link inputChatPhotoAnimation}
 */
export type InputChatPhoto =
  | inputChatPhotoPrevious
  | inputChatPhotoStatic
  | inputChatPhotoAnimation;

/**
 * Any of:
 * - {@link inputChatPhotoPrevious$Input}
 * - {@link inputChatPhotoStatic$Input}
 * - {@link inputChatPhotoAnimation$Input}
 */
export type InputChatPhoto$Input =
  | inputChatPhotoPrevious$Input
  | inputChatPhotoStatic$Input
  | inputChatPhotoAnimation$Input;

/**
 * Any of:
 * - {@link chatPermissions}
 */
export type ChatPermissions = chatPermissions;

/**
 * Any of:
 * - {@link chatPermissions$Input}
 */
export type ChatPermissions$Input = chatPermissions$Input;

/**
 * Any of:
 * - {@link chatAdministratorRights}
 */
export type ChatAdministratorRights = chatAdministratorRights;

/**
 * Any of:
 * - {@link chatAdministratorRights$Input}
 */
export type ChatAdministratorRights$Input = chatAdministratorRights$Input;

/**
 * Any of:
 * - {@link premiumPaymentOption}
 */
export type PremiumPaymentOption = premiumPaymentOption;

/**
 * Any of:
 * - {@link premiumPaymentOption$Input}
 */
export type PremiumPaymentOption$Input = premiumPaymentOption$Input;

/**
 * Any of:
 * - {@link emojiStatus}
 */
export type EmojiStatus = emojiStatus;

/**
 * Any of:
 * - {@link emojiStatus$Input}
 */
export type EmojiStatus$Input = emojiStatus$Input;

/**
 * Any of:
 * - {@link emojiStatuses}
 */
export type EmojiStatuses = emojiStatuses;

/**
 * Any of:
 * - {@link emojiStatuses$Input}
 */
export type EmojiStatuses$Input = emojiStatuses$Input;

/**
 * Any of:
 * - {@link usernames}
 */
export type Usernames = usernames;

/**
 * Any of:
 * - {@link usernames$Input}
 */
export type Usernames$Input = usernames$Input;

/**
 * Any of:
 * - {@link user}
 */
export type User = user;

/**
 * Any of:
 * - {@link user$Input}
 */
export type User$Input = user$Input;

/**
 * Any of:
 * - {@link botInfo}
 */
export type BotInfo = botInfo;

/**
 * Any of:
 * - {@link botInfo$Input}
 */
export type BotInfo$Input = botInfo$Input;

/**
 * Any of:
 * - {@link userFullInfo}
 */
export type UserFullInfo = userFullInfo;

/**
 * Any of:
 * - {@link userFullInfo$Input}
 */
export type UserFullInfo$Input = userFullInfo$Input;

/**
 * Any of:
 * - {@link users}
 */
export type Users = users;

/**
 * Any of:
 * - {@link users$Input}
 */
export type Users$Input = users$Input;

/**
 * Any of:
 * - {@link chatAdministrator}
 */
export type ChatAdministrator = chatAdministrator;

/**
 * Any of:
 * - {@link chatAdministrator$Input}
 */
export type ChatAdministrator$Input = chatAdministrator$Input;

/**
 * Any of:
 * - {@link chatAdministrators}
 */
export type ChatAdministrators = chatAdministrators;

/**
 * Any of:
 * - {@link chatAdministrators$Input}
 */
export type ChatAdministrators$Input = chatAdministrators$Input;

/**
 * Any of:
 * - {@link chatMemberStatusCreator}
 * - {@link chatMemberStatusAdministrator}
 * - {@link chatMemberStatusMember}
 * - {@link chatMemberStatusRestricted}
 * - {@link chatMemberStatusLeft}
 * - {@link chatMemberStatusBanned}
 */
export type ChatMemberStatus =
  | chatMemberStatusCreator
  | chatMemberStatusAdministrator
  | chatMemberStatusMember
  | chatMemberStatusRestricted
  | chatMemberStatusLeft
  | chatMemberStatusBanned;

/**
 * Any of:
 * - {@link chatMemberStatusCreator$Input}
 * - {@link chatMemberStatusAdministrator$Input}
 * - {@link chatMemberStatusMember$Input}
 * - {@link chatMemberStatusRestricted$Input}
 * - {@link chatMemberStatusLeft$Input}
 * - {@link chatMemberStatusBanned$Input}
 */
export type ChatMemberStatus$Input =
  | chatMemberStatusCreator$Input
  | chatMemberStatusAdministrator$Input
  | chatMemberStatusMember$Input
  | chatMemberStatusRestricted$Input
  | chatMemberStatusLeft$Input
  | chatMemberStatusBanned$Input;

/**
 * Any of:
 * - {@link chatMember}
 */
export type ChatMember = chatMember;

/**
 * Any of:
 * - {@link chatMember$Input}
 */
export type ChatMember$Input = chatMember$Input;

/**
 * Any of:
 * - {@link chatMembers}
 */
export type ChatMembers = chatMembers;

/**
 * Any of:
 * - {@link chatMembers$Input}
 */
export type ChatMembers$Input = chatMembers$Input;

/**
 * Any of:
 * - {@link chatMembersFilterContacts}
 * - {@link chatMembersFilterAdministrators}
 * - {@link chatMembersFilterMembers}
 * - {@link chatMembersFilterMention}
 * - {@link chatMembersFilterRestricted}
 * - {@link chatMembersFilterBanned}
 * - {@link chatMembersFilterBots}
 */
export type ChatMembersFilter =
  | chatMembersFilterContacts
  | chatMembersFilterAdministrators
  | chatMembersFilterMembers
  | chatMembersFilterMention
  | chatMembersFilterRestricted
  | chatMembersFilterBanned
  | chatMembersFilterBots;

/**
 * Any of:
 * - {@link chatMembersFilterContacts$Input}
 * - {@link chatMembersFilterAdministrators$Input}
 * - {@link chatMembersFilterMembers$Input}
 * - {@link chatMembersFilterMention$Input}
 * - {@link chatMembersFilterRestricted$Input}
 * - {@link chatMembersFilterBanned$Input}
 * - {@link chatMembersFilterBots$Input}
 */
export type ChatMembersFilter$Input =
  | chatMembersFilterContacts$Input
  | chatMembersFilterAdministrators$Input
  | chatMembersFilterMembers$Input
  | chatMembersFilterMention$Input
  | chatMembersFilterRestricted$Input
  | chatMembersFilterBanned$Input
  | chatMembersFilterBots$Input;

/**
 * Any of:
 * - {@link supergroupMembersFilterRecent}
 * - {@link supergroupMembersFilterContacts}
 * - {@link supergroupMembersFilterAdministrators}
 * - {@link supergroupMembersFilterSearch}
 * - {@link supergroupMembersFilterRestricted}
 * - {@link supergroupMembersFilterBanned}
 * - {@link supergroupMembersFilterMention}
 * - {@link supergroupMembersFilterBots}
 */
export type SupergroupMembersFilter =
  | supergroupMembersFilterRecent
  | supergroupMembersFilterContacts
  | supergroupMembersFilterAdministrators
  | supergroupMembersFilterSearch
  | supergroupMembersFilterRestricted
  | supergroupMembersFilterBanned
  | supergroupMembersFilterMention
  | supergroupMembersFilterBots;

/**
 * Any of:
 * - {@link supergroupMembersFilterRecent$Input}
 * - {@link supergroupMembersFilterContacts$Input}
 * - {@link supergroupMembersFilterAdministrators$Input}
 * - {@link supergroupMembersFilterSearch$Input}
 * - {@link supergroupMembersFilterRestricted$Input}
 * - {@link supergroupMembersFilterBanned$Input}
 * - {@link supergroupMembersFilterMention$Input}
 * - {@link supergroupMembersFilterBots$Input}
 */
export type SupergroupMembersFilter$Input =
  | supergroupMembersFilterRecent$Input
  | supergroupMembersFilterContacts$Input
  | supergroupMembersFilterAdministrators$Input
  | supergroupMembersFilterSearch$Input
  | supergroupMembersFilterRestricted$Input
  | supergroupMembersFilterBanned$Input
  | supergroupMembersFilterMention$Input
  | supergroupMembersFilterBots$Input;

/**
 * Any of:
 * - {@link chatInviteLink}
 */
export type ChatInviteLink = chatInviteLink;

/**
 * Any of:
 * - {@link chatInviteLink$Input}
 */
export type ChatInviteLink$Input = chatInviteLink$Input;

/**
 * Any of:
 * - {@link chatInviteLinks}
 */
export type ChatInviteLinks = chatInviteLinks;

/**
 * Any of:
 * - {@link chatInviteLinks$Input}
 */
export type ChatInviteLinks$Input = chatInviteLinks$Input;

/**
 * Any of:
 * - {@link chatInviteLinkCount}
 */
export type ChatInviteLinkCount = chatInviteLinkCount;

/**
 * Any of:
 * - {@link chatInviteLinkCount$Input}
 */
export type ChatInviteLinkCount$Input = chatInviteLinkCount$Input;

/**
 * Any of:
 * - {@link chatInviteLinkCounts}
 */
export type ChatInviteLinkCounts = chatInviteLinkCounts;

/**
 * Any of:
 * - {@link chatInviteLinkCounts$Input}
 */
export type ChatInviteLinkCounts$Input = chatInviteLinkCounts$Input;

/**
 * Any of:
 * - {@link chatInviteLinkMember}
 */
export type ChatInviteLinkMember = chatInviteLinkMember;

/**
 * Any of:
 * - {@link chatInviteLinkMember$Input}
 */
export type ChatInviteLinkMember$Input = chatInviteLinkMember$Input;

/**
 * Any of:
 * - {@link chatInviteLinkMembers}
 */
export type ChatInviteLinkMembers = chatInviteLinkMembers;

/**
 * Any of:
 * - {@link chatInviteLinkMembers$Input}
 */
export type ChatInviteLinkMembers$Input = chatInviteLinkMembers$Input;

/**
 * Any of:
 * - {@link chatInviteLinkInfo}
 */
export type ChatInviteLinkInfo = chatInviteLinkInfo;

/**
 * Any of:
 * - {@link chatInviteLinkInfo$Input}
 */
export type ChatInviteLinkInfo$Input = chatInviteLinkInfo$Input;

/**
 * Any of:
 * - {@link chatJoinRequest}
 */
export type ChatJoinRequest = chatJoinRequest;

/**
 * Any of:
 * - {@link chatJoinRequest$Input}
 */
export type ChatJoinRequest$Input = chatJoinRequest$Input;

/**
 * Any of:
 * - {@link chatJoinRequests}
 */
export type ChatJoinRequests = chatJoinRequests;

/**
 * Any of:
 * - {@link chatJoinRequests$Input}
 */
export type ChatJoinRequests$Input = chatJoinRequests$Input;

/**
 * Any of:
 * - {@link chatJoinRequestsInfo}
 */
export type ChatJoinRequestsInfo = chatJoinRequestsInfo;

/**
 * Any of:
 * - {@link chatJoinRequestsInfo$Input}
 */
export type ChatJoinRequestsInfo$Input = chatJoinRequestsInfo$Input;

/**
 * Any of:
 * - {@link basicGroup}
 */
export type BasicGroup = basicGroup;

/**
 * Any of:
 * - {@link basicGroup$Input}
 */
export type BasicGroup$Input = basicGroup$Input;

/**
 * Any of:
 * - {@link basicGroupFullInfo}
 */
export type BasicGroupFullInfo = basicGroupFullInfo;

/**
 * Any of:
 * - {@link basicGroupFullInfo$Input}
 */
export type BasicGroupFullInfo$Input = basicGroupFullInfo$Input;

/**
 * Any of:
 * - {@link supergroup}
 */
export type Supergroup = supergroup;

/**
 * Any of:
 * - {@link supergroup$Input}
 */
export type Supergroup$Input = supergroup$Input;

/**
 * Any of:
 * - {@link supergroupFullInfo}
 */
export type SupergroupFullInfo = supergroupFullInfo;

/**
 * Any of:
 * - {@link supergroupFullInfo$Input}
 */
export type SupergroupFullInfo$Input = supergroupFullInfo$Input;

/**
 * Any of:
 * - {@link secretChatStatePending}
 * - {@link secretChatStateReady}
 * - {@link secretChatStateClosed}
 */
export type SecretChatState =
  | secretChatStatePending
  | secretChatStateReady
  | secretChatStateClosed;

/**
 * Any of:
 * - {@link secretChatStatePending$Input}
 * - {@link secretChatStateReady$Input}
 * - {@link secretChatStateClosed$Input}
 */
export type SecretChatState$Input =
  | secretChatStatePending$Input
  | secretChatStateReady$Input
  | secretChatStateClosed$Input;

/**
 * Any of:
 * - {@link secretChat}
 */
export type SecretChat = secretChat;

/**
 * Any of:
 * - {@link secretChat$Input}
 */
export type SecretChat$Input = secretChat$Input;

/**
 * Any of:
 * - {@link messageSenderUser}
 * - {@link messageSenderChat}
 */
export type MessageSender = messageSenderUser | messageSenderChat;

/**
 * Any of:
 * - {@link messageSenderUser$Input}
 * - {@link messageSenderChat$Input}
 */
export type MessageSender$Input = messageSenderUser$Input | messageSenderChat$Input;

/**
 * Any of:
 * - {@link messageSenders}
 */
export type MessageSenders = messageSenders;

/**
 * Any of:
 * - {@link messageSenders$Input}
 */
export type MessageSenders$Input = messageSenders$Input;

/**
 * Any of:
 * - {@link chatMessageSender}
 */
export type ChatMessageSender = chatMessageSender;

/**
 * Any of:
 * - {@link chatMessageSender$Input}
 */
export type ChatMessageSender$Input = chatMessageSender$Input;

/**
 * Any of:
 * - {@link chatMessageSenders}
 */
export type ChatMessageSenders = chatMessageSenders;

/**
 * Any of:
 * - {@link chatMessageSenders$Input}
 */
export type ChatMessageSenders$Input = chatMessageSenders$Input;

/**
 * Any of:
 * - {@link messageForwardOriginUser}
 * - {@link messageForwardOriginChat}
 * - {@link messageForwardOriginHiddenUser}
 * - {@link messageForwardOriginChannel}
 * - {@link messageForwardOriginMessageImport}
 */
export type MessageForwardOrigin =
  | messageForwardOriginUser
  | messageForwardOriginChat
  | messageForwardOriginHiddenUser
  | messageForwardOriginChannel
  | messageForwardOriginMessageImport;

/**
 * Any of:
 * - {@link messageForwardOriginUser$Input}
 * - {@link messageForwardOriginChat$Input}
 * - {@link messageForwardOriginHiddenUser$Input}
 * - {@link messageForwardOriginChannel$Input}
 * - {@link messageForwardOriginMessageImport$Input}
 */
export type MessageForwardOrigin$Input =
  | messageForwardOriginUser$Input
  | messageForwardOriginChat$Input
  | messageForwardOriginHiddenUser$Input
  | messageForwardOriginChannel$Input
  | messageForwardOriginMessageImport$Input;

/**
 * Any of:
 * - {@link reactionTypeEmoji}
 * - {@link reactionTypeCustomEmoji}
 */
export type ReactionType = reactionTypeEmoji | reactionTypeCustomEmoji;

/**
 * Any of:
 * - {@link reactionTypeEmoji$Input}
 * - {@link reactionTypeCustomEmoji$Input}
 */
export type ReactionType$Input =
  | reactionTypeEmoji$Input
  | reactionTypeCustomEmoji$Input;

/**
 * Any of:
 * - {@link messageForwardInfo}
 */
export type MessageForwardInfo = messageForwardInfo;

/**
 * Any of:
 * - {@link messageForwardInfo$Input}
 */
export type MessageForwardInfo$Input = messageForwardInfo$Input;

/**
 * Any of:
 * - {@link messageReplyInfo}
 */
export type MessageReplyInfo = messageReplyInfo;

/**
 * Any of:
 * - {@link messageReplyInfo$Input}
 */
export type MessageReplyInfo$Input = messageReplyInfo$Input;

/**
 * Any of:
 * - {@link messageReaction}
 */
export type MessageReaction = messageReaction;

/**
 * Any of:
 * - {@link messageReaction$Input}
 */
export type MessageReaction$Input = messageReaction$Input;

/**
 * Any of:
 * - {@link messageInteractionInfo}
 */
export type MessageInteractionInfo = messageInteractionInfo;

/**
 * Any of:
 * - {@link messageInteractionInfo$Input}
 */
export type MessageInteractionInfo$Input = messageInteractionInfo$Input;

/**
 * Any of:
 * - {@link unreadReaction}
 */
export type UnreadReaction = unreadReaction;

/**
 * Any of:
 * - {@link unreadReaction$Input}
 */
export type UnreadReaction$Input = unreadReaction$Input;

/**
 * Any of:
 * - {@link messageSendingStatePending}
 * - {@link messageSendingStateFailed}
 */
export type MessageSendingState =
  | messageSendingStatePending
  | messageSendingStateFailed;

/**
 * Any of:
 * - {@link messageSendingStatePending$Input}
 * - {@link messageSendingStateFailed$Input}
 */
export type MessageSendingState$Input =
  | messageSendingStatePending$Input
  | messageSendingStateFailed$Input;

/**
 * Any of:
 * - {@link message}
 */
export type Message = message;

/**
 * Any of:
 * - {@link message$Input}
 */
export type Message$Input = message$Input;

/**
 * Any of:
 * - {@link messages}
 */
export type Messages = messages;

/**
 * Any of:
 * - {@link messages$Input}
 */
export type Messages$Input = messages$Input;

/**
 * Any of:
 * - {@link foundMessages}
 */
export type FoundMessages = foundMessages;

/**
 * Any of:
 * - {@link foundMessages$Input}
 */
export type FoundMessages$Input = foundMessages$Input;

/**
 * Any of:
 * - {@link messagePosition}
 */
export type MessagePosition = messagePosition;

/**
 * Any of:
 * - {@link messagePosition$Input}
 */
export type MessagePosition$Input = messagePosition$Input;

/**
 * Any of:
 * - {@link messagePositions}
 */
export type MessagePositions = messagePositions;

/**
 * Any of:
 * - {@link messagePositions$Input}
 */
export type MessagePositions$Input = messagePositions$Input;

/**
 * Any of:
 * - {@link messageCalendarDay}
 */
export type MessageCalendarDay = messageCalendarDay;

/**
 * Any of:
 * - {@link messageCalendarDay$Input}
 */
export type MessageCalendarDay$Input = messageCalendarDay$Input;

/**
 * Any of:
 * - {@link messageCalendar}
 */
export type MessageCalendar = messageCalendar;

/**
 * Any of:
 * - {@link messageCalendar$Input}
 */
export type MessageCalendar$Input = messageCalendar$Input;

/**
 * Any of:
 * - {@link sponsoredMessage}
 */
export type SponsoredMessage = sponsoredMessage;

/**
 * Any of:
 * - {@link sponsoredMessage$Input}
 */
export type SponsoredMessage$Input = sponsoredMessage$Input;

/**
 * Any of:
 * - {@link sponsoredMessages}
 */
export type SponsoredMessages = sponsoredMessages;

/**
 * Any of:
 * - {@link sponsoredMessages$Input}
 */
export type SponsoredMessages$Input = sponsoredMessages$Input;

/**
 * Any of:
 * - {@link fileDownload}
 */
export type FileDownload = fileDownload;

/**
 * Any of:
 * - {@link fileDownload$Input}
 */
export type FileDownload$Input = fileDownload$Input;

/**
 * Any of:
 * - {@link downloadedFileCounts}
 */
export type DownloadedFileCounts = downloadedFileCounts;

/**
 * Any of:
 * - {@link downloadedFileCounts$Input}
 */
export type DownloadedFileCounts$Input = downloadedFileCounts$Input;

/**
 * Any of:
 * - {@link foundFileDownloads}
 */
export type FoundFileDownloads = foundFileDownloads;

/**
 * Any of:
 * - {@link foundFileDownloads$Input}
 */
export type FoundFileDownloads$Input = foundFileDownloads$Input;

/**
 * Any of:
 * - {@link notificationSettingsScopePrivateChats}
 * - {@link notificationSettingsScopeGroupChats}
 * - {@link notificationSettingsScopeChannelChats}
 */
export type NotificationSettingsScope =
  | notificationSettingsScopePrivateChats
  | notificationSettingsScopeGroupChats
  | notificationSettingsScopeChannelChats;

/**
 * Any of:
 * - {@link notificationSettingsScopePrivateChats$Input}
 * - {@link notificationSettingsScopeGroupChats$Input}
 * - {@link notificationSettingsScopeChannelChats$Input}
 */
export type NotificationSettingsScope$Input =
  | notificationSettingsScopePrivateChats$Input
  | notificationSettingsScopeGroupChats$Input
  | notificationSettingsScopeChannelChats$Input;

/**
 * Any of:
 * - {@link chatNotificationSettings}
 */
export type ChatNotificationSettings = chatNotificationSettings;

/**
 * Any of:
 * - {@link chatNotificationSettings$Input}
 */
export type ChatNotificationSettings$Input = chatNotificationSettings$Input;

/**
 * Any of:
 * - {@link scopeNotificationSettings}
 */
export type ScopeNotificationSettings = scopeNotificationSettings;

/**
 * Any of:
 * - {@link scopeNotificationSettings$Input}
 */
export type ScopeNotificationSettings$Input = scopeNotificationSettings$Input;

/**
 * Any of:
 * - {@link draftMessage}
 */
export type DraftMessage = draftMessage;

/**
 * Any of:
 * - {@link draftMessage$Input}
 */
export type DraftMessage$Input = draftMessage$Input;

/**
 * Any of:
 * - {@link chatTypePrivate}
 * - {@link chatTypeBasicGroup}
 * - {@link chatTypeSupergroup}
 * - {@link chatTypeSecret}
 */
export type ChatType =
  | chatTypePrivate
  | chatTypeBasicGroup
  | chatTypeSupergroup
  | chatTypeSecret;

/**
 * Any of:
 * - {@link chatTypePrivate$Input}
 * - {@link chatTypeBasicGroup$Input}
 * - {@link chatTypeSupergroup$Input}
 * - {@link chatTypeSecret$Input}
 */
export type ChatType$Input =
  | chatTypePrivate$Input
  | chatTypeBasicGroup$Input
  | chatTypeSupergroup$Input
  | chatTypeSecret$Input;

/**
 * Any of:
 * - {@link chatFilter}
 */
export type ChatFilter = chatFilter;

/**
 * Any of:
 * - {@link chatFilter$Input}
 */
export type ChatFilter$Input = chatFilter$Input;

/**
 * Any of:
 * - {@link chatFilterInfo}
 */
export type ChatFilterInfo = chatFilterInfo;

/**
 * Any of:
 * - {@link chatFilterInfo$Input}
 */
export type ChatFilterInfo$Input = chatFilterInfo$Input;

/**
 * Any of:
 * - {@link recommendedChatFilter}
 */
export type RecommendedChatFilter = recommendedChatFilter;

/**
 * Any of:
 * - {@link recommendedChatFilter$Input}
 */
export type RecommendedChatFilter$Input = recommendedChatFilter$Input;

/**
 * Any of:
 * - {@link recommendedChatFilters}
 */
export type RecommendedChatFilters = recommendedChatFilters;

/**
 * Any of:
 * - {@link recommendedChatFilters$Input}
 */
export type RecommendedChatFilters$Input = recommendedChatFilters$Input;

/**
 * Any of:
 * - {@link chatListMain}
 * - {@link chatListArchive}
 * - {@link chatListFilter}
 */
export type ChatList = chatListMain | chatListArchive | chatListFilter;

/**
 * Any of:
 * - {@link chatListMain$Input}
 * - {@link chatListArchive$Input}
 * - {@link chatListFilter$Input}
 */
export type ChatList$Input =
  | chatListMain$Input
  | chatListArchive$Input
  | chatListFilter$Input;

/**
 * Any of:
 * - {@link chatLists}
 */
export type ChatLists = chatLists;

/**
 * Any of:
 * - {@link chatLists$Input}
 */
export type ChatLists$Input = chatLists$Input;

/**
 * Any of:
 * - {@link chatSourceMtprotoProxy}
 * - {@link chatSourcePublicServiceAnnouncement}
 */
export type ChatSource =
  | chatSourceMtprotoProxy
  | chatSourcePublicServiceAnnouncement;

/**
 * Any of:
 * - {@link chatSourceMtprotoProxy$Input}
 * - {@link chatSourcePublicServiceAnnouncement$Input}
 */
export type ChatSource$Input =
  | chatSourceMtprotoProxy$Input
  | chatSourcePublicServiceAnnouncement$Input;

/**
 * Any of:
 * - {@link chatPosition}
 */
export type ChatPosition = chatPosition;

/**
 * Any of:
 * - {@link chatPosition$Input}
 */
export type ChatPosition$Input = chatPosition$Input;

/**
 * Any of:
 * - {@link chatAvailableReactionsAll}
 * - {@link chatAvailableReactionsSome}
 */
export type ChatAvailableReactions =
  | chatAvailableReactionsAll
  | chatAvailableReactionsSome;

/**
 * Any of:
 * - {@link chatAvailableReactionsAll$Input}
 * - {@link chatAvailableReactionsSome$Input}
 */
export type ChatAvailableReactions$Input =
  | chatAvailableReactionsAll$Input
  | chatAvailableReactionsSome$Input;

/**
 * Any of:
 * - {@link videoChat}
 */
export type VideoChat = videoChat;

/**
 * Any of:
 * - {@link videoChat$Input}
 */
export type VideoChat$Input = videoChat$Input;

/**
 * Any of:
 * - {@link chat}
 */
export type Chat = chat;

/**
 * Any of:
 * - {@link chat$Input}
 */
export type Chat$Input = chat$Input;

/**
 * Any of:
 * - {@link chats}
 */
export type Chats = chats;

/**
 * Any of:
 * - {@link chats$Input}
 */
export type Chats$Input = chats$Input;

/**
 * Any of:
 * - {@link chatNearby}
 */
export type ChatNearby = chatNearby;

/**
 * Any of:
 * - {@link chatNearby$Input}
 */
export type ChatNearby$Input = chatNearby$Input;

/**
 * Any of:
 * - {@link chatsNearby}
 */
export type ChatsNearby = chatsNearby;

/**
 * Any of:
 * - {@link chatsNearby$Input}
 */
export type ChatsNearby$Input = chatsNearby$Input;

/**
 * Any of:
 * - {@link publicChatTypeHasUsername}
 * - {@link publicChatTypeIsLocationBased}
 */
export type PublicChatType =
  | publicChatTypeHasUsername
  | publicChatTypeIsLocationBased;

/**
 * Any of:
 * - {@link publicChatTypeHasUsername$Input}
 * - {@link publicChatTypeIsLocationBased$Input}
 */
export type PublicChatType$Input =
  | publicChatTypeHasUsername$Input
  | publicChatTypeIsLocationBased$Input;

/**
 * Any of:
 * - {@link chatActionBarReportSpam}
 * - {@link chatActionBarReportUnrelatedLocation}
 * - {@link chatActionBarInviteMembers}
 * - {@link chatActionBarReportAddBlock}
 * - {@link chatActionBarAddContact}
 * - {@link chatActionBarSharePhoneNumber}
 * - {@link chatActionBarJoinRequest}
 */
export type ChatActionBar =
  | chatActionBarReportSpam
  | chatActionBarReportUnrelatedLocation
  | chatActionBarInviteMembers
  | chatActionBarReportAddBlock
  | chatActionBarAddContact
  | chatActionBarSharePhoneNumber
  | chatActionBarJoinRequest;

/**
 * Any of:
 * - {@link chatActionBarReportSpam$Input}
 * - {@link chatActionBarReportUnrelatedLocation$Input}
 * - {@link chatActionBarInviteMembers$Input}
 * - {@link chatActionBarReportAddBlock$Input}
 * - {@link chatActionBarAddContact$Input}
 * - {@link chatActionBarSharePhoneNumber$Input}
 * - {@link chatActionBarJoinRequest$Input}
 */
export type ChatActionBar$Input =
  | chatActionBarReportSpam$Input
  | chatActionBarReportUnrelatedLocation$Input
  | chatActionBarInviteMembers$Input
  | chatActionBarReportAddBlock$Input
  | chatActionBarAddContact$Input
  | chatActionBarSharePhoneNumber$Input
  | chatActionBarJoinRequest$Input;

/**
 * Any of:
 * - {@link keyboardButtonTypeText}
 * - {@link keyboardButtonTypeRequestPhoneNumber}
 * - {@link keyboardButtonTypeRequestLocation}
 * - {@link keyboardButtonTypeRequestPoll}
 * - {@link keyboardButtonTypeWebApp}
 */
export type KeyboardButtonType =
  | keyboardButtonTypeText
  | keyboardButtonTypeRequestPhoneNumber
  | keyboardButtonTypeRequestLocation
  | keyboardButtonTypeRequestPoll
  | keyboardButtonTypeWebApp;

/**
 * Any of:
 * - {@link keyboardButtonTypeText$Input}
 * - {@link keyboardButtonTypeRequestPhoneNumber$Input}
 * - {@link keyboardButtonTypeRequestLocation$Input}
 * - {@link keyboardButtonTypeRequestPoll$Input}
 * - {@link keyboardButtonTypeWebApp$Input}
 */
export type KeyboardButtonType$Input =
  | keyboardButtonTypeText$Input
  | keyboardButtonTypeRequestPhoneNumber$Input
  | keyboardButtonTypeRequestLocation$Input
  | keyboardButtonTypeRequestPoll$Input
  | keyboardButtonTypeWebApp$Input;

/**
 * Any of:
 * - {@link keyboardButton}
 */
export type KeyboardButton = keyboardButton;

/**
 * Any of:
 * - {@link keyboardButton$Input}
 */
export type KeyboardButton$Input = keyboardButton$Input;

/**
 * Any of:
 * - {@link inlineKeyboardButtonTypeUrl}
 * - {@link inlineKeyboardButtonTypeLoginUrl}
 * - {@link inlineKeyboardButtonTypeWebApp}
 * - {@link inlineKeyboardButtonTypeCallback}
 * - {@link inlineKeyboardButtonTypeCallbackWithPassword}
 * - {@link inlineKeyboardButtonTypeCallbackGame}
 * - {@link inlineKeyboardButtonTypeSwitchInline}
 * - {@link inlineKeyboardButtonTypeBuy}
 * - {@link inlineKeyboardButtonTypeUser}
 */
export type InlineKeyboardButtonType =
  | inlineKeyboardButtonTypeUrl
  | inlineKeyboardButtonTypeLoginUrl
  | inlineKeyboardButtonTypeWebApp
  | inlineKeyboardButtonTypeCallback
  | inlineKeyboardButtonTypeCallbackWithPassword
  | inlineKeyboardButtonTypeCallbackGame
  | inlineKeyboardButtonTypeSwitchInline
  | inlineKeyboardButtonTypeBuy
  | inlineKeyboardButtonTypeUser;

/**
 * Any of:
 * - {@link inlineKeyboardButtonTypeUrl$Input}
 * - {@link inlineKeyboardButtonTypeLoginUrl$Input}
 * - {@link inlineKeyboardButtonTypeWebApp$Input}
 * - {@link inlineKeyboardButtonTypeCallback$Input}
 * - {@link inlineKeyboardButtonTypeCallbackWithPassword$Input}
 * - {@link inlineKeyboardButtonTypeCallbackGame$Input}
 * - {@link inlineKeyboardButtonTypeSwitchInline$Input}
 * - {@link inlineKeyboardButtonTypeBuy$Input}
 * - {@link inlineKeyboardButtonTypeUser$Input}
 */
export type InlineKeyboardButtonType$Input =
  | inlineKeyboardButtonTypeUrl$Input
  | inlineKeyboardButtonTypeLoginUrl$Input
  | inlineKeyboardButtonTypeWebApp$Input
  | inlineKeyboardButtonTypeCallback$Input
  | inlineKeyboardButtonTypeCallbackWithPassword$Input
  | inlineKeyboardButtonTypeCallbackGame$Input
  | inlineKeyboardButtonTypeSwitchInline$Input
  | inlineKeyboardButtonTypeBuy$Input
  | inlineKeyboardButtonTypeUser$Input;

/**
 * Any of:
 * - {@link inlineKeyboardButton}
 */
export type InlineKeyboardButton = inlineKeyboardButton;

/**
 * Any of:
 * - {@link inlineKeyboardButton$Input}
 */
export type InlineKeyboardButton$Input = inlineKeyboardButton$Input;

/**
 * Any of:
 * - {@link replyMarkupRemoveKeyboard}
 * - {@link replyMarkupForceReply}
 * - {@link replyMarkupShowKeyboard}
 * - {@link replyMarkupInlineKeyboard}
 */
export type ReplyMarkup =
  | replyMarkupRemoveKeyboard
  | replyMarkupForceReply
  | replyMarkupShowKeyboard
  | replyMarkupInlineKeyboard;

/**
 * Any of:
 * - {@link replyMarkupRemoveKeyboard$Input}
 * - {@link replyMarkupForceReply$Input}
 * - {@link replyMarkupShowKeyboard$Input}
 * - {@link replyMarkupInlineKeyboard$Input}
 */
export type ReplyMarkup$Input =
  | replyMarkupRemoveKeyboard$Input
  | replyMarkupForceReply$Input
  | replyMarkupShowKeyboard$Input
  | replyMarkupInlineKeyboard$Input;

/**
 * Any of:
 * - {@link loginUrlInfoOpen}
 * - {@link loginUrlInfoRequestConfirmation}
 */
export type LoginUrlInfo = loginUrlInfoOpen | loginUrlInfoRequestConfirmation;

/**
 * Any of:
 * - {@link loginUrlInfoOpen$Input}
 * - {@link loginUrlInfoRequestConfirmation$Input}
 */
export type LoginUrlInfo$Input =
  | loginUrlInfoOpen$Input
  | loginUrlInfoRequestConfirmation$Input;

/**
 * Any of:
 * - {@link webAppInfo}
 */
export type WebAppInfo = webAppInfo;

/**
 * Any of:
 * - {@link webAppInfo$Input}
 */
export type WebAppInfo$Input = webAppInfo$Input;

/**
 * Any of:
 * - {@link messageThreadInfo}
 */
export type MessageThreadInfo = messageThreadInfo;

/**
 * Any of:
 * - {@link messageThreadInfo$Input}
 */
export type MessageThreadInfo$Input = messageThreadInfo$Input;

/**
 * Any of:
 * - {@link forumTopicIcon}
 */
export type ForumTopicIcon = forumTopicIcon;

/**
 * Any of:
 * - {@link forumTopicIcon$Input}
 */
export type ForumTopicIcon$Input = forumTopicIcon$Input;

/**
 * Any of:
 * - {@link forumTopicInfo}
 */
export type ForumTopicInfo = forumTopicInfo;

/**
 * Any of:
 * - {@link forumTopicInfo$Input}
 */
export type ForumTopicInfo$Input = forumTopicInfo$Input;

/**
 * Any of:
 * - {@link forumTopic}
 */
export type ForumTopic = forumTopic;

/**
 * Any of:
 * - {@link forumTopic$Input}
 */
export type ForumTopic$Input = forumTopic$Input;

/**
 * Any of:
 * - {@link richTextPlain}
 * - {@link richTextBold}
 * - {@link richTextItalic}
 * - {@link richTextUnderline}
 * - {@link richTextStrikethrough}
 * - {@link richTextFixed}
 * - {@link richTextUrl}
 * - {@link richTextEmailAddress}
 * - {@link richTextSubscript}
 * - {@link richTextSuperscript}
 * - {@link richTextMarked}
 * - {@link richTextPhoneNumber}
 * - {@link richTextIcon}
 * - {@link richTextReference}
 * - {@link richTextAnchor}
 * - {@link richTextAnchorLink}
 * - {@link richTexts}
 */
export type RichText =
  | richTextPlain
  | richTextBold
  | richTextItalic
  | richTextUnderline
  | richTextStrikethrough
  | richTextFixed
  | richTextUrl
  | richTextEmailAddress
  | richTextSubscript
  | richTextSuperscript
  | richTextMarked
  | richTextPhoneNumber
  | richTextIcon
  | richTextReference
  | richTextAnchor
  | richTextAnchorLink
  | richTexts;

/**
 * Any of:
 * - {@link richTextPlain$Input}
 * - {@link richTextBold$Input}
 * - {@link richTextItalic$Input}
 * - {@link richTextUnderline$Input}
 * - {@link richTextStrikethrough$Input}
 * - {@link richTextFixed$Input}
 * - {@link richTextUrl$Input}
 * - {@link richTextEmailAddress$Input}
 * - {@link richTextSubscript$Input}
 * - {@link richTextSuperscript$Input}
 * - {@link richTextMarked$Input}
 * - {@link richTextPhoneNumber$Input}
 * - {@link richTextIcon$Input}
 * - {@link richTextReference$Input}
 * - {@link richTextAnchor$Input}
 * - {@link richTextAnchorLink$Input}
 * - {@link richTexts$Input}
 */
export type RichText$Input =
  | richTextPlain$Input
  | richTextBold$Input
  | richTextItalic$Input
  | richTextUnderline$Input
  | richTextStrikethrough$Input
  | richTextFixed$Input
  | richTextUrl$Input
  | richTextEmailAddress$Input
  | richTextSubscript$Input
  | richTextSuperscript$Input
  | richTextMarked$Input
  | richTextPhoneNumber$Input
  | richTextIcon$Input
  | richTextReference$Input
  | richTextAnchor$Input
  | richTextAnchorLink$Input
  | richTexts$Input;

/**
 * Any of:
 * - {@link pageBlockCaption}
 */
export type PageBlockCaption = pageBlockCaption;

/**
 * Any of:
 * - {@link pageBlockCaption$Input}
 */
export type PageBlockCaption$Input = pageBlockCaption$Input;

/**
 * Any of:
 * - {@link pageBlockListItem}
 */
export type PageBlockListItem = pageBlockListItem;

/**
 * Any of:
 * - {@link pageBlockListItem$Input}
 */
export type PageBlockListItem$Input = pageBlockListItem$Input;

/**
 * Any of:
 * - {@link pageBlockHorizontalAlignmentLeft}
 * - {@link pageBlockHorizontalAlignmentCenter}
 * - {@link pageBlockHorizontalAlignmentRight}
 */
export type PageBlockHorizontalAlignment =
  | pageBlockHorizontalAlignmentLeft
  | pageBlockHorizontalAlignmentCenter
  | pageBlockHorizontalAlignmentRight;

/**
 * Any of:
 * - {@link pageBlockHorizontalAlignmentLeft$Input}
 * - {@link pageBlockHorizontalAlignmentCenter$Input}
 * - {@link pageBlockHorizontalAlignmentRight$Input}
 */
export type PageBlockHorizontalAlignment$Input =
  | pageBlockHorizontalAlignmentLeft$Input
  | pageBlockHorizontalAlignmentCenter$Input
  | pageBlockHorizontalAlignmentRight$Input;

/**
 * Any of:
 * - {@link pageBlockVerticalAlignmentTop}
 * - {@link pageBlockVerticalAlignmentMiddle}
 * - {@link pageBlockVerticalAlignmentBottom}
 */
export type PageBlockVerticalAlignment =
  | pageBlockVerticalAlignmentTop
  | pageBlockVerticalAlignmentMiddle
  | pageBlockVerticalAlignmentBottom;

/**
 * Any of:
 * - {@link pageBlockVerticalAlignmentTop$Input}
 * - {@link pageBlockVerticalAlignmentMiddle$Input}
 * - {@link pageBlockVerticalAlignmentBottom$Input}
 */
export type PageBlockVerticalAlignment$Input =
  | pageBlockVerticalAlignmentTop$Input
  | pageBlockVerticalAlignmentMiddle$Input
  | pageBlockVerticalAlignmentBottom$Input;

/**
 * Any of:
 * - {@link pageBlockTableCell}
 */
export type PageBlockTableCell = pageBlockTableCell;

/**
 * Any of:
 * - {@link pageBlockTableCell$Input}
 */
export type PageBlockTableCell$Input = pageBlockTableCell$Input;

/**
 * Any of:
 * - {@link pageBlockRelatedArticle}
 */
export type PageBlockRelatedArticle = pageBlockRelatedArticle;

/**
 * Any of:
 * - {@link pageBlockRelatedArticle$Input}
 */
export type PageBlockRelatedArticle$Input = pageBlockRelatedArticle$Input;

/**
 * Any of:
 * - {@link pageBlockTitle}
 * - {@link pageBlockSubtitle}
 * - {@link pageBlockAuthorDate}
 * - {@link pageBlockHeader}
 * - {@link pageBlockSubheader}
 * - {@link pageBlockKicker}
 * - {@link pageBlockParagraph}
 * - {@link pageBlockPreformatted}
 * - {@link pageBlockFooter}
 * - {@link pageBlockDivider}
 * - {@link pageBlockAnchor}
 * - {@link pageBlockList}
 * - {@link pageBlockBlockQuote}
 * - {@link pageBlockPullQuote}
 * - {@link pageBlockAnimation}
 * - {@link pageBlockAudio}
 * - {@link pageBlockPhoto}
 * - {@link pageBlockVideo}
 * - {@link pageBlockVoiceNote}
 * - {@link pageBlockCover}
 * - {@link pageBlockEmbedded}
 * - {@link pageBlockEmbeddedPost}
 * - {@link pageBlockCollage}
 * - {@link pageBlockSlideshow}
 * - {@link pageBlockChatLink}
 * - {@link pageBlockTable}
 * - {@link pageBlockDetails}
 * - {@link pageBlockRelatedArticles}
 * - {@link pageBlockMap}
 */
export type PageBlock =
  | pageBlockTitle
  | pageBlockSubtitle
  | pageBlockAuthorDate
  | pageBlockHeader
  | pageBlockSubheader
  | pageBlockKicker
  | pageBlockParagraph
  | pageBlockPreformatted
  | pageBlockFooter
  | pageBlockDivider
  | pageBlockAnchor
  | pageBlockList
  | pageBlockBlockQuote
  | pageBlockPullQuote
  | pageBlockAnimation
  | pageBlockAudio
  | pageBlockPhoto
  | pageBlockVideo
  | pageBlockVoiceNote
  | pageBlockCover
  | pageBlockEmbedded
  | pageBlockEmbeddedPost
  | pageBlockCollage
  | pageBlockSlideshow
  | pageBlockChatLink
  | pageBlockTable
  | pageBlockDetails
  | pageBlockRelatedArticles
  | pageBlockMap;

/**
 * Any of:
 * - {@link pageBlockTitle$Input}
 * - {@link pageBlockSubtitle$Input}
 * - {@link pageBlockAuthorDate$Input}
 * - {@link pageBlockHeader$Input}
 * - {@link pageBlockSubheader$Input}
 * - {@link pageBlockKicker$Input}
 * - {@link pageBlockParagraph$Input}
 * - {@link pageBlockPreformatted$Input}
 * - {@link pageBlockFooter$Input}
 * - {@link pageBlockDivider$Input}
 * - {@link pageBlockAnchor$Input}
 * - {@link pageBlockList$Input}
 * - {@link pageBlockBlockQuote$Input}
 * - {@link pageBlockPullQuote$Input}
 * - {@link pageBlockAnimation$Input}
 * - {@link pageBlockAudio$Input}
 * - {@link pageBlockPhoto$Input}
 * - {@link pageBlockVideo$Input}
 * - {@link pageBlockVoiceNote$Input}
 * - {@link pageBlockCover$Input}
 * - {@link pageBlockEmbedded$Input}
 * - {@link pageBlockEmbeddedPost$Input}
 * - {@link pageBlockCollage$Input}
 * - {@link pageBlockSlideshow$Input}
 * - {@link pageBlockChatLink$Input}
 * - {@link pageBlockTable$Input}
 * - {@link pageBlockDetails$Input}
 * - {@link pageBlockRelatedArticles$Input}
 * - {@link pageBlockMap$Input}
 */
export type PageBlock$Input =
  | pageBlockTitle$Input
  | pageBlockSubtitle$Input
  | pageBlockAuthorDate$Input
  | pageBlockHeader$Input
  | pageBlockSubheader$Input
  | pageBlockKicker$Input
  | pageBlockParagraph$Input
  | pageBlockPreformatted$Input
  | pageBlockFooter$Input
  | pageBlockDivider$Input
  | pageBlockAnchor$Input
  | pageBlockList$Input
  | pageBlockBlockQuote$Input
  | pageBlockPullQuote$Input
  | pageBlockAnimation$Input
  | pageBlockAudio$Input
  | pageBlockPhoto$Input
  | pageBlockVideo$Input
  | pageBlockVoiceNote$Input
  | pageBlockCover$Input
  | pageBlockEmbedded$Input
  | pageBlockEmbeddedPost$Input
  | pageBlockCollage$Input
  | pageBlockSlideshow$Input
  | pageBlockChatLink$Input
  | pageBlockTable$Input
  | pageBlockDetails$Input
  | pageBlockRelatedArticles$Input
  | pageBlockMap$Input;

/**
 * Any of:
 * - {@link webPageInstantView}
 */
export type WebPageInstantView = webPageInstantView;

/**
 * Any of:
 * - {@link webPageInstantView$Input}
 */
export type WebPageInstantView$Input = webPageInstantView$Input;

/**
 * Any of:
 * - {@link webPage}
 */
export type WebPage = webPage;

/**
 * Any of:
 * - {@link webPage$Input}
 */
export type WebPage$Input = webPage$Input;

/**
 * Any of:
 * - {@link countryInfo}
 */
export type CountryInfo = countryInfo;

/**
 * Any of:
 * - {@link countryInfo$Input}
 */
export type CountryInfo$Input = countryInfo$Input;

/**
 * Any of:
 * - {@link countries}
 */
export type Countries = countries;

/**
 * Any of:
 * - {@link countries$Input}
 */
export type Countries$Input = countries$Input;

/**
 * Any of:
 * - {@link phoneNumberInfo}
 */
export type PhoneNumberInfo = phoneNumberInfo;

/**
 * Any of:
 * - {@link phoneNumberInfo$Input}
 */
export type PhoneNumberInfo$Input = phoneNumberInfo$Input;

/**
 * Any of:
 * - {@link bankCardActionOpenUrl}
 */
export type BankCardActionOpenUrl = bankCardActionOpenUrl;

/**
 * Any of:
 * - {@link bankCardActionOpenUrl$Input}
 */
export type BankCardActionOpenUrl$Input = bankCardActionOpenUrl$Input;

/**
 * Any of:
 * - {@link bankCardInfo}
 */
export type BankCardInfo = bankCardInfo;

/**
 * Any of:
 * - {@link bankCardInfo$Input}
 */
export type BankCardInfo$Input = bankCardInfo$Input;

/**
 * Any of:
 * - {@link address}
 */
export type Address = address;

/**
 * Any of:
 * - {@link address$Input}
 */
export type Address$Input = address$Input;

/**
 * Any of:
 * - {@link themeParameters}
 */
export type ThemeParameters = themeParameters;

/**
 * Any of:
 * - {@link themeParameters$Input}
 */
export type ThemeParameters$Input = themeParameters$Input;

/**
 * Any of:
 * - {@link labeledPricePart}
 */
export type LabeledPricePart = labeledPricePart;

/**
 * Any of:
 * - {@link labeledPricePart$Input}
 */
export type LabeledPricePart$Input = labeledPricePart$Input;

/**
 * Any of:
 * - {@link invoice}
 */
export type Invoice = invoice;

/**
 * Any of:
 * - {@link invoice$Input}
 */
export type Invoice$Input = invoice$Input;

/**
 * Any of:
 * - {@link orderInfo}
 */
export type OrderInfo = orderInfo;

/**
 * Any of:
 * - {@link orderInfo$Input}
 */
export type OrderInfo$Input = orderInfo$Input;

/**
 * Any of:
 * - {@link shippingOption}
 */
export type ShippingOption = shippingOption;

/**
 * Any of:
 * - {@link shippingOption$Input}
 */
export type ShippingOption$Input = shippingOption$Input;

/**
 * Any of:
 * - {@link savedCredentials}
 */
export type SavedCredentials = savedCredentials;

/**
 * Any of:
 * - {@link savedCredentials$Input}
 */
export type SavedCredentials$Input = savedCredentials$Input;

/**
 * Any of:
 * - {@link inputCredentialsSaved}
 * - {@link inputCredentialsNew}
 * - {@link inputCredentialsApplePay}
 * - {@link inputCredentialsGooglePay}
 */
export type InputCredentials =
  | inputCredentialsSaved
  | inputCredentialsNew
  | inputCredentialsApplePay
  | inputCredentialsGooglePay;

/**
 * Any of:
 * - {@link inputCredentialsSaved$Input}
 * - {@link inputCredentialsNew$Input}
 * - {@link inputCredentialsApplePay$Input}
 * - {@link inputCredentialsGooglePay$Input}
 */
export type InputCredentials$Input =
  | inputCredentialsSaved$Input
  | inputCredentialsNew$Input
  | inputCredentialsApplePay$Input
  | inputCredentialsGooglePay$Input;

/**
 * Any of:
 * - {@link paymentProviderSmartGlocal}
 * - {@link paymentProviderStripe}
 * - {@link paymentProviderOther}
 */
export type PaymentProvider =
  | paymentProviderSmartGlocal
  | paymentProviderStripe
  | paymentProviderOther;

/**
 * Any of:
 * - {@link paymentProviderSmartGlocal$Input}
 * - {@link paymentProviderStripe$Input}
 * - {@link paymentProviderOther$Input}
 */
export type PaymentProvider$Input =
  | paymentProviderSmartGlocal$Input
  | paymentProviderStripe$Input
  | paymentProviderOther$Input;

/**
 * Any of:
 * - {@link paymentOption}
 */
export type PaymentOption = paymentOption;

/**
 * Any of:
 * - {@link paymentOption$Input}
 */
export type PaymentOption$Input = paymentOption$Input;

/**
 * Any of:
 * - {@link paymentForm}
 */
export type PaymentForm = paymentForm;

/**
 * Any of:
 * - {@link paymentForm$Input}
 */
export type PaymentForm$Input = paymentForm$Input;

/**
 * Any of:
 * - {@link validatedOrderInfo}
 */
export type ValidatedOrderInfo = validatedOrderInfo;

/**
 * Any of:
 * - {@link validatedOrderInfo$Input}
 */
export type ValidatedOrderInfo$Input = validatedOrderInfo$Input;

/**
 * Any of:
 * - {@link paymentResult}
 */
export type PaymentResult = paymentResult;

/**
 * Any of:
 * - {@link paymentResult$Input}
 */
export type PaymentResult$Input = paymentResult$Input;

/**
 * Any of:
 * - {@link paymentReceipt}
 */
export type PaymentReceipt = paymentReceipt;

/**
 * Any of:
 * - {@link paymentReceipt$Input}
 */
export type PaymentReceipt$Input = paymentReceipt$Input;

/**
 * Any of:
 * - {@link inputInvoiceMessage}
 * - {@link inputInvoiceName}
 */
export type InputInvoice = inputInvoiceMessage | inputInvoiceName;

/**
 * Any of:
 * - {@link inputInvoiceMessage$Input}
 * - {@link inputInvoiceName$Input}
 */
export type InputInvoice$Input = inputInvoiceMessage$Input | inputInvoiceName$Input;

/**
 * Any of:
 * - {@link messageExtendedMediaPreview}
 * - {@link messageExtendedMediaPhoto}
 * - {@link messageExtendedMediaVideo}
 * - {@link messageExtendedMediaUnsupported}
 */
export type MessageExtendedMedia =
  | messageExtendedMediaPreview
  | messageExtendedMediaPhoto
  | messageExtendedMediaVideo
  | messageExtendedMediaUnsupported;

/**
 * Any of:
 * - {@link messageExtendedMediaPreview$Input}
 * - {@link messageExtendedMediaPhoto$Input}
 * - {@link messageExtendedMediaVideo$Input}
 * - {@link messageExtendedMediaUnsupported$Input}
 */
export type MessageExtendedMedia$Input =
  | messageExtendedMediaPreview$Input
  | messageExtendedMediaPhoto$Input
  | messageExtendedMediaVideo$Input
  | messageExtendedMediaUnsupported$Input;

/**
 * Any of:
 * - {@link datedFile}
 */
export type DatedFile = datedFile;

/**
 * Any of:
 * - {@link datedFile$Input}
 */
export type DatedFile$Input = datedFile$Input;

/**
 * Any of:
 * - {@link passportElementTypePersonalDetails}
 * - {@link passportElementTypePassport}
 * - {@link passportElementTypeDriverLicense}
 * - {@link passportElementTypeIdentityCard}
 * - {@link passportElementTypeInternalPassport}
 * - {@link passportElementTypeAddress}
 * - {@link passportElementTypeUtilityBill}
 * - {@link passportElementTypeBankStatement}
 * - {@link passportElementTypeRentalAgreement}
 * - {@link passportElementTypePassportRegistration}
 * - {@link passportElementTypeTemporaryRegistration}
 * - {@link passportElementTypePhoneNumber}
 * - {@link passportElementTypeEmailAddress}
 */
export type PassportElementType =
  | passportElementTypePersonalDetails
  | passportElementTypePassport
  | passportElementTypeDriverLicense
  | passportElementTypeIdentityCard
  | passportElementTypeInternalPassport
  | passportElementTypeAddress
  | passportElementTypeUtilityBill
  | passportElementTypeBankStatement
  | passportElementTypeRentalAgreement
  | passportElementTypePassportRegistration
  | passportElementTypeTemporaryRegistration
  | passportElementTypePhoneNumber
  | passportElementTypeEmailAddress;

/**
 * Any of:
 * - {@link passportElementTypePersonalDetails$Input}
 * - {@link passportElementTypePassport$Input}
 * - {@link passportElementTypeDriverLicense$Input}
 * - {@link passportElementTypeIdentityCard$Input}
 * - {@link passportElementTypeInternalPassport$Input}
 * - {@link passportElementTypeAddress$Input}
 * - {@link passportElementTypeUtilityBill$Input}
 * - {@link passportElementTypeBankStatement$Input}
 * - {@link passportElementTypeRentalAgreement$Input}
 * - {@link passportElementTypePassportRegistration$Input}
 * - {@link passportElementTypeTemporaryRegistration$Input}
 * - {@link passportElementTypePhoneNumber$Input}
 * - {@link passportElementTypeEmailAddress$Input}
 */
export type PassportElementType$Input =
  | passportElementTypePersonalDetails$Input
  | passportElementTypePassport$Input
  | passportElementTypeDriverLicense$Input
  | passportElementTypeIdentityCard$Input
  | passportElementTypeInternalPassport$Input
  | passportElementTypeAddress$Input
  | passportElementTypeUtilityBill$Input
  | passportElementTypeBankStatement$Input
  | passportElementTypeRentalAgreement$Input
  | passportElementTypePassportRegistration$Input
  | passportElementTypeTemporaryRegistration$Input
  | passportElementTypePhoneNumber$Input
  | passportElementTypeEmailAddress$Input;

/**
 * Any of:
 * - {@link date}
 */
export type Date = date;

/**
 * Any of:
 * - {@link date$Input}
 */
export type Date$Input = date$Input;

/**
 * Any of:
 * - {@link personalDetails}
 */
export type PersonalDetails = personalDetails;

/**
 * Any of:
 * - {@link personalDetails$Input}
 */
export type PersonalDetails$Input = personalDetails$Input;

/**
 * Any of:
 * - {@link identityDocument}
 */
export type IdentityDocument = identityDocument;

/**
 * Any of:
 * - {@link identityDocument$Input}
 */
export type IdentityDocument$Input = identityDocument$Input;

/**
 * Any of:
 * - {@link inputIdentityDocument}
 */
export type InputIdentityDocument = inputIdentityDocument;

/**
 * Any of:
 * - {@link inputIdentityDocument$Input}
 */
export type InputIdentityDocument$Input = inputIdentityDocument$Input;

/**
 * Any of:
 * - {@link personalDocument}
 */
export type PersonalDocument = personalDocument;

/**
 * Any of:
 * - {@link personalDocument$Input}
 */
export type PersonalDocument$Input = personalDocument$Input;

/**
 * Any of:
 * - {@link inputPersonalDocument}
 */
export type InputPersonalDocument = inputPersonalDocument;

/**
 * Any of:
 * - {@link inputPersonalDocument$Input}
 */
export type InputPersonalDocument$Input = inputPersonalDocument$Input;

/**
 * Any of:
 * - {@link passportElementPersonalDetails}
 * - {@link passportElementPassport}
 * - {@link passportElementDriverLicense}
 * - {@link passportElementIdentityCard}
 * - {@link passportElementInternalPassport}
 * - {@link passportElementAddress}
 * - {@link passportElementUtilityBill}
 * - {@link passportElementBankStatement}
 * - {@link passportElementRentalAgreement}
 * - {@link passportElementPassportRegistration}
 * - {@link passportElementTemporaryRegistration}
 * - {@link passportElementPhoneNumber}
 * - {@link passportElementEmailAddress}
 */
export type PassportElement =
  | passportElementPersonalDetails
  | passportElementPassport
  | passportElementDriverLicense
  | passportElementIdentityCard
  | passportElementInternalPassport
  | passportElementAddress
  | passportElementUtilityBill
  | passportElementBankStatement
  | passportElementRentalAgreement
  | passportElementPassportRegistration
  | passportElementTemporaryRegistration
  | passportElementPhoneNumber
  | passportElementEmailAddress;

/**
 * Any of:
 * - {@link passportElementPersonalDetails$Input}
 * - {@link passportElementPassport$Input}
 * - {@link passportElementDriverLicense$Input}
 * - {@link passportElementIdentityCard$Input}
 * - {@link passportElementInternalPassport$Input}
 * - {@link passportElementAddress$Input}
 * - {@link passportElementUtilityBill$Input}
 * - {@link passportElementBankStatement$Input}
 * - {@link passportElementRentalAgreement$Input}
 * - {@link passportElementPassportRegistration$Input}
 * - {@link passportElementTemporaryRegistration$Input}
 * - {@link passportElementPhoneNumber$Input}
 * - {@link passportElementEmailAddress$Input}
 */
export type PassportElement$Input =
  | passportElementPersonalDetails$Input
  | passportElementPassport$Input
  | passportElementDriverLicense$Input
  | passportElementIdentityCard$Input
  | passportElementInternalPassport$Input
  | passportElementAddress$Input
  | passportElementUtilityBill$Input
  | passportElementBankStatement$Input
  | passportElementRentalAgreement$Input
  | passportElementPassportRegistration$Input
  | passportElementTemporaryRegistration$Input
  | passportElementPhoneNumber$Input
  | passportElementEmailAddress$Input;

/**
 * Any of:
 * - {@link inputPassportElementPersonalDetails}
 * - {@link inputPassportElementPassport}
 * - {@link inputPassportElementDriverLicense}
 * - {@link inputPassportElementIdentityCard}
 * - {@link inputPassportElementInternalPassport}
 * - {@link inputPassportElementAddress}
 * - {@link inputPassportElementUtilityBill}
 * - {@link inputPassportElementBankStatement}
 * - {@link inputPassportElementRentalAgreement}
 * - {@link inputPassportElementPassportRegistration}
 * - {@link inputPassportElementTemporaryRegistration}
 * - {@link inputPassportElementPhoneNumber}
 * - {@link inputPassportElementEmailAddress}
 */
export type InputPassportElement =
  | inputPassportElementPersonalDetails
  | inputPassportElementPassport
  | inputPassportElementDriverLicense
  | inputPassportElementIdentityCard
  | inputPassportElementInternalPassport
  | inputPassportElementAddress
  | inputPassportElementUtilityBill
  | inputPassportElementBankStatement
  | inputPassportElementRentalAgreement
  | inputPassportElementPassportRegistration
  | inputPassportElementTemporaryRegistration
  | inputPassportElementPhoneNumber
  | inputPassportElementEmailAddress;

/**
 * Any of:
 * - {@link inputPassportElementPersonalDetails$Input}
 * - {@link inputPassportElementPassport$Input}
 * - {@link inputPassportElementDriverLicense$Input}
 * - {@link inputPassportElementIdentityCard$Input}
 * - {@link inputPassportElementInternalPassport$Input}
 * - {@link inputPassportElementAddress$Input}
 * - {@link inputPassportElementUtilityBill$Input}
 * - {@link inputPassportElementBankStatement$Input}
 * - {@link inputPassportElementRentalAgreement$Input}
 * - {@link inputPassportElementPassportRegistration$Input}
 * - {@link inputPassportElementTemporaryRegistration$Input}
 * - {@link inputPassportElementPhoneNumber$Input}
 * - {@link inputPassportElementEmailAddress$Input}
 */
export type InputPassportElement$Input =
  | inputPassportElementPersonalDetails$Input
  | inputPassportElementPassport$Input
  | inputPassportElementDriverLicense$Input
  | inputPassportElementIdentityCard$Input
  | inputPassportElementInternalPassport$Input
  | inputPassportElementAddress$Input
  | inputPassportElementUtilityBill$Input
  | inputPassportElementBankStatement$Input
  | inputPassportElementRentalAgreement$Input
  | inputPassportElementPassportRegistration$Input
  | inputPassportElementTemporaryRegistration$Input
  | inputPassportElementPhoneNumber$Input
  | inputPassportElementEmailAddress$Input;

/**
 * Any of:
 * - {@link passportElements}
 */
export type PassportElements = passportElements;

/**
 * Any of:
 * - {@link passportElements$Input}
 */
export type PassportElements$Input = passportElements$Input;

/**
 * Any of:
 * - {@link passportElementErrorSourceUnspecified}
 * - {@link passportElementErrorSourceDataField}
 * - {@link passportElementErrorSourceFrontSide}
 * - {@link passportElementErrorSourceReverseSide}
 * - {@link passportElementErrorSourceSelfie}
 * - {@link passportElementErrorSourceTranslationFile}
 * - {@link passportElementErrorSourceTranslationFiles}
 * - {@link passportElementErrorSourceFile}
 * - {@link passportElementErrorSourceFiles}
 */
export type PassportElementErrorSource =
  | passportElementErrorSourceUnspecified
  | passportElementErrorSourceDataField
  | passportElementErrorSourceFrontSide
  | passportElementErrorSourceReverseSide
  | passportElementErrorSourceSelfie
  | passportElementErrorSourceTranslationFile
  | passportElementErrorSourceTranslationFiles
  | passportElementErrorSourceFile
  | passportElementErrorSourceFiles;

/**
 * Any of:
 * - {@link passportElementErrorSourceUnspecified$Input}
 * - {@link passportElementErrorSourceDataField$Input}
 * - {@link passportElementErrorSourceFrontSide$Input}
 * - {@link passportElementErrorSourceReverseSide$Input}
 * - {@link passportElementErrorSourceSelfie$Input}
 * - {@link passportElementErrorSourceTranslationFile$Input}
 * - {@link passportElementErrorSourceTranslationFiles$Input}
 * - {@link passportElementErrorSourceFile$Input}
 * - {@link passportElementErrorSourceFiles$Input}
 */
export type PassportElementErrorSource$Input =
  | passportElementErrorSourceUnspecified$Input
  | passportElementErrorSourceDataField$Input
  | passportElementErrorSourceFrontSide$Input
  | passportElementErrorSourceReverseSide$Input
  | passportElementErrorSourceSelfie$Input
  | passportElementErrorSourceTranslationFile$Input
  | passportElementErrorSourceTranslationFiles$Input
  | passportElementErrorSourceFile$Input
  | passportElementErrorSourceFiles$Input;

/**
 * Any of:
 * - {@link passportElementError}
 */
export type PassportElementError = passportElementError;

/**
 * Any of:
 * - {@link passportElementError$Input}
 */
export type PassportElementError$Input = passportElementError$Input;

/**
 * Any of:
 * - {@link passportSuitableElement}
 */
export type PassportSuitableElement = passportSuitableElement;

/**
 * Any of:
 * - {@link passportSuitableElement$Input}
 */
export type PassportSuitableElement$Input = passportSuitableElement$Input;

/**
 * Any of:
 * - {@link passportRequiredElement}
 */
export type PassportRequiredElement = passportRequiredElement;

/**
 * Any of:
 * - {@link passportRequiredElement$Input}
 */
export type PassportRequiredElement$Input = passportRequiredElement$Input;

/**
 * Any of:
 * - {@link passportAuthorizationForm}
 */
export type PassportAuthorizationForm = passportAuthorizationForm;

/**
 * Any of:
 * - {@link passportAuthorizationForm$Input}
 */
export type PassportAuthorizationForm$Input = passportAuthorizationForm$Input;

/**
 * Any of:
 * - {@link passportElementsWithErrors}
 */
export type PassportElementsWithErrors = passportElementsWithErrors;

/**
 * Any of:
 * - {@link passportElementsWithErrors$Input}
 */
export type PassportElementsWithErrors$Input = passportElementsWithErrors$Input;

/**
 * Any of:
 * - {@link encryptedCredentials}
 */
export type EncryptedCredentials = encryptedCredentials;

/**
 * Any of:
 * - {@link encryptedCredentials$Input}
 */
export type EncryptedCredentials$Input = encryptedCredentials$Input;

/**
 * Any of:
 * - {@link encryptedPassportElement}
 */
export type EncryptedPassportElement = encryptedPassportElement;

/**
 * Any of:
 * - {@link encryptedPassportElement$Input}
 */
export type EncryptedPassportElement$Input = encryptedPassportElement$Input;

/**
 * Any of:
 * - {@link inputPassportElementErrorSourceUnspecified}
 * - {@link inputPassportElementErrorSourceDataField}
 * - {@link inputPassportElementErrorSourceFrontSide}
 * - {@link inputPassportElementErrorSourceReverseSide}
 * - {@link inputPassportElementErrorSourceSelfie}
 * - {@link inputPassportElementErrorSourceTranslationFile}
 * - {@link inputPassportElementErrorSourceTranslationFiles}
 * - {@link inputPassportElementErrorSourceFile}
 * - {@link inputPassportElementErrorSourceFiles}
 */
export type InputPassportElementErrorSource =
  | inputPassportElementErrorSourceUnspecified
  | inputPassportElementErrorSourceDataField
  | inputPassportElementErrorSourceFrontSide
  | inputPassportElementErrorSourceReverseSide
  | inputPassportElementErrorSourceSelfie
  | inputPassportElementErrorSourceTranslationFile
  | inputPassportElementErrorSourceTranslationFiles
  | inputPassportElementErrorSourceFile
  | inputPassportElementErrorSourceFiles;

/**
 * Any of:
 * - {@link inputPassportElementErrorSourceUnspecified$Input}
 * - {@link inputPassportElementErrorSourceDataField$Input}
 * - {@link inputPassportElementErrorSourceFrontSide$Input}
 * - {@link inputPassportElementErrorSourceReverseSide$Input}
 * - {@link inputPassportElementErrorSourceSelfie$Input}
 * - {@link inputPassportElementErrorSourceTranslationFile$Input}
 * - {@link inputPassportElementErrorSourceTranslationFiles$Input}
 * - {@link inputPassportElementErrorSourceFile$Input}
 * - {@link inputPassportElementErrorSourceFiles$Input}
 */
export type InputPassportElementErrorSource$Input =
  | inputPassportElementErrorSourceUnspecified$Input
  | inputPassportElementErrorSourceDataField$Input
  | inputPassportElementErrorSourceFrontSide$Input
  | inputPassportElementErrorSourceReverseSide$Input
  | inputPassportElementErrorSourceSelfie$Input
  | inputPassportElementErrorSourceTranslationFile$Input
  | inputPassportElementErrorSourceTranslationFiles$Input
  | inputPassportElementErrorSourceFile$Input
  | inputPassportElementErrorSourceFiles$Input;

/**
 * Any of:
 * - {@link inputPassportElementError}
 */
export type InputPassportElementError = inputPassportElementError;

/**
 * Any of:
 * - {@link inputPassportElementError$Input}
 */
export type InputPassportElementError$Input = inputPassportElementError$Input;

/**
 * Any of:
 * - {@link messageText}
 * - {@link messageAnimation}
 * - {@link messageAudio}
 * - {@link messageDocument}
 * - {@link messagePhoto}
 * - {@link messageExpiredPhoto}
 * - {@link messageSticker}
 * - {@link messageVideo}
 * - {@link messageExpiredVideo}
 * - {@link messageVideoNote}
 * - {@link messageVoiceNote}
 * - {@link messageLocation}
 * - {@link messageVenue}
 * - {@link messageContact}
 * - {@link messageAnimatedEmoji}
 * - {@link messageDice}
 * - {@link messageGame}
 * - {@link messagePoll}
 * - {@link messageInvoice}
 * - {@link messageCall}
 * - {@link messageVideoChatScheduled}
 * - {@link messageVideoChatStarted}
 * - {@link messageVideoChatEnded}
 * - {@link messageInviteVideoChatParticipants}
 * - {@link messageBasicGroupChatCreate}
 * - {@link messageSupergroupChatCreate}
 * - {@link messageChatChangeTitle}
 * - {@link messageChatChangePhoto}
 * - {@link messageChatDeletePhoto}
 * - {@link messageChatAddMembers}
 * - {@link messageChatJoinByLink}
 * - {@link messageChatJoinByRequest}
 * - {@link messageChatDeleteMember}
 * - {@link messageChatUpgradeTo}
 * - {@link messageChatUpgradeFrom}
 * - {@link messagePinMessage}
 * - {@link messageScreenshotTaken}
 * - {@link messageChatSetTheme}
 * - {@link messageChatSetTtl}
 * - {@link messageForumTopicCreated}
 * - {@link messageForumTopicEdited}
 * - {@link messageForumTopicIsClosedToggled}
 * - {@link messageCustomServiceAction}
 * - {@link messageGameScore}
 * - {@link messagePaymentSuccessful}
 * - {@link messagePaymentSuccessfulBot}
 * - {@link messageGiftedPremium}
 * - {@link messageContactRegistered}
 * - {@link messageWebsiteConnected}
 * - {@link messageWebAppDataSent}
 * - {@link messageWebAppDataReceived}
 * - {@link messagePassportDataSent}
 * - {@link messagePassportDataReceived}
 * - {@link messageProximityAlertTriggered}
 * - {@link messageUnsupported}
 */
export type MessageContent =
  | messageText
  | messageAnimation
  | messageAudio
  | messageDocument
  | messagePhoto
  | messageExpiredPhoto
  | messageSticker
  | messageVideo
  | messageExpiredVideo
  | messageVideoNote
  | messageVoiceNote
  | messageLocation
  | messageVenue
  | messageContact
  | messageAnimatedEmoji
  | messageDice
  | messageGame
  | messagePoll
  | messageInvoice
  | messageCall
  | messageVideoChatScheduled
  | messageVideoChatStarted
  | messageVideoChatEnded
  | messageInviteVideoChatParticipants
  | messageBasicGroupChatCreate
  | messageSupergroupChatCreate
  | messageChatChangeTitle
  | messageChatChangePhoto
  | messageChatDeletePhoto
  | messageChatAddMembers
  | messageChatJoinByLink
  | messageChatJoinByRequest
  | messageChatDeleteMember
  | messageChatUpgradeTo
  | messageChatUpgradeFrom
  | messagePinMessage
  | messageScreenshotTaken
  | messageChatSetTheme
  | messageChatSetTtl
  | messageForumTopicCreated
  | messageForumTopicEdited
  | messageForumTopicIsClosedToggled
  | messageCustomServiceAction
  | messageGameScore
  | messagePaymentSuccessful
  | messagePaymentSuccessfulBot
  | messageGiftedPremium
  | messageContactRegistered
  | messageWebsiteConnected
  | messageWebAppDataSent
  | messageWebAppDataReceived
  | messagePassportDataSent
  | messagePassportDataReceived
  | messageProximityAlertTriggered
  | messageUnsupported;

/**
 * Any of:
 * - {@link messageText$Input}
 * - {@link messageAnimation$Input}
 * - {@link messageAudio$Input}
 * - {@link messageDocument$Input}
 * - {@link messagePhoto$Input}
 * - {@link messageExpiredPhoto$Input}
 * - {@link messageSticker$Input}
 * - {@link messageVideo$Input}
 * - {@link messageExpiredVideo$Input}
 * - {@link messageVideoNote$Input}
 * - {@link messageVoiceNote$Input}
 * - {@link messageLocation$Input}
 * - {@link messageVenue$Input}
 * - {@link messageContact$Input}
 * - {@link messageAnimatedEmoji$Input}
 * - {@link messageDice$Input}
 * - {@link messageGame$Input}
 * - {@link messagePoll$Input}
 * - {@link messageInvoice$Input}
 * - {@link messageCall$Input}
 * - {@link messageVideoChatScheduled$Input}
 * - {@link messageVideoChatStarted$Input}
 * - {@link messageVideoChatEnded$Input}
 * - {@link messageInviteVideoChatParticipants$Input}
 * - {@link messageBasicGroupChatCreate$Input}
 * - {@link messageSupergroupChatCreate$Input}
 * - {@link messageChatChangeTitle$Input}
 * - {@link messageChatChangePhoto$Input}
 * - {@link messageChatDeletePhoto$Input}
 * - {@link messageChatAddMembers$Input}
 * - {@link messageChatJoinByLink$Input}
 * - {@link messageChatJoinByRequest$Input}
 * - {@link messageChatDeleteMember$Input}
 * - {@link messageChatUpgradeTo$Input}
 * - {@link messageChatUpgradeFrom$Input}
 * - {@link messagePinMessage$Input}
 * - {@link messageScreenshotTaken$Input}
 * - {@link messageChatSetTheme$Input}
 * - {@link messageChatSetTtl$Input}
 * - {@link messageForumTopicCreated$Input}
 * - {@link messageForumTopicEdited$Input}
 * - {@link messageForumTopicIsClosedToggled$Input}
 * - {@link messageCustomServiceAction$Input}
 * - {@link messageGameScore$Input}
 * - {@link messagePaymentSuccessful$Input}
 * - {@link messagePaymentSuccessfulBot$Input}
 * - {@link messageGiftedPremium$Input}
 * - {@link messageContactRegistered$Input}
 * - {@link messageWebsiteConnected$Input}
 * - {@link messageWebAppDataSent$Input}
 * - {@link messageWebAppDataReceived$Input}
 * - {@link messagePassportDataSent$Input}
 * - {@link messagePassportDataReceived$Input}
 * - {@link messageProximityAlertTriggered$Input}
 * - {@link messageUnsupported$Input}
 */
export type MessageContent$Input =
  | messageText$Input
  | messageAnimation$Input
  | messageAudio$Input
  | messageDocument$Input
  | messagePhoto$Input
  | messageExpiredPhoto$Input
  | messageSticker$Input
  | messageVideo$Input
  | messageExpiredVideo$Input
  | messageVideoNote$Input
  | messageVoiceNote$Input
  | messageLocation$Input
  | messageVenue$Input
  | messageContact$Input
  | messageAnimatedEmoji$Input
  | messageDice$Input
  | messageGame$Input
  | messagePoll$Input
  | messageInvoice$Input
  | messageCall$Input
  | messageVideoChatScheduled$Input
  | messageVideoChatStarted$Input
  | messageVideoChatEnded$Input
  | messageInviteVideoChatParticipants$Input
  | messageBasicGroupChatCreate$Input
  | messageSupergroupChatCreate$Input
  | messageChatChangeTitle$Input
  | messageChatChangePhoto$Input
  | messageChatDeletePhoto$Input
  | messageChatAddMembers$Input
  | messageChatJoinByLink$Input
  | messageChatJoinByRequest$Input
  | messageChatDeleteMember$Input
  | messageChatUpgradeTo$Input
  | messageChatUpgradeFrom$Input
  | messagePinMessage$Input
  | messageScreenshotTaken$Input
  | messageChatSetTheme$Input
  | messageChatSetTtl$Input
  | messageForumTopicCreated$Input
  | messageForumTopicEdited$Input
  | messageForumTopicIsClosedToggled$Input
  | messageCustomServiceAction$Input
  | messageGameScore$Input
  | messagePaymentSuccessful$Input
  | messagePaymentSuccessfulBot$Input
  | messageGiftedPremium$Input
  | messageContactRegistered$Input
  | messageWebsiteConnected$Input
  | messageWebAppDataSent$Input
  | messageWebAppDataReceived$Input
  | messagePassportDataSent$Input
  | messagePassportDataReceived$Input
  | messageProximityAlertTriggered$Input
  | messageUnsupported$Input;

/**
 * Any of:
 * - {@link textEntityTypeMention}
 * - {@link textEntityTypeHashtag}
 * - {@link textEntityTypeCashtag}
 * - {@link textEntityTypeBotCommand}
 * - {@link textEntityTypeUrl}
 * - {@link textEntityTypeEmailAddress}
 * - {@link textEntityTypePhoneNumber}
 * - {@link textEntityTypeBankCardNumber}
 * - {@link textEntityTypeBold}
 * - {@link textEntityTypeItalic}
 * - {@link textEntityTypeUnderline}
 * - {@link textEntityTypeStrikethrough}
 * - {@link textEntityTypeSpoiler}
 * - {@link textEntityTypeCode}
 * - {@link textEntityTypePre}
 * - {@link textEntityTypePreCode}
 * - {@link textEntityTypeTextUrl}
 * - {@link textEntityTypeMentionName}
 * - {@link textEntityTypeCustomEmoji}
 * - {@link textEntityTypeMediaTimestamp}
 */
export type TextEntityType =
  | textEntityTypeMention
  | textEntityTypeHashtag
  | textEntityTypeCashtag
  | textEntityTypeBotCommand
  | textEntityTypeUrl
  | textEntityTypeEmailAddress
  | textEntityTypePhoneNumber
  | textEntityTypeBankCardNumber
  | textEntityTypeBold
  | textEntityTypeItalic
  | textEntityTypeUnderline
  | textEntityTypeStrikethrough
  | textEntityTypeSpoiler
  | textEntityTypeCode
  | textEntityTypePre
  | textEntityTypePreCode
  | textEntityTypeTextUrl
  | textEntityTypeMentionName
  | textEntityTypeCustomEmoji
  | textEntityTypeMediaTimestamp;

/**
 * Any of:
 * - {@link textEntityTypeMention$Input}
 * - {@link textEntityTypeHashtag$Input}
 * - {@link textEntityTypeCashtag$Input}
 * - {@link textEntityTypeBotCommand$Input}
 * - {@link textEntityTypeUrl$Input}
 * - {@link textEntityTypeEmailAddress$Input}
 * - {@link textEntityTypePhoneNumber$Input}
 * - {@link textEntityTypeBankCardNumber$Input}
 * - {@link textEntityTypeBold$Input}
 * - {@link textEntityTypeItalic$Input}
 * - {@link textEntityTypeUnderline$Input}
 * - {@link textEntityTypeStrikethrough$Input}
 * - {@link textEntityTypeSpoiler$Input}
 * - {@link textEntityTypeCode$Input}
 * - {@link textEntityTypePre$Input}
 * - {@link textEntityTypePreCode$Input}
 * - {@link textEntityTypeTextUrl$Input}
 * - {@link textEntityTypeMentionName$Input}
 * - {@link textEntityTypeCustomEmoji$Input}
 * - {@link textEntityTypeMediaTimestamp$Input}
 */
export type TextEntityType$Input =
  | textEntityTypeMention$Input
  | textEntityTypeHashtag$Input
  | textEntityTypeCashtag$Input
  | textEntityTypeBotCommand$Input
  | textEntityTypeUrl$Input
  | textEntityTypeEmailAddress$Input
  | textEntityTypePhoneNumber$Input
  | textEntityTypeBankCardNumber$Input
  | textEntityTypeBold$Input
  | textEntityTypeItalic$Input
  | textEntityTypeUnderline$Input
  | textEntityTypeStrikethrough$Input
  | textEntityTypeSpoiler$Input
  | textEntityTypeCode$Input
  | textEntityTypePre$Input
  | textEntityTypePreCode$Input
  | textEntityTypeTextUrl$Input
  | textEntityTypeMentionName$Input
  | textEntityTypeCustomEmoji$Input
  | textEntityTypeMediaTimestamp$Input;

/**
 * Any of:
 * - {@link inputThumbnail}
 */
export type InputThumbnail = inputThumbnail;

/**
 * Any of:
 * - {@link inputThumbnail$Input}
 */
export type InputThumbnail$Input = inputThumbnail$Input;

/**
 * Any of:
 * - {@link messageSchedulingStateSendAtDate}
 * - {@link messageSchedulingStateSendWhenOnline}
 */
export type MessageSchedulingState =
  | messageSchedulingStateSendAtDate
  | messageSchedulingStateSendWhenOnline;

/**
 * Any of:
 * - {@link messageSchedulingStateSendAtDate$Input}
 * - {@link messageSchedulingStateSendWhenOnline$Input}
 */
export type MessageSchedulingState$Input =
  | messageSchedulingStateSendAtDate$Input
  | messageSchedulingStateSendWhenOnline$Input;

/**
 * Any of:
 * - {@link messageSendOptions}
 */
export type MessageSendOptions = messageSendOptions;

/**
 * Any of:
 * - {@link messageSendOptions$Input}
 */
export type MessageSendOptions$Input = messageSendOptions$Input;

/**
 * Any of:
 * - {@link messageCopyOptions}
 */
export type MessageCopyOptions = messageCopyOptions;

/**
 * Any of:
 * - {@link messageCopyOptions$Input}
 */
export type MessageCopyOptions$Input = messageCopyOptions$Input;

/**
 * Any of:
 * - {@link inputMessageText}
 * - {@link inputMessageAnimation}
 * - {@link inputMessageAudio}
 * - {@link inputMessageDocument}
 * - {@link inputMessagePhoto}
 * - {@link inputMessageSticker}
 * - {@link inputMessageVideo}
 * - {@link inputMessageVideoNote}
 * - {@link inputMessageVoiceNote}
 * - {@link inputMessageLocation}
 * - {@link inputMessageVenue}
 * - {@link inputMessageContact}
 * - {@link inputMessageDice}
 * - {@link inputMessageGame}
 * - {@link inputMessageInvoice}
 * - {@link inputMessagePoll}
 * - {@link inputMessageForwarded}
 */
export type InputMessageContent =
  | inputMessageText
  | inputMessageAnimation
  | inputMessageAudio
  | inputMessageDocument
  | inputMessagePhoto
  | inputMessageSticker
  | inputMessageVideo
  | inputMessageVideoNote
  | inputMessageVoiceNote
  | inputMessageLocation
  | inputMessageVenue
  | inputMessageContact
  | inputMessageDice
  | inputMessageGame
  | inputMessageInvoice
  | inputMessagePoll
  | inputMessageForwarded;

/**
 * Any of:
 * - {@link inputMessageText$Input}
 * - {@link inputMessageAnimation$Input}
 * - {@link inputMessageAudio$Input}
 * - {@link inputMessageDocument$Input}
 * - {@link inputMessagePhoto$Input}
 * - {@link inputMessageSticker$Input}
 * - {@link inputMessageVideo$Input}
 * - {@link inputMessageVideoNote$Input}
 * - {@link inputMessageVoiceNote$Input}
 * - {@link inputMessageLocation$Input}
 * - {@link inputMessageVenue$Input}
 * - {@link inputMessageContact$Input}
 * - {@link inputMessageDice$Input}
 * - {@link inputMessageGame$Input}
 * - {@link inputMessageInvoice$Input}
 * - {@link inputMessagePoll$Input}
 * - {@link inputMessageForwarded$Input}
 */
export type InputMessageContent$Input =
  | inputMessageText$Input
  | inputMessageAnimation$Input
  | inputMessageAudio$Input
  | inputMessageDocument$Input
  | inputMessagePhoto$Input
  | inputMessageSticker$Input
  | inputMessageVideo$Input
  | inputMessageVideoNote$Input
  | inputMessageVoiceNote$Input
  | inputMessageLocation$Input
  | inputMessageVenue$Input
  | inputMessageContact$Input
  | inputMessageDice$Input
  | inputMessageGame$Input
  | inputMessageInvoice$Input
  | inputMessagePoll$Input
  | inputMessageForwarded$Input;

/**
 * Any of:
 * - {@link searchMessagesFilterEmpty}
 * - {@link searchMessagesFilterAnimation}
 * - {@link searchMessagesFilterAudio}
 * - {@link searchMessagesFilterDocument}
 * - {@link searchMessagesFilterPhoto}
 * - {@link searchMessagesFilterVideo}
 * - {@link searchMessagesFilterVoiceNote}
 * - {@link searchMessagesFilterPhotoAndVideo}
 * - {@link searchMessagesFilterUrl}
 * - {@link searchMessagesFilterChatPhoto}
 * - {@link searchMessagesFilterVideoNote}
 * - {@link searchMessagesFilterVoiceAndVideoNote}
 * - {@link searchMessagesFilterMention}
 * - {@link searchMessagesFilterUnreadMention}
 * - {@link searchMessagesFilterUnreadReaction}
 * - {@link searchMessagesFilterFailedToSend}
 * - {@link searchMessagesFilterPinned}
 */
export type SearchMessagesFilter =
  | searchMessagesFilterEmpty
  | searchMessagesFilterAnimation
  | searchMessagesFilterAudio
  | searchMessagesFilterDocument
  | searchMessagesFilterPhoto
  | searchMessagesFilterVideo
  | searchMessagesFilterVoiceNote
  | searchMessagesFilterPhotoAndVideo
  | searchMessagesFilterUrl
  | searchMessagesFilterChatPhoto
  | searchMessagesFilterVideoNote
  | searchMessagesFilterVoiceAndVideoNote
  | searchMessagesFilterMention
  | searchMessagesFilterUnreadMention
  | searchMessagesFilterUnreadReaction
  | searchMessagesFilterFailedToSend
  | searchMessagesFilterPinned;

/**
 * Any of:
 * - {@link searchMessagesFilterEmpty$Input}
 * - {@link searchMessagesFilterAnimation$Input}
 * - {@link searchMessagesFilterAudio$Input}
 * - {@link searchMessagesFilterDocument$Input}
 * - {@link searchMessagesFilterPhoto$Input}
 * - {@link searchMessagesFilterVideo$Input}
 * - {@link searchMessagesFilterVoiceNote$Input}
 * - {@link searchMessagesFilterPhotoAndVideo$Input}
 * - {@link searchMessagesFilterUrl$Input}
 * - {@link searchMessagesFilterChatPhoto$Input}
 * - {@link searchMessagesFilterVideoNote$Input}
 * - {@link searchMessagesFilterVoiceAndVideoNote$Input}
 * - {@link searchMessagesFilterMention$Input}
 * - {@link searchMessagesFilterUnreadMention$Input}
 * - {@link searchMessagesFilterUnreadReaction$Input}
 * - {@link searchMessagesFilterFailedToSend$Input}
 * - {@link searchMessagesFilterPinned$Input}
 */
export type SearchMessagesFilter$Input =
  | searchMessagesFilterEmpty$Input
  | searchMessagesFilterAnimation$Input
  | searchMessagesFilterAudio$Input
  | searchMessagesFilterDocument$Input
  | searchMessagesFilterPhoto$Input
  | searchMessagesFilterVideo$Input
  | searchMessagesFilterVoiceNote$Input
  | searchMessagesFilterPhotoAndVideo$Input
  | searchMessagesFilterUrl$Input
  | searchMessagesFilterChatPhoto$Input
  | searchMessagesFilterVideoNote$Input
  | searchMessagesFilterVoiceAndVideoNote$Input
  | searchMessagesFilterMention$Input
  | searchMessagesFilterUnreadMention$Input
  | searchMessagesFilterUnreadReaction$Input
  | searchMessagesFilterFailedToSend$Input
  | searchMessagesFilterPinned$Input;

/**
 * Any of:
 * - {@link chatActionTyping}
 * - {@link chatActionRecordingVideo}
 * - {@link chatActionUploadingVideo}
 * - {@link chatActionRecordingVoiceNote}
 * - {@link chatActionUploadingVoiceNote}
 * - {@link chatActionUploadingPhoto}
 * - {@link chatActionUploadingDocument}
 * - {@link chatActionChoosingSticker}
 * - {@link chatActionChoosingLocation}
 * - {@link chatActionChoosingContact}
 * - {@link chatActionStartPlayingGame}
 * - {@link chatActionRecordingVideoNote}
 * - {@link chatActionUploadingVideoNote}
 * - {@link chatActionWatchingAnimations}
 * - {@link chatActionCancel}
 */
export type ChatAction =
  | chatActionTyping
  | chatActionRecordingVideo
  | chatActionUploadingVideo
  | chatActionRecordingVoiceNote
  | chatActionUploadingVoiceNote
  | chatActionUploadingPhoto
  | chatActionUploadingDocument
  | chatActionChoosingSticker
  | chatActionChoosingLocation
  | chatActionChoosingContact
  | chatActionStartPlayingGame
  | chatActionRecordingVideoNote
  | chatActionUploadingVideoNote
  | chatActionWatchingAnimations
  | chatActionCancel;

/**
 * Any of:
 * - {@link chatActionTyping$Input}
 * - {@link chatActionRecordingVideo$Input}
 * - {@link chatActionUploadingVideo$Input}
 * - {@link chatActionRecordingVoiceNote$Input}
 * - {@link chatActionUploadingVoiceNote$Input}
 * - {@link chatActionUploadingPhoto$Input}
 * - {@link chatActionUploadingDocument$Input}
 * - {@link chatActionChoosingSticker$Input}
 * - {@link chatActionChoosingLocation$Input}
 * - {@link chatActionChoosingContact$Input}
 * - {@link chatActionStartPlayingGame$Input}
 * - {@link chatActionRecordingVideoNote$Input}
 * - {@link chatActionUploadingVideoNote$Input}
 * - {@link chatActionWatchingAnimations$Input}
 * - {@link chatActionCancel$Input}
 */
export type ChatAction$Input =
  | chatActionTyping$Input
  | chatActionRecordingVideo$Input
  | chatActionUploadingVideo$Input
  | chatActionRecordingVoiceNote$Input
  | chatActionUploadingVoiceNote$Input
  | chatActionUploadingPhoto$Input
  | chatActionUploadingDocument$Input
  | chatActionChoosingSticker$Input
  | chatActionChoosingLocation$Input
  | chatActionChoosingContact$Input
  | chatActionStartPlayingGame$Input
  | chatActionRecordingVideoNote$Input
  | chatActionUploadingVideoNote$Input
  | chatActionWatchingAnimations$Input
  | chatActionCancel$Input;

/**
 * Any of:
 * - {@link userStatusEmpty}
 * - {@link userStatusOnline}
 * - {@link userStatusOffline}
 * - {@link userStatusRecently}
 * - {@link userStatusLastWeek}
 * - {@link userStatusLastMonth}
 */
export type UserStatus =
  | userStatusEmpty
  | userStatusOnline
  | userStatusOffline
  | userStatusRecently
  | userStatusLastWeek
  | userStatusLastMonth;

/**
 * Any of:
 * - {@link userStatusEmpty$Input}
 * - {@link userStatusOnline$Input}
 * - {@link userStatusOffline$Input}
 * - {@link userStatusRecently$Input}
 * - {@link userStatusLastWeek$Input}
 * - {@link userStatusLastMonth$Input}
 */
export type UserStatus$Input =
  | userStatusEmpty$Input
  | userStatusOnline$Input
  | userStatusOffline$Input
  | userStatusRecently$Input
  | userStatusLastWeek$Input
  | userStatusLastMonth$Input;

/**
 * Any of:
 * - {@link stickers}
 */
export type Stickers = stickers;

/**
 * Any of:
 * - {@link stickers$Input}
 */
export type Stickers$Input = stickers$Input;

/**
 * Any of:
 * - {@link emojis}
 */
export type Emojis = emojis;

/**
 * Any of:
 * - {@link emojis$Input}
 */
export type Emojis$Input = emojis$Input;

/**
 * Any of:
 * - {@link stickerSet}
 */
export type StickerSet = stickerSet;

/**
 * Any of:
 * - {@link stickerSet$Input}
 */
export type StickerSet$Input = stickerSet$Input;

/**
 * Any of:
 * - {@link stickerSetInfo}
 */
export type StickerSetInfo = stickerSetInfo;

/**
 * Any of:
 * - {@link stickerSetInfo$Input}
 */
export type StickerSetInfo$Input = stickerSetInfo$Input;

/**
 * Any of:
 * - {@link stickerSets}
 */
export type StickerSets = stickerSets;

/**
 * Any of:
 * - {@link stickerSets$Input}
 */
export type StickerSets$Input = stickerSets$Input;

/**
 * Any of:
 * - {@link trendingStickerSets}
 */
export type TrendingStickerSets = trendingStickerSets;

/**
 * Any of:
 * - {@link trendingStickerSets$Input}
 */
export type TrendingStickerSets$Input = trendingStickerSets$Input;

/**
 * Any of:
 * - {@link callDiscardReasonEmpty}
 * - {@link callDiscardReasonMissed}
 * - {@link callDiscardReasonDeclined}
 * - {@link callDiscardReasonDisconnected}
 * - {@link callDiscardReasonHungUp}
 */
export type CallDiscardReason =
  | callDiscardReasonEmpty
  | callDiscardReasonMissed
  | callDiscardReasonDeclined
  | callDiscardReasonDisconnected
  | callDiscardReasonHungUp;

/**
 * Any of:
 * - {@link callDiscardReasonEmpty$Input}
 * - {@link callDiscardReasonMissed$Input}
 * - {@link callDiscardReasonDeclined$Input}
 * - {@link callDiscardReasonDisconnected$Input}
 * - {@link callDiscardReasonHungUp$Input}
 */
export type CallDiscardReason$Input =
  | callDiscardReasonEmpty$Input
  | callDiscardReasonMissed$Input
  | callDiscardReasonDeclined$Input
  | callDiscardReasonDisconnected$Input
  | callDiscardReasonHungUp$Input;

/**
 * Any of:
 * - {@link callProtocol}
 */
export type CallProtocol = callProtocol;

/**
 * Any of:
 * - {@link callProtocol$Input}
 */
export type CallProtocol$Input = callProtocol$Input;

/**
 * Any of:
 * - {@link callServerTypeTelegramReflector}
 * - {@link callServerTypeWebrtc}
 */
export type CallServerType = callServerTypeTelegramReflector | callServerTypeWebrtc;

/**
 * Any of:
 * - {@link callServerTypeTelegramReflector$Input}
 * - {@link callServerTypeWebrtc$Input}
 */
export type CallServerType$Input =
  | callServerTypeTelegramReflector$Input
  | callServerTypeWebrtc$Input;

/**
 * Any of:
 * - {@link callServer}
 */
export type CallServer = callServer;

/**
 * Any of:
 * - {@link callServer$Input}
 */
export type CallServer$Input = callServer$Input;

/**
 * Any of:
 * - {@link callId}
 */
export type CallId = callId;

/**
 * Any of:
 * - {@link callId$Input}
 */
export type CallId$Input = callId$Input;

/**
 * Any of:
 * - {@link groupCallId}
 */
export type GroupCallId = groupCallId;

/**
 * Any of:
 * - {@link groupCallId$Input}
 */
export type GroupCallId$Input = groupCallId$Input;

/**
 * Any of:
 * - {@link callStatePending}
 * - {@link callStateExchangingKeys}
 * - {@link callStateReady}
 * - {@link callStateHangingUp}
 * - {@link callStateDiscarded}
 * - {@link callStateError}
 */
export type CallState =
  | callStatePending
  | callStateExchangingKeys
  | callStateReady
  | callStateHangingUp
  | callStateDiscarded
  | callStateError;

/**
 * Any of:
 * - {@link callStatePending$Input}
 * - {@link callStateExchangingKeys$Input}
 * - {@link callStateReady$Input}
 * - {@link callStateHangingUp$Input}
 * - {@link callStateDiscarded$Input}
 * - {@link callStateError$Input}
 */
export type CallState$Input =
  | callStatePending$Input
  | callStateExchangingKeys$Input
  | callStateReady$Input
  | callStateHangingUp$Input
  | callStateDiscarded$Input
  | callStateError$Input;

/**
 * Any of:
 * - {@link groupCallVideoQualityThumbnail}
 * - {@link groupCallVideoQualityMedium}
 * - {@link groupCallVideoQualityFull}
 */
export type GroupCallVideoQuality =
  | groupCallVideoQualityThumbnail
  | groupCallVideoQualityMedium
  | groupCallVideoQualityFull;

/**
 * Any of:
 * - {@link groupCallVideoQualityThumbnail$Input}
 * - {@link groupCallVideoQualityMedium$Input}
 * - {@link groupCallVideoQualityFull$Input}
 */
export type GroupCallVideoQuality$Input =
  | groupCallVideoQualityThumbnail$Input
  | groupCallVideoQualityMedium$Input
  | groupCallVideoQualityFull$Input;

/**
 * Any of:
 * - {@link groupCallStream}
 */
export type GroupCallStream = groupCallStream;

/**
 * Any of:
 * - {@link groupCallStream$Input}
 */
export type GroupCallStream$Input = groupCallStream$Input;

/**
 * Any of:
 * - {@link groupCallStreams}
 */
export type GroupCallStreams = groupCallStreams;

/**
 * Any of:
 * - {@link groupCallStreams$Input}
 */
export type GroupCallStreams$Input = groupCallStreams$Input;

/**
 * Any of:
 * - {@link rtmpUrl}
 */
export type RtmpUrl = rtmpUrl;

/**
 * Any of:
 * - {@link rtmpUrl$Input}
 */
export type RtmpUrl$Input = rtmpUrl$Input;

/**
 * Any of:
 * - {@link groupCallRecentSpeaker}
 */
export type GroupCallRecentSpeaker = groupCallRecentSpeaker;

/**
 * Any of:
 * - {@link groupCallRecentSpeaker$Input}
 */
export type GroupCallRecentSpeaker$Input = groupCallRecentSpeaker$Input;

/**
 * Any of:
 * - {@link groupCall}
 */
export type GroupCall = groupCall;

/**
 * Any of:
 * - {@link groupCall$Input}
 */
export type GroupCall$Input = groupCall$Input;

/**
 * Any of:
 * - {@link groupCallVideoSourceGroup}
 */
export type GroupCallVideoSourceGroup = groupCallVideoSourceGroup;

/**
 * Any of:
 * - {@link groupCallVideoSourceGroup$Input}
 */
export type GroupCallVideoSourceGroup$Input = groupCallVideoSourceGroup$Input;

/**
 * Any of:
 * - {@link groupCallParticipantVideoInfo}
 */
export type GroupCallParticipantVideoInfo = groupCallParticipantVideoInfo;

/**
 * Any of:
 * - {@link groupCallParticipantVideoInfo$Input}
 */
export type GroupCallParticipantVideoInfo$Input =
  groupCallParticipantVideoInfo$Input;

/**
 * Any of:
 * - {@link groupCallParticipant}
 */
export type GroupCallParticipant = groupCallParticipant;

/**
 * Any of:
 * - {@link groupCallParticipant$Input}
 */
export type GroupCallParticipant$Input = groupCallParticipant$Input;

/**
 * Any of:
 * - {@link callProblemEcho}
 * - {@link callProblemNoise}
 * - {@link callProblemInterruptions}
 * - {@link callProblemDistortedSpeech}
 * - {@link callProblemSilentLocal}
 * - {@link callProblemSilentRemote}
 * - {@link callProblemDropped}
 * - {@link callProblemDistortedVideo}
 * - {@link callProblemPixelatedVideo}
 */
export type CallProblem =
  | callProblemEcho
  | callProblemNoise
  | callProblemInterruptions
  | callProblemDistortedSpeech
  | callProblemSilentLocal
  | callProblemSilentRemote
  | callProblemDropped
  | callProblemDistortedVideo
  | callProblemPixelatedVideo;

/**
 * Any of:
 * - {@link callProblemEcho$Input}
 * - {@link callProblemNoise$Input}
 * - {@link callProblemInterruptions$Input}
 * - {@link callProblemDistortedSpeech$Input}
 * - {@link callProblemSilentLocal$Input}
 * - {@link callProblemSilentRemote$Input}
 * - {@link callProblemDropped$Input}
 * - {@link callProblemDistortedVideo$Input}
 * - {@link callProblemPixelatedVideo$Input}
 */
export type CallProblem$Input =
  | callProblemEcho$Input
  | callProblemNoise$Input
  | callProblemInterruptions$Input
  | callProblemDistortedSpeech$Input
  | callProblemSilentLocal$Input
  | callProblemSilentRemote$Input
  | callProblemDropped$Input
  | callProblemDistortedVideo$Input
  | callProblemPixelatedVideo$Input;

/**
 * Any of:
 * - {@link call}
 */
export type Call = call;

/**
 * Any of:
 * - {@link call$Input}
 */
export type Call$Input = call$Input;

/**
 * Any of:
 * - {@link phoneNumberAuthenticationSettings}
 */
export type PhoneNumberAuthenticationSettings = phoneNumberAuthenticationSettings;

/**
 * Any of:
 * - {@link phoneNumberAuthenticationSettings$Input}
 */
export type PhoneNumberAuthenticationSettings$Input =
  phoneNumberAuthenticationSettings$Input;

/**
 * Any of:
 * - {@link addedReaction}
 */
export type AddedReaction = addedReaction;

/**
 * Any of:
 * - {@link addedReaction$Input}
 */
export type AddedReaction$Input = addedReaction$Input;

/**
 * Any of:
 * - {@link addedReactions}
 */
export type AddedReactions = addedReactions;

/**
 * Any of:
 * - {@link addedReactions$Input}
 */
export type AddedReactions$Input = addedReactions$Input;

/**
 * Any of:
 * - {@link availableReaction}
 */
export type AvailableReaction = availableReaction;

/**
 * Any of:
 * - {@link availableReaction$Input}
 */
export type AvailableReaction$Input = availableReaction$Input;

/**
 * Any of:
 * - {@link availableReactions}
 */
export type AvailableReactions = availableReactions;

/**
 * Any of:
 * - {@link availableReactions$Input}
 */
export type AvailableReactions$Input = availableReactions$Input;

/**
 * Any of:
 * - {@link emojiReaction}
 */
export type EmojiReaction = emojiReaction;

/**
 * Any of:
 * - {@link emojiReaction$Input}
 */
export type EmojiReaction$Input = emojiReaction$Input;

/**
 * Any of:
 * - {@link animations}
 */
export type Animations = animations;

/**
 * Any of:
 * - {@link animations$Input}
 */
export type Animations$Input = animations$Input;

/**
 * Any of:
 * - {@link diceStickersRegular}
 * - {@link diceStickersSlotMachine}
 */
export type DiceStickers = diceStickersRegular | diceStickersSlotMachine;

/**
 * Any of:
 * - {@link diceStickersRegular$Input}
 * - {@link diceStickersSlotMachine$Input}
 */
export type DiceStickers$Input =
  | diceStickersRegular$Input
  | diceStickersSlotMachine$Input;

/**
 * Any of:
 * - {@link importedContacts}
 */
export type ImportedContacts = importedContacts;

/**
 * Any of:
 * - {@link importedContacts$Input}
 */
export type ImportedContacts$Input = importedContacts$Input;

/**
 * Any of:
 * - {@link speechRecognitionResultPending}
 * - {@link speechRecognitionResultText}
 * - {@link speechRecognitionResultError}
 */
export type SpeechRecognitionResult =
  | speechRecognitionResultPending
  | speechRecognitionResultText
  | speechRecognitionResultError;

/**
 * Any of:
 * - {@link speechRecognitionResultPending$Input}
 * - {@link speechRecognitionResultText$Input}
 * - {@link speechRecognitionResultError$Input}
 */
export type SpeechRecognitionResult$Input =
  | speechRecognitionResultPending$Input
  | speechRecognitionResultText$Input
  | speechRecognitionResultError$Input;

/**
 * Any of:
 * - {@link attachmentMenuBotColor}
 */
export type AttachmentMenuBotColor = attachmentMenuBotColor;

/**
 * Any of:
 * - {@link attachmentMenuBotColor$Input}
 */
export type AttachmentMenuBotColor$Input = attachmentMenuBotColor$Input;

/**
 * Any of:
 * - {@link attachmentMenuBot}
 */
export type AttachmentMenuBot = attachmentMenuBot;

/**
 * Any of:
 * - {@link attachmentMenuBot$Input}
 */
export type AttachmentMenuBot$Input = attachmentMenuBot$Input;

/**
 * Any of:
 * - {@link sentWebAppMessage}
 */
export type SentWebAppMessage = sentWebAppMessage;

/**
 * Any of:
 * - {@link sentWebAppMessage$Input}
 */
export type SentWebAppMessage$Input = sentWebAppMessage$Input;

/**
 * Any of:
 * - {@link httpUrl}
 */
export type HttpUrl = httpUrl;

/**
 * Any of:
 * - {@link httpUrl$Input}
 */
export type HttpUrl$Input = httpUrl$Input;

/**
 * Any of:
 * - {@link inputInlineQueryResultAnimation}
 * - {@link inputInlineQueryResultArticle}
 * - {@link inputInlineQueryResultAudio}
 * - {@link inputInlineQueryResultContact}
 * - {@link inputInlineQueryResultDocument}
 * - {@link inputInlineQueryResultGame}
 * - {@link inputInlineQueryResultLocation}
 * - {@link inputInlineQueryResultPhoto}
 * - {@link inputInlineQueryResultSticker}
 * - {@link inputInlineQueryResultVenue}
 * - {@link inputInlineQueryResultVideo}
 * - {@link inputInlineQueryResultVoiceNote}
 */
export type InputInlineQueryResult =
  | inputInlineQueryResultAnimation
  | inputInlineQueryResultArticle
  | inputInlineQueryResultAudio
  | inputInlineQueryResultContact
  | inputInlineQueryResultDocument
  | inputInlineQueryResultGame
  | inputInlineQueryResultLocation
  | inputInlineQueryResultPhoto
  | inputInlineQueryResultSticker
  | inputInlineQueryResultVenue
  | inputInlineQueryResultVideo
  | inputInlineQueryResultVoiceNote;

/**
 * Any of:
 * - {@link inputInlineQueryResultAnimation$Input}
 * - {@link inputInlineQueryResultArticle$Input}
 * - {@link inputInlineQueryResultAudio$Input}
 * - {@link inputInlineQueryResultContact$Input}
 * - {@link inputInlineQueryResultDocument$Input}
 * - {@link inputInlineQueryResultGame$Input}
 * - {@link inputInlineQueryResultLocation$Input}
 * - {@link inputInlineQueryResultPhoto$Input}
 * - {@link inputInlineQueryResultSticker$Input}
 * - {@link inputInlineQueryResultVenue$Input}
 * - {@link inputInlineQueryResultVideo$Input}
 * - {@link inputInlineQueryResultVoiceNote$Input}
 */
export type InputInlineQueryResult$Input =
  | inputInlineQueryResultAnimation$Input
  | inputInlineQueryResultArticle$Input
  | inputInlineQueryResultAudio$Input
  | inputInlineQueryResultContact$Input
  | inputInlineQueryResultDocument$Input
  | inputInlineQueryResultGame$Input
  | inputInlineQueryResultLocation$Input
  | inputInlineQueryResultPhoto$Input
  | inputInlineQueryResultSticker$Input
  | inputInlineQueryResultVenue$Input
  | inputInlineQueryResultVideo$Input
  | inputInlineQueryResultVoiceNote$Input;

/**
 * Any of:
 * - {@link inlineQueryResultArticle}
 * - {@link inlineQueryResultContact}
 * - {@link inlineQueryResultLocation}
 * - {@link inlineQueryResultVenue}
 * - {@link inlineQueryResultGame}
 * - {@link inlineQueryResultAnimation}
 * - {@link inlineQueryResultAudio}
 * - {@link inlineQueryResultDocument}
 * - {@link inlineQueryResultPhoto}
 * - {@link inlineQueryResultSticker}
 * - {@link inlineQueryResultVideo}
 * - {@link inlineQueryResultVoiceNote}
 */
export type InlineQueryResult =
  | inlineQueryResultArticle
  | inlineQueryResultContact
  | inlineQueryResultLocation
  | inlineQueryResultVenue
  | inlineQueryResultGame
  | inlineQueryResultAnimation
  | inlineQueryResultAudio
  | inlineQueryResultDocument
  | inlineQueryResultPhoto
  | inlineQueryResultSticker
  | inlineQueryResultVideo
  | inlineQueryResultVoiceNote;

/**
 * Any of:
 * - {@link inlineQueryResultArticle$Input}
 * - {@link inlineQueryResultContact$Input}
 * - {@link inlineQueryResultLocation$Input}
 * - {@link inlineQueryResultVenue$Input}
 * - {@link inlineQueryResultGame$Input}
 * - {@link inlineQueryResultAnimation$Input}
 * - {@link inlineQueryResultAudio$Input}
 * - {@link inlineQueryResultDocument$Input}
 * - {@link inlineQueryResultPhoto$Input}
 * - {@link inlineQueryResultSticker$Input}
 * - {@link inlineQueryResultVideo$Input}
 * - {@link inlineQueryResultVoiceNote$Input}
 */
export type InlineQueryResult$Input =
  | inlineQueryResultArticle$Input
  | inlineQueryResultContact$Input
  | inlineQueryResultLocation$Input
  | inlineQueryResultVenue$Input
  | inlineQueryResultGame$Input
  | inlineQueryResultAnimation$Input
  | inlineQueryResultAudio$Input
  | inlineQueryResultDocument$Input
  | inlineQueryResultPhoto$Input
  | inlineQueryResultSticker$Input
  | inlineQueryResultVideo$Input
  | inlineQueryResultVoiceNote$Input;

/**
 * Any of:
 * - {@link inlineQueryResults}
 */
export type InlineQueryResults = inlineQueryResults;

/**
 * Any of:
 * - {@link inlineQueryResults$Input}
 */
export type InlineQueryResults$Input = inlineQueryResults$Input;

/**
 * Any of:
 * - {@link callbackQueryPayloadData}
 * - {@link callbackQueryPayloadDataWithPassword}
 * - {@link callbackQueryPayloadGame}
 */
export type CallbackQueryPayload =
  | callbackQueryPayloadData
  | callbackQueryPayloadDataWithPassword
  | callbackQueryPayloadGame;

/**
 * Any of:
 * - {@link callbackQueryPayloadData$Input}
 * - {@link callbackQueryPayloadDataWithPassword$Input}
 * - {@link callbackQueryPayloadGame$Input}
 */
export type CallbackQueryPayload$Input =
  | callbackQueryPayloadData$Input
  | callbackQueryPayloadDataWithPassword$Input
  | callbackQueryPayloadGame$Input;

/**
 * Any of:
 * - {@link callbackQueryAnswer}
 */
export type CallbackQueryAnswer = callbackQueryAnswer;

/**
 * Any of:
 * - {@link callbackQueryAnswer$Input}
 */
export type CallbackQueryAnswer$Input = callbackQueryAnswer$Input;

/**
 * Any of:
 * - {@link customRequestResult}
 */
export type CustomRequestResult = customRequestResult;

/**
 * Any of:
 * - {@link customRequestResult$Input}
 */
export type CustomRequestResult$Input = customRequestResult$Input;

/**
 * Any of:
 * - {@link gameHighScore}
 */
export type GameHighScore = gameHighScore;

/**
 * Any of:
 * - {@link gameHighScore$Input}
 */
export type GameHighScore$Input = gameHighScore$Input;

/**
 * Any of:
 * - {@link gameHighScores}
 */
export type GameHighScores = gameHighScores;

/**
 * Any of:
 * - {@link gameHighScores$Input}
 */
export type GameHighScores$Input = gameHighScores$Input;

/**
 * Any of:
 * - {@link chatEventMessageEdited}
 * - {@link chatEventMessageDeleted}
 * - {@link chatEventMessagePinned}
 * - {@link chatEventMessageUnpinned}
 * - {@link chatEventPollStopped}
 * - {@link chatEventMemberJoined}
 * - {@link chatEventMemberJoinedByInviteLink}
 * - {@link chatEventMemberJoinedByRequest}
 * - {@link chatEventMemberInvited}
 * - {@link chatEventMemberLeft}
 * - {@link chatEventMemberPromoted}
 * - {@link chatEventMemberRestricted}
 * - {@link chatEventAvailableReactionsChanged}
 * - {@link chatEventDescriptionChanged}
 * - {@link chatEventLinkedChatChanged}
 * - {@link chatEventLocationChanged}
 * - {@link chatEventMessageTtlChanged}
 * - {@link chatEventPermissionsChanged}
 * - {@link chatEventPhotoChanged}
 * - {@link chatEventSlowModeDelayChanged}
 * - {@link chatEventStickerSetChanged}
 * - {@link chatEventTitleChanged}
 * - {@link chatEventUsernameChanged}
 * - {@link chatEventActiveUsernamesChanged}
 * - {@link chatEventHasProtectedContentToggled}
 * - {@link chatEventInvitesToggled}
 * - {@link chatEventIsAllHistoryAvailableToggled}
 * - {@link chatEventSignMessagesToggled}
 * - {@link chatEventInviteLinkEdited}
 * - {@link chatEventInviteLinkRevoked}
 * - {@link chatEventInviteLinkDeleted}
 * - {@link chatEventVideoChatCreated}
 * - {@link chatEventVideoChatEnded}
 * - {@link chatEventVideoChatMuteNewParticipantsToggled}
 * - {@link chatEventVideoChatParticipantIsMutedToggled}
 * - {@link chatEventVideoChatParticipantVolumeLevelChanged}
 * - {@link chatEventIsForumToggled}
 * - {@link chatEventForumTopicCreated}
 * - {@link chatEventForumTopicEdited}
 * - {@link chatEventForumTopicToggleIsClosed}
 * - {@link chatEventForumTopicDeleted}
 * - {@link chatEventForumTopicPinned}
 */
export type ChatEventAction =
  | chatEventMessageEdited
  | chatEventMessageDeleted
  | chatEventMessagePinned
  | chatEventMessageUnpinned
  | chatEventPollStopped
  | chatEventMemberJoined
  | chatEventMemberJoinedByInviteLink
  | chatEventMemberJoinedByRequest
  | chatEventMemberInvited
  | chatEventMemberLeft
  | chatEventMemberPromoted
  | chatEventMemberRestricted
  | chatEventAvailableReactionsChanged
  | chatEventDescriptionChanged
  | chatEventLinkedChatChanged
  | chatEventLocationChanged
  | chatEventMessageTtlChanged
  | chatEventPermissionsChanged
  | chatEventPhotoChanged
  | chatEventSlowModeDelayChanged
  | chatEventStickerSetChanged
  | chatEventTitleChanged
  | chatEventUsernameChanged
  | chatEventActiveUsernamesChanged
  | chatEventHasProtectedContentToggled
  | chatEventInvitesToggled
  | chatEventIsAllHistoryAvailableToggled
  | chatEventSignMessagesToggled
  | chatEventInviteLinkEdited
  | chatEventInviteLinkRevoked
  | chatEventInviteLinkDeleted
  | chatEventVideoChatCreated
  | chatEventVideoChatEnded
  | chatEventVideoChatMuteNewParticipantsToggled
  | chatEventVideoChatParticipantIsMutedToggled
  | chatEventVideoChatParticipantVolumeLevelChanged
  | chatEventIsForumToggled
  | chatEventForumTopicCreated
  | chatEventForumTopicEdited
  | chatEventForumTopicToggleIsClosed
  | chatEventForumTopicDeleted
  | chatEventForumTopicPinned;

/**
 * Any of:
 * - {@link chatEventMessageEdited$Input}
 * - {@link chatEventMessageDeleted$Input}
 * - {@link chatEventMessagePinned$Input}
 * - {@link chatEventMessageUnpinned$Input}
 * - {@link chatEventPollStopped$Input}
 * - {@link chatEventMemberJoined$Input}
 * - {@link chatEventMemberJoinedByInviteLink$Input}
 * - {@link chatEventMemberJoinedByRequest$Input}
 * - {@link chatEventMemberInvited$Input}
 * - {@link chatEventMemberLeft$Input}
 * - {@link chatEventMemberPromoted$Input}
 * - {@link chatEventMemberRestricted$Input}
 * - {@link chatEventAvailableReactionsChanged$Input}
 * - {@link chatEventDescriptionChanged$Input}
 * - {@link chatEventLinkedChatChanged$Input}
 * - {@link chatEventLocationChanged$Input}
 * - {@link chatEventMessageTtlChanged$Input}
 * - {@link chatEventPermissionsChanged$Input}
 * - {@link chatEventPhotoChanged$Input}
 * - {@link chatEventSlowModeDelayChanged$Input}
 * - {@link chatEventStickerSetChanged$Input}
 * - {@link chatEventTitleChanged$Input}
 * - {@link chatEventUsernameChanged$Input}
 * - {@link chatEventActiveUsernamesChanged$Input}
 * - {@link chatEventHasProtectedContentToggled$Input}
 * - {@link chatEventInvitesToggled$Input}
 * - {@link chatEventIsAllHistoryAvailableToggled$Input}
 * - {@link chatEventSignMessagesToggled$Input}
 * - {@link chatEventInviteLinkEdited$Input}
 * - {@link chatEventInviteLinkRevoked$Input}
 * - {@link chatEventInviteLinkDeleted$Input}
 * - {@link chatEventVideoChatCreated$Input}
 * - {@link chatEventVideoChatEnded$Input}
 * - {@link chatEventVideoChatMuteNewParticipantsToggled$Input}
 * - {@link chatEventVideoChatParticipantIsMutedToggled$Input}
 * - {@link chatEventVideoChatParticipantVolumeLevelChanged$Input}
 * - {@link chatEventIsForumToggled$Input}
 * - {@link chatEventForumTopicCreated$Input}
 * - {@link chatEventForumTopicEdited$Input}
 * - {@link chatEventForumTopicToggleIsClosed$Input}
 * - {@link chatEventForumTopicDeleted$Input}
 * - {@link chatEventForumTopicPinned$Input}
 */
export type ChatEventAction$Input =
  | chatEventMessageEdited$Input
  | chatEventMessageDeleted$Input
  | chatEventMessagePinned$Input
  | chatEventMessageUnpinned$Input
  | chatEventPollStopped$Input
  | chatEventMemberJoined$Input
  | chatEventMemberJoinedByInviteLink$Input
  | chatEventMemberJoinedByRequest$Input
  | chatEventMemberInvited$Input
  | chatEventMemberLeft$Input
  | chatEventMemberPromoted$Input
  | chatEventMemberRestricted$Input
  | chatEventAvailableReactionsChanged$Input
  | chatEventDescriptionChanged$Input
  | chatEventLinkedChatChanged$Input
  | chatEventLocationChanged$Input
  | chatEventMessageTtlChanged$Input
  | chatEventPermissionsChanged$Input
  | chatEventPhotoChanged$Input
  | chatEventSlowModeDelayChanged$Input
  | chatEventStickerSetChanged$Input
  | chatEventTitleChanged$Input
  | chatEventUsernameChanged$Input
  | chatEventActiveUsernamesChanged$Input
  | chatEventHasProtectedContentToggled$Input
  | chatEventInvitesToggled$Input
  | chatEventIsAllHistoryAvailableToggled$Input
  | chatEventSignMessagesToggled$Input
  | chatEventInviteLinkEdited$Input
  | chatEventInviteLinkRevoked$Input
  | chatEventInviteLinkDeleted$Input
  | chatEventVideoChatCreated$Input
  | chatEventVideoChatEnded$Input
  | chatEventVideoChatMuteNewParticipantsToggled$Input
  | chatEventVideoChatParticipantIsMutedToggled$Input
  | chatEventVideoChatParticipantVolumeLevelChanged$Input
  | chatEventIsForumToggled$Input
  | chatEventForumTopicCreated$Input
  | chatEventForumTopicEdited$Input
  | chatEventForumTopicToggleIsClosed$Input
  | chatEventForumTopicDeleted$Input
  | chatEventForumTopicPinned$Input;

/**
 * Any of:
 * - {@link chatEvent}
 */
export type ChatEvent = chatEvent;

/**
 * Any of:
 * - {@link chatEvent$Input}
 */
export type ChatEvent$Input = chatEvent$Input;

/**
 * Any of:
 * - {@link chatEvents}
 */
export type ChatEvents = chatEvents;

/**
 * Any of:
 * - {@link chatEvents$Input}
 */
export type ChatEvents$Input = chatEvents$Input;

/**
 * Any of:
 * - {@link chatEventLogFilters}
 */
export type ChatEventLogFilters = chatEventLogFilters;

/**
 * Any of:
 * - {@link chatEventLogFilters$Input}
 */
export type ChatEventLogFilters$Input = chatEventLogFilters$Input;

/**
 * Any of:
 * - {@link languagePackStringValueOrdinary}
 * - {@link languagePackStringValuePluralized}
 * - {@link languagePackStringValueDeleted}
 */
export type LanguagePackStringValue =
  | languagePackStringValueOrdinary
  | languagePackStringValuePluralized
  | languagePackStringValueDeleted;

/**
 * Any of:
 * - {@link languagePackStringValueOrdinary$Input}
 * - {@link languagePackStringValuePluralized$Input}
 * - {@link languagePackStringValueDeleted$Input}
 */
export type LanguagePackStringValue$Input =
  | languagePackStringValueOrdinary$Input
  | languagePackStringValuePluralized$Input
  | languagePackStringValueDeleted$Input;

/**
 * Any of:
 * - {@link languagePackString}
 */
export type LanguagePackString = languagePackString;

/**
 * Any of:
 * - {@link languagePackString$Input}
 */
export type LanguagePackString$Input = languagePackString$Input;

/**
 * Any of:
 * - {@link languagePackStrings}
 */
export type LanguagePackStrings = languagePackStrings;

/**
 * Any of:
 * - {@link languagePackStrings$Input}
 */
export type LanguagePackStrings$Input = languagePackStrings$Input;

/**
 * Any of:
 * - {@link languagePackInfo}
 */
export type LanguagePackInfo = languagePackInfo;

/**
 * Any of:
 * - {@link languagePackInfo$Input}
 */
export type LanguagePackInfo$Input = languagePackInfo$Input;

/**
 * Any of:
 * - {@link localizationTargetInfo}
 */
export type LocalizationTargetInfo = localizationTargetInfo;

/**
 * Any of:
 * - {@link localizationTargetInfo$Input}
 */
export type LocalizationTargetInfo$Input = localizationTargetInfo$Input;

/**
 * Any of:
 * - {@link premiumLimitTypeSupergroupCount}
 * - {@link premiumLimitTypePinnedChatCount}
 * - {@link premiumLimitTypeCreatedPublicChatCount}
 * - {@link premiumLimitTypeSavedAnimationCount}
 * - {@link premiumLimitTypeFavoriteStickerCount}
 * - {@link premiumLimitTypeChatFilterCount}
 * - {@link premiumLimitTypeChatFilterChosenChatCount}
 * - {@link premiumLimitTypePinnedArchivedChatCount}
 * - {@link premiumLimitTypeCaptionLength}
 * - {@link premiumLimitTypeBioLength}
 */
export type PremiumLimitType =
  | premiumLimitTypeSupergroupCount
  | premiumLimitTypePinnedChatCount
  | premiumLimitTypeCreatedPublicChatCount
  | premiumLimitTypeSavedAnimationCount
  | premiumLimitTypeFavoriteStickerCount
  | premiumLimitTypeChatFilterCount
  | premiumLimitTypeChatFilterChosenChatCount
  | premiumLimitTypePinnedArchivedChatCount
  | premiumLimitTypeCaptionLength
  | premiumLimitTypeBioLength;

/**
 * Any of:
 * - {@link premiumLimitTypeSupergroupCount$Input}
 * - {@link premiumLimitTypePinnedChatCount$Input}
 * - {@link premiumLimitTypeCreatedPublicChatCount$Input}
 * - {@link premiumLimitTypeSavedAnimationCount$Input}
 * - {@link premiumLimitTypeFavoriteStickerCount$Input}
 * - {@link premiumLimitTypeChatFilterCount$Input}
 * - {@link premiumLimitTypeChatFilterChosenChatCount$Input}
 * - {@link premiumLimitTypePinnedArchivedChatCount$Input}
 * - {@link premiumLimitTypeCaptionLength$Input}
 * - {@link premiumLimitTypeBioLength$Input}
 */
export type PremiumLimitType$Input =
  | premiumLimitTypeSupergroupCount$Input
  | premiumLimitTypePinnedChatCount$Input
  | premiumLimitTypeCreatedPublicChatCount$Input
  | premiumLimitTypeSavedAnimationCount$Input
  | premiumLimitTypeFavoriteStickerCount$Input
  | premiumLimitTypeChatFilterCount$Input
  | premiumLimitTypeChatFilterChosenChatCount$Input
  | premiumLimitTypePinnedArchivedChatCount$Input
  | premiumLimitTypeCaptionLength$Input
  | premiumLimitTypeBioLength$Input;

/**
 * Any of:
 * - {@link premiumFeatureIncreasedLimits}
 * - {@link premiumFeatureIncreasedUploadFileSize}
 * - {@link premiumFeatureImprovedDownloadSpeed}
 * - {@link premiumFeatureVoiceRecognition}
 * - {@link premiumFeatureDisabledAds}
 * - {@link premiumFeatureUniqueReactions}
 * - {@link premiumFeatureUniqueStickers}
 * - {@link premiumFeatureCustomEmoji}
 * - {@link premiumFeatureAdvancedChatManagement}
 * - {@link premiumFeatureProfileBadge}
 * - {@link premiumFeatureEmojiStatus}
 * - {@link premiumFeatureAnimatedProfilePhoto}
 * - {@link premiumFeatureForumTopicIcon}
 * - {@link premiumFeatureAppIcons}
 */
export type PremiumFeature =
  | premiumFeatureIncreasedLimits
  | premiumFeatureIncreasedUploadFileSize
  | premiumFeatureImprovedDownloadSpeed
  | premiumFeatureVoiceRecognition
  | premiumFeatureDisabledAds
  | premiumFeatureUniqueReactions
  | premiumFeatureUniqueStickers
  | premiumFeatureCustomEmoji
  | premiumFeatureAdvancedChatManagement
  | premiumFeatureProfileBadge
  | premiumFeatureEmojiStatus
  | premiumFeatureAnimatedProfilePhoto
  | premiumFeatureForumTopicIcon
  | premiumFeatureAppIcons;

/**
 * Any of:
 * - {@link premiumFeatureIncreasedLimits$Input}
 * - {@link premiumFeatureIncreasedUploadFileSize$Input}
 * - {@link premiumFeatureImprovedDownloadSpeed$Input}
 * - {@link premiumFeatureVoiceRecognition$Input}
 * - {@link premiumFeatureDisabledAds$Input}
 * - {@link premiumFeatureUniqueReactions$Input}
 * - {@link premiumFeatureUniqueStickers$Input}
 * - {@link premiumFeatureCustomEmoji$Input}
 * - {@link premiumFeatureAdvancedChatManagement$Input}
 * - {@link premiumFeatureProfileBadge$Input}
 * - {@link premiumFeatureEmojiStatus$Input}
 * - {@link premiumFeatureAnimatedProfilePhoto$Input}
 * - {@link premiumFeatureForumTopicIcon$Input}
 * - {@link premiumFeatureAppIcons$Input}
 */
export type PremiumFeature$Input =
  | premiumFeatureIncreasedLimits$Input
  | premiumFeatureIncreasedUploadFileSize$Input
  | premiumFeatureImprovedDownloadSpeed$Input
  | premiumFeatureVoiceRecognition$Input
  | premiumFeatureDisabledAds$Input
  | premiumFeatureUniqueReactions$Input
  | premiumFeatureUniqueStickers$Input
  | premiumFeatureCustomEmoji$Input
  | premiumFeatureAdvancedChatManagement$Input
  | premiumFeatureProfileBadge$Input
  | premiumFeatureEmojiStatus$Input
  | premiumFeatureAnimatedProfilePhoto$Input
  | premiumFeatureForumTopicIcon$Input
  | premiumFeatureAppIcons$Input;

/**
 * Any of:
 * - {@link premiumLimit}
 */
export type PremiumLimit = premiumLimit;

/**
 * Any of:
 * - {@link premiumLimit$Input}
 */
export type PremiumLimit$Input = premiumLimit$Input;

/**
 * Any of:
 * - {@link premiumFeatures}
 */
export type PremiumFeatures = premiumFeatures;

/**
 * Any of:
 * - {@link premiumFeatures$Input}
 */
export type PremiumFeatures$Input = premiumFeatures$Input;

/**
 * Any of:
 * - {@link premiumSourceLimitExceeded}
 * - {@link premiumSourceFeature}
 * - {@link premiumSourceLink}
 * - {@link premiumSourceSettings}
 */
export type PremiumSource =
  | premiumSourceLimitExceeded
  | premiumSourceFeature
  | premiumSourceLink
  | premiumSourceSettings;

/**
 * Any of:
 * - {@link premiumSourceLimitExceeded$Input}
 * - {@link premiumSourceFeature$Input}
 * - {@link premiumSourceLink$Input}
 * - {@link premiumSourceSettings$Input}
 */
export type PremiumSource$Input =
  | premiumSourceLimitExceeded$Input
  | premiumSourceFeature$Input
  | premiumSourceLink$Input
  | premiumSourceSettings$Input;

/**
 * Any of:
 * - {@link premiumFeaturePromotionAnimation}
 */
export type PremiumFeaturePromotionAnimation = premiumFeaturePromotionAnimation;

/**
 * Any of:
 * - {@link premiumFeaturePromotionAnimation$Input}
 */
export type PremiumFeaturePromotionAnimation$Input =
  premiumFeaturePromotionAnimation$Input;

/**
 * Any of:
 * - {@link premiumState}
 */
export type PremiumState = premiumState;

/**
 * Any of:
 * - {@link premiumState$Input}
 */
export type PremiumState$Input = premiumState$Input;

/**
 * Any of:
 * - {@link storePaymentPurposePremiumSubscription}
 * - {@link storePaymentPurposeGiftedPremium}
 */
export type StorePaymentPurpose =
  | storePaymentPurposePremiumSubscription
  | storePaymentPurposeGiftedPremium;

/**
 * Any of:
 * - {@link storePaymentPurposePremiumSubscription$Input}
 * - {@link storePaymentPurposeGiftedPremium$Input}
 */
export type StorePaymentPurpose$Input =
  | storePaymentPurposePremiumSubscription$Input
  | storePaymentPurposeGiftedPremium$Input;

/**
 * Any of:
 * - {@link deviceTokenFirebaseCloudMessaging}
 * - {@link deviceTokenApplePush}
 * - {@link deviceTokenApplePushVoIP}
 * - {@link deviceTokenWindowsPush}
 * - {@link deviceTokenMicrosoftPush}
 * - {@link deviceTokenMicrosoftPushVoIP}
 * - {@link deviceTokenWebPush}
 * - {@link deviceTokenSimplePush}
 * - {@link deviceTokenUbuntuPush}
 * - {@link deviceTokenBlackBerryPush}
 * - {@link deviceTokenTizenPush}
 */
export type DeviceToken =
  | deviceTokenFirebaseCloudMessaging
  | deviceTokenApplePush
  | deviceTokenApplePushVoIP
  | deviceTokenWindowsPush
  | deviceTokenMicrosoftPush
  | deviceTokenMicrosoftPushVoIP
  | deviceTokenWebPush
  | deviceTokenSimplePush
  | deviceTokenUbuntuPush
  | deviceTokenBlackBerryPush
  | deviceTokenTizenPush;

/**
 * Any of:
 * - {@link deviceTokenFirebaseCloudMessaging$Input}
 * - {@link deviceTokenApplePush$Input}
 * - {@link deviceTokenApplePushVoIP$Input}
 * - {@link deviceTokenWindowsPush$Input}
 * - {@link deviceTokenMicrosoftPush$Input}
 * - {@link deviceTokenMicrosoftPushVoIP$Input}
 * - {@link deviceTokenWebPush$Input}
 * - {@link deviceTokenSimplePush$Input}
 * - {@link deviceTokenUbuntuPush$Input}
 * - {@link deviceTokenBlackBerryPush$Input}
 * - {@link deviceTokenTizenPush$Input}
 */
export type DeviceToken$Input =
  | deviceTokenFirebaseCloudMessaging$Input
  | deviceTokenApplePush$Input
  | deviceTokenApplePushVoIP$Input
  | deviceTokenWindowsPush$Input
  | deviceTokenMicrosoftPush$Input
  | deviceTokenMicrosoftPushVoIP$Input
  | deviceTokenWebPush$Input
  | deviceTokenSimplePush$Input
  | deviceTokenUbuntuPush$Input
  | deviceTokenBlackBerryPush$Input
  | deviceTokenTizenPush$Input;

/**
 * Any of:
 * - {@link pushReceiverId}
 */
export type PushReceiverId = pushReceiverId;

/**
 * Any of:
 * - {@link pushReceiverId$Input}
 */
export type PushReceiverId$Input = pushReceiverId$Input;

/**
 * Any of:
 * - {@link backgroundFillSolid}
 * - {@link backgroundFillGradient}
 * - {@link backgroundFillFreeformGradient}
 */
export type BackgroundFill =
  | backgroundFillSolid
  | backgroundFillGradient
  | backgroundFillFreeformGradient;

/**
 * Any of:
 * - {@link backgroundFillSolid$Input}
 * - {@link backgroundFillGradient$Input}
 * - {@link backgroundFillFreeformGradient$Input}
 */
export type BackgroundFill$Input =
  | backgroundFillSolid$Input
  | backgroundFillGradient$Input
  | backgroundFillFreeformGradient$Input;

/**
 * Any of:
 * - {@link backgroundTypeWallpaper}
 * - {@link backgroundTypePattern}
 * - {@link backgroundTypeFill}
 */
export type BackgroundType =
  | backgroundTypeWallpaper
  | backgroundTypePattern
  | backgroundTypeFill;

/**
 * Any of:
 * - {@link backgroundTypeWallpaper$Input}
 * - {@link backgroundTypePattern$Input}
 * - {@link backgroundTypeFill$Input}
 */
export type BackgroundType$Input =
  | backgroundTypeWallpaper$Input
  | backgroundTypePattern$Input
  | backgroundTypeFill$Input;

/**
 * Any of:
 * - {@link background}
 */
export type Background = background;

/**
 * Any of:
 * - {@link background$Input}
 */
export type Background$Input = background$Input;

/**
 * Any of:
 * - {@link backgrounds}
 */
export type Backgrounds = backgrounds;

/**
 * Any of:
 * - {@link backgrounds$Input}
 */
export type Backgrounds$Input = backgrounds$Input;

/**
 * Any of:
 * - {@link inputBackgroundLocal}
 * - {@link inputBackgroundRemote}
 */
export type InputBackground = inputBackgroundLocal | inputBackgroundRemote;

/**
 * Any of:
 * - {@link inputBackgroundLocal$Input}
 * - {@link inputBackgroundRemote$Input}
 */
export type InputBackground$Input =
  | inputBackgroundLocal$Input
  | inputBackgroundRemote$Input;

/**
 * Any of:
 * - {@link themeSettings}
 */
export type ThemeSettings = themeSettings;

/**
 * Any of:
 * - {@link themeSettings$Input}
 */
export type ThemeSettings$Input = themeSettings$Input;

/**
 * Any of:
 * - {@link chatTheme}
 */
export type ChatTheme = chatTheme;

/**
 * Any of:
 * - {@link chatTheme$Input}
 */
export type ChatTheme$Input = chatTheme$Input;

/**
 * Any of:
 * - {@link hashtags}
 */
export type Hashtags = hashtags;

/**
 * Any of:
 * - {@link hashtags$Input}
 */
export type Hashtags$Input = hashtags$Input;

/**
 * Any of:
 * - {@link canTransferOwnershipResultOk}
 * - {@link canTransferOwnershipResultPasswordNeeded}
 * - {@link canTransferOwnershipResultPasswordTooFresh}
 * - {@link canTransferOwnershipResultSessionTooFresh}
 */
export type CanTransferOwnershipResult =
  | canTransferOwnershipResultOk
  | canTransferOwnershipResultPasswordNeeded
  | canTransferOwnershipResultPasswordTooFresh
  | canTransferOwnershipResultSessionTooFresh;

/**
 * Any of:
 * - {@link canTransferOwnershipResultOk$Input}
 * - {@link canTransferOwnershipResultPasswordNeeded$Input}
 * - {@link canTransferOwnershipResultPasswordTooFresh$Input}
 * - {@link canTransferOwnershipResultSessionTooFresh$Input}
 */
export type CanTransferOwnershipResult$Input =
  | canTransferOwnershipResultOk$Input
  | canTransferOwnershipResultPasswordNeeded$Input
  | canTransferOwnershipResultPasswordTooFresh$Input
  | canTransferOwnershipResultSessionTooFresh$Input;

/**
 * Any of:
 * - {@link checkChatUsernameResultOk}
 * - {@link checkChatUsernameResultUsernameInvalid}
 * - {@link checkChatUsernameResultUsernameOccupied}
 * - {@link checkChatUsernameResultPublicChatsTooMuch}
 * - {@link checkChatUsernameResultPublicGroupsUnavailable}
 */
export type CheckChatUsernameResult =
  | checkChatUsernameResultOk
  | checkChatUsernameResultUsernameInvalid
  | checkChatUsernameResultUsernameOccupied
  | checkChatUsernameResultPublicChatsTooMuch
  | checkChatUsernameResultPublicGroupsUnavailable;

/**
 * Any of:
 * - {@link checkChatUsernameResultOk$Input}
 * - {@link checkChatUsernameResultUsernameInvalid$Input}
 * - {@link checkChatUsernameResultUsernameOccupied$Input}
 * - {@link checkChatUsernameResultPublicChatsTooMuch$Input}
 * - {@link checkChatUsernameResultPublicGroupsUnavailable$Input}
 */
export type CheckChatUsernameResult$Input =
  | checkChatUsernameResultOk$Input
  | checkChatUsernameResultUsernameInvalid$Input
  | checkChatUsernameResultUsernameOccupied$Input
  | checkChatUsernameResultPublicChatsTooMuch$Input
  | checkChatUsernameResultPublicGroupsUnavailable$Input;

/**
 * Any of:
 * - {@link checkStickerSetNameResultOk}
 * - {@link checkStickerSetNameResultNameInvalid}
 * - {@link checkStickerSetNameResultNameOccupied}
 */
export type CheckStickerSetNameResult =
  | checkStickerSetNameResultOk
  | checkStickerSetNameResultNameInvalid
  | checkStickerSetNameResultNameOccupied;

/**
 * Any of:
 * - {@link checkStickerSetNameResultOk$Input}
 * - {@link checkStickerSetNameResultNameInvalid$Input}
 * - {@link checkStickerSetNameResultNameOccupied$Input}
 */
export type CheckStickerSetNameResult$Input =
  | checkStickerSetNameResultOk$Input
  | checkStickerSetNameResultNameInvalid$Input
  | checkStickerSetNameResultNameOccupied$Input;

/**
 * Any of:
 * - {@link resetPasswordResultOk}
 * - {@link resetPasswordResultPending}
 * - {@link resetPasswordResultDeclined}
 */
export type ResetPasswordResult =
  | resetPasswordResultOk
  | resetPasswordResultPending
  | resetPasswordResultDeclined;

/**
 * Any of:
 * - {@link resetPasswordResultOk$Input}
 * - {@link resetPasswordResultPending$Input}
 * - {@link resetPasswordResultDeclined$Input}
 */
export type ResetPasswordResult$Input =
  | resetPasswordResultOk$Input
  | resetPasswordResultPending$Input
  | resetPasswordResultDeclined$Input;

/**
 * Any of:
 * - {@link messageFileTypePrivate}
 * - {@link messageFileTypeGroup}
 * - {@link messageFileTypeUnknown}
 */
export type MessageFileType =
  | messageFileTypePrivate
  | messageFileTypeGroup
  | messageFileTypeUnknown;

/**
 * Any of:
 * - {@link messageFileTypePrivate$Input}
 * - {@link messageFileTypeGroup$Input}
 * - {@link messageFileTypeUnknown$Input}
 */
export type MessageFileType$Input =
  | messageFileTypePrivate$Input
  | messageFileTypeGroup$Input
  | messageFileTypeUnknown$Input;

/**
 * Any of:
 * - {@link pushMessageContentHidden}
 * - {@link pushMessageContentAnimation}
 * - {@link pushMessageContentAudio}
 * - {@link pushMessageContentContact}
 * - {@link pushMessageContentContactRegistered}
 * - {@link pushMessageContentDocument}
 * - {@link pushMessageContentGame}
 * - {@link pushMessageContentGameScore}
 * - {@link pushMessageContentInvoice}
 * - {@link pushMessageContentLocation}
 * - {@link pushMessageContentPhoto}
 * - {@link pushMessageContentPoll}
 * - {@link pushMessageContentScreenshotTaken}
 * - {@link pushMessageContentSticker}
 * - {@link pushMessageContentText}
 * - {@link pushMessageContentVideo}
 * - {@link pushMessageContentVideoNote}
 * - {@link pushMessageContentVoiceNote}
 * - {@link pushMessageContentBasicGroupChatCreate}
 * - {@link pushMessageContentChatAddMembers}
 * - {@link pushMessageContentChatChangePhoto}
 * - {@link pushMessageContentChatChangeTitle}
 * - {@link pushMessageContentChatSetTheme}
 * - {@link pushMessageContentChatDeleteMember}
 * - {@link pushMessageContentChatJoinByLink}
 * - {@link pushMessageContentChatJoinByRequest}
 * - {@link pushMessageContentRecurringPayment}
 * - {@link pushMessageContentMessageForwards}
 * - {@link pushMessageContentMediaAlbum}
 */
export type PushMessageContent =
  | pushMessageContentHidden
  | pushMessageContentAnimation
  | pushMessageContentAudio
  | pushMessageContentContact
  | pushMessageContentContactRegistered
  | pushMessageContentDocument
  | pushMessageContentGame
  | pushMessageContentGameScore
  | pushMessageContentInvoice
  | pushMessageContentLocation
  | pushMessageContentPhoto
  | pushMessageContentPoll
  | pushMessageContentScreenshotTaken
  | pushMessageContentSticker
  | pushMessageContentText
  | pushMessageContentVideo
  | pushMessageContentVideoNote
  | pushMessageContentVoiceNote
  | pushMessageContentBasicGroupChatCreate
  | pushMessageContentChatAddMembers
  | pushMessageContentChatChangePhoto
  | pushMessageContentChatChangeTitle
  | pushMessageContentChatSetTheme
  | pushMessageContentChatDeleteMember
  | pushMessageContentChatJoinByLink
  | pushMessageContentChatJoinByRequest
  | pushMessageContentRecurringPayment
  | pushMessageContentMessageForwards
  | pushMessageContentMediaAlbum;

/**
 * Any of:
 * - {@link pushMessageContentHidden$Input}
 * - {@link pushMessageContentAnimation$Input}
 * - {@link pushMessageContentAudio$Input}
 * - {@link pushMessageContentContact$Input}
 * - {@link pushMessageContentContactRegistered$Input}
 * - {@link pushMessageContentDocument$Input}
 * - {@link pushMessageContentGame$Input}
 * - {@link pushMessageContentGameScore$Input}
 * - {@link pushMessageContentInvoice$Input}
 * - {@link pushMessageContentLocation$Input}
 * - {@link pushMessageContentPhoto$Input}
 * - {@link pushMessageContentPoll$Input}
 * - {@link pushMessageContentScreenshotTaken$Input}
 * - {@link pushMessageContentSticker$Input}
 * - {@link pushMessageContentText$Input}
 * - {@link pushMessageContentVideo$Input}
 * - {@link pushMessageContentVideoNote$Input}
 * - {@link pushMessageContentVoiceNote$Input}
 * - {@link pushMessageContentBasicGroupChatCreate$Input}
 * - {@link pushMessageContentChatAddMembers$Input}
 * - {@link pushMessageContentChatChangePhoto$Input}
 * - {@link pushMessageContentChatChangeTitle$Input}
 * - {@link pushMessageContentChatSetTheme$Input}
 * - {@link pushMessageContentChatDeleteMember$Input}
 * - {@link pushMessageContentChatJoinByLink$Input}
 * - {@link pushMessageContentChatJoinByRequest$Input}
 * - {@link pushMessageContentRecurringPayment$Input}
 * - {@link pushMessageContentMessageForwards$Input}
 * - {@link pushMessageContentMediaAlbum$Input}
 */
export type PushMessageContent$Input =
  | pushMessageContentHidden$Input
  | pushMessageContentAnimation$Input
  | pushMessageContentAudio$Input
  | pushMessageContentContact$Input
  | pushMessageContentContactRegistered$Input
  | pushMessageContentDocument$Input
  | pushMessageContentGame$Input
  | pushMessageContentGameScore$Input
  | pushMessageContentInvoice$Input
  | pushMessageContentLocation$Input
  | pushMessageContentPhoto$Input
  | pushMessageContentPoll$Input
  | pushMessageContentScreenshotTaken$Input
  | pushMessageContentSticker$Input
  | pushMessageContentText$Input
  | pushMessageContentVideo$Input
  | pushMessageContentVideoNote$Input
  | pushMessageContentVoiceNote$Input
  | pushMessageContentBasicGroupChatCreate$Input
  | pushMessageContentChatAddMembers$Input
  | pushMessageContentChatChangePhoto$Input
  | pushMessageContentChatChangeTitle$Input
  | pushMessageContentChatSetTheme$Input
  | pushMessageContentChatDeleteMember$Input
  | pushMessageContentChatJoinByLink$Input
  | pushMessageContentChatJoinByRequest$Input
  | pushMessageContentRecurringPayment$Input
  | pushMessageContentMessageForwards$Input
  | pushMessageContentMediaAlbum$Input;

/**
 * Any of:
 * - {@link notificationTypeNewMessage}
 * - {@link notificationTypeNewSecretChat}
 * - {@link notificationTypeNewCall}
 * - {@link notificationTypeNewPushMessage}
 */
export type NotificationType =
  | notificationTypeNewMessage
  | notificationTypeNewSecretChat
  | notificationTypeNewCall
  | notificationTypeNewPushMessage;

/**
 * Any of:
 * - {@link notificationTypeNewMessage$Input}
 * - {@link notificationTypeNewSecretChat$Input}
 * - {@link notificationTypeNewCall$Input}
 * - {@link notificationTypeNewPushMessage$Input}
 */
export type NotificationType$Input =
  | notificationTypeNewMessage$Input
  | notificationTypeNewSecretChat$Input
  | notificationTypeNewCall$Input
  | notificationTypeNewPushMessage$Input;

/**
 * Any of:
 * - {@link notificationGroupTypeMessages}
 * - {@link notificationGroupTypeMentions}
 * - {@link notificationGroupTypeSecretChat}
 * - {@link notificationGroupTypeCalls}
 */
export type NotificationGroupType =
  | notificationGroupTypeMessages
  | notificationGroupTypeMentions
  | notificationGroupTypeSecretChat
  | notificationGroupTypeCalls;

/**
 * Any of:
 * - {@link notificationGroupTypeMessages$Input}
 * - {@link notificationGroupTypeMentions$Input}
 * - {@link notificationGroupTypeSecretChat$Input}
 * - {@link notificationGroupTypeCalls$Input}
 */
export type NotificationGroupType$Input =
  | notificationGroupTypeMessages$Input
  | notificationGroupTypeMentions$Input
  | notificationGroupTypeSecretChat$Input
  | notificationGroupTypeCalls$Input;

/**
 * Any of:
 * - {@link notificationSound}
 */
export type NotificationSound = notificationSound;

/**
 * Any of:
 * - {@link notificationSound$Input}
 */
export type NotificationSound$Input = notificationSound$Input;

/**
 * Any of:
 * - {@link notificationSounds}
 */
export type NotificationSounds = notificationSounds;

/**
 * Any of:
 * - {@link notificationSounds$Input}
 */
export type NotificationSounds$Input = notificationSounds$Input;

/**
 * Any of:
 * - {@link notification}
 */
export type Notification = notification;

/**
 * Any of:
 * - {@link notification$Input}
 */
export type Notification$Input = notification$Input;

/**
 * Any of:
 * - {@link notificationGroup}
 */
export type NotificationGroup = notificationGroup;

/**
 * Any of:
 * - {@link notificationGroup$Input}
 */
export type NotificationGroup$Input = notificationGroup$Input;

/**
 * Any of:
 * - {@link optionValueBoolean}
 * - {@link optionValueEmpty}
 * - {@link optionValueInteger}
 * - {@link optionValueString}
 */
export type OptionValue =
  | optionValueBoolean
  | optionValueEmpty
  | optionValueInteger
  | optionValueString;

/**
 * Any of:
 * - {@link optionValueBoolean$Input}
 * - {@link optionValueEmpty$Input}
 * - {@link optionValueInteger$Input}
 * - {@link optionValueString$Input}
 */
export type OptionValue$Input =
  | optionValueBoolean$Input
  | optionValueEmpty$Input
  | optionValueInteger$Input
  | optionValueString$Input;

/**
 * Any of:
 * - {@link jsonObjectMember}
 */
export type JsonObjectMember = jsonObjectMember;

/**
 * Any of:
 * - {@link jsonObjectMember$Input}
 */
export type JsonObjectMember$Input = jsonObjectMember$Input;

/**
 * Any of:
 * - {@link jsonValueNull}
 * - {@link jsonValueBoolean}
 * - {@link jsonValueNumber}
 * - {@link jsonValueString}
 * - {@link jsonValueArray}
 * - {@link jsonValueObject}
 */
export type JsonValue =
  | jsonValueNull
  | jsonValueBoolean
  | jsonValueNumber
  | jsonValueString
  | jsonValueArray
  | jsonValueObject;

/**
 * Any of:
 * - {@link jsonValueNull$Input}
 * - {@link jsonValueBoolean$Input}
 * - {@link jsonValueNumber$Input}
 * - {@link jsonValueString$Input}
 * - {@link jsonValueArray$Input}
 * - {@link jsonValueObject$Input}
 */
export type JsonValue$Input =
  | jsonValueNull$Input
  | jsonValueBoolean$Input
  | jsonValueNumber$Input
  | jsonValueString$Input
  | jsonValueArray$Input
  | jsonValueObject$Input;

/**
 * Any of:
 * - {@link userPrivacySettingRuleAllowAll}
 * - {@link userPrivacySettingRuleAllowContacts}
 * - {@link userPrivacySettingRuleAllowUsers}
 * - {@link userPrivacySettingRuleAllowChatMembers}
 * - {@link userPrivacySettingRuleRestrictAll}
 * - {@link userPrivacySettingRuleRestrictContacts}
 * - {@link userPrivacySettingRuleRestrictUsers}
 * - {@link userPrivacySettingRuleRestrictChatMembers}
 */
export type UserPrivacySettingRule =
  | userPrivacySettingRuleAllowAll
  | userPrivacySettingRuleAllowContacts
  | userPrivacySettingRuleAllowUsers
  | userPrivacySettingRuleAllowChatMembers
  | userPrivacySettingRuleRestrictAll
  | userPrivacySettingRuleRestrictContacts
  | userPrivacySettingRuleRestrictUsers
  | userPrivacySettingRuleRestrictChatMembers;

/**
 * Any of:
 * - {@link userPrivacySettingRuleAllowAll$Input}
 * - {@link userPrivacySettingRuleAllowContacts$Input}
 * - {@link userPrivacySettingRuleAllowUsers$Input}
 * - {@link userPrivacySettingRuleAllowChatMembers$Input}
 * - {@link userPrivacySettingRuleRestrictAll$Input}
 * - {@link userPrivacySettingRuleRestrictContacts$Input}
 * - {@link userPrivacySettingRuleRestrictUsers$Input}
 * - {@link userPrivacySettingRuleRestrictChatMembers$Input}
 */
export type UserPrivacySettingRule$Input =
  | userPrivacySettingRuleAllowAll$Input
  | userPrivacySettingRuleAllowContacts$Input
  | userPrivacySettingRuleAllowUsers$Input
  | userPrivacySettingRuleAllowChatMembers$Input
  | userPrivacySettingRuleRestrictAll$Input
  | userPrivacySettingRuleRestrictContacts$Input
  | userPrivacySettingRuleRestrictUsers$Input
  | userPrivacySettingRuleRestrictChatMembers$Input;

/**
 * Any of:
 * - {@link userPrivacySettingRules}
 */
export type UserPrivacySettingRules = userPrivacySettingRules;

/**
 * Any of:
 * - {@link userPrivacySettingRules$Input}
 */
export type UserPrivacySettingRules$Input = userPrivacySettingRules$Input;

/**
 * Any of:
 * - {@link userPrivacySettingShowStatus}
 * - {@link userPrivacySettingShowProfilePhoto}
 * - {@link userPrivacySettingShowLinkInForwardedMessages}
 * - {@link userPrivacySettingShowPhoneNumber}
 * - {@link userPrivacySettingAllowChatInvites}
 * - {@link userPrivacySettingAllowCalls}
 * - {@link userPrivacySettingAllowPeerToPeerCalls}
 * - {@link userPrivacySettingAllowFindingByPhoneNumber}
 * - {@link userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages}
 */
export type UserPrivacySetting =
  | userPrivacySettingShowStatus
  | userPrivacySettingShowProfilePhoto
  | userPrivacySettingShowLinkInForwardedMessages
  | userPrivacySettingShowPhoneNumber
  | userPrivacySettingAllowChatInvites
  | userPrivacySettingAllowCalls
  | userPrivacySettingAllowPeerToPeerCalls
  | userPrivacySettingAllowFindingByPhoneNumber
  | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages;

/**
 * Any of:
 * - {@link userPrivacySettingShowStatus$Input}
 * - {@link userPrivacySettingShowProfilePhoto$Input}
 * - {@link userPrivacySettingShowLinkInForwardedMessages$Input}
 * - {@link userPrivacySettingShowPhoneNumber$Input}
 * - {@link userPrivacySettingAllowChatInvites$Input}
 * - {@link userPrivacySettingAllowCalls$Input}
 * - {@link userPrivacySettingAllowPeerToPeerCalls$Input}
 * - {@link userPrivacySettingAllowFindingByPhoneNumber$Input}
 * - {@link userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input}
 */
export type UserPrivacySetting$Input =
  | userPrivacySettingShowStatus$Input
  | userPrivacySettingShowProfilePhoto$Input
  | userPrivacySettingShowLinkInForwardedMessages$Input
  | userPrivacySettingShowPhoneNumber$Input
  | userPrivacySettingAllowChatInvites$Input
  | userPrivacySettingAllowCalls$Input
  | userPrivacySettingAllowPeerToPeerCalls$Input
  | userPrivacySettingAllowFindingByPhoneNumber$Input
  | userPrivacySettingAllowPrivateVoiceAndVideoNoteMessages$Input;

/**
 * Any of:
 * - {@link accountTtl}
 */
export type AccountTtl = accountTtl;

/**
 * Any of:
 * - {@link accountTtl$Input}
 */
export type AccountTtl$Input = accountTtl$Input;

/**
 * Any of:
 * - {@link sessionTypeAndroid}
 * - {@link sessionTypeApple}
 * - {@link sessionTypeBrave}
 * - {@link sessionTypeChrome}
 * - {@link sessionTypeEdge}
 * - {@link sessionTypeFirefox}
 * - {@link sessionTypeIpad}
 * - {@link sessionTypeIphone}
 * - {@link sessionTypeLinux}
 * - {@link sessionTypeMac}
 * - {@link sessionTypeOpera}
 * - {@link sessionTypeSafari}
 * - {@link sessionTypeUbuntu}
 * - {@link sessionTypeUnknown}
 * - {@link sessionTypeVivaldi}
 * - {@link sessionTypeWindows}
 * - {@link sessionTypeXbox}
 */
export type SessionType =
  | sessionTypeAndroid
  | sessionTypeApple
  | sessionTypeBrave
  | sessionTypeChrome
  | sessionTypeEdge
  | sessionTypeFirefox
  | sessionTypeIpad
  | sessionTypeIphone
  | sessionTypeLinux
  | sessionTypeMac
  | sessionTypeOpera
  | sessionTypeSafari
  | sessionTypeUbuntu
  | sessionTypeUnknown
  | sessionTypeVivaldi
  | sessionTypeWindows
  | sessionTypeXbox;

/**
 * Any of:
 * - {@link sessionTypeAndroid$Input}
 * - {@link sessionTypeApple$Input}
 * - {@link sessionTypeBrave$Input}
 * - {@link sessionTypeChrome$Input}
 * - {@link sessionTypeEdge$Input}
 * - {@link sessionTypeFirefox$Input}
 * - {@link sessionTypeIpad$Input}
 * - {@link sessionTypeIphone$Input}
 * - {@link sessionTypeLinux$Input}
 * - {@link sessionTypeMac$Input}
 * - {@link sessionTypeOpera$Input}
 * - {@link sessionTypeSafari$Input}
 * - {@link sessionTypeUbuntu$Input}
 * - {@link sessionTypeUnknown$Input}
 * - {@link sessionTypeVivaldi$Input}
 * - {@link sessionTypeWindows$Input}
 * - {@link sessionTypeXbox$Input}
 */
export type SessionType$Input =
  | sessionTypeAndroid$Input
  | sessionTypeApple$Input
  | sessionTypeBrave$Input
  | sessionTypeChrome$Input
  | sessionTypeEdge$Input
  | sessionTypeFirefox$Input
  | sessionTypeIpad$Input
  | sessionTypeIphone$Input
  | sessionTypeLinux$Input
  | sessionTypeMac$Input
  | sessionTypeOpera$Input
  | sessionTypeSafari$Input
  | sessionTypeUbuntu$Input
  | sessionTypeUnknown$Input
  | sessionTypeVivaldi$Input
  | sessionTypeWindows$Input
  | sessionTypeXbox$Input;

/**
 * Any of:
 * - {@link session}
 */
export type Session = session;

/**
 * Any of:
 * - {@link session$Input}
 */
export type Session$Input = session$Input;

/**
 * Any of:
 * - {@link sessions}
 */
export type Sessions = sessions;

/**
 * Any of:
 * - {@link sessions$Input}
 */
export type Sessions$Input = sessions$Input;

/**
 * Any of:
 * - {@link connectedWebsite}
 */
export type ConnectedWebsite = connectedWebsite;

/**
 * Any of:
 * - {@link connectedWebsite$Input}
 */
export type ConnectedWebsite$Input = connectedWebsite$Input;

/**
 * Any of:
 * - {@link connectedWebsites}
 */
export type ConnectedWebsites = connectedWebsites;

/**
 * Any of:
 * - {@link connectedWebsites$Input}
 */
export type ConnectedWebsites$Input = connectedWebsites$Input;

/**
 * Any of:
 * - {@link chatReportReasonSpam}
 * - {@link chatReportReasonViolence}
 * - {@link chatReportReasonPornography}
 * - {@link chatReportReasonChildAbuse}
 * - {@link chatReportReasonCopyright}
 * - {@link chatReportReasonUnrelatedLocation}
 * - {@link chatReportReasonFake}
 * - {@link chatReportReasonIllegalDrugs}
 * - {@link chatReportReasonPersonalDetails}
 * - {@link chatReportReasonCustom}
 */
export type ChatReportReason =
  | chatReportReasonSpam
  | chatReportReasonViolence
  | chatReportReasonPornography
  | chatReportReasonChildAbuse
  | chatReportReasonCopyright
  | chatReportReasonUnrelatedLocation
  | chatReportReasonFake
  | chatReportReasonIllegalDrugs
  | chatReportReasonPersonalDetails
  | chatReportReasonCustom;

/**
 * Any of:
 * - {@link chatReportReasonSpam$Input}
 * - {@link chatReportReasonViolence$Input}
 * - {@link chatReportReasonPornography$Input}
 * - {@link chatReportReasonChildAbuse$Input}
 * - {@link chatReportReasonCopyright$Input}
 * - {@link chatReportReasonUnrelatedLocation$Input}
 * - {@link chatReportReasonFake$Input}
 * - {@link chatReportReasonIllegalDrugs$Input}
 * - {@link chatReportReasonPersonalDetails$Input}
 * - {@link chatReportReasonCustom$Input}
 */
export type ChatReportReason$Input =
  | chatReportReasonSpam$Input
  | chatReportReasonViolence$Input
  | chatReportReasonPornography$Input
  | chatReportReasonChildAbuse$Input
  | chatReportReasonCopyright$Input
  | chatReportReasonUnrelatedLocation$Input
  | chatReportReasonFake$Input
  | chatReportReasonIllegalDrugs$Input
  | chatReportReasonPersonalDetails$Input
  | chatReportReasonCustom$Input;

/**
 * Any of:
 * - {@link targetChatCurrent}
 * - {@link targetChatChosen}
 * - {@link targetChatInternalLink}
 */
export type TargetChat =
  | targetChatCurrent
  | targetChatChosen
  | targetChatInternalLink;

/**
 * Any of:
 * - {@link targetChatCurrent$Input}
 * - {@link targetChatChosen$Input}
 * - {@link targetChatInternalLink$Input}
 */
export type TargetChat$Input =
  | targetChatCurrent$Input
  | targetChatChosen$Input
  | targetChatInternalLink$Input;

/**
 * Any of:
 * - {@link internalLinkTypeActiveSessions}
 * - {@link internalLinkTypeAttachmentMenuBot}
 * - {@link internalLinkTypeAuthenticationCode}
 * - {@link internalLinkTypeBackground}
 * - {@link internalLinkTypeBotStart}
 * - {@link internalLinkTypeBotStartInGroup}
 * - {@link internalLinkTypeBotAddToChannel}
 * - {@link internalLinkTypeChangePhoneNumber}
 * - {@link internalLinkTypeChatInvite}
 * - {@link internalLinkTypeFilterSettings}
 * - {@link internalLinkTypeGame}
 * - {@link internalLinkTypeInstantView}
 * - {@link internalLinkTypeInvoice}
 * - {@link internalLinkTypeLanguagePack}
 * - {@link internalLinkTypeLanguageSettings}
 * - {@link internalLinkTypeMessage}
 * - {@link internalLinkTypeMessageDraft}
 * - {@link internalLinkTypePassportDataRequest}
 * - {@link internalLinkTypePhoneNumberConfirmation}
 * - {@link internalLinkTypePremiumFeatures}
 * - {@link internalLinkTypePrivacyAndSecuritySettings}
 * - {@link internalLinkTypeProxy}
 * - {@link internalLinkTypePublicChat}
 * - {@link internalLinkTypeQrCodeAuthentication}
 * - {@link internalLinkTypeRestorePurchases}
 * - {@link internalLinkTypeSettings}
 * - {@link internalLinkTypeStickerSet}
 * - {@link internalLinkTypeTheme}
 * - {@link internalLinkTypeThemeSettings}
 * - {@link internalLinkTypeUnknownDeepLink}
 * - {@link internalLinkTypeUnsupportedProxy}
 * - {@link internalLinkTypeUserPhoneNumber}
 * - {@link internalLinkTypeVideoChat}
 */
export type InternalLinkType =
  | internalLinkTypeActiveSessions
  | internalLinkTypeAttachmentMenuBot
  | internalLinkTypeAuthenticationCode
  | internalLinkTypeBackground
  | internalLinkTypeBotStart
  | internalLinkTypeBotStartInGroup
  | internalLinkTypeBotAddToChannel
  | internalLinkTypeChangePhoneNumber
  | internalLinkTypeChatInvite
  | internalLinkTypeFilterSettings
  | internalLinkTypeGame
  | internalLinkTypeInstantView
  | internalLinkTypeInvoice
  | internalLinkTypeLanguagePack
  | internalLinkTypeLanguageSettings
  | internalLinkTypeMessage
  | internalLinkTypeMessageDraft
  | internalLinkTypePassportDataRequest
  | internalLinkTypePhoneNumberConfirmation
  | internalLinkTypePremiumFeatures
  | internalLinkTypePrivacyAndSecuritySettings
  | internalLinkTypeProxy
  | internalLinkTypePublicChat
  | internalLinkTypeQrCodeAuthentication
  | internalLinkTypeRestorePurchases
  | internalLinkTypeSettings
  | internalLinkTypeStickerSet
  | internalLinkTypeTheme
  | internalLinkTypeThemeSettings
  | internalLinkTypeUnknownDeepLink
  | internalLinkTypeUnsupportedProxy
  | internalLinkTypeUserPhoneNumber
  | internalLinkTypeVideoChat;

/**
 * Any of:
 * - {@link internalLinkTypeActiveSessions$Input}
 * - {@link internalLinkTypeAttachmentMenuBot$Input}
 * - {@link internalLinkTypeAuthenticationCode$Input}
 * - {@link internalLinkTypeBackground$Input}
 * - {@link internalLinkTypeBotStart$Input}
 * - {@link internalLinkTypeBotStartInGroup$Input}
 * - {@link internalLinkTypeBotAddToChannel$Input}
 * - {@link internalLinkTypeChangePhoneNumber$Input}
 * - {@link internalLinkTypeChatInvite$Input}
 * - {@link internalLinkTypeFilterSettings$Input}
 * - {@link internalLinkTypeGame$Input}
 * - {@link internalLinkTypeInstantView$Input}
 * - {@link internalLinkTypeInvoice$Input}
 * - {@link internalLinkTypeLanguagePack$Input}
 * - {@link internalLinkTypeLanguageSettings$Input}
 * - {@link internalLinkTypeMessage$Input}
 * - {@link internalLinkTypeMessageDraft$Input}
 * - {@link internalLinkTypePassportDataRequest$Input}
 * - {@link internalLinkTypePhoneNumberConfirmation$Input}
 * - {@link internalLinkTypePremiumFeatures$Input}
 * - {@link internalLinkTypePrivacyAndSecuritySettings$Input}
 * - {@link internalLinkTypeProxy$Input}
 * - {@link internalLinkTypePublicChat$Input}
 * - {@link internalLinkTypeQrCodeAuthentication$Input}
 * - {@link internalLinkTypeRestorePurchases$Input}
 * - {@link internalLinkTypeSettings$Input}
 * - {@link internalLinkTypeStickerSet$Input}
 * - {@link internalLinkTypeTheme$Input}
 * - {@link internalLinkTypeThemeSettings$Input}
 * - {@link internalLinkTypeUnknownDeepLink$Input}
 * - {@link internalLinkTypeUnsupportedProxy$Input}
 * - {@link internalLinkTypeUserPhoneNumber$Input}
 * - {@link internalLinkTypeVideoChat$Input}
 */
export type InternalLinkType$Input =
  | internalLinkTypeActiveSessions$Input
  | internalLinkTypeAttachmentMenuBot$Input
  | internalLinkTypeAuthenticationCode$Input
  | internalLinkTypeBackground$Input
  | internalLinkTypeBotStart$Input
  | internalLinkTypeBotStartInGroup$Input
  | internalLinkTypeBotAddToChannel$Input
  | internalLinkTypeChangePhoneNumber$Input
  | internalLinkTypeChatInvite$Input
  | internalLinkTypeFilterSettings$Input
  | internalLinkTypeGame$Input
  | internalLinkTypeInstantView$Input
  | internalLinkTypeInvoice$Input
  | internalLinkTypeLanguagePack$Input
  | internalLinkTypeLanguageSettings$Input
  | internalLinkTypeMessage$Input
  | internalLinkTypeMessageDraft$Input
  | internalLinkTypePassportDataRequest$Input
  | internalLinkTypePhoneNumberConfirmation$Input
  | internalLinkTypePremiumFeatures$Input
  | internalLinkTypePrivacyAndSecuritySettings$Input
  | internalLinkTypeProxy$Input
  | internalLinkTypePublicChat$Input
  | internalLinkTypeQrCodeAuthentication$Input
  | internalLinkTypeRestorePurchases$Input
  | internalLinkTypeSettings$Input
  | internalLinkTypeStickerSet$Input
  | internalLinkTypeTheme$Input
  | internalLinkTypeThemeSettings$Input
  | internalLinkTypeUnknownDeepLink$Input
  | internalLinkTypeUnsupportedProxy$Input
  | internalLinkTypeUserPhoneNumber$Input
  | internalLinkTypeVideoChat$Input;

/**
 * Any of:
 * - {@link messageLink}
 */
export type MessageLink = messageLink;

/**
 * Any of:
 * - {@link messageLink$Input}
 */
export type MessageLink$Input = messageLink$Input;

/**
 * Any of:
 * - {@link messageLinkInfo}
 */
export type MessageLinkInfo = messageLinkInfo;

/**
 * Any of:
 * - {@link messageLinkInfo$Input}
 */
export type MessageLinkInfo$Input = messageLinkInfo$Input;

/**
 * Any of:
 * - {@link filePart}
 */
export type FilePart = filePart;

/**
 * Any of:
 * - {@link filePart$Input}
 */
export type FilePart$Input = filePart$Input;

/**
 * Any of:
 * - {@link fileTypeNone}
 * - {@link fileTypeAnimation}
 * - {@link fileTypeAudio}
 * - {@link fileTypeDocument}
 * - {@link fileTypeNotificationSound}
 * - {@link fileTypePhoto}
 * - {@link fileTypeProfilePhoto}
 * - {@link fileTypeSecret}
 * - {@link fileTypeSecretThumbnail}
 * - {@link fileTypeSecure}
 * - {@link fileTypeSticker}
 * - {@link fileTypeThumbnail}
 * - {@link fileTypeUnknown}
 * - {@link fileTypeVideo}
 * - {@link fileTypeVideoNote}
 * - {@link fileTypeVoiceNote}
 * - {@link fileTypeWallpaper}
 */
export type FileType =
  | fileTypeNone
  | fileTypeAnimation
  | fileTypeAudio
  | fileTypeDocument
  | fileTypeNotificationSound
  | fileTypePhoto
  | fileTypeProfilePhoto
  | fileTypeSecret
  | fileTypeSecretThumbnail
  | fileTypeSecure
  | fileTypeSticker
  | fileTypeThumbnail
  | fileTypeUnknown
  | fileTypeVideo
  | fileTypeVideoNote
  | fileTypeVoiceNote
  | fileTypeWallpaper;

/**
 * Any of:
 * - {@link fileTypeNone$Input}
 * - {@link fileTypeAnimation$Input}
 * - {@link fileTypeAudio$Input}
 * - {@link fileTypeDocument$Input}
 * - {@link fileTypeNotificationSound$Input}
 * - {@link fileTypePhoto$Input}
 * - {@link fileTypeProfilePhoto$Input}
 * - {@link fileTypeSecret$Input}
 * - {@link fileTypeSecretThumbnail$Input}
 * - {@link fileTypeSecure$Input}
 * - {@link fileTypeSticker$Input}
 * - {@link fileTypeThumbnail$Input}
 * - {@link fileTypeUnknown$Input}
 * - {@link fileTypeVideo$Input}
 * - {@link fileTypeVideoNote$Input}
 * - {@link fileTypeVoiceNote$Input}
 * - {@link fileTypeWallpaper$Input}
 */
export type FileType$Input =
  | fileTypeNone$Input
  | fileTypeAnimation$Input
  | fileTypeAudio$Input
  | fileTypeDocument$Input
  | fileTypeNotificationSound$Input
  | fileTypePhoto$Input
  | fileTypeProfilePhoto$Input
  | fileTypeSecret$Input
  | fileTypeSecretThumbnail$Input
  | fileTypeSecure$Input
  | fileTypeSticker$Input
  | fileTypeThumbnail$Input
  | fileTypeUnknown$Input
  | fileTypeVideo$Input
  | fileTypeVideoNote$Input
  | fileTypeVoiceNote$Input
  | fileTypeWallpaper$Input;

/**
 * Any of:
 * - {@link storageStatisticsByFileType}
 */
export type StorageStatisticsByFileType = storageStatisticsByFileType;

/**
 * Any of:
 * - {@link storageStatisticsByFileType$Input}
 */
export type StorageStatisticsByFileType$Input = storageStatisticsByFileType$Input;

/**
 * Any of:
 * - {@link storageStatisticsByChat}
 */
export type StorageStatisticsByChat = storageStatisticsByChat;

/**
 * Any of:
 * - {@link storageStatisticsByChat$Input}
 */
export type StorageStatisticsByChat$Input = storageStatisticsByChat$Input;

/**
 * Any of:
 * - {@link storageStatistics}
 */
export type StorageStatistics = storageStatistics;

/**
 * Any of:
 * - {@link storageStatistics$Input}
 */
export type StorageStatistics$Input = storageStatistics$Input;

/**
 * Any of:
 * - {@link storageStatisticsFast}
 */
export type StorageStatisticsFast = storageStatisticsFast;

/**
 * Any of:
 * - {@link storageStatisticsFast$Input}
 */
export type StorageStatisticsFast$Input = storageStatisticsFast$Input;

/**
 * Any of:
 * - {@link databaseStatistics}
 */
export type DatabaseStatistics = databaseStatistics;

/**
 * Any of:
 * - {@link databaseStatistics$Input}
 */
export type DatabaseStatistics$Input = databaseStatistics$Input;

/**
 * Any of:
 * - {@link networkTypeNone}
 * - {@link networkTypeMobile}
 * - {@link networkTypeMobileRoaming}
 * - {@link networkTypeWiFi}
 * - {@link networkTypeOther}
 */
export type NetworkType =
  | networkTypeNone
  | networkTypeMobile
  | networkTypeMobileRoaming
  | networkTypeWiFi
  | networkTypeOther;

/**
 * Any of:
 * - {@link networkTypeNone$Input}
 * - {@link networkTypeMobile$Input}
 * - {@link networkTypeMobileRoaming$Input}
 * - {@link networkTypeWiFi$Input}
 * - {@link networkTypeOther$Input}
 */
export type NetworkType$Input =
  | networkTypeNone$Input
  | networkTypeMobile$Input
  | networkTypeMobileRoaming$Input
  | networkTypeWiFi$Input
  | networkTypeOther$Input;

/**
 * Any of:
 * - {@link networkStatisticsEntryFile}
 * - {@link networkStatisticsEntryCall}
 */
export type NetworkStatisticsEntry =
  | networkStatisticsEntryFile
  | networkStatisticsEntryCall;

/**
 * Any of:
 * - {@link networkStatisticsEntryFile$Input}
 * - {@link networkStatisticsEntryCall$Input}
 */
export type NetworkStatisticsEntry$Input =
  | networkStatisticsEntryFile$Input
  | networkStatisticsEntryCall$Input;

/**
 * Any of:
 * - {@link networkStatistics}
 */
export type NetworkStatistics = networkStatistics;

/**
 * Any of:
 * - {@link networkStatistics$Input}
 */
export type NetworkStatistics$Input = networkStatistics$Input;

/**
 * Any of:
 * - {@link autoDownloadSettings}
 */
export type AutoDownloadSettings = autoDownloadSettings;

/**
 * Any of:
 * - {@link autoDownloadSettings$Input}
 */
export type AutoDownloadSettings$Input = autoDownloadSettings$Input;

/**
 * Any of:
 * - {@link autoDownloadSettingsPresets}
 */
export type AutoDownloadSettingsPresets = autoDownloadSettingsPresets;

/**
 * Any of:
 * - {@link autoDownloadSettingsPresets$Input}
 */
export type AutoDownloadSettingsPresets$Input = autoDownloadSettingsPresets$Input;

/**
 * Any of:
 * - {@link connectionStateWaitingForNetwork}
 * - {@link connectionStateConnectingToProxy}
 * - {@link connectionStateConnecting}
 * - {@link connectionStateUpdating}
 * - {@link connectionStateReady}
 */
export type ConnectionState =
  | connectionStateWaitingForNetwork
  | connectionStateConnectingToProxy
  | connectionStateConnecting
  | connectionStateUpdating
  | connectionStateReady;

/**
 * Any of:
 * - {@link connectionStateWaitingForNetwork$Input}
 * - {@link connectionStateConnectingToProxy$Input}
 * - {@link connectionStateConnecting$Input}
 * - {@link connectionStateUpdating$Input}
 * - {@link connectionStateReady$Input}
 */
export type ConnectionState$Input =
  | connectionStateWaitingForNetwork$Input
  | connectionStateConnectingToProxy$Input
  | connectionStateConnecting$Input
  | connectionStateUpdating$Input
  | connectionStateReady$Input;

/**
 * Any of:
 * - {@link topChatCategoryUsers}
 * - {@link topChatCategoryBots}
 * - {@link topChatCategoryGroups}
 * - {@link topChatCategoryChannels}
 * - {@link topChatCategoryInlineBots}
 * - {@link topChatCategoryCalls}
 * - {@link topChatCategoryForwardChats}
 */
export type TopChatCategory =
  | topChatCategoryUsers
  | topChatCategoryBots
  | topChatCategoryGroups
  | topChatCategoryChannels
  | topChatCategoryInlineBots
  | topChatCategoryCalls
  | topChatCategoryForwardChats;

/**
 * Any of:
 * - {@link topChatCategoryUsers$Input}
 * - {@link topChatCategoryBots$Input}
 * - {@link topChatCategoryGroups$Input}
 * - {@link topChatCategoryChannels$Input}
 * - {@link topChatCategoryInlineBots$Input}
 * - {@link topChatCategoryCalls$Input}
 * - {@link topChatCategoryForwardChats$Input}
 */
export type TopChatCategory$Input =
  | topChatCategoryUsers$Input
  | topChatCategoryBots$Input
  | topChatCategoryGroups$Input
  | topChatCategoryChannels$Input
  | topChatCategoryInlineBots$Input
  | topChatCategoryCalls$Input
  | topChatCategoryForwardChats$Input;

/**
 * Any of:
 * - {@link tMeUrlTypeUser}
 * - {@link tMeUrlTypeSupergroup}
 * - {@link tMeUrlTypeChatInvite}
 * - {@link tMeUrlTypeStickerSet}
 */
export type TMeUrlType =
  | tMeUrlTypeUser
  | tMeUrlTypeSupergroup
  | tMeUrlTypeChatInvite
  | tMeUrlTypeStickerSet;

/**
 * Any of:
 * - {@link tMeUrlTypeUser$Input}
 * - {@link tMeUrlTypeSupergroup$Input}
 * - {@link tMeUrlTypeChatInvite$Input}
 * - {@link tMeUrlTypeStickerSet$Input}
 */
export type TMeUrlType$Input =
  | tMeUrlTypeUser$Input
  | tMeUrlTypeSupergroup$Input
  | tMeUrlTypeChatInvite$Input
  | tMeUrlTypeStickerSet$Input;

/**
 * Any of:
 * - {@link tMeUrl}
 */
export type TMeUrl = tMeUrl;

/**
 * Any of:
 * - {@link tMeUrl$Input}
 */
export type TMeUrl$Input = tMeUrl$Input;

/**
 * Any of:
 * - {@link tMeUrls}
 */
export type TMeUrls = tMeUrls;

/**
 * Any of:
 * - {@link tMeUrls$Input}
 */
export type TMeUrls$Input = tMeUrls$Input;

/**
 * Any of:
 * - {@link suggestedActionEnableArchiveAndMuteNewChats}
 * - {@link suggestedActionCheckPassword}
 * - {@link suggestedActionCheckPhoneNumber}
 * - {@link suggestedActionViewChecksHint}
 * - {@link suggestedActionConvertToBroadcastGroup}
 * - {@link suggestedActionSetPassword}
 */
export type SuggestedAction =
  | suggestedActionEnableArchiveAndMuteNewChats
  | suggestedActionCheckPassword
  | suggestedActionCheckPhoneNumber
  | suggestedActionViewChecksHint
  | suggestedActionConvertToBroadcastGroup
  | suggestedActionSetPassword;

/**
 * Any of:
 * - {@link suggestedActionEnableArchiveAndMuteNewChats$Input}
 * - {@link suggestedActionCheckPassword$Input}
 * - {@link suggestedActionCheckPhoneNumber$Input}
 * - {@link suggestedActionViewChecksHint$Input}
 * - {@link suggestedActionConvertToBroadcastGroup$Input}
 * - {@link suggestedActionSetPassword$Input}
 */
export type SuggestedAction$Input =
  | suggestedActionEnableArchiveAndMuteNewChats$Input
  | suggestedActionCheckPassword$Input
  | suggestedActionCheckPhoneNumber$Input
  | suggestedActionViewChecksHint$Input
  | suggestedActionConvertToBroadcastGroup$Input
  | suggestedActionSetPassword$Input;

/**
 * Any of:
 * - {@link count}
 */
export type Count = count;

/**
 * Any of:
 * - {@link count$Input}
 */
export type Count$Input = count$Input;

/**
 * Any of:
 * - {@link text}
 */
export type Text = text;

/**
 * Any of:
 * - {@link text$Input}
 */
export type Text$Input = text$Input;

/**
 * Any of:
 * - {@link seconds}
 */
export type Seconds = seconds;

/**
 * Any of:
 * - {@link seconds$Input}
 */
export type Seconds$Input = seconds$Input;

/**
 * Any of:
 * - {@link fileDownloadedPrefixSize}
 */
export type FileDownloadedPrefixSize = fileDownloadedPrefixSize;

/**
 * Any of:
 * - {@link fileDownloadedPrefixSize$Input}
 */
export type FileDownloadedPrefixSize$Input = fileDownloadedPrefixSize$Input;

/**
 * Any of:
 * - {@link deepLinkInfo}
 */
export type DeepLinkInfo = deepLinkInfo;

/**
 * Any of:
 * - {@link deepLinkInfo$Input}
 */
export type DeepLinkInfo$Input = deepLinkInfo$Input;

/**
 * Any of:
 * - {@link textParseModeMarkdown}
 * - {@link textParseModeHTML}
 */
export type TextParseMode = textParseModeMarkdown | textParseModeHTML;

/**
 * Any of:
 * - {@link textParseModeMarkdown$Input}
 * - {@link textParseModeHTML$Input}
 */
export type TextParseMode$Input =
  | textParseModeMarkdown$Input
  | textParseModeHTML$Input;

/**
 * Any of:
 * - {@link proxyTypeSocks5}
 * - {@link proxyTypeHttp}
 * - {@link proxyTypeMtproto}
 */
export type ProxyType = proxyTypeSocks5 | proxyTypeHttp | proxyTypeMtproto;

/**
 * Any of:
 * - {@link proxyTypeSocks5$Input}
 * - {@link proxyTypeHttp$Input}
 * - {@link proxyTypeMtproto$Input}
 */
export type ProxyType$Input =
  | proxyTypeSocks5$Input
  | proxyTypeHttp$Input
  | proxyTypeMtproto$Input;

/**
 * Any of:
 * - {@link proxy}
 */
export type Proxy = proxy;

/**
 * Any of:
 * - {@link proxy$Input}
 */
export type Proxy$Input = proxy$Input;

/**
 * Any of:
 * - {@link proxies}
 */
export type Proxies = proxies;

/**
 * Any of:
 * - {@link proxies$Input}
 */
export type Proxies$Input = proxies$Input;

/**
 * Any of:
 * - {@link inputSticker}
 */
export type InputSticker = inputSticker;

/**
 * Any of:
 * - {@link inputSticker$Input}
 */
export type InputSticker$Input = inputSticker$Input;

/**
 * Any of:
 * - {@link dateRange}
 */
export type DateRange = dateRange;

/**
 * Any of:
 * - {@link dateRange$Input}
 */
export type DateRange$Input = dateRange$Input;

/**
 * Any of:
 * - {@link statisticalValue}
 */
export type StatisticalValue = statisticalValue;

/**
 * Any of:
 * - {@link statisticalValue$Input}
 */
export type StatisticalValue$Input = statisticalValue$Input;

/**
 * Any of:
 * - {@link statisticalGraphData}
 * - {@link statisticalGraphAsync}
 * - {@link statisticalGraphError}
 */
export type StatisticalGraph =
  | statisticalGraphData
  | statisticalGraphAsync
  | statisticalGraphError;

/**
 * Any of:
 * - {@link statisticalGraphData$Input}
 * - {@link statisticalGraphAsync$Input}
 * - {@link statisticalGraphError$Input}
 */
export type StatisticalGraph$Input =
  | statisticalGraphData$Input
  | statisticalGraphAsync$Input
  | statisticalGraphError$Input;

/**
 * Any of:
 * - {@link chatStatisticsMessageInteractionInfo}
 */
export type ChatStatisticsMessageInteractionInfo =
  chatStatisticsMessageInteractionInfo;

/**
 * Any of:
 * - {@link chatStatisticsMessageInteractionInfo$Input}
 */
export type ChatStatisticsMessageInteractionInfo$Input =
  chatStatisticsMessageInteractionInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsMessageSenderInfo}
 */
export type ChatStatisticsMessageSenderInfo = chatStatisticsMessageSenderInfo;

/**
 * Any of:
 * - {@link chatStatisticsMessageSenderInfo$Input}
 */
export type ChatStatisticsMessageSenderInfo$Input =
  chatStatisticsMessageSenderInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsAdministratorActionsInfo}
 */
export type ChatStatisticsAdministratorActionsInfo =
  chatStatisticsAdministratorActionsInfo;

/**
 * Any of:
 * - {@link chatStatisticsAdministratorActionsInfo$Input}
 */
export type ChatStatisticsAdministratorActionsInfo$Input =
  chatStatisticsAdministratorActionsInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsInviterInfo}
 */
export type ChatStatisticsInviterInfo = chatStatisticsInviterInfo;

/**
 * Any of:
 * - {@link chatStatisticsInviterInfo$Input}
 */
export type ChatStatisticsInviterInfo$Input = chatStatisticsInviterInfo$Input;

/**
 * Any of:
 * - {@link chatStatisticsSupergroup}
 * - {@link chatStatisticsChannel}
 */
export type ChatStatistics = chatStatisticsSupergroup | chatStatisticsChannel;

/**
 * Any of:
 * - {@link chatStatisticsSupergroup$Input}
 * - {@link chatStatisticsChannel$Input}
 */
export type ChatStatistics$Input =
  | chatStatisticsSupergroup$Input
  | chatStatisticsChannel$Input;

/**
 * Any of:
 * - {@link messageStatistics}
 */
export type MessageStatistics = messageStatistics;

/**
 * Any of:
 * - {@link messageStatistics$Input}
 */
export type MessageStatistics$Input = messageStatistics$Input;

/**
 * Any of:
 * - {@link point}
 */
export type Point = point;

/**
 * Any of:
 * - {@link point$Input}
 */
export type Point$Input = point$Input;

/**
 * Any of:
 * - {@link vectorPathCommandLine}
 * - {@link vectorPathCommandCubicBezierCurve}
 */
export type VectorPathCommand =
  | vectorPathCommandLine
  | vectorPathCommandCubicBezierCurve;

/**
 * Any of:
 * - {@link vectorPathCommandLine$Input}
 * - {@link vectorPathCommandCubicBezierCurve$Input}
 */
export type VectorPathCommand$Input =
  | vectorPathCommandLine$Input
  | vectorPathCommandCubicBezierCurve$Input;

/**
 * Any of:
 * - {@link botCommandScopeDefault}
 * - {@link botCommandScopeAllPrivateChats}
 * - {@link botCommandScopeAllGroupChats}
 * - {@link botCommandScopeAllChatAdministrators}
 * - {@link botCommandScopeChat}
 * - {@link botCommandScopeChatAdministrators}
 * - {@link botCommandScopeChatMember}
 */
export type BotCommandScope =
  | botCommandScopeDefault
  | botCommandScopeAllPrivateChats
  | botCommandScopeAllGroupChats
  | botCommandScopeAllChatAdministrators
  | botCommandScopeChat
  | botCommandScopeChatAdministrators
  | botCommandScopeChatMember;

/**
 * Any of:
 * - {@link botCommandScopeDefault$Input}
 * - {@link botCommandScopeAllPrivateChats$Input}
 * - {@link botCommandScopeAllGroupChats$Input}
 * - {@link botCommandScopeAllChatAdministrators$Input}
 * - {@link botCommandScopeChat$Input}
 * - {@link botCommandScopeChatAdministrators$Input}
 * - {@link botCommandScopeChatMember$Input}
 */
export type BotCommandScope$Input =
  | botCommandScopeDefault$Input
  | botCommandScopeAllPrivateChats$Input
  | botCommandScopeAllGroupChats$Input
  | botCommandScopeAllChatAdministrators$Input
  | botCommandScopeChat$Input
  | botCommandScopeChatAdministrators$Input
  | botCommandScopeChatMember$Input;

/**
 * Any of:
 * - {@link updateAuthorizationState}
 * - {@link updateNewMessage}
 * - {@link updateMessageSendAcknowledged}
 * - {@link updateMessageSendSucceeded}
 * - {@link updateMessageSendFailed}
 * - {@link updateMessageContent}
 * - {@link updateMessageEdited}
 * - {@link updateMessageIsPinned}
 * - {@link updateMessageInteractionInfo}
 * - {@link updateMessageContentOpened}
 * - {@link updateMessageMentionRead}
 * - {@link updateMessageUnreadReactions}
 * - {@link updateMessageLiveLocationViewed}
 * - {@link updateNewChat}
 * - {@link updateChatTitle}
 * - {@link updateChatPhoto}
 * - {@link updateChatPermissions}
 * - {@link updateChatLastMessage}
 * - {@link updateChatPosition}
 * - {@link updateChatReadInbox}
 * - {@link updateChatReadOutbox}
 * - {@link updateChatActionBar}
 * - {@link updateChatAvailableReactions}
 * - {@link updateChatDraftMessage}
 * - {@link updateChatMessageSender}
 * - {@link updateChatMessageTtl}
 * - {@link updateChatNotificationSettings}
 * - {@link updateChatPendingJoinRequests}
 * - {@link updateChatReplyMarkup}
 * - {@link updateChatTheme}
 * - {@link updateChatUnreadMentionCount}
 * - {@link updateChatUnreadReactionCount}
 * - {@link updateChatVideoChat}
 * - {@link updateChatDefaultDisableNotification}
 * - {@link updateChatHasProtectedContent}
 * - {@link updateChatHasScheduledMessages}
 * - {@link updateChatIsBlocked}
 * - {@link updateChatIsMarkedAsUnread}
 * - {@link updateChatFilters}
 * - {@link updateChatOnlineMemberCount}
 * - {@link updateForumTopicInfo}
 * - {@link updateScopeNotificationSettings}
 * - {@link updateNotification}
 * - {@link updateNotificationGroup}
 * - {@link updateActiveNotifications}
 * - {@link updateHavePendingNotifications}
 * - {@link updateDeleteMessages}
 * - {@link updateChatAction}
 * - {@link updateUserStatus}
 * - {@link updateUser}
 * - {@link updateBasicGroup}
 * - {@link updateSupergroup}
 * - {@link updateSecretChat}
 * - {@link updateUserFullInfo}
 * - {@link updateBasicGroupFullInfo}
 * - {@link updateSupergroupFullInfo}
 * - {@link updateServiceNotification}
 * - {@link updateFile}
 * - {@link updateFileGenerationStart}
 * - {@link updateFileGenerationStop}
 * - {@link updateFileDownloads}
 * - {@link updateFileAddedToDownloads}
 * - {@link updateFileDownload}
 * - {@link updateFileRemovedFromDownloads}
 * - {@link updateCall}
 * - {@link updateGroupCall}
 * - {@link updateGroupCallParticipant}
 * - {@link updateNewCallSignalingData}
 * - {@link updateUserPrivacySettingRules}
 * - {@link updateUnreadMessageCount}
 * - {@link updateUnreadChatCount}
 * - {@link updateOption}
 * - {@link updateStickerSet}
 * - {@link updateInstalledStickerSets}
 * - {@link updateTrendingStickerSets}
 * - {@link updateRecentStickers}
 * - {@link updateFavoriteStickers}
 * - {@link updateSavedAnimations}
 * - {@link updateSavedNotificationSounds}
 * - {@link updateSelectedBackground}
 * - {@link updateChatThemes}
 * - {@link updateLanguagePackStrings}
 * - {@link updateConnectionState}
 * - {@link updateTermsOfService}
 * - {@link updateUsersNearby}
 * - {@link updateAttachmentMenuBots}
 * - {@link updateWebAppMessageSent}
 * - {@link updateActiveEmojiReactions}
 * - {@link updateDefaultReactionType}
 * - {@link updateDiceEmojis}
 * - {@link updateAnimatedEmojiMessageClicked}
 * - {@link updateAnimationSearchParameters}
 * - {@link updateSuggestedActions}
 * - {@link updateNewInlineQuery}
 * - {@link updateNewChosenInlineResult}
 * - {@link updateNewCallbackQuery}
 * - {@link updateNewInlineCallbackQuery}
 * - {@link updateNewShippingQuery}
 * - {@link updateNewPreCheckoutQuery}
 * - {@link updateNewCustomEvent}
 * - {@link updateNewCustomQuery}
 * - {@link updatePoll}
 * - {@link updatePollAnswer}
 * - {@link updateChatMember}
 * - {@link updateNewChatJoinRequest}
 */
export type Update =
  | updateAuthorizationState
  | updateNewMessage
  | updateMessageSendAcknowledged
  | updateMessageSendSucceeded
  | updateMessageSendFailed
  | updateMessageContent
  | updateMessageEdited
  | updateMessageIsPinned
  | updateMessageInteractionInfo
  | updateMessageContentOpened
  | updateMessageMentionRead
  | updateMessageUnreadReactions
  | updateMessageLiveLocationViewed
  | updateNewChat
  | updateChatTitle
  | updateChatPhoto
  | updateChatPermissions
  | updateChatLastMessage
  | updateChatPosition
  | updateChatReadInbox
  | updateChatReadOutbox
  | updateChatActionBar
  | updateChatAvailableReactions
  | updateChatDraftMessage
  | updateChatMessageSender
  | updateChatMessageTtl
  | updateChatNotificationSettings
  | updateChatPendingJoinRequests
  | updateChatReplyMarkup
  | updateChatTheme
  | updateChatUnreadMentionCount
  | updateChatUnreadReactionCount
  | updateChatVideoChat
  | updateChatDefaultDisableNotification
  | updateChatHasProtectedContent
  | updateChatHasScheduledMessages
  | updateChatIsBlocked
  | updateChatIsMarkedAsUnread
  | updateChatFilters
  | updateChatOnlineMemberCount
  | updateForumTopicInfo
  | updateScopeNotificationSettings
  | updateNotification
  | updateNotificationGroup
  | updateActiveNotifications
  | updateHavePendingNotifications
  | updateDeleteMessages
  | updateChatAction
  | updateUserStatus
  | updateUser
  | updateBasicGroup
  | updateSupergroup
  | updateSecretChat
  | updateUserFullInfo
  | updateBasicGroupFullInfo
  | updateSupergroupFullInfo
  | updateServiceNotification
  | updateFile
  | updateFileGenerationStart
  | updateFileGenerationStop
  | updateFileDownloads
  | updateFileAddedToDownloads
  | updateFileDownload
  | updateFileRemovedFromDownloads
  | updateCall
  | updateGroupCall
  | updateGroupCallParticipant
  | updateNewCallSignalingData
  | updateUserPrivacySettingRules
  | updateUnreadMessageCount
  | updateUnreadChatCount
  | updateOption
  | updateStickerSet
  | updateInstalledStickerSets
  | updateTrendingStickerSets
  | updateRecentStickers
  | updateFavoriteStickers
  | updateSavedAnimations
  | updateSavedNotificationSounds
  | updateSelectedBackground
  | updateChatThemes
  | updateLanguagePackStrings
  | updateConnectionState
  | updateTermsOfService
  | updateUsersNearby
  | updateAttachmentMenuBots
  | updateWebAppMessageSent
  | updateActiveEmojiReactions
  | updateDefaultReactionType
  | updateDiceEmojis
  | updateAnimatedEmojiMessageClicked
  | updateAnimationSearchParameters
  | updateSuggestedActions
  | updateNewInlineQuery
  | updateNewChosenInlineResult
  | updateNewCallbackQuery
  | updateNewInlineCallbackQuery
  | updateNewShippingQuery
  | updateNewPreCheckoutQuery
  | updateNewCustomEvent
  | updateNewCustomQuery
  | updatePoll
  | updatePollAnswer
  | updateChatMember
  | updateNewChatJoinRequest;

/**
 * Any of:
 * - {@link updateAuthorizationState$Input}
 * - {@link updateNewMessage$Input}
 * - {@link updateMessageSendAcknowledged$Input}
 * - {@link updateMessageSendSucceeded$Input}
 * - {@link updateMessageSendFailed$Input}
 * - {@link updateMessageContent$Input}
 * - {@link updateMessageEdited$Input}
 * - {@link updateMessageIsPinned$Input}
 * - {@link updateMessageInteractionInfo$Input}
 * - {@link updateMessageContentOpened$Input}
 * - {@link updateMessageMentionRead$Input}
 * - {@link updateMessageUnreadReactions$Input}
 * - {@link updateMessageLiveLocationViewed$Input}
 * - {@link updateNewChat$Input}
 * - {@link updateChatTitle$Input}
 * - {@link updateChatPhoto$Input}
 * - {@link updateChatPermissions$Input}
 * - {@link updateChatLastMessage$Input}
 * - {@link updateChatPosition$Input}
 * - {@link updateChatReadInbox$Input}
 * - {@link updateChatReadOutbox$Input}
 * - {@link updateChatActionBar$Input}
 * - {@link updateChatAvailableReactions$Input}
 * - {@link updateChatDraftMessage$Input}
 * - {@link updateChatMessageSender$Input}
 * - {@link updateChatMessageTtl$Input}
 * - {@link updateChatNotificationSettings$Input}
 * - {@link updateChatPendingJoinRequests$Input}
 * - {@link updateChatReplyMarkup$Input}
 * - {@link updateChatTheme$Input}
 * - {@link updateChatUnreadMentionCount$Input}
 * - {@link updateChatUnreadReactionCount$Input}
 * - {@link updateChatVideoChat$Input}
 * - {@link updateChatDefaultDisableNotification$Input}
 * - {@link updateChatHasProtectedContent$Input}
 * - {@link updateChatHasScheduledMessages$Input}
 * - {@link updateChatIsBlocked$Input}
 * - {@link updateChatIsMarkedAsUnread$Input}
 * - {@link updateChatFilters$Input}
 * - {@link updateChatOnlineMemberCount$Input}
 * - {@link updateForumTopicInfo$Input}
 * - {@link updateScopeNotificationSettings$Input}
 * - {@link updateNotification$Input}
 * - {@link updateNotificationGroup$Input}
 * - {@link updateActiveNotifications$Input}
 * - {@link updateHavePendingNotifications$Input}
 * - {@link updateDeleteMessages$Input}
 * - {@link updateChatAction$Input}
 * - {@link updateUserStatus$Input}
 * - {@link updateUser$Input}
 * - {@link updateBasicGroup$Input}
 * - {@link updateSupergroup$Input}
 * - {@link updateSecretChat$Input}
 * - {@link updateUserFullInfo$Input}
 * - {@link updateBasicGroupFullInfo$Input}
 * - {@link updateSupergroupFullInfo$Input}
 * - {@link updateServiceNotification$Input}
 * - {@link updateFile$Input}
 * - {@link updateFileGenerationStart$Input}
 * - {@link updateFileGenerationStop$Input}
 * - {@link updateFileDownloads$Input}
 * - {@link updateFileAddedToDownloads$Input}
 * - {@link updateFileDownload$Input}
 * - {@link updateFileRemovedFromDownloads$Input}
 * - {@link updateCall$Input}
 * - {@link updateGroupCall$Input}
 * - {@link updateGroupCallParticipant$Input}
 * - {@link updateNewCallSignalingData$Input}
 * - {@link updateUserPrivacySettingRules$Input}
 * - {@link updateUnreadMessageCount$Input}
 * - {@link updateUnreadChatCount$Input}
 * - {@link updateOption$Input}
 * - {@link updateStickerSet$Input}
 * - {@link updateInstalledStickerSets$Input}
 * - {@link updateTrendingStickerSets$Input}
 * - {@link updateRecentStickers$Input}
 * - {@link updateFavoriteStickers$Input}
 * - {@link updateSavedAnimations$Input}
 * - {@link updateSavedNotificationSounds$Input}
 * - {@link updateSelectedBackground$Input}
 * - {@link updateChatThemes$Input}
 * - {@link updateLanguagePackStrings$Input}
 * - {@link updateConnectionState$Input}
 * - {@link updateTermsOfService$Input}
 * - {@link updateUsersNearby$Input}
 * - {@link updateAttachmentMenuBots$Input}
 * - {@link updateWebAppMessageSent$Input}
 * - {@link updateActiveEmojiReactions$Input}
 * - {@link updateDefaultReactionType$Input}
 * - {@link updateDiceEmojis$Input}
 * - {@link updateAnimatedEmojiMessageClicked$Input}
 * - {@link updateAnimationSearchParameters$Input}
 * - {@link updateSuggestedActions$Input}
 * - {@link updateNewInlineQuery$Input}
 * - {@link updateNewChosenInlineResult$Input}
 * - {@link updateNewCallbackQuery$Input}
 * - {@link updateNewInlineCallbackQuery$Input}
 * - {@link updateNewShippingQuery$Input}
 * - {@link updateNewPreCheckoutQuery$Input}
 * - {@link updateNewCustomEvent$Input}
 * - {@link updateNewCustomQuery$Input}
 * - {@link updatePoll$Input}
 * - {@link updatePollAnswer$Input}
 * - {@link updateChatMember$Input}
 * - {@link updateNewChatJoinRequest$Input}
 */
export type Update$Input =
  | updateAuthorizationState$Input
  | updateNewMessage$Input
  | updateMessageSendAcknowledged$Input
  | updateMessageSendSucceeded$Input
  | updateMessageSendFailed$Input
  | updateMessageContent$Input
  | updateMessageEdited$Input
  | updateMessageIsPinned$Input
  | updateMessageInteractionInfo$Input
  | updateMessageContentOpened$Input
  | updateMessageMentionRead$Input
  | updateMessageUnreadReactions$Input
  | updateMessageLiveLocationViewed$Input
  | updateNewChat$Input
  | updateChatTitle$Input
  | updateChatPhoto$Input
  | updateChatPermissions$Input
  | updateChatLastMessage$Input
  | updateChatPosition$Input
  | updateChatReadInbox$Input
  | updateChatReadOutbox$Input
  | updateChatActionBar$Input
  | updateChatAvailableReactions$Input
  | updateChatDraftMessage$Input
  | updateChatMessageSender$Input
  | updateChatMessageTtl$Input
  | updateChatNotificationSettings$Input
  | updateChatPendingJoinRequests$Input
  | updateChatReplyMarkup$Input
  | updateChatTheme$Input
  | updateChatUnreadMentionCount$Input
  | updateChatUnreadReactionCount$Input
  | updateChatVideoChat$Input
  | updateChatDefaultDisableNotification$Input
  | updateChatHasProtectedContent$Input
  | updateChatHasScheduledMessages$Input
  | updateChatIsBlocked$Input
  | updateChatIsMarkedAsUnread$Input
  | updateChatFilters$Input
  | updateChatOnlineMemberCount$Input
  | updateForumTopicInfo$Input
  | updateScopeNotificationSettings$Input
  | updateNotification$Input
  | updateNotificationGroup$Input
  | updateActiveNotifications$Input
  | updateHavePendingNotifications$Input
  | updateDeleteMessages$Input
  | updateChatAction$Input
  | updateUserStatus$Input
  | updateUser$Input
  | updateBasicGroup$Input
  | updateSupergroup$Input
  | updateSecretChat$Input
  | updateUserFullInfo$Input
  | updateBasicGroupFullInfo$Input
  | updateSupergroupFullInfo$Input
  | updateServiceNotification$Input
  | updateFile$Input
  | updateFileGenerationStart$Input
  | updateFileGenerationStop$Input
  | updateFileDownloads$Input
  | updateFileAddedToDownloads$Input
  | updateFileDownload$Input
  | updateFileRemovedFromDownloads$Input
  | updateCall$Input
  | updateGroupCall$Input
  | updateGroupCallParticipant$Input
  | updateNewCallSignalingData$Input
  | updateUserPrivacySettingRules$Input
  | updateUnreadMessageCount$Input
  | updateUnreadChatCount$Input
  | updateOption$Input
  | updateStickerSet$Input
  | updateInstalledStickerSets$Input
  | updateTrendingStickerSets$Input
  | updateRecentStickers$Input
  | updateFavoriteStickers$Input
  | updateSavedAnimations$Input
  | updateSavedNotificationSounds$Input
  | updateSelectedBackground$Input
  | updateChatThemes$Input
  | updateLanguagePackStrings$Input
  | updateConnectionState$Input
  | updateTermsOfService$Input
  | updateUsersNearby$Input
  | updateAttachmentMenuBots$Input
  | updateWebAppMessageSent$Input
  | updateActiveEmojiReactions$Input
  | updateDefaultReactionType$Input
  | updateDiceEmojis$Input
  | updateAnimatedEmojiMessageClicked$Input
  | updateAnimationSearchParameters$Input
  | updateSuggestedActions$Input
  | updateNewInlineQuery$Input
  | updateNewChosenInlineResult$Input
  | updateNewCallbackQuery$Input
  | updateNewInlineCallbackQuery$Input
  | updateNewShippingQuery$Input
  | updateNewPreCheckoutQuery$Input
  | updateNewCustomEvent$Input
  | updateNewCustomQuery$Input
  | updatePoll$Input
  | updatePollAnswer$Input
  | updateChatMember$Input
  | updateNewChatJoinRequest$Input;

/**
 * Any of:
 * - {@link updates}
 */
export type Updates = updates;

/**
 * Any of:
 * - {@link updates$Input}
 */
export type Updates$Input = updates$Input;

/**
 * Any of:
 * - {@link logStreamDefault}
 * - {@link logStreamFile}
 * - {@link logStreamEmpty}
 */
export type LogStream = logStreamDefault | logStreamFile | logStreamEmpty;

/**
 * Any of:
 * - {@link logStreamDefault$Input}
 * - {@link logStreamFile$Input}
 * - {@link logStreamEmpty$Input}
 */
export type LogStream$Input =
  | logStreamDefault$Input
  | logStreamFile$Input
  | logStreamEmpty$Input;

/**
 * Any of:
 * - {@link logVerbosityLevel}
 */
export type LogVerbosityLevel = logVerbosityLevel;

/**
 * Any of:
 * - {@link logVerbosityLevel$Input}
 */
export type LogVerbosityLevel$Input = logVerbosityLevel$Input;

/**
 * Any of:
 * - {@link logTags}
 */
export type LogTags = logTags;

/**
 * Any of:
 * - {@link logTags$Input}
 */
export type LogTags$Input = logTags$Input;

/**
 * Any of:
 * - {@link userSupportInfo}
 */
export type UserSupportInfo = userSupportInfo;

/**
 * Any of:
 * - {@link userSupportInfo$Input}
 */
export type UserSupportInfo$Input = userSupportInfo$Input;

/**
 * Any of:
 * - {@link testInt}
 */
export type TestInt = testInt;

/**
 * Any of:
 * - {@link testInt$Input}
 */
export type TestInt$Input = testInt$Input;

/**
 * Any of:
 * - {@link testString}
 */
export type TestString = testString;

/**
 * Any of:
 * - {@link testString$Input}
 */
export type TestString$Input = testString$Input;

/**
 * Any of:
 * - {@link testBytes}
 */
export type TestBytes = testBytes;

/**
 * Any of:
 * - {@link testBytes$Input}
 */
export type TestBytes$Input = testBytes$Input;

/**
 * Any of:
 * - {@link testVectorInt}
 */
export type TestVectorInt = testVectorInt;

/**
 * Any of:
 * - {@link testVectorInt$Input}
 */
export type TestVectorInt$Input = testVectorInt$Input;

/**
 * Any of:
 * - {@link testVectorIntObject}
 */
export type TestVectorIntObject = testVectorIntObject;

/**
 * Any of:
 * - {@link testVectorIntObject$Input}
 */
export type TestVectorIntObject$Input = testVectorIntObject$Input;

/**
 * Any of:
 * - {@link testVectorString}
 */
export type TestVectorString = testVectorString;

/**
 * Any of:
 * - {@link testVectorString$Input}
 */
export type TestVectorString$Input = testVectorString$Input;

/**
 * Any of:
 * - {@link testVectorStringObject}
 */
export type TestVectorStringObject = testVectorStringObject;

/**
 * Any of:
 * - {@link testVectorStringObject$Input}
 */
export type TestVectorStringObject$Input = testVectorStringObject$Input;

export type __functions = {
  readonly getAuthorizationState: getAuthorizationState;
  readonly setTdlibParameters: setTdlibParameters;
  readonly setAuthenticationPhoneNumber: setAuthenticationPhoneNumber;
  readonly setAuthenticationEmailAddress: setAuthenticationEmailAddress;
  readonly resendAuthenticationCode: resendAuthenticationCode;
  readonly checkAuthenticationEmailCode: checkAuthenticationEmailCode;
  readonly checkAuthenticationCode: checkAuthenticationCode;
  readonly requestQrCodeAuthentication: requestQrCodeAuthentication;
  readonly registerUser: registerUser;
  readonly checkAuthenticationPassword: checkAuthenticationPassword;
  readonly requestAuthenticationPasswordRecovery: requestAuthenticationPasswordRecovery;
  readonly checkAuthenticationPasswordRecoveryCode: checkAuthenticationPasswordRecoveryCode;
  readonly recoverAuthenticationPassword: recoverAuthenticationPassword;
  readonly checkAuthenticationBotToken: checkAuthenticationBotToken;
  readonly logOut: logOut;
  readonly close: close;
  readonly destroy: destroy;
  readonly confirmQrCodeAuthentication: confirmQrCodeAuthentication;
  readonly getCurrentState: getCurrentState;
  readonly setDatabaseEncryptionKey: setDatabaseEncryptionKey;
  readonly getPasswordState: getPasswordState;
  readonly setPassword: setPassword;
  readonly setLoginEmailAddress: setLoginEmailAddress;
  readonly resendLoginEmailAddressCode: resendLoginEmailAddressCode;
  readonly checkLoginEmailAddressCode: checkLoginEmailAddressCode;
  readonly getRecoveryEmailAddress: getRecoveryEmailAddress;
  readonly setRecoveryEmailAddress: setRecoveryEmailAddress;
  readonly checkRecoveryEmailAddressCode: checkRecoveryEmailAddressCode;
  readonly resendRecoveryEmailAddressCode: resendRecoveryEmailAddressCode;
  readonly requestPasswordRecovery: requestPasswordRecovery;
  readonly checkPasswordRecoveryCode: checkPasswordRecoveryCode;
  readonly recoverPassword: recoverPassword;
  readonly resetPassword: resetPassword;
  readonly cancelPasswordReset: cancelPasswordReset;
  readonly createTemporaryPassword: createTemporaryPassword;
  readonly getTemporaryPasswordState: getTemporaryPasswordState;
  readonly getMe: getMe;
  readonly getUser: getUser;
  readonly getUserFullInfo: getUserFullInfo;
  readonly getBasicGroup: getBasicGroup;
  readonly getBasicGroupFullInfo: getBasicGroupFullInfo;
  readonly getSupergroup: getSupergroup;
  readonly getSupergroupFullInfo: getSupergroupFullInfo;
  readonly getSecretChat: getSecretChat;
  readonly getChat: getChat;
  readonly getMessage: getMessage;
  readonly getMessageLocally: getMessageLocally;
  readonly getRepliedMessage: getRepliedMessage;
  readonly getChatPinnedMessage: getChatPinnedMessage;
  readonly getCallbackQueryMessage: getCallbackQueryMessage;
  readonly getMessages: getMessages;
  readonly getMessageThread: getMessageThread;
  readonly getMessageViewers: getMessageViewers;
  readonly getFile: getFile;
  readonly getRemoteFile: getRemoteFile;
  readonly loadChats: loadChats;
  readonly getChats: getChats;
  readonly searchPublicChat: searchPublicChat;
  readonly searchPublicChats: searchPublicChats;
  readonly searchChats: searchChats;
  readonly searchChatsOnServer: searchChatsOnServer;
  readonly searchChatsNearby: searchChatsNearby;
  readonly getTopChats: getTopChats;
  readonly removeTopChat: removeTopChat;
  readonly addRecentlyFoundChat: addRecentlyFoundChat;
  readonly removeRecentlyFoundChat: removeRecentlyFoundChat;
  readonly clearRecentlyFoundChats: clearRecentlyFoundChats;
  readonly getRecentlyOpenedChats: getRecentlyOpenedChats;
  readonly checkChatUsername: checkChatUsername;
  readonly getCreatedPublicChats: getCreatedPublicChats;
  readonly checkCreatedPublicChatsLimit: checkCreatedPublicChatsLimit;
  readonly getSuitableDiscussionChats: getSuitableDiscussionChats;
  readonly getInactiveSupergroupChats: getInactiveSupergroupChats;
  readonly getGroupsInCommon: getGroupsInCommon;
  readonly getChatHistory: getChatHistory;
  readonly getMessageThreadHistory: getMessageThreadHistory;
  readonly deleteChatHistory: deleteChatHistory;
  readonly deleteChat: deleteChat;
  readonly searchChatMessages: searchChatMessages;
  readonly searchMessages: searchMessages;
  readonly searchSecretMessages: searchSecretMessages;
  readonly searchCallMessages: searchCallMessages;
  readonly searchOutgoingDocumentMessages: searchOutgoingDocumentMessages;
  readonly deleteAllCallMessages: deleteAllCallMessages;
  readonly searchChatRecentLocationMessages: searchChatRecentLocationMessages;
  readonly getActiveLiveLocationMessages: getActiveLiveLocationMessages;
  readonly getChatMessageByDate: getChatMessageByDate;
  readonly getChatSparseMessagePositions: getChatSparseMessagePositions;
  readonly getChatMessageCalendar: getChatMessageCalendar;
  readonly getChatMessageCount: getChatMessageCount;
  readonly getChatMessagePosition: getChatMessagePosition;
  readonly getChatScheduledMessages: getChatScheduledMessages;
  readonly getMessagePublicForwards: getMessagePublicForwards;
  readonly getChatSponsoredMessages: getChatSponsoredMessages;
  readonly removeNotification: removeNotification;
  readonly removeNotificationGroup: removeNotificationGroup;
  readonly getMessageLink: getMessageLink;
  readonly getMessageEmbeddingCode: getMessageEmbeddingCode;
  readonly getMessageLinkInfo: getMessageLinkInfo;
  readonly translateText: translateText;
  readonly recognizeSpeech: recognizeSpeech;
  readonly rateSpeechRecognition: rateSpeechRecognition;
  readonly getChatAvailableMessageSenders: getChatAvailableMessageSenders;
  readonly setChatMessageSender: setChatMessageSender;
  readonly sendMessage: sendMessage;
  readonly sendMessageAlbum: sendMessageAlbum;
  readonly sendBotStartMessage: sendBotStartMessage;
  readonly sendInlineQueryResultMessage: sendInlineQueryResultMessage;
  readonly forwardMessages: forwardMessages;
  readonly resendMessages: resendMessages;
  readonly sendChatScreenshotTakenNotification: sendChatScreenshotTakenNotification;
  readonly addLocalMessage: addLocalMessage;
  readonly deleteMessages: deleteMessages;
  readonly deleteChatMessagesBySender: deleteChatMessagesBySender;
  readonly deleteChatMessagesByDate: deleteChatMessagesByDate;
  readonly editMessageText: editMessageText;
  readonly editMessageLiveLocation: editMessageLiveLocation;
  readonly editMessageMedia: editMessageMedia;
  readonly editMessageCaption: editMessageCaption;
  readonly editMessageReplyMarkup: editMessageReplyMarkup;
  readonly editInlineMessageText: editInlineMessageText;
  readonly editInlineMessageLiveLocation: editInlineMessageLiveLocation;
  readonly editInlineMessageMedia: editInlineMessageMedia;
  readonly editInlineMessageCaption: editInlineMessageCaption;
  readonly editInlineMessageReplyMarkup: editInlineMessageReplyMarkup;
  readonly editMessageSchedulingState: editMessageSchedulingState;
  readonly getForumTopicDefaultIcons: getForumTopicDefaultIcons;
  readonly createForumTopic: createForumTopic;
  readonly editForumTopic: editForumTopic;
  readonly toggleForumTopicIsClosed: toggleForumTopicIsClosed;
  readonly deleteForumTopic: deleteForumTopic;
  readonly getEmojiReaction: getEmojiReaction;
  readonly getCustomEmojiReactionAnimations: getCustomEmojiReactionAnimations;
  readonly getMessageAvailableReactions: getMessageAvailableReactions;
  readonly clearRecentReactions: clearRecentReactions;
  readonly addMessageReaction: addMessageReaction;
  readonly removeMessageReaction: removeMessageReaction;
  readonly getMessageAddedReactions: getMessageAddedReactions;
  readonly setDefaultReactionType: setDefaultReactionType;
  readonly getTextEntities: getTextEntities;
  readonly parseTextEntities: parseTextEntities;
  readonly parseMarkdown: parseMarkdown;
  readonly getMarkdownText: getMarkdownText;
  readonly getFileMimeType: getFileMimeType;
  readonly getFileExtension: getFileExtension;
  readonly cleanFileName: cleanFileName;
  readonly getLanguagePackString: getLanguagePackString;
  readonly getJsonValue: getJsonValue;
  readonly getJsonString: getJsonString;
  readonly getThemeParametersJsonString: getThemeParametersJsonString;
  readonly setPollAnswer: setPollAnswer;
  readonly getPollVoters: getPollVoters;
  readonly stopPoll: stopPoll;
  readonly hideSuggestedAction: hideSuggestedAction;
  readonly getLoginUrlInfo: getLoginUrlInfo;
  readonly getLoginUrl: getLoginUrl;
  readonly getInlineQueryResults: getInlineQueryResults;
  readonly answerInlineQuery: answerInlineQuery;
  readonly getWebAppUrl: getWebAppUrl;
  readonly sendWebAppData: sendWebAppData;
  readonly openWebApp: openWebApp;
  readonly closeWebApp: closeWebApp;
  readonly answerWebAppQuery: answerWebAppQuery;
  readonly getCallbackQueryAnswer: getCallbackQueryAnswer;
  readonly answerCallbackQuery: answerCallbackQuery;
  readonly answerShippingQuery: answerShippingQuery;
  readonly answerPreCheckoutQuery: answerPreCheckoutQuery;
  readonly setGameScore: setGameScore;
  readonly setInlineGameScore: setInlineGameScore;
  readonly getGameHighScores: getGameHighScores;
  readonly getInlineGameHighScores: getInlineGameHighScores;
  readonly deleteChatReplyMarkup: deleteChatReplyMarkup;
  readonly sendChatAction: sendChatAction;
  readonly openChat: openChat;
  readonly closeChat: closeChat;
  readonly viewMessages: viewMessages;
  readonly openMessageContent: openMessageContent;
  readonly clickAnimatedEmojiMessage: clickAnimatedEmojiMessage;
  readonly getInternalLinkType: getInternalLinkType;
  readonly getExternalLinkInfo: getExternalLinkInfo;
  readonly getExternalLink: getExternalLink;
  readonly readAllChatMentions: readAllChatMentions;
  readonly readAllMessageThreadMentions: readAllMessageThreadMentions;
  readonly readAllChatReactions: readAllChatReactions;
  readonly readAllMessageThreadReactions: readAllMessageThreadReactions;
  readonly createPrivateChat: createPrivateChat;
  readonly createBasicGroupChat: createBasicGroupChat;
  readonly createSupergroupChat: createSupergroupChat;
  readonly createSecretChat: createSecretChat;
  readonly createNewBasicGroupChat: createNewBasicGroupChat;
  readonly createNewSupergroupChat: createNewSupergroupChat;
  readonly createNewSecretChat: createNewSecretChat;
  readonly upgradeBasicGroupChatToSupergroupChat: upgradeBasicGroupChatToSupergroupChat;
  readonly getChatListsToAddChat: getChatListsToAddChat;
  readonly addChatToList: addChatToList;
  readonly getChatFilter: getChatFilter;
  readonly createChatFilter: createChatFilter;
  readonly editChatFilter: editChatFilter;
  readonly deleteChatFilter: deleteChatFilter;
  readonly reorderChatFilters: reorderChatFilters;
  readonly getRecommendedChatFilters: getRecommendedChatFilters;
  readonly getChatFilterDefaultIconName: getChatFilterDefaultIconName;
  readonly setChatTitle: setChatTitle;
  readonly setChatPhoto: setChatPhoto;
  readonly setChatMessageTtl: setChatMessageTtl;
  readonly setChatPermissions: setChatPermissions;
  readonly setChatTheme: setChatTheme;
  readonly setChatDraftMessage: setChatDraftMessage;
  readonly setChatNotificationSettings: setChatNotificationSettings;
  readonly toggleChatHasProtectedContent: toggleChatHasProtectedContent;
  readonly toggleChatIsMarkedAsUnread: toggleChatIsMarkedAsUnread;
  readonly toggleChatDefaultDisableNotification: toggleChatDefaultDisableNotification;
  readonly setChatAvailableReactions: setChatAvailableReactions;
  readonly setChatClientData: setChatClientData;
  readonly setChatDescription: setChatDescription;
  readonly setChatDiscussionGroup: setChatDiscussionGroup;
  readonly setChatLocation: setChatLocation;
  readonly setChatSlowModeDelay: setChatSlowModeDelay;
  readonly pinChatMessage: pinChatMessage;
  readonly unpinChatMessage: unpinChatMessage;
  readonly unpinAllChatMessages: unpinAllChatMessages;
  readonly unpinAllMessageThreadMessages: unpinAllMessageThreadMessages;
  readonly joinChat: joinChat;
  readonly leaveChat: leaveChat;
  readonly addChatMember: addChatMember;
  readonly addChatMembers: addChatMembers;
  readonly setChatMemberStatus: setChatMemberStatus;
  readonly banChatMember: banChatMember;
  readonly canTransferOwnership: canTransferOwnership;
  readonly transferChatOwnership: transferChatOwnership;
  readonly getChatMember: getChatMember;
  readonly searchChatMembers: searchChatMembers;
  readonly getChatAdministrators: getChatAdministrators;
  readonly clearAllDraftMessages: clearAllDraftMessages;
  readonly getSavedNotificationSound: getSavedNotificationSound;
  readonly getSavedNotificationSounds: getSavedNotificationSounds;
  readonly addSavedNotificationSound: addSavedNotificationSound;
  readonly removeSavedNotificationSound: removeSavedNotificationSound;
  readonly getChatNotificationSettingsExceptions: getChatNotificationSettingsExceptions;
  readonly getScopeNotificationSettings: getScopeNotificationSettings;
  readonly setScopeNotificationSettings: setScopeNotificationSettings;
  readonly resetAllNotificationSettings: resetAllNotificationSettings;
  readonly toggleChatIsPinned: toggleChatIsPinned;
  readonly setPinnedChats: setPinnedChats;
  readonly getAttachmentMenuBot: getAttachmentMenuBot;
  readonly toggleBotIsAddedToAttachmentMenu: toggleBotIsAddedToAttachmentMenu;
  readonly getThemedEmojiStatuses: getThemedEmojiStatuses;
  readonly getRecentEmojiStatuses: getRecentEmojiStatuses;
  readonly getDefaultEmojiStatuses: getDefaultEmojiStatuses;
  readonly clearRecentEmojiStatuses: clearRecentEmojiStatuses;
  readonly downloadFile: downloadFile;
  readonly getFileDownloadedPrefixSize: getFileDownloadedPrefixSize;
  readonly cancelDownloadFile: cancelDownloadFile;
  readonly getSuggestedFileName: getSuggestedFileName;
  readonly preliminaryUploadFile: preliminaryUploadFile;
  readonly cancelPreliminaryUploadFile: cancelPreliminaryUploadFile;
  readonly writeGeneratedFilePart: writeGeneratedFilePart;
  readonly setFileGenerationProgress: setFileGenerationProgress;
  readonly finishFileGeneration: finishFileGeneration;
  readonly readFilePart: readFilePart;
  readonly deleteFile: deleteFile;
  readonly addFileToDownloads: addFileToDownloads;
  readonly toggleDownloadIsPaused: toggleDownloadIsPaused;
  readonly toggleAllDownloadsArePaused: toggleAllDownloadsArePaused;
  readonly removeFileFromDownloads: removeFileFromDownloads;
  readonly removeAllFilesFromDownloads: removeAllFilesFromDownloads;
  readonly searchFileDownloads: searchFileDownloads;
  readonly getMessageFileType: getMessageFileType;
  readonly getMessageImportConfirmationText: getMessageImportConfirmationText;
  readonly importMessages: importMessages;
  readonly replacePrimaryChatInviteLink: replacePrimaryChatInviteLink;
  readonly createChatInviteLink: createChatInviteLink;
  readonly editChatInviteLink: editChatInviteLink;
  readonly getChatInviteLink: getChatInviteLink;
  readonly getChatInviteLinkCounts: getChatInviteLinkCounts;
  readonly getChatInviteLinks: getChatInviteLinks;
  readonly getChatInviteLinkMembers: getChatInviteLinkMembers;
  readonly revokeChatInviteLink: revokeChatInviteLink;
  readonly deleteRevokedChatInviteLink: deleteRevokedChatInviteLink;
  readonly deleteAllRevokedChatInviteLinks: deleteAllRevokedChatInviteLinks;
  readonly checkChatInviteLink: checkChatInviteLink;
  readonly joinChatByInviteLink: joinChatByInviteLink;
  readonly getChatJoinRequests: getChatJoinRequests;
  readonly processChatJoinRequest: processChatJoinRequest;
  readonly processChatJoinRequests: processChatJoinRequests;
  readonly createCall: createCall;
  readonly acceptCall: acceptCall;
  readonly sendCallSignalingData: sendCallSignalingData;
  readonly discardCall: discardCall;
  readonly sendCallRating: sendCallRating;
  readonly sendCallDebugInformation: sendCallDebugInformation;
  readonly sendCallLog: sendCallLog;
  readonly getVideoChatAvailableParticipants: getVideoChatAvailableParticipants;
  readonly setVideoChatDefaultParticipant: setVideoChatDefaultParticipant;
  readonly createVideoChat: createVideoChat;
  readonly getVideoChatRtmpUrl: getVideoChatRtmpUrl;
  readonly replaceVideoChatRtmpUrl: replaceVideoChatRtmpUrl;
  readonly getGroupCall: getGroupCall;
  readonly startScheduledGroupCall: startScheduledGroupCall;
  readonly toggleGroupCallEnabledStartNotification: toggleGroupCallEnabledStartNotification;
  readonly joinGroupCall: joinGroupCall;
  readonly startGroupCallScreenSharing: startGroupCallScreenSharing;
  readonly toggleGroupCallScreenSharingIsPaused: toggleGroupCallScreenSharingIsPaused;
  readonly endGroupCallScreenSharing: endGroupCallScreenSharing;
  readonly setGroupCallTitle: setGroupCallTitle;
  readonly toggleGroupCallMuteNewParticipants: toggleGroupCallMuteNewParticipants;
  readonly inviteGroupCallParticipants: inviteGroupCallParticipants;
  readonly getGroupCallInviteLink: getGroupCallInviteLink;
  readonly revokeGroupCallInviteLink: revokeGroupCallInviteLink;
  readonly startGroupCallRecording: startGroupCallRecording;
  readonly endGroupCallRecording: endGroupCallRecording;
  readonly toggleGroupCallIsMyVideoPaused: toggleGroupCallIsMyVideoPaused;
  readonly toggleGroupCallIsMyVideoEnabled: toggleGroupCallIsMyVideoEnabled;
  readonly setGroupCallParticipantIsSpeaking: setGroupCallParticipantIsSpeaking;
  readonly toggleGroupCallParticipantIsMuted: toggleGroupCallParticipantIsMuted;
  readonly setGroupCallParticipantVolumeLevel: setGroupCallParticipantVolumeLevel;
  readonly toggleGroupCallParticipantIsHandRaised: toggleGroupCallParticipantIsHandRaised;
  readonly loadGroupCallParticipants: loadGroupCallParticipants;
  readonly leaveGroupCall: leaveGroupCall;
  readonly endGroupCall: endGroupCall;
  readonly getGroupCallStreams: getGroupCallStreams;
  readonly getGroupCallStreamSegment: getGroupCallStreamSegment;
  readonly toggleMessageSenderIsBlocked: toggleMessageSenderIsBlocked;
  readonly blockMessageSenderFromReplies: blockMessageSenderFromReplies;
  readonly getBlockedMessageSenders: getBlockedMessageSenders;
  readonly addContact: addContact;
  readonly importContacts: importContacts;
  readonly getContacts: getContacts;
  readonly searchContacts: searchContacts;
  readonly removeContacts: removeContacts;
  readonly getImportedContactCount: getImportedContactCount;
  readonly changeImportedContacts: changeImportedContacts;
  readonly clearImportedContacts: clearImportedContacts;
  readonly searchUserByPhoneNumber: searchUserByPhoneNumber;
  readonly sharePhoneNumber: sharePhoneNumber;
  readonly getUserProfilePhotos: getUserProfilePhotos;
  readonly getStickers: getStickers;
  readonly searchStickers: searchStickers;
  readonly getPremiumStickers: getPremiumStickers;
  readonly getInstalledStickerSets: getInstalledStickerSets;
  readonly getArchivedStickerSets: getArchivedStickerSets;
  readonly getTrendingStickerSets: getTrendingStickerSets;
  readonly getAttachedStickerSets: getAttachedStickerSets;
  readonly getStickerSet: getStickerSet;
  readonly searchStickerSet: searchStickerSet;
  readonly searchInstalledStickerSets: searchInstalledStickerSets;
  readonly searchStickerSets: searchStickerSets;
  readonly changeStickerSet: changeStickerSet;
  readonly viewTrendingStickerSets: viewTrendingStickerSets;
  readonly reorderInstalledStickerSets: reorderInstalledStickerSets;
  readonly getRecentStickers: getRecentStickers;
  readonly addRecentSticker: addRecentSticker;
  readonly removeRecentSticker: removeRecentSticker;
  readonly clearRecentStickers: clearRecentStickers;
  readonly getFavoriteStickers: getFavoriteStickers;
  readonly addFavoriteSticker: addFavoriteSticker;
  readonly removeFavoriteSticker: removeFavoriteSticker;
  readonly getStickerEmojis: getStickerEmojis;
  readonly searchEmojis: searchEmojis;
  readonly getAnimatedEmoji: getAnimatedEmoji;
  readonly getEmojiSuggestionsUrl: getEmojiSuggestionsUrl;
  readonly getCustomEmojiStickers: getCustomEmojiStickers;
  readonly getSavedAnimations: getSavedAnimations;
  readonly addSavedAnimation: addSavedAnimation;
  readonly removeSavedAnimation: removeSavedAnimation;
  readonly getRecentInlineBots: getRecentInlineBots;
  readonly searchHashtags: searchHashtags;
  readonly removeRecentHashtag: removeRecentHashtag;
  readonly getWebPagePreview: getWebPagePreview;
  readonly getWebPageInstantView: getWebPageInstantView;
  readonly setProfilePhoto: setProfilePhoto;
  readonly deleteProfilePhoto: deleteProfilePhoto;
  readonly setName: setName;
  readonly setBio: setBio;
  readonly setUsername: setUsername;
  readonly toggleUsernameIsActive: toggleUsernameIsActive;
  readonly reorderActiveUsernames: reorderActiveUsernames;
  readonly setEmojiStatus: setEmojiStatus;
  readonly setLocation: setLocation;
  readonly changePhoneNumber: changePhoneNumber;
  readonly resendChangePhoneNumberCode: resendChangePhoneNumberCode;
  readonly checkChangePhoneNumberCode: checkChangePhoneNumberCode;
  readonly setCommands: setCommands;
  readonly deleteCommands: deleteCommands;
  readonly getCommands: getCommands;
  readonly setMenuButton: setMenuButton;
  readonly getMenuButton: getMenuButton;
  readonly setDefaultGroupAdministratorRights: setDefaultGroupAdministratorRights;
  readonly setDefaultChannelAdministratorRights: setDefaultChannelAdministratorRights;
  readonly getActiveSessions: getActiveSessions;
  readonly terminateSession: terminateSession;
  readonly terminateAllOtherSessions: terminateAllOtherSessions;
  readonly toggleSessionCanAcceptCalls: toggleSessionCanAcceptCalls;
  readonly toggleSessionCanAcceptSecretChats: toggleSessionCanAcceptSecretChats;
  readonly setInactiveSessionTtl: setInactiveSessionTtl;
  readonly getConnectedWebsites: getConnectedWebsites;
  readonly disconnectWebsite: disconnectWebsite;
  readonly disconnectAllWebsites: disconnectAllWebsites;
  readonly setSupergroupUsername: setSupergroupUsername;
  readonly toggleSupergroupUsernameIsActive: toggleSupergroupUsernameIsActive;
  readonly disableAllSupergroupUsernames: disableAllSupergroupUsernames;
  readonly reorderSupergroupActiveUsernames: reorderSupergroupActiveUsernames;
  readonly setSupergroupStickerSet: setSupergroupStickerSet;
  readonly toggleSupergroupSignMessages: toggleSupergroupSignMessages;
  readonly toggleSupergroupJoinToSendMessages: toggleSupergroupJoinToSendMessages;
  readonly toggleSupergroupJoinByRequest: toggleSupergroupJoinByRequest;
  readonly toggleSupergroupIsAllHistoryAvailable: toggleSupergroupIsAllHistoryAvailable;
  readonly toggleSupergroupIsForum: toggleSupergroupIsForum;
  readonly toggleSupergroupIsBroadcastGroup: toggleSupergroupIsBroadcastGroup;
  readonly reportSupergroupSpam: reportSupergroupSpam;
  readonly getSupergroupMembers: getSupergroupMembers;
  readonly closeSecretChat: closeSecretChat;
  readonly getChatEventLog: getChatEventLog;
  readonly getPaymentForm: getPaymentForm;
  readonly validateOrderInfo: validateOrderInfo;
  readonly sendPaymentForm: sendPaymentForm;
  readonly getPaymentReceipt: getPaymentReceipt;
  readonly getSavedOrderInfo: getSavedOrderInfo;
  readonly deleteSavedOrderInfo: deleteSavedOrderInfo;
  readonly deleteSavedCredentials: deleteSavedCredentials;
  readonly createInvoiceLink: createInvoiceLink;
  readonly getSupportUser: getSupportUser;
  readonly getBackgrounds: getBackgrounds;
  readonly getBackgroundUrl: getBackgroundUrl;
  readonly searchBackground: searchBackground;
  readonly setBackground: setBackground;
  readonly removeBackground: removeBackground;
  readonly resetBackgrounds: resetBackgrounds;
  readonly getLocalizationTargetInfo: getLocalizationTargetInfo;
  readonly getLanguagePackInfo: getLanguagePackInfo;
  readonly getLanguagePackStrings: getLanguagePackStrings;
  readonly synchronizeLanguagePack: synchronizeLanguagePack;
  readonly addCustomServerLanguagePack: addCustomServerLanguagePack;
  readonly setCustomLanguagePack: setCustomLanguagePack;
  readonly editCustomLanguagePackInfo: editCustomLanguagePackInfo;
  readonly setCustomLanguagePackString: setCustomLanguagePackString;
  readonly deleteLanguagePack: deleteLanguagePack;
  readonly registerDevice: registerDevice;
  readonly processPushNotification: processPushNotification;
  readonly getPushReceiverId: getPushReceiverId;
  readonly getRecentlyVisitedTMeUrls: getRecentlyVisitedTMeUrls;
  readonly setUserPrivacySettingRules: setUserPrivacySettingRules;
  readonly getUserPrivacySettingRules: getUserPrivacySettingRules;
  readonly getOption: getOption;
  readonly setOption: setOption;
  readonly setAccountTtl: setAccountTtl;
  readonly getAccountTtl: getAccountTtl;
  readonly deleteAccount: deleteAccount;
  readonly removeChatActionBar: removeChatActionBar;
  readonly reportChat: reportChat;
  readonly reportChatPhoto: reportChatPhoto;
  readonly reportMessageReactions: reportMessageReactions;
  readonly getChatStatistics: getChatStatistics;
  readonly getMessageStatistics: getMessageStatistics;
  readonly getStatisticalGraph: getStatisticalGraph;
  readonly getStorageStatistics: getStorageStatistics;
  readonly getStorageStatisticsFast: getStorageStatisticsFast;
  readonly getDatabaseStatistics: getDatabaseStatistics;
  readonly optimizeStorage: optimizeStorage;
  readonly setNetworkType: setNetworkType;
  readonly getNetworkStatistics: getNetworkStatistics;
  readonly addNetworkStatistics: addNetworkStatistics;
  readonly resetNetworkStatistics: resetNetworkStatistics;
  readonly getAutoDownloadSettingsPresets: getAutoDownloadSettingsPresets;
  readonly setAutoDownloadSettings: setAutoDownloadSettings;
  readonly getBankCardInfo: getBankCardInfo;
  readonly getPassportElement: getPassportElement;
  readonly getAllPassportElements: getAllPassportElements;
  readonly setPassportElement: setPassportElement;
  readonly deletePassportElement: deletePassportElement;
  readonly setPassportElementErrors: setPassportElementErrors;
  readonly getPreferredCountryLanguage: getPreferredCountryLanguage;
  readonly sendPhoneNumberVerificationCode: sendPhoneNumberVerificationCode;
  readonly resendPhoneNumberVerificationCode: resendPhoneNumberVerificationCode;
  readonly checkPhoneNumberVerificationCode: checkPhoneNumberVerificationCode;
  readonly sendEmailAddressVerificationCode: sendEmailAddressVerificationCode;
  readonly resendEmailAddressVerificationCode: resendEmailAddressVerificationCode;
  readonly checkEmailAddressVerificationCode: checkEmailAddressVerificationCode;
  readonly getPassportAuthorizationForm: getPassportAuthorizationForm;
  readonly getPassportAuthorizationFormAvailableElements: getPassportAuthorizationFormAvailableElements;
  readonly sendPassportAuthorizationForm: sendPassportAuthorizationForm;
  readonly sendPhoneNumberConfirmationCode: sendPhoneNumberConfirmationCode;
  readonly resendPhoneNumberConfirmationCode: resendPhoneNumberConfirmationCode;
  readonly checkPhoneNumberConfirmationCode: checkPhoneNumberConfirmationCode;
  readonly setBotUpdatesStatus: setBotUpdatesStatus;
  readonly uploadStickerFile: uploadStickerFile;
  readonly getSuggestedStickerSetName: getSuggestedStickerSetName;
  readonly checkStickerSetName: checkStickerSetName;
  readonly createNewStickerSet: createNewStickerSet;
  readonly addStickerToSet: addStickerToSet;
  readonly setStickerSetThumbnail: setStickerSetThumbnail;
  readonly setStickerPositionInSet: setStickerPositionInSet;
  readonly removeStickerFromSet: removeStickerFromSet;
  readonly getMapThumbnailFile: getMapThumbnailFile;
  readonly getPremiumLimit: getPremiumLimit;
  readonly getPremiumFeatures: getPremiumFeatures;
  readonly getPremiumStickerExamples: getPremiumStickerExamples;
  readonly viewPremiumFeature: viewPremiumFeature;
  readonly clickPremiumSubscriptionButton: clickPremiumSubscriptionButton;
  readonly getPremiumState: getPremiumState;
  readonly canPurchasePremium: canPurchasePremium;
  readonly assignAppStoreTransaction: assignAppStoreTransaction;
  readonly assignGooglePlayTransaction: assignGooglePlayTransaction;
  readonly acceptTermsOfService: acceptTermsOfService;
  readonly sendCustomRequest: sendCustomRequest;
  readonly answerCustomQuery: answerCustomQuery;
  readonly setAlarm: setAlarm;
  readonly getCountries: getCountries;
  readonly getCountryCode: getCountryCode;
  readonly getPhoneNumberInfo: getPhoneNumberInfo;
  readonly getPhoneNumberInfoSync: getPhoneNumberInfoSync;
  readonly getApplicationDownloadLink: getApplicationDownloadLink;
  readonly getDeepLinkInfo: getDeepLinkInfo;
  readonly getApplicationConfig: getApplicationConfig;
  readonly saveApplicationLogEvent: saveApplicationLogEvent;
  readonly addProxy: addProxy;
  readonly editProxy: editProxy;
  readonly enableProxy: enableProxy;
  readonly disableProxy: disableProxy;
  readonly removeProxy: removeProxy;
  readonly getProxies: getProxies;
  readonly getProxyLink: getProxyLink;
  readonly pingProxy: pingProxy;
  readonly setLogStream: setLogStream;
  readonly getLogStream: getLogStream;
  readonly setLogVerbosityLevel: setLogVerbosityLevel;
  readonly getLogVerbosityLevel: getLogVerbosityLevel;
  readonly getLogTags: getLogTags;
  readonly setLogTagVerbosityLevel: setLogTagVerbosityLevel;
  readonly getLogTagVerbosityLevel: getLogTagVerbosityLevel;
  readonly addLogMessage: addLogMessage;
  readonly getUserSupportInfo: getUserSupportInfo;
  readonly setUserSupportInfo: setUserSupportInfo;
  readonly testCallEmpty: testCallEmpty;
  readonly testCallString: testCallString;
  readonly testCallBytes: testCallBytes;
  readonly testCallVectorInt: testCallVectorInt;
  readonly testCallVectorIntObject: testCallVectorIntObject;
  readonly testCallVectorString: testCallVectorString;
  readonly testCallVectorStringObject: testCallVectorStringObject;
  readonly testSquareInt: testSquareInt;
  readonly testNetwork: testNetwork;
  readonly testProxy: testProxy;
  readonly testGetDifference: testGetDifference;
  readonly testUseUpdate: testUseUpdate;
  readonly testReturnError: testReturnError;
};

/** Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization */
export type getAuthorizationState$Input = {
  readonly _: "getAuthorizationState";
};

/**
 * Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
 *
 * @param {getAuthorizationState$Input} parameters
 * @return {AuthorizationState} {@link AuthorizationState}
 */
export type getAuthorizationState = (
  parameters: getAuthorizationState$Input
) => AuthorizationState;

/** Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters */
export type setTdlibParameters$Input = {
  readonly _: "setTdlibParameters";

  /**
   * Pass true to use Telegram test environment instead of the production environment
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_test_dc?: Bool$Input;

  /**
   * The path to the directory for the persistent database; if empty, the current working directory will be used
   * @type {string} {@link string}
   */
  readonly database_directory?: string;

  /**
   * The path to the directory for storing files; if empty, database_directory will be used
   * @type {string} {@link string}
   */
  readonly files_directory?: string;

  /**
   * Encryption key for the database
   * @type {bytes} {@link bytes}
   */
  readonly database_encryption_key?: bytes;

  /**
   * Pass true to keep information about downloaded and uploaded files between application restarts
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_file_database?: Bool$Input;

  /**
   * Pass true to keep cache of users, basic groups, supergroups, channels and secret chats between restarts. Implies use_file_database
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_chat_info_database?: Bool$Input;

  /**
   * Pass true to keep cache of chats and messages between restarts. Implies use_chat_info_database
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_message_database?: Bool$Input;

  /**
   * Pass true to enable support for secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_secret_chats?: Bool$Input;

  /**
   * Application identifier for Telegram API access, which can be obtained at https://my.telegram.org
   * @type {int32} {@link int32}
   */
  readonly api_id?: int32;

  /**
   * Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org
   * @type {string} {@link string}
   */
  readonly api_hash?: string;

  /**
   * IETF language tag of the user's operating system language; must be non-empty
   * @type {string} {@link string}
   */
  readonly system_language_code?: string;

  /**
   * Model of the device the application is being run on; must be non-empty
   * @type {string} {@link string}
   */
  readonly device_model?: string;

  /**
   * Version of the operating system the application is being run on. If empty, the version is automatically detected by TDLib
   * @type {string} {@link string}
   */
  readonly system_version?: string;

  /**
   * Application version; must be non-empty
   * @type {string} {@link string}
   */
  readonly application_version?: string;

  /**
   * Pass true to automatically delete old files in background
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable_storage_optimizer?: Bool$Input;

  /**
   * Pass true to ignore original file names for downloaded files. Otherwise, downloaded files are saved under names as close as possible to the original name
   * @type {Bool$Input} {@link Bool}
   */
  readonly ignore_file_names?: Bool$Input;
};

/**
 * Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
 *
 * @param {setTdlibParameters$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setTdlibParameters = (parameters: setTdlibParameters$Input) => Ok;

/** Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
-or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword */
export type setAuthenticationPhoneNumber$Input = {
  readonly _: "setAuthenticationPhoneNumber";

  /**
   * The phone number of the user, in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input;
};

/**
 * Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
-or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 * 
 * @param {setAuthenticationPhoneNumber$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setAuthenticationPhoneNumber = (
  parameters: setAuthenticationPhoneNumber$Input
) => Ok;

/** Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress */
export type setAuthenticationEmailAddress$Input = {
  readonly _: "setAuthenticationEmailAddress";

  /**
   * The email address of the user
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Sets the email address of the user and sends an authentication code to the email address. Works only when the current authorization state is authorizationStateWaitEmailAddress
 *
 * @param {setAuthenticationEmailAddress$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setAuthenticationEmailAddress = (
  parameters: setAuthenticationEmailAddress$Input
) => Ok;

/** Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed, or when the current authorization state is authorizationStateWaitEmailCode */
export type resendAuthenticationCode$Input = {
  readonly _: "resendAuthenticationCode";
};

/**
 * Resends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed, or when the current authorization state is authorizationStateWaitEmailCode
 *
 * @param {resendAuthenticationCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type resendAuthenticationCode = (
  parameters: resendAuthenticationCode$Input
) => Ok;

/** Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode */
export type checkAuthenticationEmailCode$Input = {
  readonly _: "checkAuthenticationEmailCode";

  /**
   * Email address authentication to check
   * @type {EmailAddressAuthentication$Input} {@link EmailAddressAuthentication}
   */
  readonly code?: EmailAddressAuthentication$Input;
};

/**
 * Checks the authentication of a email address. Works only when the current authorization state is authorizationStateWaitEmailCode
 *
 * @param {checkAuthenticationEmailCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationEmailCode = (
  parameters: checkAuthenticationEmailCode$Input
) => Ok;

/** Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode */
export type checkAuthenticationCode$Input = {
  readonly _: "checkAuthenticationCode";

  /**
   * Authentication code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
 *
 * @param {checkAuthenticationCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationCode = (
  parameters: checkAuthenticationCode$Input
) => Ok;

/** Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
-or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword */
export type requestQrCodeAuthentication$Input = {
  readonly _: "requestQrCodeAuthentication";

  /**
   * List of user identifiers of other users currently using the application
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly other_user_ids?: vector$Input<int53>;
};

/**
 * Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber,
-or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
 * 
 * @param {requestQrCodeAuthentication$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type requestQrCodeAuthentication = (
  parameters: requestQrCodeAuthentication$Input
) => Ok;

/** Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration */
export type registerUser$Input = {
  readonly _: "registerUser";

  /**
   * The first name of the user; 1-64 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * The last name of the user; 0-64 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;
};

/**
 * Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
 *
 * @param {registerUser$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type registerUser = (parameters: registerUser$Input) => Ok;

/** Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword */
export type checkAuthenticationPassword$Input = {
  readonly _: "checkAuthenticationPassword";

  /**
   * The 2-step verification password to check
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Checks the 2-step verification password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {checkAuthenticationPassword$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationPassword = (
  parameters: checkAuthenticationPassword$Input
) => Ok;

/** Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword */
export type requestAuthenticationPasswordRecovery$Input = {
  readonly _: "requestAuthenticationPasswordRecovery";
};

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {requestAuthenticationPasswordRecovery$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type requestAuthenticationPasswordRecovery = (
  parameters: requestAuthenticationPasswordRecovery$Input
) => Ok;

/** Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword */
export type checkAuthenticationPasswordRecoveryCode$Input = {
  readonly _: "checkAuthenticationPasswordRecoveryCode";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;
};

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {checkAuthenticationPasswordRecoveryCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationPasswordRecoveryCode = (
  parameters: checkAuthenticationPasswordRecoveryCode$Input
) => Ok;

/** Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword */
export type recoverAuthenticationPassword$Input = {
  readonly _: "recoverAuthenticationPassword";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;
};

/**
 * Recovers the 2-step verification password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
 *
 * @param {recoverAuthenticationPassword$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type recoverAuthenticationPassword = (
  parameters: recoverAuthenticationPassword$Input
) => Ok;

/** Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in */
export type checkAuthenticationBotToken$Input = {
  readonly _: "checkAuthenticationBotToken";

  /**
   * The bot token
   * @type {string} {@link string}
   */
  readonly token?: string;
};

/**
 * Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
 *
 * @param {checkAuthenticationBotToken$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkAuthenticationBotToken = (
  parameters: checkAuthenticationBotToken$Input
) => Ok;

/** Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent */
export type logOut$Input = {
  readonly _: "logOut";
};

/**
 * Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
 *
 * @param {logOut$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type logOut = (parameters: logOut$Input) => Ok;

/** Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization */
export type close$Input = {
  readonly _: "close";
};

/**
 * Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
 *
 * @param {close$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type close = (parameters: close$Input) => Ok;

/** Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization */
export type destroy$Input = {
  readonly _: "destroy";
};

/**
 * Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
 *
 * @param {destroy$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type destroy = (parameters: destroy$Input) => Ok;

/** Confirms QR code authentication on another device. Returns created session on success */
export type confirmQrCodeAuthentication$Input = {
  readonly _: "confirmQrCodeAuthentication";

  /**
   * A link from a QR code. The link must be scanned by the in-app camera
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Confirms QR code authentication on another device. Returns created session on success
 *
 * @param {confirmQrCodeAuthentication$Input} parameters
 * @return {Session} {@link Session}
 */
export type confirmQrCodeAuthentication = (
  parameters: confirmQrCodeAuthentication$Input
) => Session;

/** Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization */
export type getCurrentState$Input = {
  readonly _: "getCurrentState";
};

/**
 * Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
 *
 * @param {getCurrentState$Input} parameters
 * @return {Updates} {@link Updates}
 */
export type getCurrentState = (parameters: getCurrentState$Input) => Updates;

/** Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain */
export type setDatabaseEncryptionKey$Input = {
  readonly _: "setDatabaseEncryptionKey";

  /**
   * New encryption key
   * @type {bytes} {@link bytes}
   */
  readonly new_encryption_key?: bytes;
};

/**
 * Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
 *
 * @param {setDatabaseEncryptionKey$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setDatabaseEncryptionKey = (
  parameters: setDatabaseEncryptionKey$Input
) => Ok;

/** Returns the current state of 2-step verification */
export type getPasswordState$Input = {
  readonly _: "getPasswordState";
};

/**
 * Returns the current state of 2-step verification
 *
 * @param {getPasswordState$Input} parameters
 * @return {PasswordState} {@link PasswordState}
 */
export type getPasswordState = (parameters: getPasswordState$Input) => PasswordState;

/** Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed */
export type setPassword$Input = {
  readonly _: "setPassword";

  /**
   * Previous 2-step verification password of the user
   * @type {string} {@link string}
   */
  readonly old_password?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;

  /**
   * Pass true to change also the recovery email address
   * @type {Bool$Input} {@link Bool}
   */
  readonly set_recovery_email_address?: Bool$Input;

  /**
   * New recovery email address; may be empty
   * @type {string} {@link string}
   */
  readonly new_recovery_email_address?: string;
};

/**
 * Changes the 2-step verification password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
 *
 * @param {setPassword$Input} parameters
 * @return {PasswordState} {@link PasswordState}
 */
export type setPassword = (parameters: setPassword$Input) => PasswordState;

/** Changes the login email address of the user. The change will not be applied until the new login email address is confirmed with `checkLoginEmailAddressCode`. To use Apple ID/Google ID instead of a email address, call `checkLoginEmailAddressCode` directly */
export type setLoginEmailAddress$Input = {
  readonly _: "setLoginEmailAddress";

  /**
   * New login email address
   * @type {string} {@link string}
   */
  readonly new_login_email_address?: string;
};

/**
 * Changes the login email address of the user. The change will not be applied until the new login email address is confirmed with `checkLoginEmailAddressCode`. To use Apple ID/Google ID instead of a email address, call `checkLoginEmailAddressCode` directly
 *
 * @param {setLoginEmailAddress$Input} parameters
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type setLoginEmailAddress = (
  parameters: setLoginEmailAddress$Input
) => EmailAddressAuthenticationCodeInfo;

/** Resends the login email address verification code */
export type resendLoginEmailAddressCode$Input = {
  readonly _: "resendLoginEmailAddressCode";
};

/**
 * Resends the login email address verification code
 *
 * @param {resendLoginEmailAddressCode$Input} parameters
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type resendLoginEmailAddressCode = (
  parameters: resendLoginEmailAddressCode$Input
) => EmailAddressAuthenticationCodeInfo;

/** Checks the login email address authentication */
export type checkLoginEmailAddressCode$Input = {
  readonly _: "checkLoginEmailAddressCode";

  /**
   * Email address authentication to check
   * @type {EmailAddressAuthentication$Input} {@link EmailAddressAuthentication}
   */
  readonly code?: EmailAddressAuthentication$Input;
};

/**
 * Checks the login email address authentication
 *
 * @param {checkLoginEmailAddressCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkLoginEmailAddressCode = (
  parameters: checkLoginEmailAddressCode$Input
) => Ok;

/** Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user */
export type getRecoveryEmailAddress$Input = {
  readonly _: "getRecoveryEmailAddress";

  /**
   * The 2-step verification password for the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
 *
 * @param {getRecoveryEmailAddress$Input} parameters
 * @return {RecoveryEmailAddress} {@link RecoveryEmailAddress}
 */
export type getRecoveryEmailAddress = (
  parameters: getRecoveryEmailAddress$Input
) => RecoveryEmailAddress;

/** Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
-If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation */
export type setRecoveryEmailAddress$Input = {
  readonly _: "setRecoveryEmailAddress";

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * New recovery email address
   * @type {string} {@link string}
   */
  readonly new_recovery_email_address?: string;
};

/**
 * Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
-If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
 * 
 * @param {setRecoveryEmailAddress$Input} parameters
 * @return {PasswordState} {@link PasswordState}
 */
export type setRecoveryEmailAddress = (
  parameters: setRecoveryEmailAddress$Input
) => PasswordState;

/** Checks the 2-step verification recovery email address verification code */
export type checkRecoveryEmailAddressCode$Input = {
  readonly _: "checkRecoveryEmailAddressCode";

  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the 2-step verification recovery email address verification code
 *
 * @param {checkRecoveryEmailAddressCode$Input} parameters
 * @return {PasswordState} {@link PasswordState}
 */
export type checkRecoveryEmailAddressCode = (
  parameters: checkRecoveryEmailAddressCode$Input
) => PasswordState;

/** Resends the 2-step verification recovery email address verification code */
export type resendRecoveryEmailAddressCode$Input = {
  readonly _: "resendRecoveryEmailAddressCode";
};

/**
 * Resends the 2-step verification recovery email address verification code
 *
 * @param {resendRecoveryEmailAddressCode$Input} parameters
 * @return {PasswordState} {@link PasswordState}
 */
export type resendRecoveryEmailAddressCode = (
  parameters: resendRecoveryEmailAddressCode$Input
) => PasswordState;

/** Requests to send a 2-step verification password recovery code to an email address that was previously set up */
export type requestPasswordRecovery$Input = {
  readonly _: "requestPasswordRecovery";
};

/**
 * Requests to send a 2-step verification password recovery code to an email address that was previously set up
 *
 * @param {requestPasswordRecovery$Input} parameters
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type requestPasswordRecovery = (
  parameters: requestPasswordRecovery$Input
) => EmailAddressAuthenticationCodeInfo;

/** Checks whether a 2-step verification password recovery code sent to an email address is valid */
export type checkPasswordRecoveryCode$Input = {
  readonly _: "checkPasswordRecoveryCode";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;
};

/**
 * Checks whether a 2-step verification password recovery code sent to an email address is valid
 *
 * @param {checkPasswordRecoveryCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkPasswordRecoveryCode = (
  parameters: checkPasswordRecoveryCode$Input
) => Ok;

/** Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up */
export type recoverPassword$Input = {
  readonly _: "recoverPassword";

  /**
   * Recovery code to check
   * @type {string} {@link string}
   */
  readonly recovery_code?: string;

  /**
   * New 2-step verification password of the user; may be empty to remove the password
   * @type {string} {@link string}
   */
  readonly new_password?: string;

  /**
   * New password hint; may be empty
   * @type {string} {@link string}
   */
  readonly new_hint?: string;
};

/**
 * Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
 *
 * @param {recoverPassword$Input} parameters
 * @return {PasswordState} {@link PasswordState}
 */
export type recoverPassword = (parameters: recoverPassword$Input) => PasswordState;

/** Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time */
export type resetPassword$Input = {
  readonly _: "resetPassword";
};

/**
 * Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
 *
 * @param {resetPassword$Input} parameters
 * @return {ResetPasswordResult} {@link ResetPasswordResult}
 */
export type resetPassword = (parameters: resetPassword$Input) => ResetPasswordResult;

/** Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0 */
export type cancelPasswordReset$Input = {
  readonly _: "cancelPasswordReset";
};

/**
 * Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date > 0
 *
 * @param {cancelPasswordReset$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type cancelPasswordReset = (parameters: cancelPasswordReset$Input) => Ok;

/** Creates a new temporary password for processing payments */
export type createTemporaryPassword$Input = {
  readonly _: "createTemporaryPassword";

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;

  /**
   * Time during which the temporary password will be valid, in seconds; must be between 60 and 86400
   * @type {int32} {@link int32}
   */
  readonly valid_for?: int32;
};

/**
 * Creates a new temporary password for processing payments
 *
 * @param {createTemporaryPassword$Input} parameters
 * @return {TemporaryPasswordState} {@link TemporaryPasswordState}
 */
export type createTemporaryPassword = (
  parameters: createTemporaryPassword$Input
) => TemporaryPasswordState;

/** Returns information about the current temporary password */
export type getTemporaryPasswordState$Input = {
  readonly _: "getTemporaryPasswordState";
};

/**
 * Returns information about the current temporary password
 *
 * @param {getTemporaryPasswordState$Input} parameters
 * @return {TemporaryPasswordState} {@link TemporaryPasswordState}
 */
export type getTemporaryPasswordState = (
  parameters: getTemporaryPasswordState$Input
) => TemporaryPasswordState;

/** Returns the current user */
export type getMe$Input = {
  readonly _: "getMe";
};

/**
 * Returns the current user
 *
 * @param {getMe$Input} parameters
 * @return {User} {@link User}
 */
export type getMe = (parameters: getMe$Input) => User;

/** Returns information about a user by their identifier. This is an offline request if the current user is not a bot */
export type getUser$Input = {
  readonly _: "getUser";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns information about a user by their identifier. This is an offline request if the current user is not a bot
 *
 * @param {getUser$Input} parameters
 * @return {User} {@link User}
 */
export type getUser = (parameters: getUser$Input) => User;

/** Returns full information about a user by their identifier */
export type getUserFullInfo$Input = {
  readonly _: "getUserFullInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns full information about a user by their identifier
 *
 * @param {getUserFullInfo$Input} parameters
 * @return {UserFullInfo} {@link UserFullInfo}
 */
export type getUserFullInfo = (parameters: getUserFullInfo$Input) => UserFullInfo;

/** Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot */
export type getBasicGroup$Input = {
  readonly _: "getBasicGroup";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
 *
 * @param {getBasicGroup$Input} parameters
 * @return {BasicGroup} {@link BasicGroup}
 */
export type getBasicGroup = (parameters: getBasicGroup$Input) => BasicGroup;

/** Returns full information about a basic group by its identifier */
export type getBasicGroupFullInfo$Input = {
  readonly _: "getBasicGroupFullInfo";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;
};

/**
 * Returns full information about a basic group by its identifier
 *
 * @param {getBasicGroupFullInfo$Input} parameters
 * @return {BasicGroupFullInfo} {@link BasicGroupFullInfo}
 */
export type getBasicGroupFullInfo = (
  parameters: getBasicGroupFullInfo$Input
) => BasicGroupFullInfo;

/** Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot */
export type getSupergroup$Input = {
  readonly _: "getSupergroup";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
 *
 * @param {getSupergroup$Input} parameters
 * @return {Supergroup} {@link Supergroup}
 */
export type getSupergroup = (parameters: getSupergroup$Input) => Supergroup;

/** Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute */
export type getSupergroupFullInfo$Input = {
  readonly _: "getSupergroupFullInfo";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
 *
 * @param {getSupergroupFullInfo$Input} parameters
 * @return {SupergroupFullInfo} {@link SupergroupFullInfo}
 */
export type getSupergroupFullInfo = (
  parameters: getSupergroupFullInfo$Input
) => SupergroupFullInfo;

/** Returns information about a secret chat by its identifier. This is an offline request */
export type getSecretChat$Input = {
  readonly _: "getSecretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Returns information about a secret chat by its identifier. This is an offline request
 *
 * @param {getSecretChat$Input} parameters
 * @return {SecretChat} {@link SecretChat}
 */
export type getSecretChat = (parameters: getSecretChat$Input) => SecretChat;

/** Returns information about a chat by its identifier, this is an offline request if the current user is not a bot */
export type getChat$Input = {
  readonly _: "getChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
 *
 * @param {getChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type getChat = (parameters: getChat$Input) => Chat;

/** Returns information about a message */
export type getMessage$Input = {
  readonly _: "getMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message to get
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message
 *
 * @param {getMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type getMessage = (parameters: getMessage$Input) => Message;

/** Returns information about a message, if it is available without sending network request. This is an offline request */
export type getMessageLocally$Input = {
  readonly _: "getMessageLocally";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message to get
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message, if it is available without sending network request. This is an offline request
 *
 * @param {getMessageLocally$Input} parameters
 * @return {Message} {@link Message}
 */
export type getMessageLocally = (parameters: getMessageLocally$Input) => Message;

/** Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively */
export type getRepliedMessage$Input = {
  readonly _: "getRepliedMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the reply message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
 *
 * @param {getRepliedMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type getRepliedMessage = (parameters: getRepliedMessage$Input) => Message;

/** Returns information about a newest pinned message in the chat */
export type getChatPinnedMessage$Input = {
  readonly _: "getChatPinnedMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a newest pinned message in the chat
 *
 * @param {getChatPinnedMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type getChatPinnedMessage = (
  parameters: getChatPinnedMessage$Input
) => Message;

/** Returns information about a message with the callback button that originated a callback query; for bots only */
export type getCallbackQueryMessage$Input = {
  readonly _: "getCallbackQueryMessage";

  /**
   * Identifier of the chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the callback query
   * @type {int64} {@link int64}
   */
  readonly callback_query_id?: int64;
};

/**
 * Returns information about a message with the callback button that originated a callback query; for bots only
 *
 * @param {getCallbackQueryMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type getCallbackQueryMessage = (
  parameters: getCallbackQueryMessage$Input
) => Message;

/** Returns information about messages. If a message is not found, returns null on the corresponding position of the result */
export type getMessages$Input = {
  readonly _: "getMessages";

  /**
   * Identifier of the chat the messages belong to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to get
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Returns information about messages. If a message is not found, returns null on the corresponding position of the result
 *
 * @param {getMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type getMessages = (parameters: getMessages$Input) => Messages;

/** Returns information about a message thread. Can be used only if message.can_get_message_thread == true */
export type getMessageThread$Input = {
  readonly _: "getMessageThread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a message thread. Can be used only if message.can_get_message_thread == true
 *
 * @param {getMessageThread$Input} parameters
 * @return {MessageThreadInfo} {@link MessageThreadInfo}
 */
export type getMessageThread = (
  parameters: getMessageThread$Input
) => MessageThreadInfo;

/** Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true */
export type getMessageViewers$Input = {
  readonly _: "getMessageViewers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
 *
 * @param {getMessageViewers$Input} parameters
 * @return {Users} {@link Users}
 */
export type getMessageViewers = (parameters: getMessageViewers$Input) => Users;

/** Returns information about a file; this is an offline request */
export type getFile$Input = {
  readonly _: "getFile";

  /**
   * Identifier of the file to get
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Returns information about a file; this is an offline request
 *
 * @param {getFile$Input} parameters
 * @return {File} {@link File}
 */
export type getFile = (parameters: getFile$Input) => File;

/** Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
-For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application */
export type getRemoteFile$Input = {
  readonly _: "getRemoteFile";

  /**
   * Remote identifier of the file to get
   * @type {string} {@link string}
   */
  readonly remote_file_id?: string;

  /**
   * File type; pass null if unknown
   * @type {FileType$Input} {@link FileType}
   */
  readonly file_type?: FileType$Input;
};

/**
 * Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user.
-For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
 * 
 * @param {getRemoteFile$Input} parameters
 * @return {File} {@link File}
 */
export type getRemoteFile = (parameters: getRemoteFile$Input) => File;

/** Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded */
export type loadChats$Input = {
  readonly _: "loadChats";

  /**
   * The chat list in which to load chats; pass null to load chats from the main chat list
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
 *
 * @param {loadChats$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type loadChats = (parameters: loadChats$Input) => Ok;

/** Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state */
export type getChats$Input = {
  readonly _: "getChats";

  /**
   * The chat list in which to return chats; pass null to get chats from the main chat list
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
 *
 * @param {getChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getChats = (parameters: getChats$Input) => Chats;

/** Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned */
export type searchPublicChat$Input = {
  readonly _: "searchPublicChat";

  /**
   * Username to be resolved
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Searches a public chat by its username. Currently, only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
 *
 * @param {searchPublicChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type searchPublicChat = (parameters: searchPublicChat$Input) => Chat;

/** Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
-Excludes private chats with contacts and chats from the chat list from the results */
export type searchPublicChats$Input = {
  readonly _: "searchPublicChats";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Searches public chats by looking for specified query in their username and title. Currently, only private chats, supergroups and channels can be public. Returns a meaningful number of results.
-Excludes private chats with contacts and chats from the chat list from the results
 * 
 * @param {searchPublicChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type searchPublicChats = (parameters: searchPublicChats$Input) => Chats;

/** Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the main chat list */
export type searchChats$Input = {
  readonly _: "searchChats";

  /**
   * Query to search for. If the query is empty, returns up to 50 recently found chats
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the main chat list
 *
 * @param {searchChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type searchChats = (parameters: searchChats$Input) => Chats;

/** Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list */
export type searchChatsOnServer$Input = {
  readonly _: "searchChatsOnServer";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
 *
 * @param {searchChatsOnServer$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type searchChatsOnServer = (parameters: searchChatsOnServer$Input) => Chats;

/** Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby. The request must be sent again every 25 seconds with adjusted location to not miss new chats */
export type searchChatsNearby$Input = {
  readonly _: "searchChatsNearby";

  /**
   * Current user location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby. The request must be sent again every 25 seconds with adjusted location to not miss new chats
 *
 * @param {searchChatsNearby$Input} parameters
 * @return {ChatsNearby} {@link ChatsNearby}
 */
export type searchChatsNearby = (parameters: searchChatsNearby$Input) => ChatsNearby;

/** Returns a list of frequently used chats. Supported only if the chat info database is enabled */
export type getTopChats$Input = {
  readonly _: "getTopChats";

  /**
   * Category of chats to be returned
   * @type {TopChatCategory$Input} {@link TopChatCategory}
   */
  readonly category?: TopChatCategory$Input;

  /**
   * The maximum number of chats to be returned; up to 30
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of frequently used chats. Supported only if the chat info database is enabled
 *
 * @param {getTopChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getTopChats = (parameters: getTopChats$Input) => Chats;

/** Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled */
export type removeTopChat$Input = {
  readonly _: "removeTopChat";

  /**
   * Category of frequently used chats
   * @type {TopChatCategory$Input} {@link TopChatCategory}
   */
  readonly category?: TopChatCategory$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
 *
 * @param {removeTopChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeTopChat = (parameters: removeTopChat$Input) => Ok;

/** Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first */
export type addRecentlyFoundChat$Input = {
  readonly _: "addRecentlyFoundChat";

  /**
   * Identifier of the chat to add
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
 *
 * @param {addRecentlyFoundChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addRecentlyFoundChat = (parameters: addRecentlyFoundChat$Input) => Ok;

/** Removes a chat from the list of recently found chats */
export type removeRecentlyFoundChat$Input = {
  readonly _: "removeRecentlyFoundChat";

  /**
   * Identifier of the chat to be removed
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat from the list of recently found chats
 *
 * @param {removeRecentlyFoundChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeRecentlyFoundChat = (
  parameters: removeRecentlyFoundChat$Input
) => Ok;

/** Clears the list of recently found chats */
export type clearRecentlyFoundChats$Input = {
  readonly _: "clearRecentlyFoundChats";
};

/**
 * Clears the list of recently found chats
 *
 * @param {clearRecentlyFoundChats$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clearRecentlyFoundChats = (
  parameters: clearRecentlyFoundChats$Input
) => Ok;

/** Returns recently opened chats, this is an offline request. Returns chats in the order of last opening */
export type getRecentlyOpenedChats$Input = {
  readonly _: "getRecentlyOpenedChats";

  /**
   * The maximum number of chats to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns recently opened chats, this is an offline request. Returns chats in the order of last opening
 *
 * @param {getRecentlyOpenedChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getRecentlyOpenedChats = (
  parameters: getRecentlyOpenedChats$Input
) => Chats;

/** Checks whether a username can be set for a chat */
export type checkChatUsername$Input = {
  readonly _: "checkChatUsername";

  /**
   * Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if the chat is being created
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Username to be checked
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Checks whether a username can be set for a chat
 *
 * @param {checkChatUsername$Input} parameters
 * @return {CheckChatUsernameResult} {@link CheckChatUsernameResult}
 */
export type checkChatUsername = (
  parameters: checkChatUsername$Input
) => CheckChatUsernameResult;

/** Returns a list of public chats of the specified type, owned by the user */
export type getCreatedPublicChats$Input = {
  readonly _: "getCreatedPublicChats";

  /**
   * Type of the public chats to return
   * @type {PublicChatType$Input} {@link PublicChatType}
   */
  readonly type?: PublicChatType$Input;
};

/**
 * Returns a list of public chats of the specified type, owned by the user
 *
 * @param {getCreatedPublicChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getCreatedPublicChats = (
  parameters: getCreatedPublicChats$Input
) => Chats;

/** Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium */
export type checkCreatedPublicChatsLimit$Input = {
  readonly _: "checkCreatedPublicChatsLimit";

  /**
   * Type of the public chats, for which to check the limit
   * @type {PublicChatType$Input} {@link PublicChatType}
   */
  readonly type?: PublicChatType$Input;
};

/**
 * Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached. The limit can be increased with Telegram Premium
 *
 * @param {checkCreatedPublicChatsLimit$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkCreatedPublicChatsLimit = (
  parameters: checkCreatedPublicChatsLimit$Input
) => Ok;

/** Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group. To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first */
export type getSuitableDiscussionChats$Input = {
  readonly _: "getSuitableDiscussionChats";
};

/**
 * Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group. To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
 *
 * @param {getSuitableDiscussionChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getSuitableDiscussionChats = (
  parameters: getSuitableDiscussionChats$Input
) => Chats;

/** Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium */
export type getInactiveSupergroupChats$Input = {
  readonly _: "getInactiveSupergroupChats";
};

/**
 * Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error. Also, the limit can be increased with Telegram Premium
 *
 * @param {getInactiveSupergroupChats$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getInactiveSupergroupChats = (
  parameters: getInactiveSupergroupChats$Input
) => Chats;

/** Returns a list of common group chats with a given user. Chats are sorted by their type and creation date */
export type getGroupsInCommon$Input = {
  readonly _: "getGroupsInCommon";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Chat identifier starting from which to return chats; use 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_chat_id?: int53;

  /**
   * The maximum number of chats to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
 *
 * @param {getGroupsInCommon$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getGroupsInCommon = (parameters: getGroupsInCommon$Input) => Chats;

/** Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
-For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true */
export type getChatHistory$Input = {
  readonly _: "getChatHistory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to get only messages that are available without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id).
-For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
 * 
 * @param {getChatHistory$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type getChatHistory = (parameters: getChatHistory$Input) => Messages;

/** Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
-The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib */
export type getMessageThreadHistory$Input = {
  readonly _: "getMessageThreadHistory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier, which thread history needs to be returned
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup.
-The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 * 
 * @param {getMessageThreadHistory$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type getMessageThreadHistory = (
  parameters: getMessageThreadHistory$Input
) => Messages;

/** Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat */
export type deleteChatHistory$Input = {
  readonly _: "deleteChatHistory";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to remove the chat from all chat lists
   * @type {Bool$Input} {@link Bool}
   */
  readonly remove_from_chat_list?: Bool$Input;

  /**
   * Pass true to delete chat history for all users
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
 *
 * @param {deleteChatHistory$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteChatHistory = (parameters: deleteChatHistory$Input) => Ok;

/** Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members. Use the field chat.can_be_deleted_for_all_users to find whether the method can be applied to the chat */
export type deleteChat$Input = {
  readonly _: "deleteChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Deletes a chat along with all messages in the corresponding chat for all chat members. For group chats this will release the usernames and remove all members. Use the field chat.can_be_deleted_for_all_users to find whether the method can be applied to the chat
 *
 * @param {deleteChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteChat = (parameters: deleteChat$Input) => Ok;

/** Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
-(searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
-A combination of query, sender_id, filter and message_thread_id search criteria is expected to be supported, only if it is required for Telegram official application implementation */
export type searchChatMessages$Input = {
  readonly _: "searchChatMessages";

  /**
   * Identifier of the chat in which to search messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of the sender of messages to search for; pass null to search for messages from any sender. Not supported in secret chats
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * If not 0, only messages in the specified thread will be returned; supergroups only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query
-(searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit.
-A combination of query, sender_id, filter and message_thread_id search criteria is expected to be supported, only if it is required for Telegram official application implementation
 * 
 * @param {searchChatMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type searchChatMessages = (parameters: searchChatMessages$Input) => Messages;

/** Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
-For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit */
export type searchMessages$Input = {
  readonly _: "searchMessages";

  /**
   * Chat list in which to search messages; pass null to search in all chats regardless of their chat list. Only Main and Archive chat lists are supported
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The date of the message starting from which the results need to be fetched. Use 0 or any date in the future to get results from the last message
   * @type {int32} {@link int32}
   */
  readonly offset_date?: int32;

  /**
   * The chat identifier of the last found message, or 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_chat_id?: int53;

  /**
   * The message identifier of the last found message, or 0 for the first request
   * @type {int53} {@link int53}
   */
  readonly offset_message_id?: int53;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages. Filters searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, searchMessagesFilterFailedToSend, and searchMessagesFilterPinned are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * If not 0, the minimum date of the messages to return
   * @type {int32} {@link int32}
   */
  readonly min_date?: int32;

  /**
   * If not 0, the maximum date of the messages to return
   * @type {int32} {@link int32}
   */
  readonly max_date?: int32;
};

/**
 * Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)).
-For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
 * 
 * @param {searchMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type searchMessages = (parameters: searchMessages$Input) => Messages;

/** Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib */
export type searchSecretMessages$Input = {
  readonly _: "searchSecretMessages";

  /**
   * Identifier of the chat in which to search. Specify 0 to search in all secret chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for. If empty, searchChatMessages must be used instead
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Additional filter for messages to search; pass null to search for all messages
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;
};

/**
 * Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
 *
 * @param {searchSecretMessages$Input} parameters
 * @return {FoundMessages} {@link FoundMessages}
 */
export type searchSecretMessages = (
  parameters: searchSecretMessages$Input
) => FoundMessages;

/** Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib */
export type searchCallMessages$Input = {
  readonly _: "searchCallMessages";

  /**
   * Identifier of the message from which to search; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Pass true to search only for messages with missed/declined calls
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_missed?: Bool$Input;
};

/**
 * Searches for call messages. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
 *
 * @param {searchCallMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type searchCallMessages = (parameters: searchCallMessages$Input) => Messages;

/** Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order */
export type searchOutgoingDocumentMessages$Input = {
  readonly _: "searchOutgoingDocumentMessages";

  /**
   * Query to search for in document file name and message caption
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of messages to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for outgoing messages with content of the type messageDocument in all chats except secret chats. Returns the results in reverse chronological order
 *
 * @param {searchOutgoingDocumentMessages$Input} parameters
 * @return {FoundMessages} {@link FoundMessages}
 */
export type searchOutgoingDocumentMessages = (
  parameters: searchOutgoingDocumentMessages$Input
) => FoundMessages;

/** Deletes all call messages */
export type deleteAllCallMessages$Input = {
  readonly _: "deleteAllCallMessages";

  /**
   * Pass true to delete the messages for all users
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all call messages
 *
 * @param {deleteAllCallMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteAllCallMessages = (parameters: deleteAllCallMessages$Input) => Ok;

/** Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user */
export type searchChatRecentLocationMessages$Input = {
  readonly _: "searchChatRecentLocationMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The maximum number of messages to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
 *
 * @param {searchChatRecentLocationMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type searchChatRecentLocationMessages = (
  parameters: searchChatRecentLocationMessages$Input
) => Messages;

/** Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used */
export type getActiveLiveLocationMessages$Input = {
  readonly _: "getActiveLiveLocationMessages";
};

/**
 * Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
 *
 * @param {getActiveLiveLocationMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type getActiveLiveLocationMessages = (
  parameters: getActiveLiveLocationMessages$Input
) => Messages;

/** Returns the last message sent in a chat no later than the specified date */
export type getChatMessageByDate$Input = {
  readonly _: "getChatMessageByDate";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Point in time (Unix timestamp) relative to which to search for messages
   * @type {int32} {@link int32}
   */
  readonly date?: int32;
};

/**
 * Returns the last message sent in a chat no later than the specified date
 *
 * @param {getChatMessageByDate$Input} parameters
 * @return {Message} {@link Message}
 */
export type getChatMessageByDate = (
  parameters: getChatMessageByDate$Input
) => Message;

/** Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
-Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database */
export type getChatSparseMessagePositions$Input = {
  readonly _: "getChatSparseMessagePositions";

  /**
   * Identifier of the chat in which to return information about message positions
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * The message identifier from which to return information about message positions
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;

  /**
   * The expected number of message positions to be returned; 50-2000. A smaller number of positions can be returned, if there are not enough appropriate messages
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id).
-Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
 * 
 * @param {getChatSparseMessagePositions$Input} parameters
 * @return {MessagePositions} {@link MessagePositions}
 */
export type getChatSparseMessagePositions = (
  parameters: getChatSparseMessagePositions$Input
) => MessagePositions;

/** Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset" */
export type getChatMessageCalendar$Input = {
  readonly _: "getChatMessageCalendar";

  /**
   * Identifier of the chat in which to return information about messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterMention, searchMessagesFilterUnreadMention, and searchMessagesFilterUnreadReaction are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * The message identifier from which to return information about messages; use 0 to get results from the last message
   * @type {int53} {@link int53}
   */
  readonly from_message_id?: int53;
};

/**
 * Returns information about the next messages of the specified type in the chat split by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
 *
 * @param {getChatMessageCalendar$Input} parameters
 * @return {MessageCalendar} {@link MessageCalendar}
 */
export type getChatMessageCalendar = (
  parameters: getChatMessageCalendar$Input
) => MessageCalendar;

/** Returns approximate number of messages of the specified type in the chat */
export type getChatMessageCount$Input = {
  readonly _: "getChatMessageCount";

  /**
   * Identifier of the chat in which to count messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Filter for message content; searchMessagesFilterEmpty is unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * Pass true to get the number of messages without sending network requests, or -1 if the number of messages is unknown locally
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_local?: Bool$Input;
};

/**
 * Returns approximate number of messages of the specified type in the chat
 *
 * @param {getChatMessageCount$Input} parameters
 * @return {Count} {@link Count}
 */
export type getChatMessageCount = (parameters: getChatMessageCount$Input) => Count;

/** Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats */
export type getChatMessagePosition$Input = {
  readonly _: "getChatMessagePosition";

  /**
   * Identifier of the chat in which to find message position
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Filter for message content; searchMessagesFilterEmpty, searchMessagesFilterUnreadMention, searchMessagesFilterUnreadReaction, and searchMessagesFilterFailedToSend are unsupported in this function
   * @type {SearchMessagesFilter$Input} {@link SearchMessagesFilter}
   */
  readonly filter?: SearchMessagesFilter$Input;

  /**
   * If not 0, only messages in the specified thread will be considered; supergroups only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Returns approximate 1-based position of a message among messages, which can be found by the specified filter in the chat. Cannot be used in secret chats
 *
 * @param {getChatMessagePosition$Input} parameters
 * @return {Count} {@link Count}
 */
export type getChatMessagePosition = (
  parameters: getChatMessagePosition$Input
) => Count;

/** Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id) */
export type getChatScheduledMessages$Input = {
  readonly _: "getChatScheduledMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
 *
 * @param {getChatScheduledMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type getChatScheduledMessages = (
  parameters: getChatScheduledMessages$Input
) => Messages;

/** Returns forwarded copies of a channel message to different public channels. For optimal performance, the number of returned messages is chosen by TDLib */
export type getMessagePublicForwards$Input = {
  readonly _: "getMessagePublicForwards";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of messages to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns forwarded copies of a channel message to different public channels. For optimal performance, the number of returned messages is chosen by TDLib
 *
 * @param {getMessagePublicForwards$Input} parameters
 * @return {FoundMessages} {@link FoundMessages}
 */
export type getMessagePublicForwards = (
  parameters: getMessagePublicForwards$Input
) => FoundMessages;

/** Returns sponsored messages to be shown in a chat; for channel chats only */
export type getChatSponsoredMessages$Input = {
  readonly _: "getChatSponsoredMessages";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns sponsored messages to be shown in a chat; for channel chats only
 *
 * @param {getChatSponsoredMessages$Input} parameters
 * @return {SponsoredMessages} {@link SponsoredMessages}
 */
export type getChatSponsoredMessages = (
  parameters: getChatSponsoredMessages$Input
) => SponsoredMessages;

/** Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user */
export type removeNotification$Input = {
  readonly _: "removeNotification";

  /**
   * Identifier of notification group to which the notification belongs
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * Identifier of removed notification
   * @type {int32} {@link int32}
   */
  readonly notification_id?: int32;
};

/**
 * Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
 *
 * @param {removeNotification$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeNotification = (parameters: removeNotification$Input) => Ok;

/** Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user */
export type removeNotificationGroup$Input = {
  readonly _: "removeNotificationGroup";

  /**
   * Notification group identifier
   * @type {int32} {@link int32}
   */
  readonly notification_group_id?: int32;

  /**
   * The maximum identifier of removed notifications
   * @type {int32} {@link int32}
   */
  readonly max_notification_id?: int32;
};

/**
 * Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
 *
 * @param {removeNotificationGroup$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeNotificationGroup = (
  parameters: removeNotificationGroup$Input
) => Ok;

/** Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request */
export type getMessageLink$Input = {
  readonly _: "getMessageLink";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * If not 0, timestamp from which the video/audio/video note/voice note playing must start, in seconds. The media can be in the message content or in its web page preview
   * @type {int32} {@link int32}
   */
  readonly media_timestamp?: int32;

  /**
   * Pass true to create a link for the whole media album
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_album?: Bool$Input;

  /**
   * Pass true to create a link to the message as a channel post comment, in a message thread, or a forum topic
   * @type {Bool$Input} {@link Bool}
   */
  readonly in_message_thread?: Bool$Input;
};

/**
 * Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
 *
 * @param {getMessageLink$Input} parameters
 * @return {MessageLink} {@link MessageLink}
 */
export type getMessageLink = (parameters: getMessageLink$Input) => MessageLink;

/** Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username */
export type getMessageEmbeddingCode$Input = {
  readonly _: "getMessageEmbeddingCode";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to return an HTML code for embedding of the whole media album
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_album?: Bool$Input;
};

/**
 * Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
 *
 * @param {getMessageEmbeddingCode$Input} parameters
 * @return {Text} {@link Text}
 */
export type getMessageEmbeddingCode = (
  parameters: getMessageEmbeddingCode$Input
) => Text;

/** Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage */
export type getMessageLinkInfo$Input = {
  readonly _: "getMessageLinkInfo";

  /**
   * The message link
   * @type {string} {@link string}
   */
  readonly url?: string;
};

/**
 * Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
 *
 * @param {getMessageLinkInfo$Input} parameters
 * @return {MessageLinkInfo} {@link MessageLinkInfo}
 */
export type getMessageLinkInfo = (
  parameters: getMessageLinkInfo$Input
) => MessageLinkInfo;

/** Translates a text to the given language. Returns a 404 error if the translation can't be performed */
export type translateText$Input = {
  readonly _: "translateText";

  /**
   * Text to translate
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * A two-letter ISO 639-1 language code of the language from which the message is translated. If empty, the language will be detected automatically
   * @type {string} {@link string}
   */
  readonly from_language_code?: string;

  /**
   * A two-letter ISO 639-1 language code of the language to which the message is translated
   * @type {string} {@link string}
   */
  readonly to_language_code?: string;
};

/**
 * Translates a text to the given language. Returns a 404 error if the translation can't be performed
 *
 * @param {translateText$Input} parameters
 * @return {Text} {@link Text}
 */
export type translateText = (parameters: translateText$Input) => Text;

/** Recognizes speech in a video note or a voice note message. The message must be successfully sent and must not be scheduled. May return an error with a message "MSG_VOICE_TOO_LONG" if media duration is too big to be recognized */
export type recognizeSpeech$Input = {
  readonly _: "recognizeSpeech";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Recognizes speech in a video note or a voice note message. The message must be successfully sent and must not be scheduled. May return an error with a message "MSG_VOICE_TOO_LONG" if media duration is too big to be recognized
 *
 * @param {recognizeSpeech$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type recognizeSpeech = (parameters: recognizeSpeech$Input) => Ok;

/** Rates recognized speech in a video note or a voice note message */
export type rateSpeechRecognition$Input = {
  readonly _: "rateSpeechRecognition";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true if the speech recognition is good
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_good?: Bool$Input;
};

/**
 * Rates recognized speech in a video note or a voice note message
 *
 * @param {rateSpeechRecognition$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type rateSpeechRecognition = (parameters: rateSpeechRecognition$Input) => Ok;

/** Returns list of message sender identifiers, which can be used to send messages in a chat */
export type getChatAvailableMessageSenders$Input = {
  readonly _: "getChatAvailableMessageSenders";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of message sender identifiers, which can be used to send messages in a chat
 *
 * @param {getChatAvailableMessageSenders$Input} parameters
 * @return {ChatMessageSenders} {@link ChatMessageSenders}
 */
export type getChatAvailableMessageSenders = (
  parameters: getChatAvailableMessageSenders$Input
) => ChatMessageSenders;

/** Selects a message sender to send messages in a chat */
export type setChatMessageSender$Input = {
  readonly _: "setChatMessageSender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New message sender for the chat
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly message_sender_id?: MessageSender$Input;
};

/**
 * Selects a message sender to send messages in a chat
 *
 * @param {setChatMessageSender$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatMessageSender = (parameters: setChatMessageSender$Input) => Ok;

/** Sends a message. Returns the sent message */
export type sendMessage$Input = {
  readonly _: "sendMessage";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of the replied message; 0 if none
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;

  /**
   * Options to be used to send the message; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input;

  /**
   * Markup for replying to the message; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * The content of the message to be sent
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Sends a message. Returns the sent message
 *
 * @param {sendMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type sendMessage = (parameters: sendMessage$Input) => Message;

/** Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages */
export type sendMessageAlbum$Input = {
  readonly _: "sendMessageAlbum";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the messages will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of a replied message; 0 if none
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;

  /**
   * Options to be used to send the messages; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input;

  /**
   * Contents of messages to be sent. At most 10 messages can be added to an album
   * @type {vector$Input<InputMessageContent$Input>} {@link vector<InputMessageContent>}
   */
  readonly input_message_contents?: vector$Input<InputMessageContent$Input>;

  /**
   * Pass true to get fake messages instead of actually sending them
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_preview?: Bool$Input;
};

/**
 * Sends 2-10 messages grouped together into an album. Currently, only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
 *
 * @param {sendMessageAlbum$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type sendMessageAlbum = (parameters: sendMessageAlbum$Input) => Messages;

/** Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message */
export type sendBotStartMessage$Input = {
  readonly _: "sendBotStartMessage";

  /**
   * Identifier of the bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Identifier of the target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)
   * @type {string} {@link string}
   */
  readonly parameter?: string;
};

/**
 * Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
 *
 * @param {sendBotStartMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type sendBotStartMessage = (parameters: sendBotStartMessage$Input) => Message;

/** Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message */
export type sendInlineQueryResultMessage$Input = {
  readonly _: "sendInlineQueryResultMessage";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of a replied message; 0 if none
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;

  /**
   * Options to be used to send the message; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input;

  /**
   * Identifier of the inline query
   * @type {int64} {@link int64}
   */
  readonly query_id?: int64;

  /**
   * Identifier of the inline result
   * @type {string} {@link string}
   */
  readonly result_id?: string;

  /**
   * Pass true to hide the bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username"), and GetOption("venue_search_bot_username")
   * @type {Bool$Input} {@link Bool}
   */
  readonly hide_via_bot?: Bool$Input;
};

/**
 * Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
 *
 * @param {sendInlineQueryResultMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type sendInlineQueryResultMessage = (
  parameters: sendInlineQueryResultMessage$Input
) => Message;

/** Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message */
export type forwardMessages$Input = {
  readonly _: "forwardMessages";

  /**
   * Identifier of the chat to which to forward messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the message will be sent; for forum threads only
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of the chat from which to forward messages
   * @type {int53} {@link int53}
   */
  readonly from_chat_id?: int53;

  /**
   * Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order. At most 100 messages can be forwarded simultaneously
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Options to be used to send the messages; pass null to use default options
   * @type {messageSendOptions$Input} {@link messageSendOptions}
   */
  readonly options?: messageSendOptions$Input;

  /**
   * Pass true to copy content of the messages without reference to the original sender. Always true if the messages are forwarded to a secret chat or are local
   * @type {Bool$Input} {@link Bool}
   */
  readonly send_copy?: Bool$Input;

  /**
   * Pass true to remove media captions of message copies. Ignored if send_copy is false
   * @type {Bool$Input} {@link Bool}
   */
  readonly remove_caption?: Bool$Input;

  /**
   * Pass true to get fake messages instead of actually forwarding them
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_preview?: Bool$Input;
};

/**
 * Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
 *
 * @param {forwardMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type forwardMessages = (parameters: forwardMessages$Input) => Messages;

/** Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
-If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message */
export type resendMessages$Input = {
  readonly _: "resendMessages";

  /**
   * Identifier of the chat to send messages
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed.
-If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
 * 
 * @param {resendMessages$Input} parameters
 * @return {Messages} {@link Messages}
 */
export type resendMessages = (parameters: resendMessages$Input) => Messages;

/** Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats */
export type sendChatScreenshotTakenNotification$Input = {
  readonly _: "sendChatScreenshotTakenNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
 *
 * @param {sendChatScreenshotTakenNotification$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendChatScreenshotTakenNotification = (
  parameters: sendChatScreenshotTakenNotification$Input
) => Ok;

/** Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message */
export type addLocalMessage$Input = {
  readonly _: "addLocalMessage";

  /**
   * Target chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sender of the message
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * Identifier of the replied message; 0 if none
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;

  /**
   * Pass true to disable notification for the message
   * @type {Bool$Input} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * The content of the message to be added
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
 *
 * @param {addLocalMessage$Input} parameters
 * @return {Message} {@link Message}
 */
export type addLocalMessage = (parameters: addLocalMessage$Input) => Message;

/** Deletes messages */
export type deleteMessages$Input = {
  readonly _: "deleteMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the messages to be deleted
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Pass true to delete messages for all chat members. Always true for supergroups, channels and secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes messages
 *
 * @param {deleteMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteMessages = (parameters: deleteMessages$Input) => Ok;

/** Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges */
export type deleteChatMessagesBySender$Input = {
  readonly _: "deleteChatMessagesBySender";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the sender of messages to delete
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/**
 * Deletes all messages sent by the specified message sender in a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
 *
 * @param {deleteChatMessagesBySender$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteChatMessagesBySender = (
  parameters: deleteChatMessagesBySender$Input
) => Ok;

/** Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted */
export type deleteChatMessagesByDate$Input = {
  readonly _: "deleteChatMessagesByDate";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The minimum date of the messages to delete
   * @type {int32} {@link int32}
   */
  readonly min_date?: int32;

  /**
   * The maximum date of the messages to delete
   * @type {int32} {@link int32}
   */
  readonly max_date?: int32;

  /**
   * Pass true to delete chat messages for all users; private chats only
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke?: Bool$Input;
};

/**
 * Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
 *
 * @param {deleteChatMessagesByDate$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteChatMessagesByDate = (
  parameters: deleteChatMessagesByDate$Input
) => Ok;

/** Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side */
export type editMessageText$Input = {
  readonly _: "editMessageText";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New text content of the message. Must be of type inputMessageText
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageText$Input} parameters
 * @return {Message} {@link Message}
 */
export type editMessageText = (parameters: editMessageText$Input) => Message;

/** Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side */
export type editMessageLiveLocation$Input = {
  readonly _: "editMessageLiveLocation";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New location content of the message; pass null to stop sharing the live location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;

  /**
   * The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageLiveLocation$Input} parameters
 * @return {Message} {@link Message}
 */
export type editMessageLiveLocation = (
  parameters: editMessageLiveLocation$Input
) => Message;

/** Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
-The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side */
export type editMessageMedia$Input = {
  readonly _: "editMessageMedia";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead.
-The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
 * 
 * @param {editMessageMedia$Input} parameters
 * @return {Message} {@link Message}
 */
export type editMessageMedia = (parameters: editMessageMedia$Input) => Message;

/** Edits the message content caption. Returns the edited message after the edit is completed on the server side */
export type editMessageCaption$Input = {
  readonly _: "editMessageCaption";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New message content caption; 0-GetOption("message_caption_length_max") characters; pass null to remove caption
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * Edits the message content caption. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageCaption$Input} parameters
 * @return {Message} {@link Message}
 */
export type editMessageCaption = (parameters: editMessageCaption$Input) => Message;

/** Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side */
export type editMessageReplyMarkup$Input = {
  readonly _: "editMessageReplyMarkup";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;
};

/**
 * Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
 *
 * @param {editMessageReplyMarkup$Input} parameters
 * @return {Message} {@link Message}
 */
export type editMessageReplyMarkup = (
  parameters: editMessageReplyMarkup$Input
) => Message;

/** Edits the text of an inline text or game message sent via a bot; for bots only */
export type editInlineMessageText$Input = {
  readonly _: "editInlineMessageText";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New text content of the message. Must be of type inputMessageText
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the text of an inline text or game message sent via a bot; for bots only
 *
 * @param {editInlineMessageText$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageText = (parameters: editInlineMessageText$Input) => Ok;

/** Edits the content of a live location in an inline message sent via a bot; for bots only */
export type editInlineMessageLiveLocation$Input = {
  readonly _: "editInlineMessageLiveLocation";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New location content of the message; pass null to stop sharing the live location
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;

  /**
   * The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
   * @type {int32} {@link int32}
   */
  readonly heading?: int32;

  /**
   * The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
   * @type {int32} {@link int32}
   */
  readonly proximity_alert_radius?: int32;
};

/**
 * Edits the content of a live location in an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageLiveLocation$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageLiveLocation = (
  parameters: editInlineMessageLiveLocation$Input
) => Ok;

/** Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only */
export type editInlineMessageMedia$Input = {
  readonly _: "editInlineMessageMedia";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly input_message_content?: InputMessageContent$Input;
};

/**
 * Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageMedia$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageMedia = (
  parameters: editInlineMessageMedia$Input
) => Ok;

/** Edits the caption of an inline message sent via a bot; for bots only */
export type editInlineMessageCaption$Input = {
  readonly _: "editInlineMessageCaption";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;

  /**
   * New message content caption; pass null to remove caption; 0-GetOption("message_caption_length_max") characters
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly caption?: formattedText$Input;
};

/**
 * Edits the caption of an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageCaption$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageCaption = (
  parameters: editInlineMessageCaption$Input
) => Ok;

/** Edits the reply markup of an inline message sent via a bot; for bots only */
export type editInlineMessageReplyMarkup$Input = {
  readonly _: "editInlineMessageReplyMarkup";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * The new message reply markup; pass null if none
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;
};

/**
 * Edits the reply markup of an inline message sent via a bot; for bots only
 *
 * @param {editInlineMessageReplyMarkup$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editInlineMessageReplyMarkup = (
  parameters: editInlineMessageReplyMarkup$Input
) => Ok;

/** Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed */
export type editMessageSchedulingState$Input = {
  readonly _: "editMessageSchedulingState";

  /**
   * The chat the message belongs to
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message scheduling state; pass null to send the message immediately
   * @type {MessageSchedulingState$Input} {@link MessageSchedulingState}
   */
  readonly scheduling_state?: MessageSchedulingState$Input;
};

/**
 * Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
 *
 * @param {editMessageSchedulingState$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editMessageSchedulingState = (
  parameters: editMessageSchedulingState$Input
) => Ok;

/** Returns list of custom emojis, which can be used as forum topic icon by all users */
export type getForumTopicDefaultIcons$Input = {
  readonly _: "getForumTopicDefaultIcons";
};

/**
 * Returns list of custom emojis, which can be used as forum topic icon by all users
 *
 * @param {getForumTopicDefaultIcons$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getForumTopicDefaultIcons = (
  parameters: getForumTopicDefaultIcons$Input
) => Stickers;

/** Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup */
export type createForumTopic$Input = {
  readonly _: "createForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Name of the topic; 1-128 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Icon of the topic. Icon color must be one of 0x6FB9F0, 0xFFD67E, 0xCB86DB, 0x8EEE98, 0xFF93B2, or 0xFB6F5F. Telegram Premium users can use any custom emoji as topic icon, other users can use only a custom emoji returned by getForumTopicDefaultIcons
   * @type {forumTopicIcon$Input} {@link forumTopicIcon}
   */
  readonly icon?: forumTopicIcon$Input;
};

/**
 * Creates a topic in a forum supergroup chat; requires can_manage_topics rights in the supergroup
 *
 * @param {createForumTopic$Input} parameters
 * @return {ForumTopicInfo} {@link ForumTopicInfo}
 */
export type createForumTopic = (
  parameters: createForumTopic$Input
) => ForumTopicInfo;

/** Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator rights in the supergroup unless the user is creator of the topic */
export type editForumTopic$Input = {
  readonly _: "editForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New name of the topic; 1-128 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Identifier of the new custom emoji for topic icon. Telegram Premium users can use any custom emoji, other users can use only a custom emoji returned by getForumTopicDefaultIcons
   * @type {int64} {@link int64}
   */
  readonly icon_custom_emoji_id?: int64;
};

/**
 * Edits title and icon of a topic in a forum supergroup chat; requires can_manage_topics administrator rights in the supergroup unless the user is creator of the topic
 *
 * @param {editForumTopic$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editForumTopic = (parameters: editForumTopic$Input) => Ok;

/** Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator rights in the supergroup unless the user is creator of the topic */
export type toggleForumTopicIsClosed$Input = {
  readonly _: "toggleForumTopicIsClosed";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Pass true to close the topic; pass false to reopen it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_closed?: Bool$Input;
};

/**
 * Toggles whether a topic is closed in a forum supergroup chat; requires can_manage_topics administrator rights in the supergroup unless the user is creator of the topic
 *
 * @param {toggleForumTopicIsClosed$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleForumTopicIsClosed = (
  parameters: toggleForumTopicIsClosed$Input
) => Ok;

/** Deletes all messages in a forum topic; requires can_delete_messages administrator rights in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages */
export type deleteForumTopic$Input = {
  readonly _: "deleteForumTopic";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier of the forum topic
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Deletes all messages in a forum topic; requires can_delete_messages administrator rights in the supergroup unless the user is creator of the topic, the topic has no messages from other users and has at most 11 messages
 *
 * @param {deleteForumTopic$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteForumTopic = (parameters: deleteForumTopic$Input) => Ok;

/** Returns information about a emoji reaction. Returns a 404 error if the reaction is not found */
export type getEmojiReaction$Input = {
  readonly _: "getEmojiReaction";

  /**
   * Text representation of the reaction
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * Returns information about a emoji reaction. Returns a 404 error if the reaction is not found
 *
 * @param {getEmojiReaction$Input} parameters
 * @return {EmojiReaction} {@link EmojiReaction}
 */
export type getEmojiReaction = (parameters: getEmojiReaction$Input) => EmojiReaction;

/** Returns TGS stickers with generic animations for custom emoji reactions */
export type getCustomEmojiReactionAnimations$Input = {
  readonly _: "getCustomEmojiReactionAnimations";
};

/**
 * Returns TGS stickers with generic animations for custom emoji reactions
 *
 * @param {getCustomEmojiReactionAnimations$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getCustomEmojiReactionAnimations = (
  parameters: getCustomEmojiReactionAnimations$Input
) => Stickers;

/** Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message */
export type getMessageAvailableReactions$Input = {
  readonly _: "getMessageAvailableReactions";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Number of reaction per row, 5-25
   * @type {int32} {@link int32}
   */
  readonly row_size?: int32;
};

/**
 * Returns reactions, which can be added to a message. The list can change after updateActiveEmojiReactions, updateChatAvailableReactions for the chat, or updateMessageInteractionInfo for the message
 *
 * @param {getMessageAvailableReactions$Input} parameters
 * @return {AvailableReactions} {@link AvailableReactions}
 */
export type getMessageAvailableReactions = (
  parameters: getMessageAvailableReactions$Input
) => AvailableReactions;

/** Clears the list of recently used reactions */
export type clearRecentReactions$Input = {
  readonly _: "clearRecentReactions";
};

/**
 * Clears the list of recently used reactions
 *
 * @param {clearRecentReactions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clearRecentReactions = (parameters: clearRecentReactions$Input) => Ok;

/** Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message */
export type addMessageReaction$Input = {
  readonly _: "addMessageReaction";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reaction to add
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;

  /**
   * Pass true if the reaction is added with a big animation
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_big?: Bool$Input;

  /**
   * Pass true if the reaction needs to be added to recent reactions
   * @type {Bool$Input} {@link Bool}
   */
  readonly update_recent_reactions?: Bool$Input;
};

/**
 * Adds a reaction to a message. Use getMessageAvailableReactions to receive the list of available reactions for the message
 *
 * @param {addMessageReaction$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addMessageReaction = (parameters: addMessageReaction$Input) => Ok;

/** Removes a reaction from a message. A chosen reaction can always be removed */
export type removeMessageReaction$Input = {
  readonly _: "removeMessageReaction";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reaction to remove
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * Removes a reaction from a message. A chosen reaction can always be removed
 *
 * @param {removeMessageReaction$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeMessageReaction = (parameters: removeMessageReaction$Input) => Ok;

/** Returns reactions added for a message, along with their sender */
export type getMessageAddedReactions$Input = {
  readonly _: "getMessageAddedReactions";

  /**
   * Identifier of the chat to which the message belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Type of the reactions to return; pass null to return all added reactions
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of reactions to be returned; must be positive and can't be greater than 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns reactions added for a message, along with their sender
 *
 * @param {getMessageAddedReactions$Input} parameters
 * @return {AddedReactions} {@link AddedReactions}
 */
export type getMessageAddedReactions = (
  parameters: getMessageAddedReactions$Input
) => AddedReactions;

/** Changes type of default reaction for the current user */
export type setDefaultReactionType$Input = {
  readonly _: "setDefaultReactionType";

  /**
   * New type of the default reaction
   * @type {ReactionType$Input} {@link ReactionType}
   */
  readonly reaction_type?: ReactionType$Input;
};

/**
 * Changes type of default reaction for the current user
 *
 * @param {setDefaultReactionType$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setDefaultReactionType = (
  parameters: setDefaultReactionType$Input
) => Ok;

/** Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously */
export type getTextEntities$Input = {
  readonly _: "getTextEntities";

  /**
   * The text in which to look for entites
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) found in the text. Can be called synchronously
 *
 * @param {getTextEntities$Input} parameters
 * @return {TextEntities} {@link TextEntities}
 */
export type getTextEntities = (parameters: getTextEntities$Input) => TextEntities;

/** Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously */
export type parseTextEntities$Input = {
  readonly _: "parseTextEntities";

  /**
   * The text to parse
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Text parse mode
   * @type {TextParseMode$Input} {@link TextParseMode}
   */
  readonly parse_mode?: TextParseMode$Input;
};

/**
 * Parses Bold, Italic, Underline, Strikethrough, Spoiler, CustomEmoji, Code, Pre, PreCode, TextUrl and MentionName entities from a marked-up text. Can be called synchronously
 *
 * @param {parseTextEntities$Input} parameters
 * @return {FormattedText} {@link FormattedText}
 */
export type parseTextEntities = (
  parameters: parseTextEntities$Input
) => FormattedText;

/** Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously */
export type parseMarkdown$Input = {
  readonly _: "parseMarkdown";

  /**
   * The text to parse. For example, "__italic__ ~~strikethrough~~ ||spoiler|| **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
 *
 * @param {parseMarkdown$Input} parameters
 * @return {FormattedText} {@link FormattedText}
 */
export type parseMarkdown = (parameters: parseMarkdown$Input) => FormattedText;

/** Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously */
export type getMarkdownText$Input = {
  readonly _: "getMarkdownText";

  /**
   * The text
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
 *
 * @param {getMarkdownText$Input} parameters
 * @return {FormattedText} {@link FormattedText}
 */
export type getMarkdownText = (parameters: getMarkdownText$Input) => FormattedText;

/** Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously */
export type getFileMimeType$Input = {
  readonly _: "getFileMimeType";

  /**
   * The name of the file or path to the file
   * @type {string} {@link string}
   */
  readonly file_name?: string;
};

/**
 * Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
 *
 * @param {getFileMimeType$Input} parameters
 * @return {Text} {@link Text}
 */
export type getFileMimeType = (parameters: getFileMimeType$Input) => Text;

/** Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously */
export type getFileExtension$Input = {
  readonly _: "getFileExtension";

  /**
   * The MIME type of the file
   * @type {string} {@link string}
   */
  readonly mime_type?: string;
};

/**
 * Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
 *
 * @param {getFileExtension$Input} parameters
 * @return {Text} {@link Text}
 */
export type getFileExtension = (parameters: getFileExtension$Input) => Text;

/** Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously */
export type cleanFileName$Input = {
  readonly _: "cleanFileName";

  /**
   * File name or path to the file
   * @type {string} {@link string}
   */
  readonly file_name?: string;
};

/**
 * Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
 *
 * @param {cleanFileName$Input} parameters
 * @return {Text} {@link Text}
 */
export type cleanFileName = (parameters: cleanFileName$Input) => Text;

/** Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously */
export type getLanguagePackString$Input = {
  readonly _: "getLanguagePackString";

  /**
   * Path to the language pack database in which strings are stored
   * @type {string} {@link string}
   */
  readonly language_pack_database_path?: string;

  /**
   * Localization target to which the language pack belongs
   * @type {string} {@link string}
   */
  readonly localization_target?: string;

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * Language pack key of the string to be returned
   * @type {string} {@link string}
   */
  readonly key?: string;
};

/**
 * Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
 *
 * @param {getLanguagePackString$Input} parameters
 * @return {LanguagePackStringValue} {@link LanguagePackStringValue}
 */
export type getLanguagePackString = (
  parameters: getLanguagePackString$Input
) => LanguagePackStringValue;

/** Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously */
export type getJsonValue$Input = {
  readonly _: "getJsonValue";

  /**
   * The JSON-serialized string
   * @type {string} {@link string}
   */
  readonly json?: string;
};

/**
 * Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
 *
 * @param {getJsonValue$Input} parameters
 * @return {JsonValue} {@link JsonValue}
 */
export type getJsonValue = (parameters: getJsonValue$Input) => JsonValue;

/** Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously */
export type getJsonString$Input = {
  readonly _: "getJsonString";

  /**
   * The JsonValue object
   * @type {JsonValue$Input} {@link JsonValue}
   */
  readonly json_value?: JsonValue$Input;
};

/**
 * Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
 *
 * @param {getJsonString$Input} parameters
 * @return {Text} {@link Text}
 */
export type getJsonString = (parameters: getJsonString$Input) => Text;

/** Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously */
export type getThemeParametersJsonString$Input = {
  readonly _: "getThemeParametersJsonString";

  /**
   * Theme parameters to convert to JSON
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input;
};

/**
 * Converts a themeParameters object to corresponding JSON-serialized string. Can be called synchronously
 *
 * @param {getThemeParametersJsonString$Input} parameters
 * @return {Text} {@link Text}
 */
export type getThemeParametersJsonString = (
  parameters: getThemeParametersJsonString$Input
) => Text;

/** Changes the user answer to a poll. A poll in quiz mode can be answered only once */
export type setPollAnswer$Input = {
  readonly _: "setPollAnswer";

  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * 0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly option_ids?: vector$Input<int32>;
};

/**
 * Changes the user answer to a poll. A poll in quiz mode can be answered only once
 *
 * @param {setPollAnswer$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setPollAnswer = (parameters: setPollAnswer$Input) => Ok;

/** Returns users voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib */
export type getPollVoters$Input = {
  readonly _: "getPollVoters";

  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * 0-based identifier of the answer option
   * @type {int32} {@link int32}
   */
  readonly option_id?: int32;

  /**
   * Number of users to skip in the result; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users to be returned; must be positive and can't be greater than 50. For optimal performance, the number of returned users is chosen by TDLib and can be smaller than the specified limit, even if the end of the voter list has not been reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns users voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
 *
 * @param {getPollVoters$Input} parameters
 * @return {Users} {@link Users}
 */
export type getPollVoters = (parameters: getPollVoters$Input) => Users;

/** Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set */
export type stopPoll$Input = {
  readonly _: "stopPoll";

  /**
   * Identifier of the chat to which the poll belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message containing the poll
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * The new message reply markup; pass null if none; for bots only
   * @type {ReplyMarkup$Input} {@link ReplyMarkup}
   */
  readonly reply_markup?: ReplyMarkup$Input;
};

/**
 * Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set
 *
 * @param {stopPoll$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type stopPoll = (parameters: stopPoll$Input) => Ok;

/** Hides a suggested action */
export type hideSuggestedAction$Input = {
  readonly _: "hideSuggestedAction";

  /**
   * Suggested action to hide
   * @type {SuggestedAction$Input} {@link SuggestedAction}
   */
  readonly action?: SuggestedAction$Input;
};

/**
 * Hides a suggested action
 *
 * @param {hideSuggestedAction$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type hideSuggestedAction = (parameters: hideSuggestedAction$Input) => Ok;

/** Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button */
export type getLoginUrlInfo$Input = {
  readonly _: "getLoginUrlInfo";

  /**
   * Chat identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Button identifier
   * @type {int53} {@link int53}
   */
  readonly button_id?: int53;
};

/**
 * Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
 *
 * @param {getLoginUrlInfo$Input} parameters
 * @return {LoginUrlInfo} {@link LoginUrlInfo}
 */
export type getLoginUrlInfo = (parameters: getLoginUrlInfo$Input) => LoginUrlInfo;

/** Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
-Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button */
export type getLoginUrl$Input = {
  readonly _: "getLoginUrl";

  /**
   * Chat identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier of the message with the button
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Button identifier
   * @type {int53} {@link int53}
   */
  readonly button_id?: int53;

  /**
   * Pass true to allow the bot to send messages to the current user
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl.
-Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
 * 
 * @param {getLoginUrl$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getLoginUrl = (parameters: getLoginUrl$Input) => HttpUrl;

/** Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires */
export type getInlineQueryResults$Input = {
  readonly _: "getInlineQueryResults";

  /**
   * The identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Identifier of the chat where the query was sent
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Location of the user; pass null if unknown or the bot doesn't need user's location
   * @type {location$Input} {@link location}
   */
  readonly user_location?: location$Input;

  /**
   * Text of the query
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Offset of the first entry to return
   * @type {string} {@link string}
   */
  readonly offset?: string;
};

/**
 * Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 *
 * @param {getInlineQueryResults$Input} parameters
 * @return {InlineQueryResults} {@link InlineQueryResults}
 */
export type getInlineQueryResults = (
  parameters: getInlineQueryResults$Input
) => InlineQueryResults;

/** Sets the result of an inline query; for bots only */
export type answerInlineQuery$Input = {
  readonly _: "answerInlineQuery";

  /**
   * Identifier of the inline query
   * @type {int64} {@link int64}
   */
  readonly inline_query_id?: int64;

  /**
   * Pass true if results may be cached and returned only for the user that sent the query. By default, results may be returned to any user who sends the same query
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_personal?: Bool$Input;

  /**
   * The results of the query
   * @type {vector$Input<InputInlineQueryResult$Input>} {@link vector<InputInlineQueryResult>}
   */
  readonly results?: vector$Input<InputInlineQueryResult$Input>;

  /**
   * Allowed time to cache the results of the query, in seconds
   * @type {int32} {@link int32}
   */
  readonly cache_time?: int32;

  /**
   * Offset for the next inline query; pass an empty string if there are no more results
   * @type {string} {@link string}
   */
  readonly next_offset?: string;

  /**
   * If non-empty, this text must be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter
   * @type {string} {@link string}
   */
  readonly switch_pm_text?: string;

  /**
   * The parameter for the bot start message
   * @type {string} {@link string}
   */
  readonly switch_pm_parameter?: string;
};

/**
 * Sets the result of an inline query; for bots only
 *
 * @param {answerInlineQuery$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type answerInlineQuery = (parameters: answerInlineQuery$Input) => Ok;

/** Returns an HTTPS URL of a Web App to open after keyboardButtonTypeWebApp button is pressed */
export type getWebAppUrl$Input = {
  readonly _: "getWebAppUrl";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The URL from the keyboardButtonTypeWebApp button
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;
};

/**
 * Returns an HTTPS URL of a Web App to open after keyboardButtonTypeWebApp button is pressed
 *
 * @param {getWebAppUrl$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getWebAppUrl = (parameters: getWebAppUrl$Input) => HttpUrl;

/** Sends data received from a keyboardButtonTypeWebApp Web App to a bot */
export type sendWebAppData$Input = {
  readonly _: "sendWebAppData";

  /**
   * Identifier of the target bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Text of the keyboardButtonTypeWebApp button, which opened the Web App
   * @type {string} {@link string}
   */
  readonly button_text?: string;

  /**
   * Received data
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Sends data received from a keyboardButtonTypeWebApp Web App to a bot
 *
 * @param {sendWebAppData$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendWebAppData = (parameters: sendWebAppData$Input) => Ok;

/** Informs TDLib that a Web App is being opened from attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
-For each bot, a confirmation alert about data sent to the bot must be shown once */
export type openWebApp$Input = {
  readonly _: "openWebApp";

  /**
   * Identifier of the chat in which the Web App is opened
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the bot, providing the Web App
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * The URL from an inlineKeyboardButtonTypeWebApp button, a botMenuButton button, or an internalLinkTypeAttachmentMenuBot link, or an empty string otherwise
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Preferred Web App theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input;

  /**
   * Short name of the application; 0-64 English letters, digits, and underscores
   * @type {string} {@link string}
   */
  readonly application_name?: string;

  /**
   * If not 0, a message thread identifier in which the message will be sent
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * Identifier of the replied message for the message sent by the Web App; 0 if none
   * @type {int53} {@link int53}
   */
  readonly reply_to_message_id?: int53;
};

/**
 * Informs TDLib that a Web App is being opened from attachment menu, a botMenuButton button, an internalLinkTypeAttachmentMenuBot link, or an inlineKeyboardButtonTypeWebApp button.
-For each bot, a confirmation alert about data sent to the bot must be shown once
 * 
 * @param {openWebApp$Input} parameters
 * @return {WebAppInfo} {@link WebAppInfo}
 */
export type openWebApp = (parameters: openWebApp$Input) => WebAppInfo;

/** Informs TDLib that a previously opened Web App was closed */
export type closeWebApp$Input = {
  readonly _: "closeWebApp";

  /**
   * Identifier of Web App launch, received from openWebApp
   * @type {int64} {@link int64}
   */
  readonly web_app_launch_id?: int64;
};

/**
 * Informs TDLib that a previously opened Web App was closed
 *
 * @param {closeWebApp$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type closeWebApp = (parameters: closeWebApp$Input) => Ok;

/** Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only */
export type answerWebAppQuery$Input = {
  readonly _: "answerWebAppQuery";

  /**
   * Identifier of the Web App query
   * @type {string} {@link string}
   */
  readonly web_app_query_id?: string;

  /**
   * The result of the query
   * @type {InputInlineQueryResult$Input} {@link InputInlineQueryResult}
   */
  readonly result?: InputInlineQueryResult$Input;
};

/**
 * Sets the result of interaction with a Web App and sends corresponding message on behalf of the user to the chat from which the query originated; for bots only
 *
 * @param {answerWebAppQuery$Input} parameters
 * @return {SentWebAppMessage} {@link SentWebAppMessage}
 */
export type answerWebAppQuery = (
  parameters: answerWebAppQuery$Input
) => SentWebAppMessage;

/** Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires */
export type getCallbackQueryAnswer$Input = {
  readonly _: "getCallbackQueryAnswer";

  /**
   * Identifier of the chat with the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message from which the query originated
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Query payload
   * @type {CallbackQueryPayload$Input} {@link CallbackQueryPayload}
   */
  readonly payload?: CallbackQueryPayload$Input;
};

/**
 * Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
 *
 * @param {getCallbackQueryAnswer$Input} parameters
 * @return {CallbackQueryAnswer} {@link CallbackQueryAnswer}
 */
export type getCallbackQueryAnswer = (
  parameters: getCallbackQueryAnswer$Input
) => CallbackQueryAnswer;

/** Sets the result of a callback query; for bots only */
export type answerCallbackQuery$Input = {
  readonly _: "answerCallbackQuery";

  /**
   * Identifier of the callback query
   * @type {int64} {@link int64}
   */
  readonly callback_query_id?: int64;

  /**
   * Text of the answer
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Pass true to show an alert to the user instead of a toast notification
   * @type {Bool$Input} {@link Bool}
   */
  readonly show_alert?: Bool$Input;

  /**
   * URL to be opened
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Time during which the result of the query can be cached, in seconds
   * @type {int32} {@link int32}
   */
  readonly cache_time?: int32;
};

/**
 * Sets the result of a callback query; for bots only
 *
 * @param {answerCallbackQuery$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type answerCallbackQuery = (parameters: answerCallbackQuery$Input) => Ok;

/** Sets the result of a shipping query; for bots only */
export type answerShippingQuery$Input = {
  readonly _: "answerShippingQuery";

  /**
   * Identifier of the shipping query
   * @type {int64} {@link int64}
   */
  readonly shipping_query_id?: int64;

  /**
   * Available shipping options
   * @type {vector$Input<shippingOption$Input>} {@link vector<shippingOption>}
   */
  readonly shipping_options?: vector$Input<shippingOption$Input>;

  /**
   * An error message, empty on success
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Sets the result of a shipping query; for bots only
 *
 * @param {answerShippingQuery$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type answerShippingQuery = (parameters: answerShippingQuery$Input) => Ok;

/** Sets the result of a pre-checkout query; for bots only */
export type answerPreCheckoutQuery$Input = {
  readonly _: "answerPreCheckoutQuery";

  /**
   * Identifier of the pre-checkout query
   * @type {int64} {@link int64}
   */
  readonly pre_checkout_query_id?: int64;

  /**
   * An error message, empty on success
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Sets the result of a pre-checkout query; for bots only
 *
 * @param {answerPreCheckoutQuery$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type answerPreCheckoutQuery = (
  parameters: answerPreCheckoutQuery$Input
) => Ok;

/** Updates the game score of the specified user in the game; for bots only */
export type setGameScore$Input = {
  readonly _: "setGameScore";

  /**
   * The chat to which the message with the game belongs
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to edit the game message to include the current scoreboard
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_message?: Bool$Input;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The new score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Updates the game score of the specified user in the game; for bots only
 *
 * @param {setGameScore$Input} parameters
 * @return {Message} {@link Message}
 */
export type setGameScore = (parameters: setGameScore$Input) => Message;

/** Updates the game score of the specified user in a game; for bots only */
export type setInlineGameScore$Input = {
  readonly _: "setInlineGameScore";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * Pass true to edit the game message to include the current scoreboard
   * @type {Bool$Input} {@link Bool}
   */
  readonly edit_message?: Bool$Input;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The new score
   * @type {int32} {@link int32}
   */
  readonly score?: int32;

  /**
   * Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Updates the game score of the specified user in a game; for bots only
 *
 * @param {setInlineGameScore$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setInlineGameScore = (parameters: setInlineGameScore$Input) => Ok;

/** Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only */
export type getGameHighScores$Input = {
  readonly _: "getGameHighScores";

  /**
   * The chat that contains the message with the game
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
 *
 * @param {getGameHighScores$Input} parameters
 * @return {GameHighScores} {@link GameHighScores}
 */
export type getGameHighScores = (
  parameters: getGameHighScores$Input
) => GameHighScores;

/** Returns game high scores and some part of the high score table in the range of the specified user; for bots only */
export type getInlineGameHighScores$Input = {
  readonly _: "getInlineGameHighScores";

  /**
   * Inline message identifier
   * @type {string} {@link string}
   */
  readonly inline_message_id?: string;

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns game high scores and some part of the high score table in the range of the specified user; for bots only
 *
 * @param {getInlineGameHighScores$Input} parameters
 * @return {GameHighScores} {@link GameHighScores}
 */
export type getInlineGameHighScores = (
  parameters: getInlineGameHighScores$Input
) => GameHighScores;

/** Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup is changed */
export type deleteChatReplyMarkup$Input = {
  readonly _: "deleteChatReplyMarkup";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The message identifier of the used keyboard
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup is changed
 *
 * @param {deleteChatReplyMarkup$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteChatReplyMarkup = (parameters: deleteChatReplyMarkup$Input) => Ok;

/** Sends a notification about user activity in a chat */
export type sendChatAction$Input = {
  readonly _: "sendChatAction";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the action was performed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * The action description; pass null to cancel the currently active action
   * @type {ChatAction$Input} {@link ChatAction}
   */
  readonly action?: ChatAction$Input;
};

/**
 * Sends a notification about user activity in a chat
 *
 * @param {sendChatAction$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendChatAction = (parameters: sendChatAction$Input) => Ok;

/** Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats) */
export type openChat$Input = {
  readonly _: "openChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
 *
 * @param {openChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type openChat = (parameters: openChat$Input) => Ok;

/** Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed */
export type closeChat$Input = {
  readonly _: "closeChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
 *
 * @param {closeChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type closeChat = (parameters: closeChat$Input) => Ok;

/** Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button). Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels) */
export type viewMessages$Input = {
  readonly _: "viewMessages";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the messages are being viewed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * The identifiers of the messages being viewed
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * Pass true to mark as read the specified messages even the chat is closed
   * @type {Bool$Input} {@link Bool}
   */
  readonly force_read?: Bool$Input;
};

/**
 * Informs TDLib that messages are being viewed by the user. Sponsored messages must be marked as viewed only when the entire text of the message is shown on the screen (excluding the button). Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
 *
 * @param {viewMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type viewMessages = (parameters: viewMessages$Input) => Ok;

/** Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed */
export type openMessageContent$Input = {
  readonly _: "openMessageContent";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the message with the opened content
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
 *
 * @param {openMessageContent$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type openMessageContent = (parameters: openMessageContent$Input) => Ok;

/** Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played */
export type clickAnimatedEmojiMessage$Input = {
  readonly _: "clickAnimatedEmojiMessage";

  /**
   * Chat identifier of the message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the clicked message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
 *
 * @param {clickAnimatedEmojiMessage$Input} parameters
 * @return {Sticker} {@link Sticker}
 */
export type clickAnimatedEmojiMessage = (
  parameters: clickAnimatedEmojiMessage$Input
) => Sticker;

/** Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization */
export type getInternalLinkType$Input = {
  readonly _: "getInternalLinkType";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
 *
 * @param {getInternalLinkType$Input} parameters
 * @return {InternalLinkType} {@link InternalLinkType}
 */
export type getInternalLinkType = (
  parameters: getInternalLinkType$Input
) => InternalLinkType;

/** Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats */
export type getExternalLinkInfo$Input = {
  readonly _: "getExternalLinkInfo";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
 *
 * @param {getExternalLinkInfo$Input} parameters
 * @return {LoginUrlInfo} {@link LoginUrlInfo}
 */
export type getExternalLinkInfo = (
  parameters: getExternalLinkInfo$Input
) => LoginUrlInfo;

/** Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed */
export type getExternalLink$Input = {
  readonly _: "getExternalLink";

  /**
   * The HTTP link
   * @type {string} {@link string}
   */
  readonly link?: string;

  /**
   * Pass true if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_write_access?: Bool$Input;
};

/**
 * Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
 *
 * @param {getExternalLink$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getExternalLink = (parameters: getExternalLink$Input) => HttpUrl;

/** Marks all mentions in a chat as read */
export type readAllChatMentions$Input = {
  readonly _: "readAllChatMentions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Marks all mentions in a chat as read
 *
 * @param {readAllChatMentions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type readAllChatMentions = (parameters: readAllChatMentions$Input) => Ok;

/** Marks all mentions in a forum topic as read */
export type readAllMessageThreadMentions$Input = {
  readonly _: "readAllMessageThreadMentions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which mentions are marked as read
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Marks all mentions in a forum topic as read
 *
 * @param {readAllMessageThreadMentions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type readAllMessageThreadMentions = (
  parameters: readAllMessageThreadMentions$Input
) => Ok;

/** Marks all reactions in a chat or a forum topic as read */
export type readAllChatReactions$Input = {
  readonly _: "readAllChatReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Marks all reactions in a chat or a forum topic as read
 *
 * @param {readAllChatReactions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type readAllChatReactions = (parameters: readAllChatReactions$Input) => Ok;

/** Marks all reactions in a forum topic as read */
export type readAllMessageThreadReactions$Input = {
  readonly _: "readAllMessageThreadReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which reactions are marked as read
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Marks all reactions in a forum topic as read
 *
 * @param {readAllMessageThreadReactions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type readAllMessageThreadReactions = (
  parameters: readAllMessageThreadReactions$Input
) => Ok;

/** Returns an existing chat corresponding to a given user */
export type createPrivateChat$Input = {
  readonly _: "createPrivateChat";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a given user
 *
 * @param {createPrivateChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createPrivateChat = (parameters: createPrivateChat$Input) => Chat;

/** Returns an existing chat corresponding to a known basic group */
export type createBasicGroupChat$Input = {
  readonly _: "createBasicGroupChat";

  /**
   * Basic group identifier
   * @type {int53} {@link int53}
   */
  readonly basic_group_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a known basic group
 *
 * @param {createBasicGroupChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createBasicGroupChat = (parameters: createBasicGroupChat$Input) => Chat;

/** Returns an existing chat corresponding to a known supergroup or channel */
export type createSupergroupChat$Input = {
  readonly _: "createSupergroupChat";

  /**
   * Supergroup or channel identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Pass true to create the chat without a network request. In this case all information about the chat except its type, title and photo can be incorrect
   * @type {Bool$Input} {@link Bool}
   */
  readonly force?: Bool$Input;
};

/**
 * Returns an existing chat corresponding to a known supergroup or channel
 *
 * @param {createSupergroupChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createSupergroupChat = (parameters: createSupergroupChat$Input) => Chat;

/** Returns an existing chat corresponding to a known secret chat */
export type createSecretChat$Input = {
  readonly _: "createSecretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Returns an existing chat corresponding to a known secret chat
 *
 * @param {createSecretChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createSecretChat = (parameters: createSecretChat$Input) => Chat;

/** Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat */
export type createNewBasicGroupChat$Input = {
  readonly _: "createNewBasicGroupChat";

  /**
   * Identifiers of users to be added to the basic group
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;

  /**
   * Title of the new basic group; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
 *
 * @param {createNewBasicGroupChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createNewBasicGroupChat = (
  parameters: createNewBasicGroupChat$Input
) => Chat;

/** Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat */
export type createNewSupergroupChat$Input = {
  readonly _: "createNewSupergroupChat";

  /**
   * Title of the new chat; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Pass true to create a channel chat
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_channel?: Bool$Input;

  /**
   * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
   * @type {string} {@link string}
   */
  readonly description?: string;

  /**
   * Chat location if a location-based supergroup is being created; pass null to create an ordinary supergroup chat
   * @type {chatLocation$Input} {@link chatLocation}
   */
  readonly location?: chatLocation$Input;

  /**
   * Pass true to create a supergroup for importing messages using importMessage
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_import?: Bool$Input;
};

/**
 * Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
 *
 * @param {createNewSupergroupChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createNewSupergroupChat = (
  parameters: createNewSupergroupChat$Input
) => Chat;

/** Creates a new secret chat. Returns the newly created chat */
export type createNewSecretChat$Input = {
  readonly _: "createNewSecretChat";

  /**
   * Identifier of the target user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Creates a new secret chat. Returns the newly created chat
 *
 * @param {createNewSecretChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type createNewSecretChat = (parameters: createNewSecretChat$Input) => Chat;

/** Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group */
export type upgradeBasicGroupChatToSupergroupChat$Input = {
  readonly _: "upgradeBasicGroupChatToSupergroupChat";

  /**
   * Identifier of the chat to upgrade
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
 *
 * @param {upgradeBasicGroupChatToSupergroupChat$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type upgradeBasicGroupChatToSupergroupChat = (
  parameters: upgradeBasicGroupChatToSupergroupChat$Input
) => Chat;

/** Returns chat lists to which the chat can be added. This is an offline request */
export type getChatListsToAddChat$Input = {
  readonly _: "getChatListsToAddChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns chat lists to which the chat can be added. This is an offline request
 *
 * @param {getChatListsToAddChat$Input} parameters
 * @return {ChatLists} {@link ChatLists}
 */
export type getChatListsToAddChat = (
  parameters: getChatListsToAddChat$Input
) => ChatLists;

/** Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed */
export type addChatToList$Input = {
  readonly _: "addChatToList";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The chat list. Use getChatListsToAddChat to get suitable chat lists
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;
};

/**
 * Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
 *
 * @param {addChatToList$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addChatToList = (parameters: addChatToList$Input) => Ok;

/** Returns information about a chat filter by its identifier */
export type getChatFilter$Input = {
  readonly _: "getChatFilter";

  /**
   * Chat filter identifier
   * @type {int32} {@link int32}
   */
  readonly chat_filter_id?: int32;
};

/**
 * Returns information about a chat filter by its identifier
 *
 * @param {getChatFilter$Input} parameters
 * @return {ChatFilter} {@link ChatFilter}
 */
export type getChatFilter = (parameters: getChatFilter$Input) => ChatFilter;

/** Creates new chat filter. Returns information about the created chat filter. There can be up to GetOption("chat_filter_count_max") chat filters, but the limit can be increased with Telegram Premium */
export type createChatFilter$Input = {
  readonly _: "createChatFilter";

  /**
   * Chat filter
   * @type {chatFilter$Input} {@link chatFilter}
   */
  readonly filter?: chatFilter$Input;
};

/**
 * Creates new chat filter. Returns information about the created chat filter. There can be up to GetOption("chat_filter_count_max") chat filters, but the limit can be increased with Telegram Premium
 *
 * @param {createChatFilter$Input} parameters
 * @return {ChatFilterInfo} {@link ChatFilterInfo}
 */
export type createChatFilter = (
  parameters: createChatFilter$Input
) => ChatFilterInfo;

/** Edits existing chat filter. Returns information about the edited chat filter */
export type editChatFilter$Input = {
  readonly _: "editChatFilter";

  /**
   * Chat filter identifier
   * @type {int32} {@link int32}
   */
  readonly chat_filter_id?: int32;

  /**
   * The edited chat filter
   * @type {chatFilter$Input} {@link chatFilter}
   */
  readonly filter?: chatFilter$Input;
};

/**
 * Edits existing chat filter. Returns information about the edited chat filter
 *
 * @param {editChatFilter$Input} parameters
 * @return {ChatFilterInfo} {@link ChatFilterInfo}
 */
export type editChatFilter = (parameters: editChatFilter$Input) => ChatFilterInfo;

/** Deletes existing chat filter */
export type deleteChatFilter$Input = {
  readonly _: "deleteChatFilter";

  /**
   * Chat filter identifier
   * @type {int32} {@link int32}
   */
  readonly chat_filter_id?: int32;
};

/**
 * Deletes existing chat filter
 *
 * @param {deleteChatFilter$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteChatFilter = (parameters: deleteChatFilter$Input) => Ok;

/** Changes the order of chat filters */
export type reorderChatFilters$Input = {
  readonly _: "reorderChatFilters";

  /**
   * Identifiers of chat filters in the new correct order
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly chat_filter_ids?: vector$Input<int32>;

  /**
   * Position of the main chat list among chat filters, 0-based. Can be non-zero only for Premium users
   * @type {int32} {@link int32}
   */
  readonly main_chat_list_position?: int32;
};

/**
 * Changes the order of chat filters
 *
 * @param {reorderChatFilters$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reorderChatFilters = (parameters: reorderChatFilters$Input) => Ok;

/** Returns recommended chat filters for the current user */
export type getRecommendedChatFilters$Input = {
  readonly _: "getRecommendedChatFilters";
};

/**
 * Returns recommended chat filters for the current user
 *
 * @param {getRecommendedChatFilters$Input} parameters
 * @return {RecommendedChatFilters} {@link RecommendedChatFilters}
 */
export type getRecommendedChatFilters = (
  parameters: getRecommendedChatFilters$Input
) => RecommendedChatFilters;

/** Returns default icon name for a filter. Can be called synchronously */
export type getChatFilterDefaultIconName$Input = {
  readonly _: "getChatFilterDefaultIconName";

  /**
   * Chat filter
   * @type {chatFilter$Input} {@link chatFilter}
   */
  readonly filter?: chatFilter$Input;
};

/**
 * Returns default icon name for a filter. Can be called synchronously
 *
 * @param {getChatFilterDefaultIconName$Input} parameters
 * @return {Text} {@link Text}
 */
export type getChatFilterDefaultIconName = (
  parameters: getChatFilterDefaultIconName$Input
) => Text;

/** Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right */
export type setChatTitle$Input = {
  readonly _: "setChatTitle";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New title of the chat; 1-128 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 *
 * @param {setChatTitle$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatTitle = (parameters: setChatTitle$Input) => Ok;

/** Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right */
export type setChatPhoto$Input = {
  readonly _: "setChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New chat photo; pass null to delete the chat photo
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input;
};

/**
 * Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
 *
 * @param {setChatPhoto$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatPhoto = (parameters: setChatPhoto$Input) => Ok;

/** Changes the message TTL in a chat. Requires can_delete_messages administrator right in basic groups, supergroups and channels
-Message TTL can't be changed in a chat with the current user (Saved Messages) and the chat 777000 (Telegram). */
export type setChatMessageTtl$Input = {
  readonly _: "setChatMessageTtl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New TTL value, in seconds; unless the chat is secret, it must be from 0 up to 365 * 86400 and be divisible by 86400
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;
};

/**
 * Changes the message TTL in a chat. Requires can_delete_messages administrator right in basic groups, supergroups and channels
-Message TTL can't be changed in a chat with the current user (Saved Messages) and the chat 777000 (Telegram).
 * 
 * @param {setChatMessageTtl$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatMessageTtl = (parameters: setChatMessageTtl$Input) => Ok;

/** Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right */
export type setChatPermissions$Input = {
  readonly _: "setChatPermissions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New non-administrator members permissions in the chat
   * @type {chatPermissions$Input} {@link chatPermissions}
   */
  readonly permissions?: chatPermissions$Input;
};

/**
 * Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
 *
 * @param {setChatPermissions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatPermissions = (parameters: setChatPermissions$Input) => Ok;

/** Changes the chat theme. Supported only in private and secret chats */
export type setChatTheme$Input = {
  readonly _: "setChatTheme";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Name of the new chat theme; pass an empty string to return the default theme
   * @type {string} {@link string}
   */
  readonly theme_name?: string;
};

/**
 * Changes the chat theme. Supported only in private and secret chats
 *
 * @param {setChatTheme$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatTheme = (parameters: setChatTheme$Input) => Ok;

/** Changes the draft message in a chat */
export type setChatDraftMessage$Input = {
  readonly _: "setChatDraftMessage";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * If not 0, a message thread identifier in which the draft was changed
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;

  /**
   * New draft message; pass null to remove the draft
   * @type {draftMessage$Input} {@link draftMessage}
   */
  readonly draft_message?: draftMessage$Input;
};

/**
 * Changes the draft message in a chat
 *
 * @param {setChatDraftMessage$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatDraftMessage = (parameters: setChatDraftMessage$Input) => Ok;

/** Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed */
export type setChatNotificationSettings$Input = {
  readonly _: "setChatNotificationSettings";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New notification settings for the chat. If the chat is muted for more than 366 days, it is considered to be muted forever
   * @type {chatNotificationSettings$Input} {@link chatNotificationSettings}
   */
  readonly notification_settings?: chatNotificationSettings$Input;
};

/**
 * Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
 *
 * @param {setChatNotificationSettings$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatNotificationSettings = (
  parameters: setChatNotificationSettings$Input
) => Ok;

/** Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges */
export type toggleChatHasProtectedContent$Input = {
  readonly _: "toggleChatHasProtectedContent";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of has_protected_content
   * @type {Bool$Input} {@link Bool}
   */
  readonly has_protected_content?: Bool$Input;
};

/**
 * Changes the ability of users to save, forward, or copy chat content. Supported only for basic groups, supergroups and channels. Requires owner privileges
 *
 * @param {toggleChatHasProtectedContent$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleChatHasProtectedContent = (
  parameters: toggleChatHasProtectedContent$Input
) => Ok;

/** Changes the marked as unread state of a chat */
export type toggleChatIsMarkedAsUnread$Input = {
  readonly _: "toggleChatIsMarkedAsUnread";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of is_marked_as_unread
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_marked_as_unread?: Bool$Input;
};

/**
 * Changes the marked as unread state of a chat
 *
 * @param {toggleChatIsMarkedAsUnread$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleChatIsMarkedAsUnread = (
  parameters: toggleChatIsMarkedAsUnread$Input
) => Ok;

/** Changes the value of the default disable_notification parameter, used when a message is sent to a chat */
export type toggleChatDefaultDisableNotification$Input = {
  readonly _: "toggleChatDefaultDisableNotification";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of default_disable_notification
   * @type {Bool$Input} {@link Bool}
   */
  readonly default_disable_notification?: Bool$Input;
};

/**
 * Changes the value of the default disable_notification parameter, used when a message is sent to a chat
 *
 * @param {toggleChatDefaultDisableNotification$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleChatDefaultDisableNotification = (
  parameters: toggleChatDefaultDisableNotification$Input
) => Ok;

/** Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right */
export type setChatAvailableReactions$Input = {
  readonly _: "setChatAvailableReactions";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Reactions available in the chat. All emoji reactions must be active
   * @type {ChatAvailableReactions$Input} {@link ChatAvailableReactions}
   */
  readonly available_reactions?: ChatAvailableReactions$Input;
};

/**
 * Changes reactions, available in a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 *
 * @param {setChatAvailableReactions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatAvailableReactions = (
  parameters: setChatAvailableReactions$Input
) => Ok;

/** Changes application-specific data associated with a chat */
export type setChatClientData$Input = {
  readonly _: "setChatClientData";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New value of client_data
   * @type {string} {@link string}
   */
  readonly client_data?: string;
};

/**
 * Changes application-specific data associated with a chat
 *
 * @param {setChatClientData$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatClientData = (parameters: setChatClientData$Input) => Ok;

/** Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right */
export type setChatDescription$Input = {
  readonly _: "setChatDescription";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
   * @type {string} {@link string}
   */
  readonly description?: string;
};

/**
 * Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
 *
 * @param {setChatDescription$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatDescription = (parameters: setChatDescription$Input) => Ok;

/** Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified */
export type setChatDiscussionGroup$Input = {
  readonly _: "setChatDiscussionGroup";

  /**
   * Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of a new channel's discussion group. Use 0 to remove the discussion group.
   * -Use the method getSuitableDiscussionChats to find all suitable groups. Basic group chats must be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable must be used first to change that
   * @type {int53} {@link int53}
   */
  readonly discussion_chat_id?: int53;
};

/**
 * Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
 *
 * @param {setChatDiscussionGroup$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatDiscussionGroup = (
  parameters: setChatDiscussionGroup$Input
) => Ok;

/** Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use */
export type setChatLocation$Input = {
  readonly _: "setChatLocation";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New location for the chat; must be valid and not null
   * @type {chatLocation$Input} {@link chatLocation}
   */
  readonly location?: chatLocation$Input;
};

/**
 * Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
 *
 * @param {setChatLocation$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatLocation = (parameters: setChatLocation$Input) => Ok;

/** Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights */
export type setChatSlowModeDelay$Input = {
  readonly _: "setChatSlowModeDelay";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300, 900, 3600
   * @type {int32} {@link int32}
   */
  readonly slow_mode_delay?: int32;
};

/**
 * Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
 *
 * @param {setChatSlowModeDelay$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatSlowModeDelay = (parameters: setChatSlowModeDelay$Input) => Ok;

/** Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel */
export type pinChatMessage$Input = {
  readonly _: "pinChatMessage";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the new pinned message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to disable notification about the pinned message. Notifications are always disabled in channels and private chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly disable_notification?: Bool$Input;

  /**
   * Pass true to pin the message only for self; private chats only
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_for_self?: Bool$Input;
};

/**
 * Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
 *
 * @param {pinChatMessage$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type pinChatMessage = (parameters: pinChatMessage$Input) => Ok;

/** Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel */
export type unpinChatMessage$Input = {
  readonly _: "unpinChatMessage";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the removed pinned message
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 *
 * @param {unpinChatMessage$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type unpinChatMessage = (parameters: unpinChatMessage$Input) => Ok;

/** Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel */
export type unpinAllChatMessages$Input = {
  readonly _: "unpinAllChatMessages";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
 *
 * @param {unpinAllChatMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type unpinAllChatMessages = (parameters: unpinAllChatMessages$Input) => Ok;

/** Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup */
export type unpinAllMessageThreadMessages$Input = {
  readonly _: "unpinAllMessageThreadMessages";

  /**
   * Identifier of the chat
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message thread identifier in which messages will be unpinned
   * @type {int53} {@link int53}
   */
  readonly message_thread_id?: int53;
};

/**
 * Removes all pinned messages from a forum topic; requires can_pin_messages rights in the supergroup
 *
 * @param {unpinAllMessageThreadMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type unpinAllMessageThreadMessages = (
  parameters: unpinAllMessageThreadMessages$Input
) => Ok;

/** Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created */
export type joinChat$Input = {
  readonly _: "joinChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 *
 * @param {joinChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type joinChat = (parameters: joinChat$Input) => Ok;

/** Removes the current user from chat members. Private and secret chats can't be left using this method */
export type leaveChat$Input = {
  readonly _: "leaveChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes the current user from chat members. Private and secret chats can't be left using this method
 *
 * @param {leaveChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type leaveChat = (parameters: leaveChat$Input) => Ok;

/** Adds a new member to a chat. Members can't be added to private or secret chats */
export type addChatMember$Input = {
  readonly _: "addChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels, or if the added user is a bot
   * @type {int32} {@link int32}
   */
  readonly forward_limit?: int32;
};

/**
 * Adds a new member to a chat. Members can't be added to private or secret chats
 *
 * @param {addChatMember$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addChatMember = (parameters: addChatMember$Input) => Ok;

/** Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members */
export type addChatMembers$Input = {
  readonly _: "addChatMembers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Adds multiple new members to a chat. Currently, this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
 *
 * @param {addChatMembers$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addChatMembers = (parameters: addChatMembers$Input) => Ok;

/** Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed */
export type setChatMemberStatus$Input = {
  readonly _: "setChatMemberStatus";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier. Chats can be only banned and unbanned in supergroups and channels
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * The new status of the member in the chat
   * @type {ChatMemberStatus$Input} {@link ChatMemberStatus}
   */
  readonly status?: ChatMemberStatus$Input;
};

/**
 * Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
 *
 * @param {setChatMemberStatus$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setChatMemberStatus = (parameters: setChatMemberStatus$Input) => Ok;

/** Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first */
export type banChatMember$Input = {
  readonly _: "banChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;

  /**
   * Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups and if a chat is banned
   * @type {int32} {@link int32}
   */
  readonly banned_until_date?: int32;

  /**
   * Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels
   * @type {Bool$Input} {@link Bool}
   */
  readonly revoke_messages?: Bool$Input;
};

/**
 * Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
 *
 * @param {banChatMember$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type banChatMember = (parameters: banChatMember$Input) => Ok;

/** Checks whether the current session can be used to transfer a chat ownership to another user */
export type canTransferOwnership$Input = {
  readonly _: "canTransferOwnership";
};

/**
 * Checks whether the current session can be used to transfer a chat ownership to another user
 *
 * @param {canTransferOwnership$Input} parameters
 * @return {CanTransferOwnershipResult} {@link CanTransferOwnershipResult}
 */
export type canTransferOwnership = (
  parameters: canTransferOwnership$Input
) => CanTransferOwnershipResult;

/** Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats */
export type transferChatOwnership$Input = {
  readonly _: "transferChatOwnership";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
 *
 * @param {transferChatOwnership$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type transferChatOwnership = (parameters: transferChatOwnership$Input) => Ok;

/** Returns information about a single member of a chat */
export type getChatMember$Input = {
  readonly _: "getChatMember";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Member identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly member_id?: MessageSender$Input;
};

/**
 * Returns information about a single member of a chat
 *
 * @param {getChatMember$Input} parameters
 * @return {ChatMember} {@link ChatMember}
 */
export type getChatMember = (parameters: getChatMember$Input) => ChatMember;

/** Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels */
export type searchChatMembers$Input = {
  readonly _: "searchChatMembers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of users to be returned; up to 200
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * The type of users to search for; pass null to search among all chat members
   * @type {ChatMembersFilter$Input} {@link ChatMembersFilter}
   */
  readonly filter?: ChatMembersFilter$Input;
};

/**
 * Searches for a specified query in the first name, last name and usernames of the members of a specified chat. Requires administrator rights in channels
 *
 * @param {searchChatMembers$Input} parameters
 * @return {ChatMembers} {@link ChatMembers}
 */
export type searchChatMembers = (parameters: searchChatMembers$Input) => ChatMembers;

/** Returns a list of administrators of the chat with their custom titles */
export type getChatAdministrators$Input = {
  readonly _: "getChatAdministrators";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a list of administrators of the chat with their custom titles
 *
 * @param {getChatAdministrators$Input} parameters
 * @return {ChatAdministrators} {@link ChatAdministrators}
 */
export type getChatAdministrators = (
  parameters: getChatAdministrators$Input
) => ChatAdministrators;

/** Clears message drafts in all chats */
export type clearAllDraftMessages$Input = {
  readonly _: "clearAllDraftMessages";

  /**
   * Pass true to keep local message drafts in secret chats
   * @type {Bool$Input} {@link Bool}
   */
  readonly exclude_secret_chats?: Bool$Input;
};

/**
 * Clears message drafts in all chats
 *
 * @param {clearAllDraftMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clearAllDraftMessages = (parameters: clearAllDraftMessages$Input) => Ok;

/** Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier */
export type getSavedNotificationSound$Input = {
  readonly _: "getSavedNotificationSound";

  /**
   * Identifier of the notification sound
   * @type {int64} {@link int64}
   */
  readonly notification_sound_id?: int64;
};

/**
 * Returns saved notification sound by its identifier. Returns a 404 error if there is no saved notification sound with the specified identifier
 *
 * @param {getSavedNotificationSound$Input} parameters
 * @return {NotificationSounds} {@link NotificationSounds}
 */
export type getSavedNotificationSound = (
  parameters: getSavedNotificationSound$Input
) => NotificationSounds;

/** Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used */
export type getSavedNotificationSounds$Input = {
  readonly _: "getSavedNotificationSounds";
};

/**
 * Returns list of saved notification sounds. If a sound isn't in the list, then default sound needs to be used
 *
 * @param {getSavedNotificationSounds$Input} parameters
 * @return {NotificationSounds} {@link NotificationSounds}
 */
export type getSavedNotificationSounds = (
  parameters: getSavedNotificationSounds$Input
) => NotificationSounds;

/** Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed */
export type addSavedNotificationSound$Input = {
  readonly _: "addSavedNotificationSound";

  /**
   * Notification sound file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sound?: InputFile$Input;
};

/**
 * Adds a new notification sound to the list of saved notification sounds. The new notification sound is added to the top of the list. If it is already in the list, its position isn't changed
 *
 * @param {addSavedNotificationSound$Input} parameters
 * @return {NotificationSound} {@link NotificationSound}
 */
export type addSavedNotificationSound = (
  parameters: addSavedNotificationSound$Input
) => NotificationSound;

/** Removes a notification sound from the list of saved notification sounds */
export type removeSavedNotificationSound$Input = {
  readonly _: "removeSavedNotificationSound";

  /**
   * Identifier of the notification sound
   * @type {int64} {@link int64}
   */
  readonly notification_sound_id?: int64;
};

/**
 * Removes a notification sound from the list of saved notification sounds
 *
 * @param {removeSavedNotificationSound$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeSavedNotificationSound = (
  parameters: removeSavedNotificationSound$Input
) => Ok;

/** Returns list of chats with non-default notification settings */
export type getChatNotificationSettingsExceptions$Input = {
  readonly _: "getChatNotificationSettingsExceptions";

  /**
   * If specified, only chats from the scope will be returned; pass null to return chats from all scopes
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;

  /**
   * Pass true to include in the response chats with only non-default sound
   * @type {Bool$Input} {@link Bool}
   */
  readonly compare_sound?: Bool$Input;
};

/**
 * Returns list of chats with non-default notification settings
 *
 * @param {getChatNotificationSettingsExceptions$Input} parameters
 * @return {Chats} {@link Chats}
 */
export type getChatNotificationSettingsExceptions = (
  parameters: getChatNotificationSettingsExceptions$Input
) => Chats;

/** Returns the notification settings for chats of a given type */
export type getScopeNotificationSettings$Input = {
  readonly _: "getScopeNotificationSettings";

  /**
   * Types of chats for which to return the notification settings information
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;
};

/**
 * Returns the notification settings for chats of a given type
 *
 * @param {getScopeNotificationSettings$Input} parameters
 * @return {ScopeNotificationSettings} {@link ScopeNotificationSettings}
 */
export type getScopeNotificationSettings = (
  parameters: getScopeNotificationSettings$Input
) => ScopeNotificationSettings;

/** Changes notification settings for chats of a given type */
export type setScopeNotificationSettings$Input = {
  readonly _: "setScopeNotificationSettings";

  /**
   * Types of chats for which to change the notification settings
   * @type {NotificationSettingsScope$Input} {@link NotificationSettingsScope}
   */
  readonly scope?: NotificationSettingsScope$Input;

  /**
   * The new notification settings for the given scope
   * @type {scopeNotificationSettings$Input} {@link scopeNotificationSettings}
   */
  readonly notification_settings?: scopeNotificationSettings$Input;
};

/**
 * Changes notification settings for chats of a given type
 *
 * @param {setScopeNotificationSettings$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setScopeNotificationSettings = (
  parameters: setScopeNotificationSettings$Input
) => Ok;

/** Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown */
export type resetAllNotificationSettings$Input = {
  readonly _: "resetAllNotificationSettings";
};

/**
 * Resets all notification settings to their default values. By default, all chats are unmuted and message previews are shown
 *
 * @param {resetAllNotificationSettings$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type resetAllNotificationSettings = (
  parameters: resetAllNotificationSettings$Input
) => Ok;

/** Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium */
export type toggleChatIsPinned$Input = {
  readonly _: "toggleChatIsPinned";

  /**
   * Chat list in which to change the pinned state of the chat
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true to pin the chat; pass false to unpin it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_pinned?: Bool$Input;
};

/**
 * Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/archive chat list. The limit can be increased with Telegram Premium
 *
 * @param {toggleChatIsPinned$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleChatIsPinned = (parameters: toggleChatIsPinned$Input) => Ok;

/** Changes the order of pinned chats */
export type setPinnedChats$Input = {
  readonly _: "setPinnedChats";

  /**
   * Chat list in which to change the order of pinned chats
   * @type {ChatList$Input} {@link ChatList}
   */
  readonly chat_list?: ChatList$Input;

  /**
   * The new list of pinned chats
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;
};

/**
 * Changes the order of pinned chats
 *
 * @param {setPinnedChats$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setPinnedChats = (parameters: setPinnedChats$Input) => Ok;

/** Returns information about a bot that can be added to attachment menu */
export type getAttachmentMenuBot$Input = {
  readonly _: "getAttachmentMenuBot";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;
};

/**
 * Returns information about a bot that can be added to attachment menu
 *
 * @param {getAttachmentMenuBot$Input} parameters
 * @return {AttachmentMenuBot} {@link AttachmentMenuBot}
 */
export type getAttachmentMenuBot = (
  parameters: getAttachmentMenuBot$Input
) => AttachmentMenuBot;

/** Adds or removes a bot to attachment menu. Bot can be added to attachment menu, only if userTypeBot.can_be_added_to_attachment_menu == true */
export type toggleBotIsAddedToAttachmentMenu$Input = {
  readonly _: "toggleBotIsAddedToAttachmentMenu";

  /**
   * Bot's user identifier
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Pass true to add the bot to attachment menu; pass false to remove the bot from attachment menu
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_added?: Bool$Input;
};

/**
 * Adds or removes a bot to attachment menu. Bot can be added to attachment menu, only if userTypeBot.can_be_added_to_attachment_menu == true
 *
 * @param {toggleBotIsAddedToAttachmentMenu$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleBotIsAddedToAttachmentMenu = (
  parameters: toggleBotIsAddedToAttachmentMenu$Input
) => Ok;

/** Returns up to 8 themed emoji statuses, which color must be changed to the color of the Telegram Premium badge */
export type getThemedEmojiStatuses$Input = {
  readonly _: "getThemedEmojiStatuses";
};

/**
 * Returns up to 8 themed emoji statuses, which color must be changed to the color of the Telegram Premium badge
 *
 * @param {getThemedEmojiStatuses$Input} parameters
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getThemedEmojiStatuses = (
  parameters: getThemedEmojiStatuses$Input
) => EmojiStatuses;

/** Returns recent emoji statuses */
export type getRecentEmojiStatuses$Input = {
  readonly _: "getRecentEmojiStatuses";
};

/**
 * Returns recent emoji statuses
 *
 * @param {getRecentEmojiStatuses$Input} parameters
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getRecentEmojiStatuses = (
  parameters: getRecentEmojiStatuses$Input
) => EmojiStatuses;

/** Returns default emoji statuses */
export type getDefaultEmojiStatuses$Input = {
  readonly _: "getDefaultEmojiStatuses";
};

/**
 * Returns default emoji statuses
 *
 * @param {getDefaultEmojiStatuses$Input} parameters
 * @return {EmojiStatuses} {@link EmojiStatuses}
 */
export type getDefaultEmojiStatuses = (
  parameters: getDefaultEmojiStatuses$Input
) => EmojiStatuses;

/** Clears the list of recently used emoji statuses */
export type clearRecentEmojiStatuses$Input = {
  readonly _: "clearRecentEmojiStatuses";
};

/**
 * Clears the list of recently used emoji statuses
 *
 * @param {clearRecentEmojiStatuses$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clearRecentEmojiStatuses = (
  parameters: clearRecentEmojiStatuses$Input
) => Ok;

/** Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates */
export type downloadFile$Input = {
  readonly _: "downloadFile";

  /**
   * Identifier of the file to download
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;

  /**
   * The starting position from which the file needs to be downloaded
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * Number of bytes which need to be downloaded starting from the "offset" position before the download will automatically be canceled; use 0 to download without a limit
   * @type {int53} {@link int53}
   */
  readonly limit?: int53;

  /**
   * Pass true to return response only after the file download has succeeded, has failed, has been canceled, or a new downloadFile request with different offset/limit parameters was sent; pass false to return file state immediately, just after the download has been started
   * @type {Bool$Input} {@link Bool}
   */
  readonly synchronous?: Bool$Input;
};

/**
 * Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
 *
 * @param {downloadFile$Input} parameters
 * @return {File} {@link File}
 */
export type downloadFile = (parameters: downloadFile$Input) => File;

/** Returns file downloaded prefix size from a given offset, in bytes */
export type getFileDownloadedPrefixSize$Input = {
  readonly _: "getFileDownloadedPrefixSize";

  /**
   * Identifier of the file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Offset from which downloaded prefix size needs to be calculated
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;
};

/**
 * Returns file downloaded prefix size from a given offset, in bytes
 *
 * @param {getFileDownloadedPrefixSize$Input} parameters
 * @return {FileDownloadedPrefixSize} {@link FileDownloadedPrefixSize}
 */
export type getFileDownloadedPrefixSize = (
  parameters: getFileDownloadedPrefixSize$Input
) => FileDownloadedPrefixSize;

/** Stops the downloading of a file. If a file has already been downloaded, does nothing */
export type cancelDownloadFile$Input = {
  readonly _: "cancelDownloadFile";

  /**
   * Identifier of a file to stop downloading
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_if_pending?: Bool$Input;
};

/**
 * Stops the downloading of a file. If a file has already been downloaded, does nothing
 *
 * @param {cancelDownloadFile$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type cancelDownloadFile = (parameters: cancelDownloadFile$Input) => Ok;

/** Returns suggested name for saving a file in a given directory */
export type getSuggestedFileName$Input = {
  readonly _: "getSuggestedFileName";

  /**
   * Identifier of the file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Directory in which the file is supposed to be saved
   * @type {string} {@link string}
   */
  readonly directory?: string;
};

/**
 * Returns suggested name for saving a file in a given directory
 *
 * @param {getSuggestedFileName$Input} parameters
 * @return {Text} {@link Text}
 */
export type getSuggestedFileName = (parameters: getSuggestedFileName$Input) => Text;

/** Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message */
export type preliminaryUploadFile$Input = {
  readonly _: "preliminaryUploadFile";

  /**
   * File to upload
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly file?: InputFile$Input;

  /**
   * File type; pass null if unknown
   * @type {FileType$Input} {@link FileType}
   */
  readonly file_type?: FileType$Input;

  /**
   * Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which preliminaryUploadFile was called will be uploaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;
};

/**
 * Preliminary uploads a file to the cloud before sending it in a message, which can be useful for uploading of being recorded voice and video notes. Updates updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message
 *
 * @param {preliminaryUploadFile$Input} parameters
 * @return {File} {@link File}
 */
export type preliminaryUploadFile = (
  parameters: preliminaryUploadFile$Input
) => File;

/** Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined */
export type cancelPreliminaryUploadFile$Input = {
  readonly _: "cancelPreliminaryUploadFile";

  /**
   * Identifier of the file to stop uploading
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Stops the preliminary uploading of a file. Supported only for files uploaded by using preliminaryUploadFile. For other files the behavior is undefined
 *
 * @param {cancelPreliminaryUploadFile$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type cancelPreliminaryUploadFile = (
  parameters: cancelPreliminaryUploadFile$Input
) => Ok;

/** Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file */
export type writeGeneratedFilePart$Input = {
  readonly _: "writeGeneratedFilePart";

  /**
   * The identifier of the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64;

  /**
   * The offset from which to write the data to the file
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * The data to write
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/**
 * Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
 *
 * @param {writeGeneratedFilePart$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type writeGeneratedFilePart = (
  parameters: writeGeneratedFilePart$Input
) => Ok;

/** Informs TDLib on a file generation progress */
export type setFileGenerationProgress$Input = {
  readonly _: "setFileGenerationProgress";

  /**
   * The identifier of the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64;

  /**
   * Expected size of the generated file, in bytes; 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly expected_size?: int53;

  /**
   * The number of bytes already generated
   * @type {int53} {@link int53}
   */
  readonly local_prefix_size?: int53;
};

/**
 * Informs TDLib on a file generation progress
 *
 * @param {setFileGenerationProgress$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setFileGenerationProgress = (
  parameters: setFileGenerationProgress$Input
) => Ok;

/** Finishes the file generation */
export type finishFileGeneration$Input = {
  readonly _: "finishFileGeneration";

  /**
   * The identifier of the generation process
   * @type {int64} {@link int64}
   */
  readonly generation_id?: int64;

  /**
   * If passed, the file generation has failed and must be terminated; pass null if the file generation succeeded
   * @type {error$Input} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * Finishes the file generation
 *
 * @param {finishFileGeneration$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type finishFileGeneration = (parameters: finishFileGeneration$Input) => Ok;

/** Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file */
export type readFilePart$Input = {
  readonly _: "readFilePart";

  /**
   * Identifier of the file. The file must be located in the TDLib file cache
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The offset from which to read the file
   * @type {int53} {@link int53}
   */
  readonly offset?: int53;

  /**
   * Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position
   * @type {int53} {@link int53}
   */
  readonly count?: int53;
};

/**
 * Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
 *
 * @param {readFilePart$Input} parameters
 * @return {FilePart} {@link FilePart}
 */
export type readFilePart = (parameters: readFilePart$Input) => FilePart;

/** Deletes a file from the TDLib file cache */
export type deleteFile$Input = {
  readonly _: "deleteFile";

  /**
   * Identifier of the file to delete
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Deletes a file from the TDLib file cache
 *
 * @param {deleteFile$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteFile = (parameters: deleteFile$Input) => Ok;

/** Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
-If message database is used, the list of file downloads is persistent across application restarts. The downloading is independent from download using downloadFile, i.e. it continues if downloadFile is canceled or is used to download a part of the file */
export type addFileToDownloads$Input = {
  readonly _: "addFileToDownloads";

  /**
   * Identifier of the file to download
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Chat identifier of the message with the file
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile/addFileToDownloads was called will be downloaded first
   * @type {int32} {@link int32}
   */
  readonly priority?: int32;
};

/**
 * Adds a file from a message to the list of file downloads. Download progress and completion of the download will be notified through updateFile updates.
-If message database is used, the list of file downloads is persistent across application restarts. The downloading is independent from download using downloadFile, i.e. it continues if downloadFile is canceled or is used to download a part of the file
 * 
 * @param {addFileToDownloads$Input} parameters
 * @return {File} {@link File}
 */
export type addFileToDownloads = (parameters: addFileToDownloads$Input) => File;

/** Changes pause state of a file in the file download list */
export type toggleDownloadIsPaused$Input = {
  readonly _: "toggleDownloadIsPaused";

  /**
   * Identifier of the downloaded file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true if the download is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Changes pause state of a file in the file download list
 *
 * @param {toggleDownloadIsPaused$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleDownloadIsPaused = (
  parameters: toggleDownloadIsPaused$Input
) => Ok;

/** Changes pause state of all files in the file download list */
export type toggleAllDownloadsArePaused$Input = {
  readonly _: "toggleAllDownloadsArePaused";

  /**
   * Pass true to pause all downloads; pass false to unpause them
   * @type {Bool$Input} {@link Bool}
   */
  readonly are_paused?: Bool$Input;
};

/**
 * Changes pause state of all files in the file download list
 *
 * @param {toggleAllDownloadsArePaused$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleAllDownloadsArePaused = (
  parameters: toggleAllDownloadsArePaused$Input
) => Ok;

/** Removes a file from the file download list */
export type removeFileFromDownloads$Input = {
  readonly _: "removeFileFromDownloads";

  /**
   * Identifier of the downloaded file
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * Pass true to delete the file from the TDLib file cache
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_from_cache?: Bool$Input;
};

/**
 * Removes a file from the file download list
 *
 * @param {removeFileFromDownloads$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeFileFromDownloads = (
  parameters: removeFileFromDownloads$Input
) => Ok;

/** Removes all files from the file download list */
export type removeAllFilesFromDownloads$Input = {
  readonly _: "removeAllFilesFromDownloads";

  /**
   * Pass true to remove only active downloads, including paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_active?: Bool$Input;

  /**
   * Pass true to remove only completed downloads
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_completed?: Bool$Input;

  /**
   * Pass true to delete the file from the TDLib file cache
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_from_cache?: Bool$Input;
};

/**
 * Removes all files from the file download list
 *
 * @param {removeAllFilesFromDownloads$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeAllFilesFromDownloads = (
  parameters: removeAllFilesFromDownloads$Input
) => Ok;

/** Searches for files in the file download list or recently downloaded files from the list */
export type searchFileDownloads$Input = {
  readonly _: "searchFileDownloads";

  /**
   * Query to search for; may be empty to return all downloaded files
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Pass true to search only for active downloads, including paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_active?: Bool$Input;

  /**
   * Pass true to search only for completed downloads
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_completed?: Bool$Input;

  /**
   * Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
   * @type {string} {@link string}
   */
  readonly offset?: string;

  /**
   * The maximum number of files to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for files in the file download list or recently downloaded files from the list
 *
 * @param {searchFileDownloads$Input} parameters
 * @return {FoundFileDownloads} {@link FoundFileDownloads}
 */
export type searchFileDownloads = (
  parameters: searchFileDownloads$Input
) => FoundFileDownloads;

/** Returns information about a file with messages exported from another application */
export type getMessageFileType$Input = {
  readonly _: "getMessageFileType";

  /**
   * Beginning of the message file; up to 100 first lines
   * @type {string} {@link string}
   */
  readonly message_file_head?: string;
};

/**
 * Returns information about a file with messages exported from another application
 *
 * @param {getMessageFileType$Input} parameters
 * @return {MessageFileType} {@link MessageFileType}
 */
export type getMessageFileType = (
  parameters: getMessageFileType$Input
) => MessageFileType;

/** Returns a confirmation text to be shown to the user before starting message import */
export type getMessageImportConfirmationText$Input = {
  readonly _: "getMessageImportConfirmationText";

  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns a confirmation text to be shown to the user before starting message import
 *
 * @param {getMessageImportConfirmationText$Input} parameters
 * @return {Text} {@link Text}
 */
export type getMessageImportConfirmationText = (
  parameters: getMessageImportConfirmationText$Input
) => Text;

/** Imports messages exported from another app */
export type importMessages$Input = {
  readonly _: "importMessages";

  /**
   * Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly message_file?: InputFile$Input;

  /**
   * Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded
   * @type {vector$Input<InputFile$Input>} {@link vector<InputFile>}
   */
  readonly attached_files?: vector$Input<InputFile$Input>;
};

/**
 * Imports messages exported from another app
 *
 * @param {importMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type importMessages = (parameters: importMessages$Input) => Ok;

/** Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right */
export type replacePrimaryChatInviteLink$Input = {
  readonly _: "replacePrimaryChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
 *
 * @param {replacePrimaryChatInviteLink$Input} parameters
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type replacePrimaryChatInviteLink = (
  parameters: replacePrimaryChatInviteLink$Input
) => ChatInviteLink;

/** Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat */
export type createChatInviteLink$Input = {
  readonly _: "createChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link name; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Point in time (Unix timestamp) when the link will expire; pass 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0
   * @type {Bool$Input} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;
};

/**
 * Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
 *
 * @param {createChatInviteLink$Input} parameters
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type createChatInviteLink = (
  parameters: createChatInviteLink$Input
) => ChatInviteLink;

/** Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links */
export type editChatInviteLink$Input = {
  readonly _: "editChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to be edited
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Invite link name; 0-32 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Point in time (Unix timestamp) when the link will expire; pass 0 if never
   * @type {int32} {@link int32}
   */
  readonly expiration_date?: int32;

  /**
   * The maximum number of chat members that can join the chat via the link simultaneously; 0-99999; pass 0 if not limited
   * @type {int32} {@link int32}
   */
  readonly member_limit?: int32;

  /**
   * Pass true if users joining the chat via the link need to be approved by chat administrators. In this case, member_limit must be 0
   * @type {Bool$Input} {@link Bool}
   */
  readonly creates_join_request?: Bool$Input;
};

/**
 * Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {editChatInviteLink$Input} parameters
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type editChatInviteLink = (
  parameters: editChatInviteLink$Input
) => ChatInviteLink;

/** Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links */
export type getChatInviteLink$Input = {
  readonly _: "getChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to get
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 *
 * @param {getChatInviteLink$Input} parameters
 * @return {ChatInviteLink} {@link ChatInviteLink}
 */
export type getChatInviteLink = (
  parameters: getChatInviteLink$Input
) => ChatInviteLink;

/** Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat */
export type getChatInviteLinkCounts$Input = {
  readonly _: "getChatInviteLinkCounts";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
 *
 * @param {getChatInviteLinkCounts$Input} parameters
 * @return {ChatInviteLinkCounts} {@link ChatInviteLinkCounts}
 */
export type getChatInviteLinkCounts = (
  parameters: getChatInviteLinkCounts$Input
) => ChatInviteLinkCounts;

/** Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links */
export type getChatInviteLinks$Input = {
  readonly _: "getChatInviteLinks";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier of a chat administrator. Must be an identifier of the current user for non-owner
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;

  /**
   * Pass true if revoked links needs to be returned instead of active or expired
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_revoked?: Bool$Input;

  /**
   * Creation date of an invite link starting after which to return invite links; use 0 to get results from the beginning
   * @type {int32} {@link int32}
   */
  readonly offset_date?: int32;

  /**
   * Invite link starting after which to return invite links; use empty string to get results from the beginning
   * @type {string} {@link string}
   */
  readonly offset_invite_link?: string;

  /**
   * The maximum number of invite links to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
 *
 * @param {getChatInviteLinks$Input} parameters
 * @return {ChatInviteLinks} {@link ChatInviteLinks}
 */
export type getChatInviteLinks = (
  parameters: getChatInviteLinks$Input
) => ChatInviteLinks;

/** Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links */
export type getChatInviteLinkMembers$Input = {
  readonly _: "getChatInviteLinkMembers";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to return chat members
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * A chat member from which to return next chat members; pass null to get results from the beginning
   * @type {chatInviteLinkMember$Input} {@link chatInviteLinkMember}
   */
  readonly offset_member?: chatInviteLinkMember$Input;

  /**
   * The maximum number of chat members to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns chat members joined a chat via an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {getChatInviteLinkMembers$Input} parameters
 * @return {ChatInviteLinkMembers} {@link ChatInviteLinkMembers}
 */
export type getChatInviteLinkMembers = (
  parameters: getChatInviteLinkMembers$Input
) => ChatInviteLinkMembers;

/** Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
-If a primary link is revoked, then additionally to the revoked link returns new primary link */
export type revokeChatInviteLink$Input = {
  readonly _: "revokeChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to be revoked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links.
-If a primary link is revoked, then additionally to the revoked link returns new primary link
 * 
 * @param {revokeChatInviteLink$Input} parameters
 * @return {ChatInviteLinks} {@link ChatInviteLinks}
 */
export type revokeChatInviteLink = (
  parameters: revokeChatInviteLink$Input
) => ChatInviteLinks;

/** Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links */
export type deleteRevokedChatInviteLink$Input = {
  readonly _: "deleteRevokedChatInviteLink";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link to revoke
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {deleteRevokedChatInviteLink$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteRevokedChatInviteLink = (
  parameters: deleteRevokedChatInviteLink$Input
) => Ok;

/** Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links */
export type deleteAllRevokedChatInviteLinks$Input = {
  readonly _: "deleteAllRevokedChatInviteLinks";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner
   * @type {int53} {@link int53}
   */
  readonly creator_user_id?: int53;
};

/**
 * Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
 *
 * @param {deleteAllRevokedChatInviteLinks$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteAllRevokedChatInviteLinks = (
  parameters: deleteAllRevokedChatInviteLinks$Input
) => Ok;

/** Checks the validity of an invite link for a chat and returns information about the corresponding chat */
export type checkChatInviteLink$Input = {
  readonly _: "checkChatInviteLink";

  /**
   * Invite link to be checked
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Checks the validity of an invite link for a chat and returns information about the corresponding chat
 *
 * @param {checkChatInviteLink$Input} parameters
 * @return {ChatInviteLinkInfo} {@link ChatInviteLinkInfo}
 */
export type checkChatInviteLink = (
  parameters: checkChatInviteLink$Input
) => ChatInviteLinkInfo;

/** Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created */
export type joinChatByInviteLink$Input = {
  readonly _: "joinChatByInviteLink";

  /**
   * Invite link to use
   * @type {string} {@link string}
   */
  readonly invite_link?: string;
};

/**
 * Uses an invite link to add the current user to the chat if possible. May return an error with a message "INVITE_REQUEST_SENT" if only a join request was created
 *
 * @param {joinChatByInviteLink$Input} parameters
 * @return {Chat} {@link Chat}
 */
export type joinChatByInviteLink = (parameters: joinChatByInviteLink$Input) => Chat;

/** Returns pending join requests in a chat */
export type getChatJoinRequests$Input = {
  readonly _: "getChatJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to return join requests. If empty, all join requests will be returned. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * A query to search for in the first names, last names and usernames of the users to return
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * A chat join request from which to return next requests; pass null to get results from the beginning
   * @type {chatJoinRequest$Input} {@link chatJoinRequest}
   */
  readonly offset_request?: chatJoinRequest$Input;

  /**
   * The maximum number of requests to join the chat to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns pending join requests in a chat
 *
 * @param {getChatJoinRequests$Input} parameters
 * @return {ChatJoinRequests} {@link ChatJoinRequests}
 */
export type getChatJoinRequests = (
  parameters: getChatJoinRequests$Input
) => ChatJoinRequests;

/** Handles a pending join request in a chat */
export type processChatJoinRequest$Input = {
  readonly _: "processChatJoinRequest";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the user that sent the request
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Pass true to approve the request; pass false to decline it
   * @type {Bool$Input} {@link Bool}
   */
  readonly approve?: Bool$Input;
};

/**
 * Handles a pending join request in a chat
 *
 * @param {processChatJoinRequest$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type processChatJoinRequest = (
  parameters: processChatJoinRequest$Input
) => Ok;

/** Handles all pending join requests for a given link in a chat */
export type processChatJoinRequests$Input = {
  readonly _: "processChatJoinRequests";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Invite link for which to process join requests. If empty, all join requests will be processed. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
   * @type {string} {@link string}
   */
  readonly invite_link?: string;

  /**
   * Pass true to approve all requests; pass false to decline them
   * @type {Bool$Input} {@link Bool}
   */
  readonly approve?: Bool$Input;
};

/**
 * Handles all pending join requests for a given link in a chat
 *
 * @param {processChatJoinRequests$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type processChatJoinRequests = (
  parameters: processChatJoinRequests$Input
) => Ok;

/** Creates a new call */
export type createCall$Input = {
  readonly _: "createCall";

  /**
   * Identifier of the user to be called
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The call protocols supported by the application
   * @type {callProtocol$Input} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;

  /**
   * Pass true to create a video call
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_video?: Bool$Input;
};

/**
 * Creates a new call
 *
 * @param {createCall$Input} parameters
 * @return {CallId} {@link CallId}
 */
export type createCall = (parameters: createCall$Input) => CallId;

/** Accepts an incoming call */
export type acceptCall$Input = {
  readonly _: "acceptCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The call protocols supported by the application
   * @type {callProtocol$Input} {@link callProtocol}
   */
  readonly protocol?: callProtocol$Input;
};

/**
 * Accepts an incoming call
 *
 * @param {acceptCall$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type acceptCall = (parameters: acceptCall$Input) => Ok;

/** Sends call signaling data */
export type sendCallSignalingData$Input = {
  readonly _: "sendCallSignalingData";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * The data
   * @type {bytes} {@link bytes}
   */
  readonly data?: bytes;
};

/**
 * Sends call signaling data
 *
 * @param {sendCallSignalingData$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendCallSignalingData = (parameters: sendCallSignalingData$Input) => Ok;

/** Discards a call */
export type discardCall$Input = {
  readonly _: "discardCall";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Pass true if the user was disconnected
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_disconnected?: Bool$Input;

  /**
   * The call duration, in seconds
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;

  /**
   * Pass true if the call was a video call
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_video?: Bool$Input;

  /**
   * Identifier of the connection used during the call
   * @type {int64} {@link int64}
   */
  readonly connection_id?: int64;
};

/**
 * Discards a call
 *
 * @param {discardCall$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type discardCall = (parameters: discardCall$Input) => Ok;

/** Sends a call rating */
export type sendCallRating$Input = {
  readonly _: "sendCallRating";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Call rating; 1-5
   * @type {int32} {@link int32}
   */
  readonly rating?: int32;

  /**
   * An optional user comment if the rating is less than 5
   * @type {string} {@link string}
   */
  readonly comment?: string;

  /**
   * List of the exact types of problems with the call, specified by the user
   * @type {vector$Input<CallProblem$Input>} {@link vector<CallProblem>}
   */
  readonly problems?: vector$Input<CallProblem$Input>;
};

/**
 * Sends a call rating
 *
 * @param {sendCallRating$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendCallRating = (parameters: sendCallRating$Input) => Ok;

/** Sends debug information for a call to Telegram servers */
export type sendCallDebugInformation$Input = {
  readonly _: "sendCallDebugInformation";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Debug information in application-specific format
   * @type {string} {@link string}
   */
  readonly debug_information?: string;
};

/**
 * Sends debug information for a call to Telegram servers
 *
 * @param {sendCallDebugInformation$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendCallDebugInformation = (
  parameters: sendCallDebugInformation$Input
) => Ok;

/** Sends log file for a call to Telegram servers */
export type sendCallLog$Input = {
  readonly _: "sendCallLog";

  /**
   * Call identifier
   * @type {int32} {@link int32}
   */
  readonly call_id?: int32;

  /**
   * Call log file. Only inputFileLocal and inputFileGenerated are supported
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly log_file?: InputFile$Input;
};

/**
 * Sends log file for a call to Telegram servers
 *
 * @param {sendCallLog$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendCallLog = (parameters: sendCallLog$Input) => Ok;

/** Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined */
export type getVideoChatAvailableParticipants$Input = {
  readonly _: "getVideoChatAvailableParticipants";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns list of participant identifiers, on whose behalf a video chat in the chat can be joined
 *
 * @param {getVideoChatAvailableParticipants$Input} parameters
 * @return {MessageSenders} {@link MessageSenders}
 */
export type getVideoChatAvailableParticipants = (
  parameters: getVideoChatAvailableParticipants$Input
) => MessageSenders;

/** Changes default participant identifier, on whose behalf a video chat in the chat will be joined */
export type setVideoChatDefaultParticipant$Input = {
  readonly _: "setVideoChatDefaultParticipant";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Default group call participant identifier to join the video chats
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly default_participant_id?: MessageSender$Input;
};

/**
 * Changes default participant identifier, on whose behalf a video chat in the chat will be joined
 *
 * @param {setVideoChatDefaultParticipant$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setVideoChatDefaultParticipant = (
  parameters: setVideoChatDefaultParticipant$Input
) => Ok;

/** Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights */
export type createVideoChat$Input = {
  readonly _: "createVideoChat";

  /**
   * Identifier of a chat in which the video chat will be created
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Group call title; if empty, chat title will be used
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 to start the video chat immediately. The date must be at least 10 seconds and at most 8 days in the future
   * @type {int32} {@link int32}
   */
  readonly start_date?: int32;

  /**
   * Pass true to create an RTMP stream instead of an ordinary video chat; requires creator privileges
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_rtmp_stream?: Bool$Input;
};

/**
 * Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
 *
 * @param {createVideoChat$Input} parameters
 * @return {GroupCallId} {@link GroupCallId}
 */
export type createVideoChat = (parameters: createVideoChat$Input) => GroupCallId;

/** Returns RTMP URL for streaming to the chat; requires creator privileges */
export type getVideoChatRtmpUrl$Input = {
  readonly _: "getVideoChatRtmpUrl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns RTMP URL for streaming to the chat; requires creator privileges
 *
 * @param {getVideoChatRtmpUrl$Input} parameters
 * @return {RtmpUrl} {@link RtmpUrl}
 */
export type getVideoChatRtmpUrl = (parameters: getVideoChatRtmpUrl$Input) => RtmpUrl;

/** Replaces the current RTMP URL for streaming to the chat; requires creator privileges */
export type replaceVideoChatRtmpUrl$Input = {
  readonly _: "replaceVideoChatRtmpUrl";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Replaces the current RTMP URL for streaming to the chat; requires creator privileges
 *
 * @param {replaceVideoChatRtmpUrl$Input} parameters
 * @return {RtmpUrl} {@link RtmpUrl}
 */
export type replaceVideoChatRtmpUrl = (
  parameters: replaceVideoChatRtmpUrl$Input
) => RtmpUrl;

/** Returns information about a group call */
export type getGroupCall$Input = {
  readonly _: "getGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Returns information about a group call
 *
 * @param {getGroupCall$Input} parameters
 * @return {GroupCall} {@link GroupCall}
 */
export type getGroupCall = (parameters: getGroupCall$Input) => GroupCall;

/** Starts a scheduled group call */
export type startScheduledGroupCall$Input = {
  readonly _: "startScheduledGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Starts a scheduled group call
 *
 * @param {startScheduledGroupCall$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type startScheduledGroupCall = (
  parameters: startScheduledGroupCall$Input
) => Ok;

/** Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only */
export type toggleGroupCallEnabledStartNotification$Input = {
  readonly _: "toggleGroupCallEnabledStartNotification";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New value of the enabled_start_notification setting
   * @type {Bool$Input} {@link Bool}
   */
  readonly enabled_start_notification?: Bool$Input;
};

/**
 * Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only
 *
 * @param {toggleGroupCallEnabledStartNotification$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallEnabledStartNotification = (
  parameters: toggleGroupCallEnabledStartNotification$Input
) => Ok;

/** Joins an active group call. Returns join response payload for tgcalls */
export type joinGroupCall$Input = {
  readonly _: "joinGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Identifier of a group call participant, which will be used to join the call; pass null to join as self; video chats only
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Caller audio channel synchronization source identifier; received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * Group call join payload; received from tgcalls
   * @type {string} {@link string}
   */
  readonly payload?: string;

  /**
   * Pass true to join the call with muted microphone
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_muted?: Bool$Input;

  /**
   * Pass true if the user's video is enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;

  /**
   * If non-empty, invite hash to be used to join the group call without being muted by administrators
   * @type {string} {@link string}
   */
  readonly invite_hash?: string;
};

/**
 * Joins an active group call. Returns join response payload for tgcalls
 *
 * @param {joinGroupCall$Input} parameters
 * @return {Text} {@link Text}
 */
export type joinGroupCall = (parameters: joinGroupCall$Input) => Text;

/** Starts screen sharing in a joined group call. Returns join response payload for tgcalls */
export type startGroupCallScreenSharing$Input = {
  readonly _: "startGroupCallScreenSharing";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Screen sharing audio channel synchronization source identifier; received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly audio_source_id?: int32;

  /**
   * Group call join payload; received from tgcalls
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Starts screen sharing in a joined group call. Returns join response payload for tgcalls
 *
 * @param {startGroupCallScreenSharing$Input} parameters
 * @return {Text} {@link Text}
 */
export type startGroupCallScreenSharing = (
  parameters: startGroupCallScreenSharing$Input
) => Text;

/** Pauses or unpauses screen sharing in a joined group call */
export type toggleGroupCallScreenSharingIsPaused$Input = {
  readonly _: "toggleGroupCallScreenSharingIsPaused";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * True if screen sharing is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_paused?: Bool$Input;
};

/**
 * Pauses or unpauses screen sharing in a joined group call
 *
 * @param {toggleGroupCallScreenSharingIsPaused$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallScreenSharingIsPaused = (
  parameters: toggleGroupCallScreenSharingIsPaused$Input
) => Ok;

/** Ends screen sharing in a joined group call */
export type endGroupCallScreenSharing$Input = {
  readonly _: "endGroupCallScreenSharing";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends screen sharing in a joined group call
 *
 * @param {endGroupCallScreenSharing$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type endGroupCallScreenSharing = (
  parameters: endGroupCallScreenSharing$Input
) => Ok;

/** Sets group call title. Requires groupCall.can_be_managed group call flag */
export type setGroupCallTitle$Input = {
  readonly _: "setGroupCallTitle";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New group call title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Sets group call title. Requires groupCall.can_be_managed group call flag
 *
 * @param {setGroupCallTitle$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setGroupCallTitle = (parameters: setGroupCallTitle$Input) => Ok;

/** Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag */
export type toggleGroupCallMuteNewParticipants$Input = {
  readonly _: "toggleGroupCallMuteNewParticipants";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * New value of the mute_new_participants setting
   * @type {Bool$Input} {@link Bool}
   */
  readonly mute_new_participants?: Bool$Input;
};

/**
 * Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
 *
 * @param {toggleGroupCallMuteNewParticipants$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallMuteNewParticipants = (
  parameters: toggleGroupCallMuteNewParticipants$Input
) => Ok;

/** Invites users to an active group call. Sends a service message of type messageInviteToGroupCall for video chats */
export type inviteGroupCallParticipants$Input = {
  readonly _: "inviteGroupCallParticipants";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * User identifiers. At most 10 users can be invited simultaneously
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Invites users to an active group call. Sends a service message of type messageInviteToGroupCall for video chats
 *
 * @param {inviteGroupCallParticipants$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type inviteGroupCallParticipants = (
  parameters: inviteGroupCallParticipants$Input
) => Ok;

/** Returns invite link to a video chat in a public chat */
export type getGroupCallInviteLink$Input = {
  readonly _: "getGroupCallInviteLink";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_self_unmute?: Bool$Input;
};

/**
 * Returns invite link to a video chat in a public chat
 *
 * @param {getGroupCallInviteLink$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getGroupCallInviteLink = (
  parameters: getGroupCallInviteLink$Input
) => HttpUrl;

/** Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag */
export type revokeGroupCallInviteLink$Input = {
  readonly _: "revokeGroupCallInviteLink";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
 *
 * @param {revokeGroupCallInviteLink$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type revokeGroupCallInviteLink = (
  parameters: revokeGroupCallInviteLink$Input
) => Ok;

/** Starts recording of an active group call. Requires groupCall.can_be_managed group call flag */
export type startGroupCallRecording$Input = {
  readonly _: "startGroupCallRecording";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Group call recording title; 0-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Pass true to record a video file instead of an audio file
   * @type {Bool$Input} {@link Bool}
   */
  readonly record_video?: Bool$Input;

  /**
   * Pass true to use portrait orientation for video instead of landscape one
   * @type {Bool$Input} {@link Bool}
   */
  readonly use_portrait_orientation?: Bool$Input;
};

/**
 * Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
 *
 * @param {startGroupCallRecording$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type startGroupCallRecording = (
  parameters: startGroupCallRecording$Input
) => Ok;

/** Ends recording of an active group call. Requires groupCall.can_be_managed group call flag */
export type endGroupCallRecording$Input = {
  readonly _: "endGroupCallRecording";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
 *
 * @param {endGroupCallRecording$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type endGroupCallRecording = (parameters: endGroupCallRecording$Input) => Ok;

/** Toggles whether current user's video is paused */
export type toggleGroupCallIsMyVideoPaused$Input = {
  readonly _: "toggleGroupCallIsMyVideoPaused";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the current user's video is paused
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_paused?: Bool$Input;
};

/**
 * Toggles whether current user's video is paused
 *
 * @param {toggleGroupCallIsMyVideoPaused$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallIsMyVideoPaused = (
  parameters: toggleGroupCallIsMyVideoPaused$Input
) => Ok;

/** Toggles whether current user's video is enabled */
export type toggleGroupCallIsMyVideoEnabled$Input = {
  readonly _: "toggleGroupCallIsMyVideoEnabled";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Pass true if the current user's video is enabled
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_my_video_enabled?: Bool$Input;
};

/**
 * Toggles whether current user's video is enabled
 *
 * @param {toggleGroupCallIsMyVideoEnabled$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallIsMyVideoEnabled = (
  parameters: toggleGroupCallIsMyVideoEnabled$Input
) => Ok;

/** Informs TDLib that speaking state of a participant of an active group has changed */
export type setGroupCallParticipantIsSpeaking$Input = {
  readonly _: "setGroupCallParticipantIsSpeaking";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Group call participant's synchronization audio source identifier, or 0 for the current user
   * @type {int32} {@link int32}
   */
  readonly audio_source?: int32;

  /**
   * Pass true if the user is speaking
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_speaking?: Bool$Input;
};

/**
 * Informs TDLib that speaking state of a participant of an active group has changed
 *
 * @param {setGroupCallParticipantIsSpeaking$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setGroupCallParticipantIsSpeaking = (
  parameters: setGroupCallParticipantIsSpeaking$Input
) => Ok;

/** Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves */
export type toggleGroupCallParticipantIsMuted$Input = {
  readonly _: "toggleGroupCallParticipantIsMuted";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Pass true to mute the user; pass false to unmute the them
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_muted?: Bool$Input;
};

/**
 * Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
 *
 * @param {toggleGroupCallParticipantIsMuted$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallParticipantIsMuted = (
  parameters: toggleGroupCallParticipantIsMuted$Input
) => Ok;

/** Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level */
export type setGroupCallParticipantVolumeLevel$Input = {
  readonly _: "setGroupCallParticipantVolumeLevel";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * New participant's volume level; 1-20000 in hundreds of percents
   * @type {int32} {@link int32}
   */
  readonly volume_level?: int32;
};

/**
 * Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
 *
 * @param {setGroupCallParticipantVolumeLevel$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setGroupCallParticipantVolumeLevel = (
  parameters: setGroupCallParticipantVolumeLevel$Input
) => Ok;

/** Toggles whether a group call participant hand is rased */
export type toggleGroupCallParticipantIsHandRaised$Input = {
  readonly _: "toggleGroupCallParticipantIsHandRaised";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Participant identifier
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly participant_id?: MessageSender$Input;

  /**
   * Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_hand_raised?: Bool$Input;
};

/**
 * Toggles whether a group call participant hand is rased
 *
 * @param {toggleGroupCallParticipantIsHandRaised$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleGroupCallParticipantIsHandRaised = (
  parameters: toggleGroupCallParticipantIsHandRaised$Input
) => Ok;

/** Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded */
export type loadGroupCallParticipants$Input = {
  readonly _: "loadGroupCallParticipants";

  /**
   * Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * The maximum number of participants to load; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
 *
 * @param {loadGroupCallParticipants$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type loadGroupCallParticipants = (
  parameters: loadGroupCallParticipants$Input
) => Ok;

/** Leaves a group call */
export type leaveGroupCall$Input = {
  readonly _: "leaveGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Leaves a group call
 *
 * @param {leaveGroupCall$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type leaveGroupCall = (parameters: leaveGroupCall$Input) => Ok;

/** Ends a group call. Requires groupCall.can_be_managed */
export type endGroupCall$Input = {
  readonly _: "endGroupCall";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Ends a group call. Requires groupCall.can_be_managed
 *
 * @param {endGroupCall$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type endGroupCall = (parameters: endGroupCall$Input) => Ok;

/** Returns information about available group call streams */
export type getGroupCallStreams$Input = {
  readonly _: "getGroupCallStreams";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;
};

/**
 * Returns information about available group call streams
 *
 * @param {getGroupCallStreams$Input} parameters
 * @return {GroupCallStreams} {@link GroupCallStreams}
 */
export type getGroupCallStreams = (
  parameters: getGroupCallStreams$Input
) => GroupCallStreams;

/** Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video */
export type getGroupCallStreamSegment$Input = {
  readonly _: "getGroupCallStreamSegment";

  /**
   * Group call identifier
   * @type {int32} {@link int32}
   */
  readonly group_call_id?: int32;

  /**
   * Point in time when the stream segment begins; Unix timestamp in milliseconds
   * @type {int53} {@link int53}
   */
  readonly time_offset?: int53;

  /**
   * Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Identifier of an audio/video channel to get as received from tgcalls
   * @type {int32} {@link int32}
   */
  readonly channel_id?: int32;

  /**
   * Video quality as received from tgcalls; pass null to get the worst available quality
   * @type {GroupCallVideoQuality$Input} {@link GroupCallVideoQuality}
   */
  readonly video_quality?: GroupCallVideoQuality$Input;
};

/**
 * Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
 *
 * @param {getGroupCallStreamSegment$Input} parameters
 * @return {FilePart} {@link FilePart}
 */
export type getGroupCallStreamSegment = (
  parameters: getGroupCallStreamSegment$Input
) => FilePart;

/** Changes the block state of a message sender. Currently, only users and supergroup chats can be blocked */
export type toggleMessageSenderIsBlocked$Input = {
  readonly _: "toggleMessageSenderIsBlocked";

  /**
   * Identifier of a message sender to block/unblock
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;

  /**
   * New value of is_blocked
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_blocked?: Bool$Input;
};

/**
 * Changes the block state of a message sender. Currently, only users and supergroup chats can be blocked
 *
 * @param {toggleMessageSenderIsBlocked$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleMessageSenderIsBlocked = (
  parameters: toggleMessageSenderIsBlocked$Input
) => Ok;

/** Blocks an original sender of a message in the Replies chat */
export type blockMessageSenderFromReplies$Input = {
  readonly _: "blockMessageSenderFromReplies";

  /**
   * The identifier of an incoming message in the Replies chat
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true to delete the message
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_message?: Bool$Input;

  /**
   * Pass true to delete all messages from the same sender
   * @type {Bool$Input} {@link Bool}
   */
  readonly delete_all_messages?: Bool$Input;

  /**
   * Pass true to report the sender to the Telegram moderators
   * @type {Bool$Input} {@link Bool}
   */
  readonly report_spam?: Bool$Input;
};

/**
 * Blocks an original sender of a message in the Replies chat
 *
 * @param {blockMessageSenderFromReplies$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type blockMessageSenderFromReplies = (
  parameters: blockMessageSenderFromReplies$Input
) => Ok;

/** Returns users and chats that were blocked by the current user */
export type getBlockedMessageSenders$Input = {
  readonly _: "getBlockedMessageSenders";

  /**
   * Number of users and chats to skip in the result; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users and chats to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns users and chats that were blocked by the current user
 *
 * @param {getBlockedMessageSenders$Input} parameters
 * @return {MessageSenders} {@link MessageSenders}
 */
export type getBlockedMessageSenders = (
  parameters: getBlockedMessageSenders$Input
) => MessageSenders;

/** Adds a user to the contact list or edits an existing contact by their user identifier */
export type addContact$Input = {
  readonly _: "addContact";

  /**
   * The contact to add or edit; phone number may be empty and needs to be specified only if known, vCard is ignored
   * @type {contact$Input} {@link contact}
   */
  readonly contact?: contact$Input;

  /**
   * Pass true to share the current user's phone number with the new contact. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field userFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number
   * @type {Bool$Input} {@link Bool}
   */
  readonly share_phone_number?: Bool$Input;
};

/**
 * Adds a user to the contact list or edits an existing contact by their user identifier
 *
 * @param {addContact$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addContact = (parameters: addContact$Input) => Ok;

/** Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored */
export type importContacts$Input = {
  readonly _: "importContacts";

  /**
   * The list of contacts to import or edit; contacts' vCard are ignored and are not imported
   * @type {vector$Input<contact$Input>} {@link vector<contact>}
   */
  readonly contacts?: vector$Input<contact$Input>;
};

/**
 * Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
 *
 * @param {importContacts$Input} parameters
 * @return {ImportedContacts} {@link ImportedContacts}
 */
export type importContacts = (parameters: importContacts$Input) => ImportedContacts;

/** Returns all user contacts */
export type getContacts$Input = {
  readonly _: "getContacts";
};

/**
 * Returns all user contacts
 *
 * @param {getContacts$Input} parameters
 * @return {Users} {@link Users}
 */
export type getContacts = (parameters: getContacts$Input) => Users;

/** Searches for the specified query in the first names, last names and usernames of the known user contacts */
export type searchContacts$Input = {
  readonly _: "searchContacts";

  /**
   * Query to search for; may be empty to return all contacts
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of users to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for the specified query in the first names, last names and usernames of the known user contacts
 *
 * @param {searchContacts$Input} parameters
 * @return {Users} {@link Users}
 */
export type searchContacts = (parameters: searchContacts$Input) => Users;

/** Removes users from the contact list */
export type removeContacts$Input = {
  readonly _: "removeContacts";

  /**
   * Identifiers of users to be deleted
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Removes users from the contact list
 *
 * @param {removeContacts$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeContacts = (parameters: removeContacts$Input) => Ok;

/** Returns the total number of imported contacts */
export type getImportedContactCount$Input = {
  readonly _: "getImportedContactCount";
};

/**
 * Returns the total number of imported contacts
 *
 * @param {getImportedContactCount$Input} parameters
 * @return {Count} {@link Count}
 */
export type getImportedContactCount = (
  parameters: getImportedContactCount$Input
) => Count;

/** Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
-Query result depends on the result of the previous query, so only one query is possible at the same time */
export type changeImportedContacts$Input = {
  readonly _: "changeImportedContacts";

  /**
   * The new list of contacts, contact's vCard are ignored and are not imported
   * @type {vector$Input<contact$Input>} {@link vector<contact>}
   */
  readonly contacts?: vector$Input<contact$Input>;
};

/**
 * Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts.
-Query result depends on the result of the previous query, so only one query is possible at the same time
 * 
 * @param {changeImportedContacts$Input} parameters
 * @return {ImportedContacts} {@link ImportedContacts}
 */
export type changeImportedContacts = (
  parameters: changeImportedContacts$Input
) => ImportedContacts;

/** Clears all imported contacts, contact list remains unchanged */
export type clearImportedContacts$Input = {
  readonly _: "clearImportedContacts";
};

/**
 * Clears all imported contacts, contact list remains unchanged
 *
 * @param {clearImportedContacts$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clearImportedContacts = (parameters: clearImportedContacts$Input) => Ok;

/** Searches a user by their phone number. Returns a 404 error if the user can't be found */
export type searchUserByPhoneNumber$Input = {
  readonly _: "searchUserByPhoneNumber";

  /**
   * Phone number to search for
   * @type {string} {@link string}
   */
  readonly phone_number?: string;
};

/**
 * Searches a user by their phone number. Returns a 404 error if the user can't be found
 *
 * @param {searchUserByPhoneNumber$Input} parameters
 * @return {User} {@link User}
 */
export type searchUserByPhoneNumber = (
  parameters: searchUserByPhoneNumber$Input
) => User;

/** Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber */
export type sharePhoneNumber$Input = {
  readonly _: "sharePhoneNumber";

  /**
   * Identifier of the user with whom to share the phone number. The user must be a mutual contact
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
 *
 * @param {sharePhoneNumber$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sharePhoneNumber = (parameters: sharePhoneNumber$Input) => Ok;

/** Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already */
export type getUserProfilePhotos$Input = {
  readonly _: "getUserProfilePhotos";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The number of photos to skip; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of photos to be returned; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already
 *
 * @param {getUserProfilePhotos$Input} parameters
 * @return {ChatPhotos} {@link ChatPhotos}
 */
export type getUserProfilePhotos = (
  parameters: getUserProfilePhotos$Input
) => ChatPhotos;

/** Returns stickers from the installed sticker sets that correspond to a given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned */
export type getStickers$Input = {
  readonly _: "getStickers";

  /**
   * Type of the stickers to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Search query; an emoji or a keyword prefix. If empty, returns all known installed stickers
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of stickers to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * Chat identifier for which to return stickers. Available custom emoji stickers may be different for different chats
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns stickers from the installed sticker sets that correspond to a given emoji or can be found by sticker-specific keywords. If the query is non-empty, then favorite, recently used or trending stickers may also be returned
 *
 * @param {getStickers$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getStickers = (parameters: getStickers$Input) => Stickers;

/** Searches for stickers from public sticker sets that correspond to a given emoji */
export type searchStickers$Input = {
  readonly _: "searchStickers";

  /**
   * String representation of emoji; must be non-empty
   * @type {string} {@link string}
   */
  readonly emoji?: string;

  /**
   * The maximum number of stickers to be returned; 0-100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for stickers from public sticker sets that correspond to a given emoji
 *
 * @param {searchStickers$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type searchStickers = (parameters: searchStickers$Input) => Stickers;

/** Returns premium stickers from regular sticker sets */
export type getPremiumStickers$Input = {
  readonly _: "getPremiumStickers";

  /**
   * The maximum number of stickers to be returned; 0-100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns premium stickers from regular sticker sets
 *
 * @param {getPremiumStickers$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getPremiumStickers = (parameters: getPremiumStickers$Input) => Stickers;

/** Returns a list of installed sticker sets */
export type getInstalledStickerSets$Input = {
  readonly _: "getInstalledStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;
};

/**
 * Returns a list of installed sticker sets
 *
 * @param {getInstalledStickerSets$Input} parameters
 * @return {StickerSets} {@link StickerSets}
 */
export type getInstalledStickerSets = (
  parameters: getInstalledStickerSets$Input
) => StickerSets;

/** Returns a list of archived sticker sets */
export type getArchivedStickerSets$Input = {
  readonly _: "getArchivedStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Identifier of the sticker set from which to return the result
   * @type {int64} {@link int64}
   */
  readonly offset_sticker_set_id?: int64;

  /**
   * The maximum number of sticker sets to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of archived sticker sets
 *
 * @param {getArchivedStickerSets$Input} parameters
 * @return {StickerSets} {@link StickerSets}
 */
export type getArchivedStickerSets = (
  parameters: getArchivedStickerSets$Input
) => StickerSets;

/** Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib */
export type getTrendingStickerSets$Input = {
  readonly _: "getTrendingStickerSets";

  /**
   * Type of the sticker sets to return
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * The offset from which to return the sticker sets; must be non-negative
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of sticker sets to be returned; up to 100. For optimal performance, the number of returned sticker sets is chosen by TDLib and can be smaller than the specified limit, even if the end of the list has not been reached
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
 *
 * @param {getTrendingStickerSets$Input} parameters
 * @return {TrendingStickerSets} {@link TrendingStickerSets}
 */
export type getTrendingStickerSets = (
  parameters: getTrendingStickerSets$Input
) => TrendingStickerSets;

/** Returns a list of sticker sets attached to a file. Currently, only photos and videos can have attached sticker sets */
export type getAttachedStickerSets$Input = {
  readonly _: "getAttachedStickerSets";

  /**
   * File identifier
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;
};

/**
 * Returns a list of sticker sets attached to a file. Currently, only photos and videos can have attached sticker sets
 *
 * @param {getAttachedStickerSets$Input} parameters
 * @return {StickerSets} {@link StickerSets}
 */
export type getAttachedStickerSets = (
  parameters: getAttachedStickerSets$Input
) => StickerSets;

/** Returns information about a sticker set by its identifier */
export type getStickerSet$Input = {
  readonly _: "getStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly set_id?: int64;
};

/**
 * Returns information about a sticker set by its identifier
 *
 * @param {getStickerSet$Input} parameters
 * @return {StickerSet} {@link StickerSet}
 */
export type getStickerSet = (parameters: getStickerSet$Input) => StickerSet;

/** Searches for a sticker set by its name */
export type searchStickerSet$Input = {
  readonly _: "searchStickerSet";

  /**
   * Name of the sticker set
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Searches for a sticker set by its name
 *
 * @param {searchStickerSet$Input} parameters
 * @return {StickerSet} {@link StickerSet}
 */
export type searchStickerSet = (parameters: searchStickerSet$Input) => StickerSet;

/** Searches for installed sticker sets by looking for specified query in their title and name */
export type searchInstalledStickerSets$Input = {
  readonly _: "searchInstalledStickerSets";

  /**
   * Type of the sticker sets to search for
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * The maximum number of sticker sets to return
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for installed sticker sets by looking for specified query in their title and name
 *
 * @param {searchInstalledStickerSets$Input} parameters
 * @return {StickerSets} {@link StickerSets}
 */
export type searchInstalledStickerSets = (
  parameters: searchInstalledStickerSets$Input
) => StickerSets;

/** Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results */
export type searchStickerSets$Input = {
  readonly _: "searchStickerSets";

  /**
   * Query to search for
   * @type {string} {@link string}
   */
  readonly query?: string;
};

/**
 * Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
 *
 * @param {searchStickerSets$Input} parameters
 * @return {StickerSets} {@link StickerSets}
 */
export type searchStickerSets = (parameters: searchStickerSets$Input) => StickerSets;

/** Installs/uninstalls or activates/archives a sticker set */
export type changeStickerSet$Input = {
  readonly _: "changeStickerSet";

  /**
   * Identifier of the sticker set
   * @type {int64} {@link int64}
   */
  readonly set_id?: int64;

  /**
   * The new value of is_installed
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_installed?: Bool$Input;

  /**
   * The new value of is_archived. A sticker set can't be installed and archived simultaneously
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_archived?: Bool$Input;
};

/**
 * Installs/uninstalls or activates/archives a sticker set
 *
 * @param {changeStickerSet$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type changeStickerSet = (parameters: changeStickerSet$Input) => Ok;

/** Informs the server that some trending sticker sets have been viewed by the user */
export type viewTrendingStickerSets$Input = {
  readonly _: "viewTrendingStickerSets";

  /**
   * Identifiers of viewed trending sticker sets
   * @type {vector$Input<int64>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64>;
};

/**
 * Informs the server that some trending sticker sets have been viewed by the user
 *
 * @param {viewTrendingStickerSets$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type viewTrendingStickerSets = (
  parameters: viewTrendingStickerSets$Input
) => Ok;

/** Changes the order of installed sticker sets */
export type reorderInstalledStickerSets$Input = {
  readonly _: "reorderInstalledStickerSets";

  /**
   * Type of the sticker sets to reorder
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * Identifiers of installed sticker sets in the new correct order
   * @type {vector$Input<int64>} {@link vector<int64>}
   */
  readonly sticker_set_ids?: vector$Input<int64>;
};

/**
 * Changes the order of installed sticker sets
 *
 * @param {reorderInstalledStickerSets$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reorderInstalledStickerSets = (
  parameters: reorderInstalledStickerSets$Input
) => Ok;

/** Returns a list of recently used stickers */
export type getRecentStickers$Input = {
  readonly _: "getRecentStickers";

  /**
   * Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;
};

/**
 * Returns a list of recently used stickers
 *
 * @param {getRecentStickers$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getRecentStickers = (parameters: getRecentStickers$Input) => Stickers;

/** Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to recent stickers */
export type addRecentSticker$Input = {
  readonly _: "addRecentSticker";

  /**
   * Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * Sticker file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to recent stickers
 *
 * @param {addRecentSticker$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type addRecentSticker = (parameters: addRecentSticker$Input) => Stickers;

/** Removes a sticker from the list of recently used stickers */
export type removeRecentSticker$Input = {
  readonly _: "removeRecentSticker";

  /**
   * Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;

  /**
   * Sticker file to delete
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the list of recently used stickers
 *
 * @param {removeRecentSticker$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeRecentSticker = (parameters: removeRecentSticker$Input) => Ok;

/** Clears the list of recently used stickers */
export type clearRecentStickers$Input = {
  readonly _: "clearRecentStickers";

  /**
   * Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_attached?: Bool$Input;
};

/**
 * Clears the list of recently used stickers
 *
 * @param {clearRecentStickers$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clearRecentStickers = (parameters: clearRecentStickers$Input) => Ok;

/** Returns favorite stickers */
export type getFavoriteStickers$Input = {
  readonly _: "getFavoriteStickers";
};

/**
 * Returns favorite stickers
 *
 * @param {getFavoriteStickers$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getFavoriteStickers = (
  parameters: getFavoriteStickers$Input
) => Stickers;

/** Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to favorite stickers */
export type addFavoriteSticker$Input = {
  readonly _: "addFavoriteSticker";

  /**
   * Sticker file to add
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list. Emoji stickers can't be added to favorite stickers
 *
 * @param {addFavoriteSticker$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addFavoriteSticker = (parameters: addFavoriteSticker$Input) => Ok;

/** Removes a sticker from the list of favorite stickers */
export type removeFavoriteSticker$Input = {
  readonly _: "removeFavoriteSticker";

  /**
   * Sticker file to delete from the list
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the list of favorite stickers
 *
 * @param {removeFavoriteSticker$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeFavoriteSticker = (parameters: removeFavoriteSticker$Input) => Ok;

/** Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object */
export type getStickerEmojis$Input = {
  readonly _: "getStickerEmojis";

  /**
   * Sticker file identifier
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
 *
 * @param {getStickerEmojis$Input} parameters
 * @return {Emojis} {@link Emojis}
 */
export type getStickerEmojis = (parameters: getStickerEmojis$Input) => Emojis;

/** Searches for emojis by keywords. Supported only if the file database is enabled */
export type searchEmojis$Input = {
  readonly _: "searchEmojis";

  /**
   * Text to search for
   * @type {string} {@link string}
   */
  readonly text?: string;

  /**
   * Pass true if only emojis, which exactly match the text, needs to be returned
   * @type {Bool$Input} {@link Bool}
   */
  readonly exact_match?: Bool$Input;

  /**
   * List of possible IETF language tags of the user's input language; may be empty if unknown
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly input_language_codes?: vector$Input<string>;
};

/**
 * Searches for emojis by keywords. Supported only if the file database is enabled
 *
 * @param {searchEmojis$Input} parameters
 * @return {Emojis} {@link Emojis}
 */
export type searchEmojis = (parameters: searchEmojis$Input) => Emojis;

/** Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji */
export type getAnimatedEmoji$Input = {
  readonly _: "getAnimatedEmoji";

  /**
   * The emoji
   * @type {string} {@link string}
   */
  readonly emoji?: string;
};

/**
 * Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
 *
 * @param {getAnimatedEmoji$Input} parameters
 * @return {AnimatedEmoji} {@link AnimatedEmoji}
 */
export type getAnimatedEmoji = (parameters: getAnimatedEmoji$Input) => AnimatedEmoji;

/** Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation */
export type getEmojiSuggestionsUrl$Input = {
  readonly _: "getEmojiSuggestionsUrl";

  /**
   * Language code for which the emoji replacements will be suggested
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
 *
 * @param {getEmojiSuggestionsUrl$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getEmojiSuggestionsUrl = (
  parameters: getEmojiSuggestionsUrl$Input
) => HttpUrl;

/** Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned */
export type getCustomEmojiStickers$Input = {
  readonly _: "getCustomEmojiStickers";

  /**
   * Identifiers of custom emoji stickers. At most 200 custom emoji stickers can be received simultaneously
   * @type {vector$Input<int64>} {@link vector<int64>}
   */
  readonly custom_emoji_ids?: vector$Input<int64>;
};

/**
 * Returns list of custom emoji stickers by their identifiers. Stickers are returned in arbitrary order. Only found stickers are returned
 *
 * @param {getCustomEmojiStickers$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getCustomEmojiStickers = (
  parameters: getCustomEmojiStickers$Input
) => Stickers;

/** Returns saved animations */
export type getSavedAnimations$Input = {
  readonly _: "getSavedAnimations";
};

/**
 * Returns saved animations
 *
 * @param {getSavedAnimations$Input} parameters
 * @return {Animations} {@link Animations}
 */
export type getSavedAnimations = (
  parameters: getSavedAnimations$Input
) => Animations;

/** Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list */
export type addSavedAnimation$Input = {
  readonly _: "addSavedAnimation";

  /**
   * The animation file to be added. Only animations known to the server (i.e., successfully sent via a message) can be added to the list
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly animation?: InputFile$Input;
};

/**
 * Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
 *
 * @param {addSavedAnimation$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addSavedAnimation = (parameters: addSavedAnimation$Input) => Ok;

/** Removes an animation from the list of saved animations */
export type removeSavedAnimation$Input = {
  readonly _: "removeSavedAnimation";

  /**
   * Animation file to be removed
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly animation?: InputFile$Input;
};

/**
 * Removes an animation from the list of saved animations
 *
 * @param {removeSavedAnimation$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeSavedAnimation = (parameters: removeSavedAnimation$Input) => Ok;

/** Returns up to 20 recently used inline bots in the order of their last usage */
export type getRecentInlineBots$Input = {
  readonly _: "getRecentInlineBots";
};

/**
 * Returns up to 20 recently used inline bots in the order of their last usage
 *
 * @param {getRecentInlineBots$Input} parameters
 * @return {Users} {@link Users}
 */
export type getRecentInlineBots = (parameters: getRecentInlineBots$Input) => Users;

/** Searches for recently used hashtags by their prefix */
export type searchHashtags$Input = {
  readonly _: "searchHashtags";

  /**
   * Hashtag prefix to search for
   * @type {string} {@link string}
   */
  readonly prefix?: string;

  /**
   * The maximum number of hashtags to be returned
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Searches for recently used hashtags by their prefix
 *
 * @param {searchHashtags$Input} parameters
 * @return {Hashtags} {@link Hashtags}
 */
export type searchHashtags = (parameters: searchHashtags$Input) => Hashtags;

/** Removes a hashtag from the list of recently used hashtags */
export type removeRecentHashtag$Input = {
  readonly _: "removeRecentHashtag";

  /**
   * Hashtag to delete
   * @type {string} {@link string}
   */
  readonly hashtag?: string;
};

/**
 * Removes a hashtag from the list of recently used hashtags
 *
 * @param {removeRecentHashtag$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeRecentHashtag = (parameters: removeRecentHashtag$Input) => Ok;

/** Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview */
export type getWebPagePreview$Input = {
  readonly _: "getWebPagePreview";

  /**
   * Message text with formatting
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly text?: formattedText$Input;
};

/**
 * Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
 *
 * @param {getWebPagePreview$Input} parameters
 * @return {WebPage} {@link WebPage}
 */
export type getWebPagePreview = (parameters: getWebPagePreview$Input) => WebPage;

/** Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page */
export type getWebPageInstantView$Input = {
  readonly _: "getWebPageInstantView";

  /**
   * The web page URL
   * @type {string} {@link string}
   */
  readonly url?: string;

  /**
   * Pass true to get full instant view for the web page
   * @type {Bool$Input} {@link Bool}
   */
  readonly force_full?: Bool$Input;
};

/**
 * Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
 *
 * @param {getWebPageInstantView$Input} parameters
 * @return {WebPageInstantView} {@link WebPageInstantView}
 */
export type getWebPageInstantView = (
  parameters: getWebPageInstantView$Input
) => WebPageInstantView;

/** Changes a profile photo for the current user */
export type setProfilePhoto$Input = {
  readonly _: "setProfilePhoto";

  /**
   * Profile photo to set
   * @type {InputChatPhoto$Input} {@link InputChatPhoto}
   */
  readonly photo?: InputChatPhoto$Input;
};

/**
 * Changes a profile photo for the current user
 *
 * @param {setProfilePhoto$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setProfilePhoto = (parameters: setProfilePhoto$Input) => Ok;

/** Deletes a profile photo */
export type deleteProfilePhoto$Input = {
  readonly _: "deleteProfilePhoto";

  /**
   * Identifier of the profile photo to delete
   * @type {int64} {@link int64}
   */
  readonly profile_photo_id?: int64;
};

/**
 * Deletes a profile photo
 *
 * @param {deleteProfilePhoto$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteProfilePhoto = (parameters: deleteProfilePhoto$Input) => Ok;

/** Changes the first and last name of the current user */
export type setName$Input = {
  readonly _: "setName";

  /**
   * The new value of the first name for the current user; 1-64 characters
   * @type {string} {@link string}
   */
  readonly first_name?: string;

  /**
   * The new value of the optional last name for the current user; 0-64 characters
   * @type {string} {@link string}
   */
  readonly last_name?: string;
};

/**
 * Changes the first and last name of the current user
 *
 * @param {setName$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setName = (parameters: setName$Input) => Ok;

/** Changes the bio of the current user */
export type setBio$Input = {
  readonly _: "setBio";

  /**
   * The new value of the user bio; 0-GetOption("bio_length_max") characters without line feeds
   * @type {string} {@link string}
   */
  readonly bio?: string;
};

/**
 * Changes the bio of the current user
 *
 * @param {setBio$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setBio = (parameters: setBio$Input) => Ok;

/** Changes the editable username of the current user */
export type setUsername$Input = {
  readonly _: "setUsername";

  /**
   * The new value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Changes the editable username of the current user
 *
 * @param {setUsername$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setUsername = (parameters: setUsername$Input) => Ok;

/** Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached */
export type toggleUsernameIsActive$Input = {
  readonly _: "toggleUsernameIsActive";

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of the current user. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 *
 * @param {toggleUsernameIsActive$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleUsernameIsActive = (
  parameters: toggleUsernameIsActive$Input
) => Ok;

/** Changes order of active usernames of the current user */
export type reorderActiveUsernames$Input = {
  readonly _: "reorderActiveUsernames";

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of the current user
 *
 * @param {reorderActiveUsernames$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reorderActiveUsernames = (
  parameters: reorderActiveUsernames$Input
) => Ok;

/** Changes the emoji status of the current user; for Telegram Premium users only */
export type setEmojiStatus$Input = {
  readonly _: "setEmojiStatus";

  /**
   * New emoji status; pass null to switch to the default badge
   * @type {emojiStatus$Input} {@link emojiStatus}
   */
  readonly emoji_status?: emojiStatus$Input;

  /**
   * Duration of the status, in seconds; pass 0 to keep the status active until it will be changed manually
   * @type {int32} {@link int32}
   */
  readonly duration?: int32;
};

/**
 * Changes the emoji status of the current user; for Telegram Premium users only
 *
 * @param {setEmojiStatus$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setEmojiStatus = (parameters: setEmojiStatus$Input) => Ok;

/** Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer */
export type setLocation$Input = {
  readonly _: "setLocation";

  /**
   * The new location of the user
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;
};

/**
 * Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer
 *
 * @param {setLocation$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setLocation = (parameters: setLocation$Input) => Ok;

/** Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code */
export type changePhoneNumber$Input = {
  readonly _: "changePhoneNumber";

  /**
   * The new phone number of the user in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input;
};

/**
 * Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code
 *
 * @param {changePhoneNumber$Input} parameters
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type changePhoneNumber = (
  parameters: changePhoneNumber$Input
) => AuthenticationCodeInfo;

/** Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed */
export type resendChangePhoneNumberCode$Input = {
  readonly _: "resendChangePhoneNumberCode";
};

/**
 * Resends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
 *
 * @param {resendChangePhoneNumberCode$Input} parameters
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type resendChangePhoneNumberCode = (
  parameters: resendChangePhoneNumberCode$Input
) => AuthenticationCodeInfo;

/** Checks the authentication code sent to confirm a new phone number of the user */
export type checkChangePhoneNumberCode$Input = {
  readonly _: "checkChangePhoneNumberCode";

  /**
   * Authentication code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the authentication code sent to confirm a new phone number of the user
 *
 * @param {checkChangePhoneNumberCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkChangePhoneNumberCode = (
  parameters: checkChangePhoneNumberCode$Input
) => Ok;

/** Sets the list of commands supported by the bot for the given user scope and language; for bots only */
export type setCommands$Input = {
  readonly _: "setCommands";

  /**
   * The scope to which the commands are relevant; pass null to change commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input;

  /**
   * A two-letter ISO 639-1 language code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * List of the bot's commands
   * @type {vector$Input<botCommand$Input>} {@link vector<botCommand>}
   */
  readonly commands?: vector$Input<botCommand$Input>;
};

/**
 * Sets the list of commands supported by the bot for the given user scope and language; for bots only
 *
 * @param {setCommands$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setCommands = (parameters: setCommands$Input) => Ok;

/** Deletes commands supported by the bot for the given user scope and language; for bots only */
export type deleteCommands$Input = {
  readonly _: "deleteCommands";

  /**
   * The scope to which the commands are relevant; pass null to delete commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Deletes commands supported by the bot for the given user scope and language; for bots only
 *
 * @param {deleteCommands$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteCommands = (parameters: deleteCommands$Input) => Ok;

/** Returns the list of commands supported by the bot for the given user scope and language; for bots only */
export type getCommands$Input = {
  readonly _: "getCommands";

  /**
   * The scope to which the commands are relevant; pass null to get commands in the default bot command scope
   * @type {BotCommandScope$Input} {@link BotCommandScope}
   */
  readonly scope?: BotCommandScope$Input;

  /**
   * A two-letter ISO 639-1 language code or an empty string
   * @type {string} {@link string}
   */
  readonly language_code?: string;
};

/**
 * Returns the list of commands supported by the bot for the given user scope and language; for bots only
 *
 * @param {getCommands$Input} parameters
 * @return {BotCommands} {@link BotCommands}
 */
export type getCommands = (parameters: getCommands$Input) => BotCommands;

/** Sets menu button for the given user or for all users; for bots only */
export type setMenuButton$Input = {
  readonly _: "setMenuButton";

  /**
   * Identifier of the user or 0 to set menu button for all users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New menu button
   * @type {botMenuButton$Input} {@link botMenuButton}
   */
  readonly menu_button?: botMenuButton$Input;
};

/**
 * Sets menu button for the given user or for all users; for bots only
 *
 * @param {setMenuButton$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setMenuButton = (parameters: setMenuButton$Input) => Ok;

/** Returns menu button set by the bot for the given user; for bots only */
export type getMenuButton$Input = {
  readonly _: "getMenuButton";

  /**
   * Identifier of the user or 0 to get the default menu button
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns menu button set by the bot for the given user; for bots only
 *
 * @param {getMenuButton$Input} parameters
 * @return {BotMenuButton} {@link BotMenuButton}
 */
export type getMenuButton = (parameters: getMenuButton$Input) => BotMenuButton;

/** Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only */
export type setDefaultGroupAdministratorRights$Input = {
  readonly _: "setDefaultGroupAdministratorRights";

  /**
   * Default administrator rights for adding the bot to basic group and supergroup chats; may be null
   * @type {chatAdministratorRights$Input} {@link chatAdministratorRights}
   */
  readonly default_group_administrator_rights?: chatAdministratorRights$Input;
};

/**
 * Sets default administrator rights for adding the bot to basic group and supergroup chats; for bots only
 *
 * @param {setDefaultGroupAdministratorRights$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setDefaultGroupAdministratorRights = (
  parameters: setDefaultGroupAdministratorRights$Input
) => Ok;

/** Sets default administrator rights for adding the bot to channel chats; for bots only */
export type setDefaultChannelAdministratorRights$Input = {
  readonly _: "setDefaultChannelAdministratorRights";

  /**
   * Default administrator rights for adding the bot to channels; may be null
   * @type {chatAdministratorRights$Input} {@link chatAdministratorRights}
   */
  readonly default_channel_administrator_rights?: chatAdministratorRights$Input;
};

/**
 * Sets default administrator rights for adding the bot to channel chats; for bots only
 *
 * @param {setDefaultChannelAdministratorRights$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setDefaultChannelAdministratorRights = (
  parameters: setDefaultChannelAdministratorRights$Input
) => Ok;

/** Returns all active sessions of the current user */
export type getActiveSessions$Input = {
  readonly _: "getActiveSessions";
};

/**
 * Returns all active sessions of the current user
 *
 * @param {getActiveSessions$Input} parameters
 * @return {Sessions} {@link Sessions}
 */
export type getActiveSessions = (parameters: getActiveSessions$Input) => Sessions;

/** Terminates a session of the current user */
export type terminateSession$Input = {
  readonly _: "terminateSession";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  readonly session_id?: int64;
};

/**
 * Terminates a session of the current user
 *
 * @param {terminateSession$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type terminateSession = (parameters: terminateSession$Input) => Ok;

/** Terminates all other sessions of the current user */
export type terminateAllOtherSessions$Input = {
  readonly _: "terminateAllOtherSessions";
};

/**
 * Terminates all other sessions of the current user
 *
 * @param {terminateAllOtherSessions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type terminateAllOtherSessions = (
  parameters: terminateAllOtherSessions$Input
) => Ok;

/** Toggles whether a session can accept incoming calls */
export type toggleSessionCanAcceptCalls$Input = {
  readonly _: "toggleSessionCanAcceptCalls";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  readonly session_id?: int64;

  /**
   * Pass true to allow accepting incoming calls by the session; pass false otherwise
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_accept_calls?: Bool$Input;
};

/**
 * Toggles whether a session can accept incoming calls
 *
 * @param {toggleSessionCanAcceptCalls$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSessionCanAcceptCalls = (
  parameters: toggleSessionCanAcceptCalls$Input
) => Ok;

/** Toggles whether a session can accept incoming secret chats */
export type toggleSessionCanAcceptSecretChats$Input = {
  readonly _: "toggleSessionCanAcceptSecretChats";

  /**
   * Session identifier
   * @type {int64} {@link int64}
   */
  readonly session_id?: int64;

  /**
   * Pass true to allow accepring secret chats by the session; pass false otherwise
   * @type {Bool$Input} {@link Bool}
   */
  readonly can_accept_secret_chats?: Bool$Input;
};

/**
 * Toggles whether a session can accept incoming secret chats
 *
 * @param {toggleSessionCanAcceptSecretChats$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSessionCanAcceptSecretChats = (
  parameters: toggleSessionCanAcceptSecretChats$Input
) => Ok;

/** Changes the period of inactivity after which sessions will automatically be terminated */
export type setInactiveSessionTtl$Input = {
  readonly _: "setInactiveSessionTtl";

  /**
   * New number of days of inactivity before sessions will be automatically terminated; 1-366 days
   * @type {int32} {@link int32}
   */
  readonly inactive_session_ttl_days?: int32;
};

/**
 * Changes the period of inactivity after which sessions will automatically be terminated
 *
 * @param {setInactiveSessionTtl$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setInactiveSessionTtl = (parameters: setInactiveSessionTtl$Input) => Ok;

/** Returns all website where the current user used Telegram to log in */
export type getConnectedWebsites$Input = {
  readonly _: "getConnectedWebsites";
};

/**
 * Returns all website where the current user used Telegram to log in
 *
 * @param {getConnectedWebsites$Input} parameters
 * @return {ConnectedWebsites} {@link ConnectedWebsites}
 */
export type getConnectedWebsites = (
  parameters: getConnectedWebsites$Input
) => ConnectedWebsites;

/** Disconnects website from the current user's Telegram account */
export type disconnectWebsite$Input = {
  readonly _: "disconnectWebsite";

  /**
   * Website identifier
   * @type {int64} {@link int64}
   */
  readonly website_id?: int64;
};

/**
 * Disconnects website from the current user's Telegram account
 *
 * @param {disconnectWebsite$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type disconnectWebsite = (parameters: disconnectWebsite$Input) => Ok;

/** Disconnects all websites from the current user's Telegram account */
export type disconnectAllWebsites$Input = {
  readonly _: "disconnectAllWebsites";
};

/**
 * Disconnects all websites from the current user's Telegram account
 *
 * @param {disconnectAllWebsites$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type disconnectAllWebsites = (parameters: disconnectAllWebsites$Input) => Ok;

/** Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel */
export type setSupergroupUsername$Input = {
  readonly _: "setSupergroupUsername";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of the username. Use an empty string to remove the username. The username can't be completely removed if there is another active or disabled username
   * @type {string} {@link string}
   */
  readonly username?: string;
};

/**
 * Changes the editable username of a supergroup or channel, requires owner privileges in the supergroup or channel
 *
 * @param {setSupergroupUsername$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setSupergroupUsername = (parameters: setSupergroupUsername$Input) => Ok;

/** Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached */
export type toggleSupergroupUsernameIsActive$Input = {
  readonly _: "toggleSupergroupUsernameIsActive";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The username to change
   * @type {string} {@link string}
   */
  readonly username?: string;

  /**
   * Pass true to activate the username; pass false to disable it
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_active?: Bool$Input;
};

/**
 * Changes active state for a username of a supergroup or channel, requires owner privileges in the supergroup or channel. The editable username can't be disabled. May return an error with a message "USERNAMES_ACTIVE_TOO_MUCH" if the maximum number of active usernames has been reached
 *
 * @param {toggleSupergroupUsernameIsActive$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupUsernameIsActive = (
  parameters: toggleSupergroupUsernameIsActive$Input
) => Ok;

/** Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel */
export type disableAllSupergroupUsernames$Input = {
  readonly _: "disableAllSupergroupUsernames";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Disables all active non-editable usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 *
 * @param {disableAllSupergroupUsernames$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type disableAllSupergroupUsernames = (
  parameters: disableAllSupergroupUsernames$Input
) => Ok;

/** Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel */
export type reorderSupergroupActiveUsernames$Input = {
  readonly _: "reorderSupergroupActiveUsernames";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new order of active usernames. All currently active usernames must be specified
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly usernames?: vector$Input<string>;
};

/**
 * Changes order of active usernames of a supergroup or channel, requires owner privileges in the supergroup or channel
 *
 * @param {reorderSupergroupActiveUsernames$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reorderSupergroupActiveUsernames = (
  parameters: reorderSupergroupActiveUsernames$Input
) => Ok;

/** Changes the sticker set of a supergroup; requires can_change_info administrator right */
export type setSupergroupStickerSet$Input = {
  readonly _: "setSupergroupStickerSet";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set
   * @type {int64} {@link int64}
   */
  readonly sticker_set_id?: int64;
};

/**
 * Changes the sticker set of a supergroup; requires can_change_info administrator right
 *
 * @param {setSupergroupStickerSet$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setSupergroupStickerSet = (
  parameters: setSupergroupStickerSet$Input
) => Ok;

/** Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right */
export type toggleSupergroupSignMessages$Input = {
  readonly _: "toggleSupergroupSignMessages";

  /**
   * Identifier of the channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of sign_messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly sign_messages?: Bool$Input;
};

/**
 * Toggles whether sender signature is added to sent messages in a channel; requires can_change_info administrator right
 *
 * @param {toggleSupergroupSignMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupSignMessages = (
  parameters: toggleSupergroupSignMessages$Input
) => Ok;

/** Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right */
export type toggleSupergroupJoinToSendMessages$Input = {
  readonly _: "toggleSupergroupJoinToSendMessages";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of join_to_send_messages
   * @type {Bool$Input} {@link Bool}
   */
  readonly join_to_send_messages?: Bool$Input;
};

/**
 * Toggles whether joining is mandatory to send messages to a discussion supergroup; requires can_restrict_members administrator right
 *
 * @param {toggleSupergroupJoinToSendMessages$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupJoinToSendMessages = (
  parameters: toggleSupergroupJoinToSendMessages$Input
) => Ok;

/** Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right */
export type toggleSupergroupJoinByRequest$Input = {
  readonly _: "toggleSupergroupJoinByRequest";

  /**
   * Identifier of the channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of join_by_request
   * @type {Bool$Input} {@link Bool}
   */
  readonly join_by_request?: Bool$Input;
};

/**
 * Toggles whether all users directly joining the supergroup need to be approved by supergroup administrators; requires can_restrict_members administrator right
 *
 * @param {toggleSupergroupJoinByRequest$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupJoinByRequest = (
  parameters: toggleSupergroupJoinByRequest$Input
) => Ok;

/** Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right */
export type toggleSupergroupIsAllHistoryAvailable$Input = {
  readonly _: "toggleSupergroupIsAllHistoryAvailable";

  /**
   * The identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The new value of is_all_history_available
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_all_history_available?: Bool$Input;
};

/**
 * Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
 *
 * @param {toggleSupergroupIsAllHistoryAvailable$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupIsAllHistoryAvailable = (
  parameters: toggleSupergroupIsAllHistoryAvailable$Input
) => Ok;

/** Toggles whether the supergroup is a forum; requires owner privileges in the supergroup */
export type toggleSupergroupIsForum$Input = {
  readonly _: "toggleSupergroupIsForum";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * New value of is_forum. A supergroup can be converted to a forum, only if it has at least GetOption("forum_member_count_min") members
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_forum?: Bool$Input;
};

/**
 * Toggles whether the supergroup is a forum; requires owner privileges in the supergroup
 *
 * @param {toggleSupergroupIsForum$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupIsForum = (
  parameters: toggleSupergroupIsForum$Input
) => Ok;

/** Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup */
export type toggleSupergroupIsBroadcastGroup$Input = {
  readonly _: "toggleSupergroupIsBroadcastGroup";

  /**
   * Identifier of the supergroup
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;
};

/**
 * Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
 *
 * @param {toggleSupergroupIsBroadcastGroup$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type toggleSupergroupIsBroadcastGroup = (
  parameters: toggleSupergroupIsBroadcastGroup$Input
) => Ok;

/** Reports messages in a supergroup as spam; requires administrator rights in the supergroup */
export type reportSupergroupSpam$Input = {
  readonly _: "reportSupergroupSpam";

  /**
   * Supergroup identifier
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * Identifiers of messages to report
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;
};

/**
 * Reports messages in a supergroup as spam; requires administrator rights in the supergroup
 *
 * @param {reportSupergroupSpam$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reportSupergroupSpam = (parameters: reportSupergroupSpam$Input) => Ok;

/** Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters */
export type getSupergroupMembers$Input = {
  readonly _: "getSupergroupMembers";

  /**
   * Identifier of the supergroup or channel
   * @type {int53} {@link int53}
   */
  readonly supergroup_id?: int53;

  /**
   * The type of users to return; pass null to use supergroupMembersFilterRecent
   * @type {SupergroupMembersFilter$Input} {@link SupergroupMembersFilter}
   */
  readonly filter?: SupergroupMembersFilter$Input;

  /**
   * Number of users to skip
   * @type {int32} {@link int32}
   */
  readonly offset?: int32;

  /**
   * The maximum number of users be returned; up to 200
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;
};

/**
 * Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
 *
 * @param {getSupergroupMembers$Input} parameters
 * @return {ChatMembers} {@link ChatMembers}
 */
export type getSupergroupMembers = (
  parameters: getSupergroupMembers$Input
) => ChatMembers;

/** Closes a secret chat, effectively transferring its state to secretChatStateClosed */
export type closeSecretChat$Input = {
  readonly _: "closeSecretChat";

  /**
   * Secret chat identifier
   * @type {int32} {@link int32}
   */
  readonly secret_chat_id?: int32;
};

/**
 * Closes a secret chat, effectively transferring its state to secretChatStateClosed
 *
 * @param {closeSecretChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type closeSecretChat = (parameters: closeSecretChat$Input) => Ok;

/** Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id) */
export type getChatEventLog$Input = {
  readonly _: "getChatEventLog";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Search query by which to filter events
   * @type {string} {@link string}
   */
  readonly query?: string;

  /**
   * Identifier of an event from which to return results. Use 0 to get results from the latest events
   * @type {int64} {@link int64}
   */
  readonly from_event_id?: int64;

  /**
   * The maximum number of events to return; up to 100
   * @type {int32} {@link int32}
   */
  readonly limit?: int32;

  /**
   * The types of events to return; pass null to get chat events of all types
   * @type {chatEventLogFilters$Input} {@link chatEventLogFilters}
   */
  readonly filters?: chatEventLogFilters$Input;

  /**
   * User identifiers by which to filter events. By default, events relating to all users will be returned
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly user_ids?: vector$Input<int53>;
};

/**
 * Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i.e., in order of decreasing event_id)
 *
 * @param {getChatEventLog$Input} parameters
 * @return {ChatEvents} {@link ChatEvents}
 */
export type getChatEventLog = (parameters: getChatEventLog$Input) => ChatEvents;

/** Returns an invoice payment form. This method must be called when the user presses inlineKeyboardButtonBuy */
export type getPaymentForm$Input = {
  readonly _: "getPaymentForm";

  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * Preferred payment form theme; pass null to use the default theme
   * @type {themeParameters$Input} {@link themeParameters}
   */
  readonly theme?: themeParameters$Input;
};

/**
 * Returns an invoice payment form. This method must be called when the user presses inlineKeyboardButtonBuy
 *
 * @param {getPaymentForm$Input} parameters
 * @return {PaymentForm} {@link PaymentForm}
 */
export type getPaymentForm = (parameters: getPaymentForm$Input) => PaymentForm;

/** Validates the order information provided by a user and returns the available shipping options for a flexible invoice */
export type validateOrderInfo$Input = {
  readonly _: "validateOrderInfo";

  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * The order information, provided by the user; pass null if empty
   * @type {orderInfo$Input} {@link orderInfo}
   */
  readonly order_info?: orderInfo$Input;

  /**
   * Pass true to save the order information
   * @type {Bool$Input} {@link Bool}
   */
  readonly allow_save?: Bool$Input;
};

/**
 * Validates the order information provided by a user and returns the available shipping options for a flexible invoice
 *
 * @param {validateOrderInfo$Input} parameters
 * @return {ValidatedOrderInfo} {@link ValidatedOrderInfo}
 */
export type validateOrderInfo = (
  parameters: validateOrderInfo$Input
) => ValidatedOrderInfo;

/** Sends a filled-out payment form to the bot for final verification */
export type sendPaymentForm$Input = {
  readonly _: "sendPaymentForm";

  /**
   * The invoice
   * @type {InputInvoice$Input} {@link InputInvoice}
   */
  readonly input_invoice?: InputInvoice$Input;

  /**
   * Payment form identifier returned by getPaymentForm
   * @type {int64} {@link int64}
   */
  readonly payment_form_id?: int64;

  /**
   * Identifier returned by validateOrderInfo, or an empty string
   * @type {string} {@link string}
   */
  readonly order_info_id?: string;

  /**
   * Identifier of a chosen shipping option, if applicable
   * @type {string} {@link string}
   */
  readonly shipping_option_id?: string;

  /**
   * The credentials chosen by user for payment
   * @type {InputCredentials$Input} {@link InputCredentials}
   */
  readonly credentials?: InputCredentials$Input;

  /**
   * Chosen by the user amount of tip in the smallest units of the currency
   * @type {int53} {@link int53}
   */
  readonly tip_amount?: int53;
};

/**
 * Sends a filled-out payment form to the bot for final verification
 *
 * @param {sendPaymentForm$Input} parameters
 * @return {PaymentResult} {@link PaymentResult}
 */
export type sendPaymentForm = (parameters: sendPaymentForm$Input) => PaymentResult;

/** Returns information about a successful payment */
export type getPaymentReceipt$Input = {
  readonly _: "getPaymentReceipt";

  /**
   * Chat identifier of the PaymentSuccessful message
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;
};

/**
 * Returns information about a successful payment
 *
 * @param {getPaymentReceipt$Input} parameters
 * @return {PaymentReceipt} {@link PaymentReceipt}
 */
export type getPaymentReceipt = (
  parameters: getPaymentReceipt$Input
) => PaymentReceipt;

/** Returns saved order information. Returns a 404 error if there is no saved order information */
export type getSavedOrderInfo$Input = {
  readonly _: "getSavedOrderInfo";
};

/**
 * Returns saved order information. Returns a 404 error if there is no saved order information
 *
 * @param {getSavedOrderInfo$Input} parameters
 * @return {OrderInfo} {@link OrderInfo}
 */
export type getSavedOrderInfo = (parameters: getSavedOrderInfo$Input) => OrderInfo;

/** Deletes saved order information */
export type deleteSavedOrderInfo$Input = {
  readonly _: "deleteSavedOrderInfo";
};

/**
 * Deletes saved order information
 *
 * @param {deleteSavedOrderInfo$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteSavedOrderInfo = (parameters: deleteSavedOrderInfo$Input) => Ok;

/** Deletes saved credentials for all payment provider bots */
export type deleteSavedCredentials$Input = {
  readonly _: "deleteSavedCredentials";
};

/**
 * Deletes saved credentials for all payment provider bots
 *
 * @param {deleteSavedCredentials$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteSavedCredentials = (
  parameters: deleteSavedCredentials$Input
) => Ok;

/** Creates a link for the given invoice; for bots only */
export type createInvoiceLink$Input = {
  readonly _: "createInvoiceLink";

  /**
   * Information about the invoice of the type inputMessageInvoice
   * @type {InputMessageContent$Input} {@link InputMessageContent}
   */
  readonly invoice?: InputMessageContent$Input;
};

/**
 * Creates a link for the given invoice; for bots only
 *
 * @param {createInvoiceLink$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type createInvoiceLink = (parameters: createInvoiceLink$Input) => HttpUrl;

/** Returns a user that can be contacted to get support */
export type getSupportUser$Input = {
  readonly _: "getSupportUser";
};

/**
 * Returns a user that can be contacted to get support
 *
 * @param {getSupportUser$Input} parameters
 * @return {User} {@link User}
 */
export type getSupportUser = (parameters: getSupportUser$Input) => User;

/** Returns backgrounds installed by the user */
export type getBackgrounds$Input = {
  readonly _: "getBackgrounds";

  /**
   * Pass true to order returned backgrounds for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Returns backgrounds installed by the user
 *
 * @param {getBackgrounds$Input} parameters
 * @return {Backgrounds} {@link Backgrounds}
 */
export type getBackgrounds = (parameters: getBackgrounds$Input) => Backgrounds;

/** Constructs a persistent HTTP URL for a background */
export type getBackgroundUrl$Input = {
  readonly _: "getBackgroundUrl";

  /**
   * Background name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Background type
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input;
};

/**
 * Constructs a persistent HTTP URL for a background
 *
 * @param {getBackgroundUrl$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getBackgroundUrl = (parameters: getBackgroundUrl$Input) => HttpUrl;

/** Searches for a background by its name */
export type searchBackground$Input = {
  readonly _: "searchBackground";

  /**
   * The name of the background
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Searches for a background by its name
 *
 * @param {searchBackground$Input} parameters
 * @return {Background} {@link Background}
 */
export type searchBackground = (parameters: searchBackground$Input) => Background;

/** Changes the background selected by the user; adds background to the list of installed backgrounds */
export type setBackground$Input = {
  readonly _: "setBackground";

  /**
   * The input background to use; pass null to create a new filled backgrounds or to remove the current background
   * @type {InputBackground$Input} {@link InputBackground}
   */
  readonly background?: InputBackground$Input;

  /**
   * Background type; pass null to use the default type of the remote background or to remove the current background
   * @type {BackgroundType$Input} {@link BackgroundType}
   */
  readonly type?: BackgroundType$Input;

  /**
   * Pass true if the background is changed for a dark theme
   * @type {Bool$Input} {@link Bool}
   */
  readonly for_dark_theme?: Bool$Input;
};

/**
 * Changes the background selected by the user; adds background to the list of installed backgrounds
 *
 * @param {setBackground$Input} parameters
 * @return {Background} {@link Background}
 */
export type setBackground = (parameters: setBackground$Input) => Background;

/** Removes background from the list of installed backgrounds */
export type removeBackground$Input = {
  readonly _: "removeBackground";

  /**
   * The background identifier
   * @type {int64} {@link int64}
   */
  readonly background_id?: int64;
};

/**
 * Removes background from the list of installed backgrounds
 *
 * @param {removeBackground$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeBackground = (parameters: removeBackground$Input) => Ok;

/** Resets list of installed backgrounds to its default value */
export type resetBackgrounds$Input = {
  readonly _: "resetBackgrounds";
};

/**
 * Resets list of installed backgrounds to its default value
 *
 * @param {resetBackgrounds$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type resetBackgrounds = (parameters: resetBackgrounds$Input) => Ok;

/** Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization */
export type getLocalizationTargetInfo$Input = {
  readonly _: "getLocalizationTargetInfo";

  /**
   * Pass true to get only locally available information without sending network requests
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_local?: Bool$Input;
};

/**
 * Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
 *
 * @param {getLocalizationTargetInfo$Input} parameters
 * @return {LocalizationTargetInfo} {@link LocalizationTargetInfo}
 */
export type getLocalizationTargetInfo = (
  parameters: getLocalizationTargetInfo$Input
) => LocalizationTargetInfo;

/** Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization */
export type getLanguagePackInfo$Input = {
  readonly _: "getLanguagePackInfo";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
 *
 * @param {getLanguagePackInfo$Input} parameters
 * @return {LanguagePackInfo} {@link LanguagePackInfo}
 */
export type getLanguagePackInfo = (
  parameters: getLanguagePackInfo$Input
) => LanguagePackInfo;

/** Returns strings from a language pack in the current localization target by their keys. Can be called before authorization */
export type getLanguagePackStrings$Input = {
  readonly _: "getLanguagePackStrings";

  /**
   * Language pack identifier of the strings to be returned
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * Language pack keys of the strings to be returned; leave empty to request all available strings
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly keys?: vector$Input<string>;
};

/**
 * Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
 *
 * @param {getLanguagePackStrings$Input} parameters
 * @return {LanguagePackStrings} {@link LanguagePackStrings}
 */
export type getLanguagePackStrings = (
  parameters: getLanguagePackStrings$Input
) => LanguagePackStrings;

/** Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization */
export type synchronizeLanguagePack$Input = {
  readonly _: "synchronizeLanguagePack";

  /**
   * Language pack identifier
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
 *
 * @param {synchronizeLanguagePack$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type synchronizeLanguagePack = (
  parameters: synchronizeLanguagePack$Input
) => Ok;

/** Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization */
export type addCustomServerLanguagePack$Input = {
  readonly _: "addCustomServerLanguagePack";

  /**
   * Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
 *
 * @param {addCustomServerLanguagePack$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addCustomServerLanguagePack = (
  parameters: addCustomServerLanguagePack$Input
) => Ok;

/** Adds or changes a custom local language pack to the current localization target */
export type setCustomLanguagePack$Input = {
  readonly _: "setCustomLanguagePack";

  /**
   * Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization
   * @type {languagePackInfo$Input} {@link languagePackInfo}
   */
  readonly info?: languagePackInfo$Input;

  /**
   * Strings of the new language pack
   * @type {vector$Input<languagePackString$Input>} {@link vector<languagePackString>}
   */
  readonly strings?: vector$Input<languagePackString$Input>;
};

/**
 * Adds or changes a custom local language pack to the current localization target
 *
 * @param {setCustomLanguagePack$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setCustomLanguagePack = (parameters: setCustomLanguagePack$Input) => Ok;

/** Edits information about a custom local language pack in the current localization target. Can be called before authorization */
export type editCustomLanguagePackInfo$Input = {
  readonly _: "editCustomLanguagePackInfo";

  /**
   * New information about the custom local language pack
   * @type {languagePackInfo$Input} {@link languagePackInfo}
   */
  readonly info?: languagePackInfo$Input;
};

/**
 * Edits information about a custom local language pack in the current localization target. Can be called before authorization
 *
 * @param {editCustomLanguagePackInfo$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type editCustomLanguagePackInfo = (
  parameters: editCustomLanguagePackInfo$Input
) => Ok;

/** Adds, edits or deletes a string in a custom local language pack. Can be called before authorization */
export type setCustomLanguagePackString$Input = {
  readonly _: "setCustomLanguagePackString";

  /**
   * Identifier of a previously added custom local language pack in the current localization target
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;

  /**
   * New language pack string
   * @type {languagePackString$Input} {@link languagePackString}
   */
  readonly new_string?: languagePackString$Input;
};

/**
 * Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
 *
 * @param {setCustomLanguagePackString$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setCustomLanguagePackString = (
  parameters: setCustomLanguagePackString$Input
) => Ok;

/** Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization */
export type deleteLanguagePack$Input = {
  readonly _: "deleteLanguagePack";

  /**
   * Identifier of the language pack to delete
   * @type {string} {@link string}
   */
  readonly language_pack_id?: string;
};

/**
 * Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization
 *
 * @param {deleteLanguagePack$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteLanguagePack = (parameters: deleteLanguagePack$Input) => Ok;

/** Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription */
export type registerDevice$Input = {
  readonly _: "registerDevice";

  /**
   * Device token
   * @type {DeviceToken$Input} {@link DeviceToken}
   */
  readonly device_token?: DeviceToken$Input;

  /**
   * List of user identifiers of other users currently using the application
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly other_user_ids?: vector$Input<int53>;
};

/**
 * Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
 *
 * @param {registerDevice$Input} parameters
 * @return {PushReceiverId} {@link PushReceiverId}
 */
export type registerDevice = (parameters: registerDevice$Input) => PushReceiverId;

/** Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization */
export type processPushNotification$Input = {
  readonly _: "processPushNotification";

  /**
   * JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
 *
 * @param {processPushNotification$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type processPushNotification = (
  parameters: processPushNotification$Input
) => Ok;

/** Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously */
export type getPushReceiverId$Input = {
  readonly _: "getPushReceiverId";

  /**
   * JSON-encoded push notification payload
   * @type {string} {@link string}
   */
  readonly payload?: string;
};

/**
 * Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
 *
 * @param {getPushReceiverId$Input} parameters
 * @return {PushReceiverId} {@link PushReceiverId}
 */
export type getPushReceiverId = (
  parameters: getPushReceiverId$Input
) => PushReceiverId;

/** Returns t.me URLs recently visited by a newly registered user */
export type getRecentlyVisitedTMeUrls$Input = {
  readonly _: "getRecentlyVisitedTMeUrls";

  /**
   * Google Play referrer to identify the user
   * @type {string} {@link string}
   */
  readonly referrer?: string;
};

/**
 * Returns t.me URLs recently visited by a newly registered user
 *
 * @param {getRecentlyVisitedTMeUrls$Input} parameters
 * @return {TMeUrls} {@link TMeUrls}
 */
export type getRecentlyVisitedTMeUrls = (
  parameters: getRecentlyVisitedTMeUrls$Input
) => TMeUrls;

/** Changes user privacy settings */
export type setUserPrivacySettingRules$Input = {
  readonly _: "setUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting$Input} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;

  /**
   * The new privacy rules
   * @type {userPrivacySettingRules$Input} {@link userPrivacySettingRules}
   */
  readonly rules?: userPrivacySettingRules$Input;
};

/**
 * Changes user privacy settings
 *
 * @param {setUserPrivacySettingRules$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setUserPrivacySettingRules = (
  parameters: setUserPrivacySettingRules$Input
) => Ok;

/** Returns the current privacy settings */
export type getUserPrivacySettingRules$Input = {
  readonly _: "getUserPrivacySettingRules";

  /**
   * The privacy setting
   * @type {UserPrivacySetting$Input} {@link UserPrivacySetting}
   */
  readonly setting?: UserPrivacySetting$Input;
};

/**
 * Returns the current privacy settings
 *
 * @param {getUserPrivacySettingRules$Input} parameters
 * @return {UserPrivacySettingRules} {@link UserPrivacySettingRules}
 */
export type getUserPrivacySettingRules = (
  parameters: getUserPrivacySettingRules$Input
) => UserPrivacySettingRules;

/** Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash" */
export type getOption$Input = {
  readonly _: "getOption";

  /**
   * The name of the option
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization. Can be called synchronously for options "version" and "commit_hash"
 *
 * @param {getOption$Input} parameters
 * @return {OptionValue} {@link OptionValue}
 */
export type getOption = (parameters: getOption$Input) => OptionValue;

/** Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization */
export type setOption$Input = {
  readonly _: "setOption";

  /**
   * The name of the option
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * The new value of the option; pass null to reset option value to a default value
   * @type {OptionValue$Input} {@link OptionValue}
   */
  readonly value?: OptionValue$Input;
};

/**
 * Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
 *
 * @param {setOption$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setOption = (parameters: setOption$Input) => Ok;

/** Changes the period of inactivity after which the account of the current user will automatically be deleted */
export type setAccountTtl$Input = {
  readonly _: "setAccountTtl";

  /**
   * New account TTL
   * @type {accountTtl$Input} {@link accountTtl}
   */
  readonly ttl?: accountTtl$Input;
};

/**
 * Changes the period of inactivity after which the account of the current user will automatically be deleted
 *
 * @param {setAccountTtl$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setAccountTtl = (parameters: setAccountTtl$Input) => Ok;

/** Returns the period of inactivity after which the account of the current user will automatically be deleted */
export type getAccountTtl$Input = {
  readonly _: "getAccountTtl";
};

/**
 * Returns the period of inactivity after which the account of the current user will automatically be deleted
 *
 * @param {getAccountTtl$Input} parameters
 * @return {AccountTtl} {@link AccountTtl}
 */
export type getAccountTtl = (parameters: getAccountTtl$Input) => AccountTtl;

/** Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword */
export type deleteAccount$Input = {
  readonly _: "deleteAccount";

  /**
   * The reason why the account was deleted; optional
   * @type {string} {@link string}
   */
  readonly reason?: string;

  /**
   * The 2-step verification password of the current user. If not specified, account deletion can be canceled within one week
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword
 *
 * @param {deleteAccount$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deleteAccount = (parameters: deleteAccount$Input) => Ok;

/** Removes a chat action bar without any other action */
export type removeChatActionBar$Input = {
  readonly _: "removeChatActionBar";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Removes a chat action bar without any other action
 *
 * @param {removeChatActionBar$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeChatActionBar = (parameters: removeChatActionBar$Input) => Ok;

/** Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported */
export type reportChat$Input = {
  readonly _: "reportChat";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifiers of reported messages; may be empty to report the whole chat
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly message_ids?: vector$Input<int53>;

  /**
   * The reason for reporting the chat
   * @type {ChatReportReason$Input} {@link ChatReportReason}
   */
  readonly reason?: ChatReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if chat.can_be_reported
 *
 * @param {reportChat$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reportChat = (parameters: reportChat$Input) => Ok;

/** Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported */
export type reportChatPhoto$Input = {
  readonly _: "reportChatPhoto";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Identifier of the photo to report. Only full photos from chatPhoto can be reported
   * @type {int32} {@link int32}
   */
  readonly file_id?: int32;

  /**
   * The reason for reporting the chat photo
   * @type {ChatReportReason$Input} {@link ChatReportReason}
   */
  readonly reason?: ChatReportReason$Input;

  /**
   * Additional report details; 0-1024 characters
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Reports a chat photo to the Telegram moderators. A chat photo can be reported only if chat.can_be_reported
 *
 * @param {reportChatPhoto$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reportChatPhoto = (parameters: reportChatPhoto$Input) => Ok;

/** Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions */
export type reportMessageReactions$Input = {
  readonly _: "reportMessageReactions";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Identifier of the sender, which added the reaction
   * @type {MessageSender$Input} {@link MessageSender}
   */
  readonly sender_id?: MessageSender$Input;
};

/**
 * Reports reactions set on a message to the Telegram moderators. Reactions on a message can be reported only if message.can_report_reactions
 *
 * @param {reportMessageReactions$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type reportMessageReactions = (
  parameters: reportMessageReactions$Input
) => Ok;

/** Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true */
export type getChatStatistics$Input = {
  readonly _: "getChatStatistics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a chat. Currently, this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
 *
 * @param {getChatStatistics$Input} parameters
 * @return {ChatStatistics} {@link ChatStatistics}
 */
export type getChatStatistics = (
  parameters: getChatStatistics$Input
) => ChatStatistics;

/** Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true */
export type getMessageStatistics$Input = {
  readonly _: "getMessageStatistics";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * Message identifier
   * @type {int53} {@link int53}
   */
  readonly message_id?: int53;

  /**
   * Pass true if a dark theme is used by the application
   * @type {Bool$Input} {@link Bool}
   */
  readonly is_dark?: Bool$Input;
};

/**
 * Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
 *
 * @param {getMessageStatistics$Input} parameters
 * @return {MessageStatistics} {@link MessageStatistics}
 */
export type getMessageStatistics = (
  parameters: getMessageStatistics$Input
) => MessageStatistics;

/** Loads an asynchronous or a zoomed in statistical graph */
export type getStatisticalGraph$Input = {
  readonly _: "getStatisticalGraph";

  /**
   * Chat identifier
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The token for graph loading
   * @type {string} {@link string}
   */
  readonly token?: string;

  /**
   * X-value for zoomed in graph or 0 otherwise
   * @type {int53} {@link int53}
   */
  readonly x?: int53;
};

/**
 * Loads an asynchronous or a zoomed in statistical graph
 *
 * @param {getStatisticalGraph$Input} parameters
 * @return {StatisticalGraph} {@link StatisticalGraph}
 */
export type getStatisticalGraph = (
  parameters: getStatisticalGraph$Input
) => StatisticalGraph;

/** Returns storage usage statistics. Can be called before authorization */
export type getStorageStatistics$Input = {
  readonly _: "getStorageStatistics";

  /**
   * The maximum number of chats with the largest storage usage for which separate statistics need to be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0
   * @type {int32} {@link int32}
   */
  readonly chat_limit?: int32;
};

/**
 * Returns storage usage statistics. Can be called before authorization
 *
 * @param {getStorageStatistics$Input} parameters
 * @return {StorageStatistics} {@link StorageStatistics}
 */
export type getStorageStatistics = (
  parameters: getStorageStatistics$Input
) => StorageStatistics;

/** Quickly returns approximate storage usage statistics. Can be called before authorization */
export type getStorageStatisticsFast$Input = {
  readonly _: "getStorageStatisticsFast";
};

/**
 * Quickly returns approximate storage usage statistics. Can be called before authorization
 *
 * @param {getStorageStatisticsFast$Input} parameters
 * @return {StorageStatisticsFast} {@link StorageStatisticsFast}
 */
export type getStorageStatisticsFast = (
  parameters: getStorageStatisticsFast$Input
) => StorageStatisticsFast;

/** Returns database statistics */
export type getDatabaseStatistics$Input = {
  readonly _: "getDatabaseStatistics";
};

/**
 * Returns database statistics
 *
 * @param {getDatabaseStatistics$Input} parameters
 * @return {DatabaseStatistics} {@link DatabaseStatistics}
 */
export type getDatabaseStatistics = (
  parameters: getDatabaseStatistics$Input
) => DatabaseStatistics;

/** Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted */
export type optimizeStorage$Input = {
  readonly _: "optimizeStorage";

  /**
   * Limit on the total size of files after deletion, in bytes. Pass -1 to use the default limit
   * @type {int53} {@link int53}
   */
  readonly size?: int53;

  /**
   * Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit
   * @type {int32} {@link int32}
   */
  readonly ttl?: int32;

  /**
   * Limit on the total number of files after deletion. Pass -1 to use the default limit
   * @type {int32} {@link int32}
   */
  readonly count?: int32;

  /**
   * The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value
   * @type {int32} {@link int32}
   */
  readonly immunity_delay?: int32;

  /**
   * If non-empty, only files with the given types are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted
   * @type {vector$Input<FileType$Input>} {@link vector<FileType>}
   */
  readonly file_types?: vector$Input<FileType$Input>;

  /**
   * If non-empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly chat_ids?: vector$Input<int53>;

  /**
   * If non-empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)
   * @type {vector$Input<int53>} {@link vector<int53>}
   */
  readonly exclude_chat_ids?: vector$Input<int53>;

  /**
   * Pass true if statistics about the files that were deleted must be returned instead of the whole storage usage statistics. Affects only returned statistics
   * @type {Bool$Input} {@link Bool}
   */
  readonly return_deleted_file_statistics?: Bool$Input;

  /**
   * Same as in getStorageStatistics. Affects only returned statistics
   * @type {int32} {@link int32}
   */
  readonly chat_limit?: int32;
};

/**
 * Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
 *
 * @param {optimizeStorage$Input} parameters
 * @return {StorageStatistics} {@link StorageStatistics}
 */
export type optimizeStorage = (
  parameters: optimizeStorage$Input
) => StorageStatistics;

/** Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it must be called whenever the network is changed, even if the network type remains the same.
-Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics */
export type setNetworkType$Input = {
  readonly _: "setNetworkType";

  /**
   * The new network type; pass null to set network type to networkTypeOther
   * @type {NetworkType$Input} {@link NetworkType}
   */
  readonly type?: NetworkType$Input;
};

/**
 * Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it must be called whenever the network is changed, even if the network type remains the same.
-Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
 * 
 * @param {setNetworkType$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setNetworkType = (parameters: setNetworkType$Input) => Ok;

/** Returns network data usage statistics. Can be called before authorization */
export type getNetworkStatistics$Input = {
  readonly _: "getNetworkStatistics";

  /**
   * Pass true to get statistics only for the current library launch
   * @type {Bool$Input} {@link Bool}
   */
  readonly only_current?: Bool$Input;
};

/**
 * Returns network data usage statistics. Can be called before authorization
 *
 * @param {getNetworkStatistics$Input} parameters
 * @return {NetworkStatistics} {@link NetworkStatistics}
 */
export type getNetworkStatistics = (
  parameters: getNetworkStatistics$Input
) => NetworkStatistics;

/** Adds the specified data to data usage statistics. Can be called before authorization */
export type addNetworkStatistics$Input = {
  readonly _: "addNetworkStatistics";

  /**
   * The network statistics entry with the data to be added to statistics
   * @type {NetworkStatisticsEntry$Input} {@link NetworkStatisticsEntry}
   */
  readonly entry?: NetworkStatisticsEntry$Input;
};

/**
 * Adds the specified data to data usage statistics. Can be called before authorization
 *
 * @param {addNetworkStatistics$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addNetworkStatistics = (parameters: addNetworkStatistics$Input) => Ok;

/** Resets all network data usage statistics to zero. Can be called before authorization */
export type resetNetworkStatistics$Input = {
  readonly _: "resetNetworkStatistics";
};

/**
 * Resets all network data usage statistics to zero. Can be called before authorization
 *
 * @param {resetNetworkStatistics$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type resetNetworkStatistics = (
  parameters: resetNetworkStatistics$Input
) => Ok;

/** Returns auto-download settings presets for the current user */
export type getAutoDownloadSettingsPresets$Input = {
  readonly _: "getAutoDownloadSettingsPresets";
};

/**
 * Returns auto-download settings presets for the current user
 *
 * @param {getAutoDownloadSettingsPresets$Input} parameters
 * @return {AutoDownloadSettingsPresets} {@link AutoDownloadSettingsPresets}
 */
export type getAutoDownloadSettingsPresets = (
  parameters: getAutoDownloadSettingsPresets$Input
) => AutoDownloadSettingsPresets;

/** Sets auto-download settings */
export type setAutoDownloadSettings$Input = {
  readonly _: "setAutoDownloadSettings";

  /**
   * New user auto-download settings
   * @type {autoDownloadSettings$Input} {@link autoDownloadSettings}
   */
  readonly settings?: autoDownloadSettings$Input;

  /**
   * Type of the network for which the new settings are relevant
   * @type {NetworkType$Input} {@link NetworkType}
   */
  readonly type?: NetworkType$Input;
};

/**
 * Sets auto-download settings
 *
 * @param {setAutoDownloadSettings$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setAutoDownloadSettings = (
  parameters: setAutoDownloadSettings$Input
) => Ok;

/** Returns information about a bank card */
export type getBankCardInfo$Input = {
  readonly _: "getBankCardInfo";

  /**
   * The bank card number
   * @type {string} {@link string}
   */
  readonly bank_card_number?: string;
};

/**
 * Returns information about a bank card
 *
 * @param {getBankCardInfo$Input} parameters
 * @return {BankCardInfo} {@link BankCardInfo}
 */
export type getBankCardInfo = (parameters: getBankCardInfo$Input) => BankCardInfo;

/** Returns one of the available Telegram Passport elements */
export type getPassportElement$Input = {
  readonly _: "getPassportElement";

  /**
   * Telegram Passport element type
   * @type {PassportElementType$Input} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns one of the available Telegram Passport elements
 *
 * @param {getPassportElement$Input} parameters
 * @return {PassportElement} {@link PassportElement}
 */
export type getPassportElement = (
  parameters: getPassportElement$Input
) => PassportElement;

/** Returns all available Telegram Passport elements */
export type getAllPassportElements$Input = {
  readonly _: "getAllPassportElements";

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns all available Telegram Passport elements
 *
 * @param {getAllPassportElements$Input} parameters
 * @return {PassportElements} {@link PassportElements}
 */
export type getAllPassportElements = (
  parameters: getAllPassportElements$Input
) => PassportElements;

/** Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first */
export type setPassportElement$Input = {
  readonly _: "setPassportElement";

  /**
   * Input Telegram Passport element
   * @type {InputPassportElement$Input} {@link InputPassportElement}
   */
  readonly element?: InputPassportElement$Input;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
 *
 * @param {setPassportElement$Input} parameters
 * @return {PassportElement} {@link PassportElement}
 */
export type setPassportElement = (
  parameters: setPassportElement$Input
) => PassportElement;

/** Deletes a Telegram Passport element */
export type deletePassportElement$Input = {
  readonly _: "deletePassportElement";

  /**
   * Element type
   * @type {PassportElementType$Input} {@link PassportElementType}
   */
  readonly type?: PassportElementType$Input;
};

/**
 * Deletes a Telegram Passport element
 *
 * @param {deletePassportElement$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type deletePassportElement = (parameters: deletePassportElement$Input) => Ok;

/** Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed */
export type setPassportElementErrors$Input = {
  readonly _: "setPassportElementErrors";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * The errors
   * @type {vector$Input<inputPassportElementError$Input>} {@link vector<inputPassportElementError>}
   */
  readonly errors?: vector$Input<inputPassportElementError$Input>;
};

/**
 * Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
 *
 * @param {setPassportElementErrors$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setPassportElementErrors = (
  parameters: setPassportElementErrors$Input
) => Ok;

/** Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown */
export type getPreferredCountryLanguage$Input = {
  readonly _: "getPreferredCountryLanguage";

  /**
   * A two-letter ISO 3166-1 alpha-2 country code
   * @type {string} {@link string}
   */
  readonly country_code?: string;
};

/**
 * Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
 *
 * @param {getPreferredCountryLanguage$Input} parameters
 * @return {Text} {@link Text}
 */
export type getPreferredCountryLanguage = (
  parameters: getPreferredCountryLanguage$Input
) => Text;

/** Sends a code to verify a phone number to be added to a user's Telegram Passport */
export type sendPhoneNumberVerificationCode$Input = {
  readonly _: "sendPhoneNumberVerificationCode";

  /**
   * The phone number of the user, in international format
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input;
};

/**
 * Sends a code to verify a phone number to be added to a user's Telegram Passport
 *
 * @param {sendPhoneNumberVerificationCode$Input} parameters
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type sendPhoneNumberVerificationCode = (
  parameters: sendPhoneNumberVerificationCode$Input
) => AuthenticationCodeInfo;

/** Resends the code to verify a phone number to be added to a user's Telegram Passport */
export type resendPhoneNumberVerificationCode$Input = {
  readonly _: "resendPhoneNumberVerificationCode";
};

/**
 * Resends the code to verify a phone number to be added to a user's Telegram Passport
 *
 * @param {resendPhoneNumberVerificationCode$Input} parameters
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type resendPhoneNumberVerificationCode = (
  parameters: resendPhoneNumberVerificationCode$Input
) => AuthenticationCodeInfo;

/** Checks the phone number verification code for Telegram Passport */
export type checkPhoneNumberVerificationCode$Input = {
  readonly _: "checkPhoneNumberVerificationCode";

  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the phone number verification code for Telegram Passport
 *
 * @param {checkPhoneNumberVerificationCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkPhoneNumberVerificationCode = (
  parameters: checkPhoneNumberVerificationCode$Input
) => Ok;

/** Sends a code to verify an email address to be added to a user's Telegram Passport */
export type sendEmailAddressVerificationCode$Input = {
  readonly _: "sendEmailAddressVerificationCode";

  /**
   * Email address
   * @type {string} {@link string}
   */
  readonly email_address?: string;
};

/**
 * Sends a code to verify an email address to be added to a user's Telegram Passport
 *
 * @param {sendEmailAddressVerificationCode$Input} parameters
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type sendEmailAddressVerificationCode = (
  parameters: sendEmailAddressVerificationCode$Input
) => EmailAddressAuthenticationCodeInfo;

/** Resends the code to verify an email address to be added to a user's Telegram Passport */
export type resendEmailAddressVerificationCode$Input = {
  readonly _: "resendEmailAddressVerificationCode";
};

/**
 * Resends the code to verify an email address to be added to a user's Telegram Passport
 *
 * @param {resendEmailAddressVerificationCode$Input} parameters
 * @return {EmailAddressAuthenticationCodeInfo} {@link EmailAddressAuthenticationCodeInfo}
 */
export type resendEmailAddressVerificationCode = (
  parameters: resendEmailAddressVerificationCode$Input
) => EmailAddressAuthenticationCodeInfo;

/** Checks the email address verification code for Telegram Passport */
export type checkEmailAddressVerificationCode$Input = {
  readonly _: "checkEmailAddressVerificationCode";

  /**
   * Verification code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks the email address verification code for Telegram Passport
 *
 * @param {checkEmailAddressVerificationCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkEmailAddressVerificationCode = (
  parameters: checkEmailAddressVerificationCode$Input
) => Ok;

/** Returns a Telegram Passport authorization form for sharing data with a service */
export type getPassportAuthorizationForm$Input = {
  readonly _: "getPassportAuthorizationForm";

  /**
   * User identifier of the service's bot
   * @type {int53} {@link int53}
   */
  readonly bot_user_id?: int53;

  /**
   * Telegram Passport element types requested by the service
   * @type {string} {@link string}
   */
  readonly scope?: string;

  /**
   * Service's public key
   * @type {string} {@link string}
   */
  readonly public_key?: string;

  /**
   * Unique request identifier provided by the service
   * @type {string} {@link string}
   */
  readonly nonce?: string;
};

/**
 * Returns a Telegram Passport authorization form for sharing data with a service
 *
 * @param {getPassportAuthorizationForm$Input} parameters
 * @return {PassportAuthorizationForm} {@link PassportAuthorizationForm}
 */
export type getPassportAuthorizationForm = (
  parameters: getPassportAuthorizationForm$Input
) => PassportAuthorizationForm;

/** Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form */
export type getPassportAuthorizationFormAvailableElements$Input = {
  readonly _: "getPassportAuthorizationFormAvailableElements";

  /**
   * Authorization form identifier
   * @type {int32} {@link int32}
   */
  readonly autorization_form_id?: int32;

  /**
   * The 2-step verification password of the current user
   * @type {string} {@link string}
   */
  readonly password?: string;
};

/**
 * Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
 *
 * @param {getPassportAuthorizationFormAvailableElements$Input} parameters
 * @return {PassportElementsWithErrors} {@link PassportElementsWithErrors}
 */
export type getPassportAuthorizationFormAvailableElements = (
  parameters: getPassportAuthorizationFormAvailableElements$Input
) => PassportElementsWithErrors;

/** Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused */
export type sendPassportAuthorizationForm$Input = {
  readonly _: "sendPassportAuthorizationForm";

  /**
   * Authorization form identifier
   * @type {int32} {@link int32}
   */
  readonly autorization_form_id?: int32;

  /**
   * Types of Telegram Passport elements chosen by user to complete the authorization form
   * @type {vector$Input<PassportElementType$Input>} {@link vector<PassportElementType>}
   */
  readonly types?: vector$Input<PassportElementType$Input>;
};

/**
 * Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
 *
 * @param {sendPassportAuthorizationForm$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type sendPassportAuthorizationForm = (
  parameters: sendPassportAuthorizationForm$Input
) => Ok;

/** Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation */
export type sendPhoneNumberConfirmationCode$Input = {
  readonly _: "sendPhoneNumberConfirmationCode";

  /**
   * Hash value from the link
   * @type {string} {@link string}
   */
  readonly hash?: string;

  /**
   * Phone number value from the link
   * @type {string} {@link string}
   */
  readonly phone_number?: string;

  /**
   * Settings for the authentication of the user's phone number; pass null to use default settings
   * @type {phoneNumberAuthenticationSettings$Input} {@link phoneNumberAuthenticationSettings}
   */
  readonly settings?: phoneNumberAuthenticationSettings$Input;
};

/**
 * Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
 *
 * @param {sendPhoneNumberConfirmationCode$Input} parameters
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type sendPhoneNumberConfirmationCode = (
  parameters: sendPhoneNumberConfirmationCode$Input
) => AuthenticationCodeInfo;

/** Resends phone number confirmation code */
export type resendPhoneNumberConfirmationCode$Input = {
  readonly _: "resendPhoneNumberConfirmationCode";
};

/**
 * Resends phone number confirmation code
 *
 * @param {resendPhoneNumberConfirmationCode$Input} parameters
 * @return {AuthenticationCodeInfo} {@link AuthenticationCodeInfo}
 */
export type resendPhoneNumberConfirmationCode = (
  parameters: resendPhoneNumberConfirmationCode$Input
) => AuthenticationCodeInfo;

/** Checks phone number confirmation code */
export type checkPhoneNumberConfirmationCode$Input = {
  readonly _: "checkPhoneNumberConfirmationCode";

  /**
   * Confirmation code to check
   * @type {string} {@link string}
   */
  readonly code?: string;
};

/**
 * Checks phone number confirmation code
 *
 * @param {checkPhoneNumberConfirmationCode$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type checkPhoneNumberConfirmationCode = (
  parameters: checkPhoneNumberConfirmationCode$Input
) => Ok;

/** Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only */
export type setBotUpdatesStatus$Input = {
  readonly _: "setBotUpdatesStatus";

  /**
   * The number of pending updates
   * @type {int32} {@link int32}
   */
  readonly pending_update_count?: int32;

  /**
   * The last error message
   * @type {string} {@link string}
   */
  readonly error_message?: string;
};

/**
 * Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
 *
 * @param {setBotUpdatesStatus$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setBotUpdatesStatus = (parameters: setBotUpdatesStatus$Input) => Ok;

/** Uploads a file with a sticker; returns the uploaded file */
export type uploadStickerFile$Input = {
  readonly _: "uploadStickerFile";

  /**
   * Sticker file owner; ignored for regular users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker file to upload
   * @type {inputSticker$Input} {@link inputSticker}
   */
  readonly sticker?: inputSticker$Input;
};

/**
 * Uploads a file with a sticker; returns the uploaded file
 *
 * @param {uploadStickerFile$Input} parameters
 * @return {File} {@link File}
 */
export type uploadStickerFile = (parameters: uploadStickerFile$Input) => File;

/** Returns a suggested name for a new sticker set with a given title */
export type getSuggestedStickerSetName$Input = {
  readonly _: "getSuggestedStickerSetName";

  /**
   * Sticker set title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;
};

/**
 * Returns a suggested name for a new sticker set with a given title
 *
 * @param {getSuggestedStickerSetName$Input} parameters
 * @return {Text} {@link Text}
 */
export type getSuggestedStickerSetName = (
  parameters: getSuggestedStickerSetName$Input
) => Text;

/** Checks whether a name can be used for a new sticker set */
export type checkStickerSetName$Input = {
  readonly _: "checkStickerSetName";

  /**
   * Name to be checked
   * @type {string} {@link string}
   */
  readonly name?: string;
};

/**
 * Checks whether a name can be used for a new sticker set
 *
 * @param {checkStickerSetName$Input} parameters
 * @return {CheckStickerSetNameResult} {@link CheckStickerSetNameResult}
 */
export type checkStickerSetName = (
  parameters: checkStickerSetName$Input
) => CheckStickerSetNameResult;

/** Creates a new sticker set. Returns the newly created sticker set */
export type createNewStickerSet$Input = {
  readonly _: "createNewStickerSet";

  /**
   * Sticker set owner; ignored for regular users
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set title; 1-64 characters
   * @type {string} {@link string}
   */
  readonly title?: string;

  /**
   * Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive) for bots; 1-64 characters
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Type of the stickers in the set
   * @type {StickerType$Input} {@link StickerType}
   */
  readonly sticker_type?: StickerType$Input;

  /**
   * List of stickers to be added to the set; must be non-empty. All stickers must have the same format. For TGS stickers, uploadStickerFile must be used before the sticker is shown
   * @type {vector$Input<inputSticker$Input>} {@link vector<inputSticker>}
   */
  readonly stickers?: vector$Input<inputSticker$Input>;

  /**
   * Source of the sticker set; may be empty if unknown
   * @type {string} {@link string}
   */
  readonly source?: string;
};

/**
 * Creates a new sticker set. Returns the newly created sticker set
 *
 * @param {createNewStickerSet$Input} parameters
 * @return {StickerSet} {@link StickerSet}
 */
export type createNewStickerSet = (
  parameters: createNewStickerSet$Input
) => StickerSet;

/** Adds a new sticker to a set; for bots only. Returns the sticker set */
export type addStickerToSet$Input = {
  readonly _: "addStickerToSet";

  /**
   * Sticker set owner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Sticker to add to the set
   * @type {inputSticker$Input} {@link inputSticker}
   */
  readonly sticker?: inputSticker$Input;
};

/**
 * Adds a new sticker to a set; for bots only. Returns the sticker set
 *
 * @param {addStickerToSet$Input} parameters
 * @return {StickerSet} {@link StickerSet}
 */
export type addStickerToSet = (parameters: addStickerToSet$Input) => StickerSet;

/** Sets a sticker set thumbnail; for bots only. Returns the sticker set */
export type setStickerSetThumbnail$Input = {
  readonly _: "setStickerSetThumbnail";

  /**
   * Sticker set owner
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * Sticker set name
   * @type {string} {@link string}
   */
  readonly name?: string;

  /**
   * Thumbnail to set in PNG, TGS, or WEBM format; pass null to remove the sticker set thumbnail. Thumbnail format must match the format of stickers in the set
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly thumbnail?: InputFile$Input;
};

/**
 * Sets a sticker set thumbnail; for bots only. Returns the sticker set
 *
 * @param {setStickerSetThumbnail$Input} parameters
 * @return {StickerSet} {@link StickerSet}
 */
export type setStickerSetThumbnail = (
  parameters: setStickerSetThumbnail$Input
) => StickerSet;

/** Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot */
export type setStickerPositionInSet$Input = {
  readonly _: "setStickerPositionInSet";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;

  /**
   * New position of the sticker in the set, 0-based
   * @type {int32} {@link int32}
   */
  readonly position?: int32;
};

/**
 * Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
 *
 * @param {setStickerPositionInSet$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setStickerPositionInSet = (
  parameters: setStickerPositionInSet$Input
) => Ok;

/** Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot */
export type removeStickerFromSet$Input = {
  readonly _: "removeStickerFromSet";

  /**
   * Sticker
   * @type {InputFile$Input} {@link InputFile}
   */
  readonly sticker?: InputFile$Input;
};

/**
 * Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
 *
 * @param {removeStickerFromSet$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeStickerFromSet = (parameters: removeStickerFromSet$Input) => Ok;

/** Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded */
export type getMapThumbnailFile$Input = {
  readonly _: "getMapThumbnailFile";

  /**
   * Location of the map center
   * @type {location$Input} {@link location}
   */
  readonly location?: location$Input;

  /**
   * Map zoom level; 13-20
   * @type {int32} {@link int32}
   */
  readonly zoom?: int32;

  /**
   * Map width in pixels before applying scale; 16-1024
   * @type {int32} {@link int32}
   */
  readonly width?: int32;

  /**
   * Map height in pixels before applying scale; 16-1024
   * @type {int32} {@link int32}
   */
  readonly height?: int32;

  /**
   * Map scale; 1-3
   * @type {int32} {@link int32}
   */
  readonly scale?: int32;

  /**
   * Identifier of a chat in which the thumbnail will be shown. Use 0 if unknown
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;
};

/**
 * Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
 *
 * @param {getMapThumbnailFile$Input} parameters
 * @return {File} {@link File}
 */
export type getMapThumbnailFile = (parameters: getMapThumbnailFile$Input) => File;

/** Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown */
export type getPremiumLimit$Input = {
  readonly _: "getPremiumLimit";

  /**
   * Type of the limit
   * @type {PremiumLimitType$Input} {@link PremiumLimitType}
   */
  readonly limit_type?: PremiumLimitType$Input;
};

/**
 * Returns information about a limit, increased for Premium users. Returns a 404 error if the limit is unknown
 *
 * @param {getPremiumLimit$Input} parameters
 * @return {PremiumLimit} {@link PremiumLimit}
 */
export type getPremiumLimit = (parameters: getPremiumLimit$Input) => PremiumLimit;

/** Returns information about features, available to Premium users */
export type getPremiumFeatures$Input = {
  readonly _: "getPremiumFeatures";

  /**
   * Source of the request; pass null if the method is called from some non-standard source
   * @type {PremiumSource$Input} {@link PremiumSource}
   */
  readonly source?: PremiumSource$Input;
};

/**
 * Returns information about features, available to Premium users
 *
 * @param {getPremiumFeatures$Input} parameters
 * @return {PremiumFeatures} {@link PremiumFeatures}
 */
export type getPremiumFeatures = (
  parameters: getPremiumFeatures$Input
) => PremiumFeatures;

/** Returns examples of premium stickers for demonstration purposes */
export type getPremiumStickerExamples$Input = {
  readonly _: "getPremiumStickerExamples";
};

/**
 * Returns examples of premium stickers for demonstration purposes
 *
 * @param {getPremiumStickerExamples$Input} parameters
 * @return {Stickers} {@link Stickers}
 */
export type getPremiumStickerExamples = (
  parameters: getPremiumStickerExamples$Input
) => Stickers;

/** Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen */
export type viewPremiumFeature$Input = {
  readonly _: "viewPremiumFeature";

  /**
   * The viewed premium feature
   * @type {PremiumFeature$Input} {@link PremiumFeature}
   */
  readonly feature?: PremiumFeature$Input;
};

/**
 * Informs TDLib that the user viewed detailed information about a Premium feature on the Premium features screen
 *
 * @param {viewPremiumFeature$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type viewPremiumFeature = (parameters: viewPremiumFeature$Input) => Ok;

/** Informs TDLib that the user clicked Premium subscription button on the Premium features screen */
export type clickPremiumSubscriptionButton$Input = {
  readonly _: "clickPremiumSubscriptionButton";
};

/**
 * Informs TDLib that the user clicked Premium subscription button on the Premium features screen
 *
 * @param {clickPremiumSubscriptionButton$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type clickPremiumSubscriptionButton = (
  parameters: clickPremiumSubscriptionButton$Input
) => Ok;

/** Returns state of Telegram Premium subscription and promotion videos for Premium features */
export type getPremiumState$Input = {
  readonly _: "getPremiumState";
};

/**
 * Returns state of Telegram Premium subscription and promotion videos for Premium features
 *
 * @param {getPremiumState$Input} parameters
 * @return {PremiumState} {@link PremiumState}
 */
export type getPremiumState = (parameters: getPremiumState$Input) => PremiumState;

/** Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase */
export type canPurchasePremium$Input = {
  readonly _: "canPurchasePremium";

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase
 *
 * @param {canPurchasePremium$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type canPurchasePremium = (parameters: canPurchasePremium$Input) => Ok;

/** Informs server about a purchase through App Store. For official applications only */
export type assignAppStoreTransaction$Input = {
  readonly _: "assignAppStoreTransaction";

  /**
   * App Store receipt
   * @type {bytes} {@link bytes}
   */
  readonly receipt?: bytes;

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Informs server about a purchase through App Store. For official applications only
 *
 * @param {assignAppStoreTransaction$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type assignAppStoreTransaction = (
  parameters: assignAppStoreTransaction$Input
) => Ok;

/** Informs server about a purchase through Google Play. For official applications only */
export type assignGooglePlayTransaction$Input = {
  readonly _: "assignGooglePlayTransaction";

  /**
   * Application package name
   * @type {string} {@link string}
   */
  readonly package_name?: string;

  /**
   * Identifier of the purchased store product
   * @type {string} {@link string}
   */
  readonly store_product_id?: string;

  /**
   * Google Play purchase token
   * @type {string} {@link string}
   */
  readonly purchase_token?: string;

  /**
   * Transaction purpose
   * @type {StorePaymentPurpose$Input} {@link StorePaymentPurpose}
   */
  readonly purpose?: StorePaymentPurpose$Input;
};

/**
 * Informs server about a purchase through Google Play. For official applications only
 *
 * @param {assignGooglePlayTransaction$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type assignGooglePlayTransaction = (
  parameters: assignGooglePlayTransaction$Input
) => Ok;

/** Accepts Telegram terms of services */
export type acceptTermsOfService$Input = {
  readonly _: "acceptTermsOfService";

  /**
   * Terms of service identifier
   * @type {string} {@link string}
   */
  readonly terms_of_service_id?: string;
};

/**
 * Accepts Telegram terms of services
 *
 * @param {acceptTermsOfService$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type acceptTermsOfService = (parameters: acceptTermsOfService$Input) => Ok;

/** Sends a custom request; for bots only */
export type sendCustomRequest$Input = {
  readonly _: "sendCustomRequest";

  /**
   * The method name
   * @type {string} {@link string}
   */
  readonly method?: string;

  /**
   * JSON-serialized method parameters
   * @type {string} {@link string}
   */
  readonly parameters?: string;
};

/**
 * Sends a custom request; for bots only
 *
 * @param {sendCustomRequest$Input} parameters
 * @return {CustomRequestResult} {@link CustomRequestResult}
 */
export type sendCustomRequest = (
  parameters: sendCustomRequest$Input
) => CustomRequestResult;

/** Answers a custom query; for bots only */
export type answerCustomQuery$Input = {
  readonly _: "answerCustomQuery";

  /**
   * Identifier of a custom query
   * @type {int64} {@link int64}
   */
  readonly custom_query_id?: int64;

  /**
   * JSON-serialized answer to the query
   * @type {string} {@link string}
   */
  readonly data?: string;
};

/**
 * Answers a custom query; for bots only
 *
 * @param {answerCustomQuery$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type answerCustomQuery = (parameters: answerCustomQuery$Input) => Ok;

/** Succeeds after a specified amount of time has passed. Can be called before initialization */
export type setAlarm$Input = {
  readonly _: "setAlarm";

  /**
   * Number of seconds before the function returns
   * @type {double} {@link double}
   */
  readonly seconds?: double;
};

/**
 * Succeeds after a specified amount of time has passed. Can be called before initialization
 *
 * @param {setAlarm$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setAlarm = (parameters: setAlarm$Input) => Ok;

/** Returns information about existing countries. Can be called before authorization */
export type getCountries$Input = {
  readonly _: "getCountries";
};

/**
 * Returns information about existing countries. Can be called before authorization
 *
 * @param {getCountries$Input} parameters
 * @return {Countries} {@link Countries}
 */
export type getCountries = (parameters: getCountries$Input) => Countries;

/** Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization */
export type getCountryCode$Input = {
  readonly _: "getCountryCode";
};

/**
 * Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
 *
 * @param {getCountryCode$Input} parameters
 * @return {Text} {@link Text}
 */
export type getCountryCode = (parameters: getCountryCode$Input) => Text;

/** Returns information about a phone number by its prefix. Can be called before authorization */
export type getPhoneNumberInfo$Input = {
  readonly _: "getPhoneNumberInfo";

  /**
   * The phone number prefix
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;
};

/**
 * Returns information about a phone number by its prefix. Can be called before authorization
 *
 * @param {getPhoneNumberInfo$Input} parameters
 * @return {PhoneNumberInfo} {@link PhoneNumberInfo}
 */
export type getPhoneNumberInfo = (
  parameters: getPhoneNumberInfo$Input
) => PhoneNumberInfo;

/** Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously */
export type getPhoneNumberInfoSync$Input = {
  readonly _: "getPhoneNumberInfoSync";

  /**
   * A two-letter ISO 639-1 language code for country information localization
   * @type {string} {@link string}
   */
  readonly language_code?: string;

  /**
   * The phone number prefix
   * @type {string} {@link string}
   */
  readonly phone_number_prefix?: string;
};

/**
 * Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
 *
 * @param {getPhoneNumberInfoSync$Input} parameters
 * @return {PhoneNumberInfo} {@link PhoneNumberInfo}
 */
export type getPhoneNumberInfoSync = (
  parameters: getPhoneNumberInfoSync$Input
) => PhoneNumberInfo;

/** Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram */
export type getApplicationDownloadLink$Input = {
  readonly _: "getApplicationDownloadLink";
};

/**
 * Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
 *
 * @param {getApplicationDownloadLink$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getApplicationDownloadLink = (
  parameters: getApplicationDownloadLink$Input
) => HttpUrl;

/** Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization */
export type getDeepLinkInfo$Input = {
  readonly _: "getDeepLinkInfo";

  /**
   * The link
   * @type {string} {@link string}
   */
  readonly link?: string;
};

/**
 * Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
 *
 * @param {getDeepLinkInfo$Input} parameters
 * @return {DeepLinkInfo} {@link DeepLinkInfo}
 */
export type getDeepLinkInfo = (parameters: getDeepLinkInfo$Input) => DeepLinkInfo;

/** Returns application config, provided by the server. Can be called before authorization */
export type getApplicationConfig$Input = {
  readonly _: "getApplicationConfig";
};

/**
 * Returns application config, provided by the server. Can be called before authorization
 *
 * @param {getApplicationConfig$Input} parameters
 * @return {JsonValue} {@link JsonValue}
 */
export type getApplicationConfig = (
  parameters: getApplicationConfig$Input
) => JsonValue;

/** Saves application log event on the server. Can be called before authorization */
export type saveApplicationLogEvent$Input = {
  readonly _: "saveApplicationLogEvent";

  /**
   * Event type
   * @type {string} {@link string}
   */
  readonly type?: string;

  /**
   * Optional chat identifier, associated with the event
   * @type {int53} {@link int53}
   */
  readonly chat_id?: int53;

  /**
   * The log event data
   * @type {JsonValue$Input} {@link JsonValue}
   */
  readonly data?: JsonValue$Input;
};

/**
 * Saves application log event on the server. Can be called before authorization
 *
 * @param {saveApplicationLogEvent$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type saveApplicationLogEvent = (
  parameters: saveApplicationLogEvent$Input
) => Ok;

/** Adds a proxy server for network requests. Can be called before authorization */
export type addProxy$Input = {
  readonly _: "addProxy";

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Pass true to immediately enable the proxy
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable?: Bool$Input;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Adds a proxy server for network requests. Can be called before authorization
 *
 * @param {addProxy$Input} parameters
 * @return {Proxy} {@link Proxy}
 */
export type addProxy = (parameters: addProxy$Input) => Proxy;

/** Edits an existing proxy server for network requests. Can be called before authorization */
export type editProxy$Input = {
  readonly _: "editProxy";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Pass true to immediately enable the proxy
   * @type {Bool$Input} {@link Bool}
   */
  readonly enable?: Bool$Input;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;
};

/**
 * Edits an existing proxy server for network requests. Can be called before authorization
 *
 * @param {editProxy$Input} parameters
 * @return {Proxy} {@link Proxy}
 */
export type editProxy = (parameters: editProxy$Input) => Proxy;

/** Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization */
export type enableProxy$Input = {
  readonly _: "enableProxy";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
 *
 * @param {enableProxy$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type enableProxy = (parameters: enableProxy$Input) => Ok;

/** Disables the currently enabled proxy. Can be called before authorization */
export type disableProxy$Input = {
  readonly _: "disableProxy";
};

/**
 * Disables the currently enabled proxy. Can be called before authorization
 *
 * @param {disableProxy$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type disableProxy = (parameters: disableProxy$Input) => Ok;

/** Removes a proxy server. Can be called before authorization */
export type removeProxy$Input = {
  readonly _: "removeProxy";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Removes a proxy server. Can be called before authorization
 *
 * @param {removeProxy$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type removeProxy = (parameters: removeProxy$Input) => Ok;

/** Returns list of proxies that are currently set up. Can be called before authorization */
export type getProxies$Input = {
  readonly _: "getProxies";
};

/**
 * Returns list of proxies that are currently set up. Can be called before authorization
 *
 * @param {getProxies$Input} parameters
 * @return {Proxies} {@link Proxies}
 */
export type getProxies = (parameters: getProxies$Input) => Proxies;

/** Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization */
export type getProxyLink$Input = {
  readonly _: "getProxyLink";

  /**
   * Proxy identifier
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
 *
 * @param {getProxyLink$Input} parameters
 * @return {HttpUrl} {@link HttpUrl}
 */
export type getProxyLink = (parameters: getProxyLink$Input) => HttpUrl;

/** Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization */
export type pingProxy$Input = {
  readonly _: "pingProxy";

  /**
   * Proxy identifier. Use 0 to ping a Telegram server without a proxy
   * @type {int32} {@link int32}
   */
  readonly proxy_id?: int32;
};

/**
 * Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
 *
 * @param {pingProxy$Input} parameters
 * @return {Seconds} {@link Seconds}
 */
export type pingProxy = (parameters: pingProxy$Input) => Seconds;

/** Sets new log stream for internal logging of TDLib. Can be called synchronously */
export type setLogStream$Input = {
  readonly _: "setLogStream";

  /**
   * New log stream
   * @type {LogStream$Input} {@link LogStream}
   */
  readonly log_stream?: LogStream$Input;
};

/**
 * Sets new log stream for internal logging of TDLib. Can be called synchronously
 *
 * @param {setLogStream$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setLogStream = (parameters: setLogStream$Input) => Ok;

/** Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously */
export type getLogStream$Input = {
  readonly _: "getLogStream";
};

/**
 * Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
 *
 * @param {getLogStream$Input} parameters
 * @return {LogStream} {@link LogStream}
 */
export type getLogStream = (parameters: getLogStream$Input) => LogStream;

/** Sets the verbosity level of the internal logging of TDLib. Can be called synchronously */
export type setLogVerbosityLevel$Input = {
  readonly _: "setLogVerbosityLevel";

  /**
   * New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging
   * @type {int32} {@link int32}
   */
  readonly new_verbosity_level?: int32;
};

/**
 * Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
 *
 * @param {setLogVerbosityLevel$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setLogVerbosityLevel = (parameters: setLogVerbosityLevel$Input) => Ok;

/** Returns current verbosity level of the internal logging of TDLib. Can be called synchronously */
export type getLogVerbosityLevel$Input = {
  readonly _: "getLogVerbosityLevel";
};

/**
 * Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
 *
 * @param {getLogVerbosityLevel$Input} parameters
 * @return {LogVerbosityLevel} {@link LogVerbosityLevel}
 */
export type getLogVerbosityLevel = (
  parameters: getLogVerbosityLevel$Input
) => LogVerbosityLevel;

/** Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously */
export type getLogTags$Input = {
  readonly _: "getLogTags";
};

/**
 * Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
 *
 * @param {getLogTags$Input} parameters
 * @return {LogTags} {@link LogTags}
 */
export type getLogTags = (parameters: getLogTags$Input) => LogTags;

/** Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously */
export type setLogTagVerbosityLevel$Input = {
  readonly _: "setLogTagVerbosityLevel";

  /**
   * Logging tag to change verbosity level
   * @type {string} {@link string}
   */
  readonly tag?: string;

  /**
   * New verbosity level; 1-1024
   * @type {int32} {@link int32}
   */
  readonly new_verbosity_level?: int32;
};

/**
 * Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
 *
 * @param {setLogTagVerbosityLevel$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type setLogTagVerbosityLevel = (
  parameters: setLogTagVerbosityLevel$Input
) => Ok;

/** Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously */
export type getLogTagVerbosityLevel$Input = {
  readonly _: "getLogTagVerbosityLevel";

  /**
   * Logging tag to change verbosity level
   * @type {string} {@link string}
   */
  readonly tag?: string;
};

/**
 * Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
 *
 * @param {getLogTagVerbosityLevel$Input} parameters
 * @return {LogVerbosityLevel} {@link LogVerbosityLevel}
 */
export type getLogTagVerbosityLevel = (
  parameters: getLogTagVerbosityLevel$Input
) => LogVerbosityLevel;

/** Adds a message to TDLib internal log. Can be called synchronously */
export type addLogMessage$Input = {
  readonly _: "addLogMessage";

  /**
   * The minimum verbosity level needed for the message to be logged; 0-1023
   * @type {int32} {@link int32}
   */
  readonly verbosity_level?: int32;

  /**
   * Text of a message to log
   * @type {string} {@link string}
   */
  readonly text?: string;
};

/**
 * Adds a message to TDLib internal log. Can be called synchronously
 *
 * @param {addLogMessage$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type addLogMessage = (parameters: addLogMessage$Input) => Ok;

/** Returns support information for the given user; for Telegram support only */
export type getUserSupportInfo$Input = {
  readonly _: "getUserSupportInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;
};

/**
 * Returns support information for the given user; for Telegram support only
 *
 * @param {getUserSupportInfo$Input} parameters
 * @return {UserSupportInfo} {@link UserSupportInfo}
 */
export type getUserSupportInfo = (
  parameters: getUserSupportInfo$Input
) => UserSupportInfo;

/** Sets support information for the given user; for Telegram support only */
export type setUserSupportInfo$Input = {
  readonly _: "setUserSupportInfo";

  /**
   * User identifier
   * @type {int53} {@link int53}
   */
  readonly user_id?: int53;

  /**
   * New information message
   * @type {formattedText$Input} {@link formattedText}
   */
  readonly message?: formattedText$Input;
};

/**
 * Sets support information for the given user; for Telegram support only
 *
 * @param {setUserSupportInfo$Input} parameters
 * @return {UserSupportInfo} {@link UserSupportInfo}
 */
export type setUserSupportInfo = (
  parameters: setUserSupportInfo$Input
) => UserSupportInfo;

/** Does nothing; for testing only. This is an offline method. Can be called before authorization */
export type testCallEmpty$Input = {
  readonly _: "testCallEmpty";
};

/**
 * Does nothing; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallEmpty$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type testCallEmpty = (parameters: testCallEmpty$Input) => Ok;

/** Returns the received string; for testing only. This is an offline method. Can be called before authorization */
export type testCallString$Input = {
  readonly _: "testCallString";

  /**
   * String to return
   * @type {string} {@link string}
   */
  readonly x?: string;
};

/**
 * Returns the received string; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallString$Input} parameters
 * @return {TestString} {@link TestString}
 */
export type testCallString = (parameters: testCallString$Input) => TestString;

/** Returns the received bytes; for testing only. This is an offline method. Can be called before authorization */
export type testCallBytes$Input = {
  readonly _: "testCallBytes";

  /**
   * Bytes to return
   * @type {bytes} {@link bytes}
   */
  readonly x?: bytes;
};

/**
 * Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallBytes$Input} parameters
 * @return {TestBytes} {@link TestBytes}
 */
export type testCallBytes = (parameters: testCallBytes$Input) => TestBytes;

/** Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization */
export type testCallVectorInt$Input = {
  readonly _: "testCallVectorInt";

  /**
   * Vector of numbers to return
   * @type {vector$Input<int32>} {@link vector<int32>}
   */
  readonly x?: vector$Input<int32>;
};

/**
 * Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorInt$Input} parameters
 * @return {TestVectorInt} {@link TestVectorInt}
 */
export type testCallVectorInt = (
  parameters: testCallVectorInt$Input
) => TestVectorInt;

/** Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization */
export type testCallVectorIntObject$Input = {
  readonly _: "testCallVectorIntObject";

  /**
   * Vector of objects to return
   * @type {vector$Input<testInt$Input>} {@link vector<testInt>}
   */
  readonly x?: vector$Input<testInt$Input>;
};

/**
 * Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorIntObject$Input} parameters
 * @return {TestVectorIntObject} {@link TestVectorIntObject}
 */
export type testCallVectorIntObject = (
  parameters: testCallVectorIntObject$Input
) => TestVectorIntObject;

/** Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization */
export type testCallVectorString$Input = {
  readonly _: "testCallVectorString";

  /**
   * Vector of strings to return
   * @type {vector$Input<string>} {@link vector<string>}
   */
  readonly x?: vector$Input<string>;
};

/**
 * Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorString$Input} parameters
 * @return {TestVectorString} {@link TestVectorString}
 */
export type testCallVectorString = (
  parameters: testCallVectorString$Input
) => TestVectorString;

/** Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization */
export type testCallVectorStringObject$Input = {
  readonly _: "testCallVectorStringObject";

  /**
   * Vector of objects to return
   * @type {vector$Input<testString$Input>} {@link vector<testString>}
   */
  readonly x?: vector$Input<testString$Input>;
};

/**
 * Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testCallVectorStringObject$Input} parameters
 * @return {TestVectorStringObject} {@link TestVectorStringObject}
 */
export type testCallVectorStringObject = (
  parameters: testCallVectorStringObject$Input
) => TestVectorStringObject;

/** Returns the squared received number; for testing only. This is an offline method. Can be called before authorization */
export type testSquareInt$Input = {
  readonly _: "testSquareInt";

  /**
   * Number to square
   * @type {int32} {@link int32}
   */
  readonly x?: int32;
};

/**
 * Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testSquareInt$Input} parameters
 * @return {TestInt} {@link TestInt}
 */
export type testSquareInt = (parameters: testSquareInt$Input) => TestInt;

/** Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization */
export type testNetwork$Input = {
  readonly _: "testNetwork";
};

/**
 * Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
 *
 * @param {testNetwork$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type testNetwork = (parameters: testNetwork$Input) => Ok;

/** Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization */
export type testProxy$Input = {
  readonly _: "testProxy";

  /**
   * Proxy server IP address
   * @type {string} {@link string}
   */
  readonly server?: string;

  /**
   * Proxy server port
   * @type {int32} {@link int32}
   */
  readonly port?: int32;

  /**
   * Proxy type
   * @type {ProxyType$Input} {@link ProxyType}
   */
  readonly type?: ProxyType$Input;

  /**
   * Identifier of a datacenter with which to test connection
   * @type {int32} {@link int32}
   */
  readonly dc_id?: int32;

  /**
   * The maximum overall timeout for the request
   * @type {double} {@link double}
   */
  readonly timeout?: double;
};

/**
 * Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
 *
 * @param {testProxy$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type testProxy = (parameters: testProxy$Input) => Ok;

/** Forces an updates.getDifference call to the Telegram servers; for testing only */
export type testGetDifference$Input = {
  readonly _: "testGetDifference";
};

/**
 * Forces an updates.getDifference call to the Telegram servers; for testing only
 *
 * @param {testGetDifference$Input} parameters
 * @return {Ok} {@link Ok}
 */
export type testGetDifference = (parameters: testGetDifference$Input) => Ok;

/** Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization */
export type testUseUpdate$Input = {
  readonly _: "testUseUpdate";
};

/**
 * Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
 *
 * @param {testUseUpdate$Input} parameters
 * @return {Update} {@link Update}
 */
export type testUseUpdate = (parameters: testUseUpdate$Input) => Update;

/** Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously */
export type testReturnError$Input = {
  readonly _: "testReturnError";

  /**
   * The error to be returned
   * @type {error$Input} {@link error}
   */
  readonly error?: error$Input;
};

/**
 * Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
 *
 * @param {testReturnError$Input} parameters
 * @return {Error} {@link Error}
 */
export type testReturnError = (parameters: testReturnError$Input) => Error;
